# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

@typing.final
class Document:
    r"""
    A Mokaccino Document object, representing a flat collection of field-value pairs. (all strings)
    There are no contraints on field names or values.
    """
    def __new__(cls) -> Document: ...
    def __str__(self) -> builtins.str: ...
    def with_value(self, field: builtins.str, value: builtins.str) -> Document:
        r"""
        Return a new Document with the given field set to the given value.
        
        This will leave this document empty, so you MUST use the returned value.
        """
    def add_value(self, field: builtins.str, value: builtins.str) -> None:
        r"""
        Adds the given field,value to the document in place.
        """
    def field_values(self) -> builtins.list[tuple[builtins.str, builtins.str]]:
        r"""
        Return a list of (field, value) pairs in this Document.
        """
    def merge_with(self, other: Document) -> Document:
        r"""
        Return a new Document merging this Document with another Document.
        """

@typing.final
class Percolator:
    r"""
    A Mokaccino Percolator object, representing an index of Queries
    against which Documents can be percolated.
    """
    def __new__(cls) -> Percolator: ...
    def add_query(self, query: Query) -> builtins.int:
        r"""
        Add a Query to the Percolator, returning its Qid.
        
        The Qid can be used to identify the Query later, so you need
        to keep track of it in your application.
        """
    def percolate_list(self, document: Document) -> builtins.list[builtins.int]:
        r"""
        Percolate the given Document against the Percolator,
        returning a list of Qids of matching Queries.
        """
    def to_json(self) -> builtins.str:
        r"""
        Serialize the Percolator to a JSON string.
        This is compatible with the Rust mokaccino library,
        allowing to build percolators in one language and use them in the other.
        """
    @classmethod
    def from_json(cls, json_str: builtins.str) -> Percolator:
        r"""
        Deserialize a Percolator from a JSON string.
        """

@typing.final
class Query:
    r"""
    A Mokaccino Query object, representing an interest
    in documents matching certain criteria.
    """
    @classmethod
    def parse(cls, s: builtins.str) -> Query:
        r"""
        Parse the given query string into a Query object.
        
        See mokaccino documentation for the query syntax, or individual
        methods to create Query objects.
        """
    @classmethod
    def from_kv(cls, k: builtins.str, v: builtins.str) -> Query:
        r"""
        Create a Query that matches documents where field `k` has value `v`.
        
        This is the equivalent to parsing the query string `k:v`.
        """
    @classmethod
    def from_kprefix(cls, k: builtins.str, p: builtins.str) -> Query:
        r"""
        Create a Query that matches documents where field `k` has prefix `p`.
        
        This is the equivalent to parsing the query string `k:p*`.
        """
    @classmethod
    def from_klt(cls, k: builtins.str, v: builtins.int) -> Query:
        r"""
        Create a Query that matches documents where field `k` as an integer
        is lower than the given `v` value.
        
        This is the equivalent to parsing the query string `k<v`.
        """
    @classmethod
    def from_kle(cls, k: builtins.str, v: builtins.int) -> Query:
        r"""
        Create a Query that matches documents where field `k` as an integer
        is lower than or equal to the given `v` value.
        
        This is the equivalent to parsing the query string `k<=v`.
        """
    @classmethod
    def from_keq(cls, k: builtins.str, v: builtins.int) -> Query:
        r"""
        Create a Query that matches documents where field `k` as an integer
        is equal to the given `v` value.
        
        This is the equivalent to parsing the query string `k=v`.
        """
    @classmethod
    def from_kge(cls, k: builtins.str, v: builtins.int) -> Query:
        r"""
        Create a Query that matches documents where field `k` as an integer
        is greater than or equal to the given `v` value.
        
        This is the equivalent to parsing the query string `k>=v`.
        """
    @classmethod
    def from_kgt(cls, k: builtins.str, v: builtins.int) -> Query:
        r"""
        Create a Query that matches documents where field `k` as an integer
        is greater than the given `v` value.
        
        This is the equivalent to parsing the query string `k>v`.
        """
    @classmethod
    def from_h3in(cls, k: builtins.str, cell: builtins.str) -> Query:
        r"""
        Create a Query that matches documents where field `k` is a location
        inside or equal to the given h3 cell.

        This is the equivalent to parsing the query string `k H3IN cell`.

        The cell must be a valid h3 index hexadecimal string.
        """
    @classmethod
    def from_not(cls, q: Query) -> Query:
        r"""
        Create a Query that matches documents NOT matching the given Query `q`.
        Alternatively, use the `~` operator before a Query object.
        
        This is the equivalent to parsing the query string `NOT a:b` , or `NOT ( .. )`.
        """
    @classmethod
    def from_and(cls, iterable: typing.Any) -> Query:
        r"""
        Create a Query that matches documents matching ALL of the given Queries
        Alternatively, use the `&` operator between Query objects.
        
        This is the equivalent to parsing the query string `a:b AND c:d AND (..) ...`
        """
    @classmethod
    def from_or(cls, iterable: typing.Any) -> Query:
        r"""
        Create a Query that matches documents matching ANY of the given Queries
        Alternatively, use the `|` operator between Query objects.
        
        This is the equivalent to parsing the query string `a:b OR c:d OR (..) ...`
        """
    def __str__(self) -> builtins.str: ...
    def __and__(self, other: Query) -> Query: ...
    def __or__(self, other: Query) -> Query: ...
    def __invert__(self) -> Query: ...


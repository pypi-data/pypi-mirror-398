"""The Plash CLI tool"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_cli.ipynb.

# %% auto 0
__all__ = ['PLASH_CONFIG_HOME', 'PLASH_DOMAIN', 'pat', 'log_modes', 'PlashError', 'login', 'create_tar_archive', 'deploy', 'view',
           'delete', 'start', 'stop', 'logs', 'download', 'apps']

# %% ../nbs/00_cli.ipynb 3
from fastcore.all import *
from fastcore.xdg import *
import secrets, webbrowser, json, httpx, io, tarfile, random, string
from pathlib import Path
from uuid import uuid4
from time import time, sleep
import io, os, re, tarfile, tomllib

from . import __version__

# %% ../nbs/00_cli.ipynb 6
PLASH_CONFIG_HOME = xdg_config_home() / 'plash_config.json'
PLASH_DOMAIN = os.getenv("PLASH_DOMAIN","pla.sh")  # pla.sh plash-dev.answer.ai localhost:5002

# %% ../nbs/00_cli.ipynb 7
def _get_client(cfg=PLASH_CONFIG_HOME):
    client = httpx.Client()
    if tok := os.getenv("PLASH_TOKEN"): cookies = {"session_": tok}
    elif cfg.exists(): cookies = cfg.read_json()
    else: raise FileNotFoundError("Config not found. Run plash_login and retry.")
    client.cookies.update(cookies)
    client.headers.update({'X-PLASH': 'true', 'User-Agent': f'plash_cli/{__version__}'})
    return client

# %% ../nbs/00_cli.ipynb 8
def _mk_auth_req(url:str, method:str='get', timeout=300., **kwargs):
    r = getattr(_get_client(), method)(url, timeout=timeout, **kwargs)
    if r.status_code == 200: return r
    else: print(f'Failure: {r.headers["X-Plash-Error"]}')

# %% ../nbs/00_cli.ipynb 9
def _get_app_name(path:Path):
    plash_app = Path(path) / '.plash'
    if not plash_app.exists(): raise FileNotFoundError(f"File not found: {plash_app=}")
    env = parse_env(fn=plash_app)
    if name:=env.get("PLASH_APP_NAME"): return name
    if aid :=env.get('PLASH_APP_ID'): 
            plash_app.write_text(f"export PLASH_APP_NAME={aid}")
            return aid
    raise RuntimeError(f"{plash_app=} did not have a PLASH_APP_NAME")


# %% ../nbs/00_cli.ipynb 10
def _endpoint(sub='', rt=''):
    p = "http" if "localhost" in PLASH_DOMAIN else "https"
    return f"{p}://{sub}{'.' if sub else ''}{PLASH_DOMAIN}{rt}"

# %% ../nbs/00_cli.ipynb 11
def _is_included(path):
    "Returns True if path should be included in deployment"
    if path.name.startswith('.'): return False
    if path.suffix == '.pyc': return False
    excludes = {'.git', '__pycache__', '.gitignore', '.env', 
                '.pytest_cache', '.venv', 'venv', '.ipynb_checkpoints',
                '.vscode', '.idea', '.sesskey'}
    return not any(p in excludes for p in path.parts)

# %% ../nbs/00_cli.ipynb 12
class PlashError(Exception): pass

# %% ../nbs/00_cli.ipynb 13
def _poll_cookies(paircode, interval=1, timeout=180):
    "Poll server for token until received or timeout"
    start = time()
    client = httpx.Client()
    url = _endpoint(rt=f"/cli_token?paircode={paircode}")
    while time()-start < timeout:
        resp = client.get(url).raise_for_status()
        if resp.text.strip(): return dict(client.cookies)
        sleep(interval)

# %% ../nbs/00_cli.ipynb 14
@call_parse
def login(
    token:str=None,  # Token to save directly to config
    show:bool=False  # Output the current session token
):
    "Authenticate CLI with server and save config"
    if show:
        if not PLASH_CONFIG_HOME.exists(): return print("No config found.")
        return print(PLASH_CONFIG_HOME.read_json().get("session_", ""), end='')
    if token:
        PLASH_CONFIG_HOME.write_text(json.dumps({"session_": token.strip()}))
        return f"Token saved to {PLASH_CONFIG_HOME}"
    paircode = secrets.token_urlsafe(16)
    login_url = httpx.get(_endpoint(rt=f"/cli_login?paircode={paircode}")).text
    print(f"Opening browser for authentication:\n{login_url}\n")
    webbrowser.open(login_url)
    
    cookies = _poll_cookies(paircode)
    if cookies:
        PLASH_CONFIG_HOME.write_text(json.dumps(cookies))
        print(f"Authentication successful! Config saved to {PLASH_CONFIG_HOME}")
    else: print("Authentication timed out.")

# %% ../nbs/00_cli.ipynb 17
pat = r'(?m)^# /// (?P<type>[a-zA-Z0-9-]+)$\s(?P<content>(^#(| .*)$\s)+)^# ///$'

def _deps(script: bytes | str):
    'Get the dependencies from the script. From: https://peps.python.org/pep-0723/'
    name = 'script'
    if isinstance(script, bytes): script = script.decode('utf-8')
    matches = L(re.finditer(pat, script)).filter(lambda m: m.group('type') == name)
    if len(matches) > 1: raise ValueError(f'Multiple {name} blocks found')
    elif len(matches) == 1:
        content = ''.join(line[2:] if line.startswith('# ') else line[1:]
                          for line in matches[0].group('content').splitlines(keepends=True))
        return '\n'.join(tomllib.loads(content)['dependencies'])
    else: return None

# %% ../nbs/00_cli.ipynb 19
def _validate_app(path):
    "Validates directory `path` is a deployable Plash app"
    if not (path / 'main.py').exists():
        raise PlashError('A Plash app requires a main.py file.')
    deps = _deps((path / 'main.py').read_text(encoding='utf-8'))
    if  deps and (path/"requirements.txt").exists(): 
        raise PlashError('A Plash app should not contain both a requirements.txt file and inline dependencies (see PEP723).')

# %% ../nbs/00_cli.ipynb 22
def create_tar_archive(path:Path, force_data:bool=False) -> tuple[io.BytesIO, int]:
    "Creates a tar archive of a directory, excluding files based on is_included"
    tarz = io.BytesIO()
    files = L(path if path.is_file() else path.iterdir()).filter(_is_included)
    if not force_data: files = files.filter(lambda f: f.name != 'data')
    with tarfile.open(fileobj=tarz, mode='w:gz') as tar:
        for f in files: tar.add(f, arcname=f.name)
        if deps:=_deps((path/'main.py').read_bytes()):
            info = tarfile.TarInfo('requirements.txt')
            info.size = len(deps)
            tar.addfile(info, io.BytesIO(deps.encode('utf-8')))
    tarz.seek(0)
    return tarz, len(files)

# %% ../nbs/00_cli.ipynb 23
@call_parse
def deploy(
    path:Path=Path('.'),    # Path to project
    name:str=None,          # Overrides the .plash file in project root if provided
    force_data:bool=False): # Overwrite data/ directory during deployment
    """
    Deploys app to production. By default, this command erases all files in your app which are not in data/.
    Then uploads all files and folders, except paths starting with `.` and except the local data/ directory.
    If `--force_data` is used, then it erases all files in production. Then it uploads all files and folders,
    including `data/`, except paths starting with `.`.
    """
    print('Initializing deployment...')
    if name == '': print('Error: App name cannot be an empty string'); return
    if not path.is_dir(): print("Error: Path should point to the project directory"); return
    try: _validate_app(path)
    except PlashError as e: print(f"Error: {str(e)}\nInvalid path: {path}"); return
    
    try: 
        if not name: name = _get_app_name(path)
    except FileNotFoundError:
        plash_app = path / '.plash'
        name = friendly_name(3, 3)
        plash_app.write_text(f'export PLASH_APP_NAME={name}')
    
    tarz, _ = create_tar_archive(path, force_data)
    r = _mk_auth_req(_endpoint(rt="/upload"), "post", files={'file': tarz},
                     data={'name': name, 'force_data': force_data})
    if r:
        print('âœ… Upload complete! Your app is currently being built.\n' +
            f'It will be live at {name if "." in name else _endpoint(sub=name)}')
    else: return 'Unknown failure'

# %% ../nbs/00_cli.ipynb 26
@call_parse
def view(
    path:Path=Path('.'), # Path to project directory
    name:str=None,     # Overrides the .plash file in project root if provided
):
    "Open your app in the browser"
    if not name: name = _get_app_name(path)
    url = name if '.' in name else _endpoint(sub=name)
    print(f"Opening browser to view app :\n{url}\n")
    webbrowser.open(url)

# %% ../nbs/00_cli.ipynb 29
@call_parse
def delete(
    path:Path=Path('.'), # Path to project
    name:str=None,     # Overrides the .plash file in project root if provided
    force:bool=False):   # Skip confirmation prompt
    'Delete your deployed app'
    if not name: name = _get_app_name(path)
    if not force:
        confirm = input(f"Are you sure you want to delete app '{name}'? This action cannot be undone. [y/N]: ")
        if confirm.lower() not in ['y', 'yes']:
            print("Deletion cancelled.")
            return
    
    print(f"Deleting app '{name}'...")
    if r := _mk_auth_req(_endpoint(rt=f"/delete?name={name}"), "delete"): return r.text

# %% ../nbs/00_cli.ipynb 32
@call_parse
def start(path:Path=Path('.'), name:str=None):
    "Start your deployed app"
    if not name: name = _get_app_name(path)
    if r := _mk_auth_req(_endpoint(rt=f"/start?name={name}")): return r.text

# %% ../nbs/00_cli.ipynb 35
@call_parse  
def stop(path:Path=Path('.'), name:str=None):
    "Stop your deployed app" 
    if not name: name = _get_app_name(path)
    if r := _mk_auth_req(_endpoint(rt=f"/stop?name={name}")): return r.text

# %% ../nbs/00_cli.ipynb 38
log_modes = str_enum('log_modes', 'build', 'app')

# %% ../nbs/00_cli.ipynb 39
@call_parse
def logs(
    path:Path=Path('.'),    # Path to project
    name:str=None,          # Overrides the .plash file in project root if provided
    mode:log_modes='build', # Choose between build or app logs
    tail:bool=False):       # Tail the logs
    'Prints the logs for your deployed app'
    if not name: name = _get_app_name(path)
    if tail:
        text = ''
        while True:
            try:
                r = _mk_auth_req(_endpoint(rt=f"/logs?name={name}&mode={mode}"))
                print(r.text[len(text):], end='') # Only print updates
                text = r.text
                if mode == 'build' and 'Build End Time:' in r.text: return
                sleep(1)
            except KeyboardInterrupt: return "\nExiting"
    if r := _mk_auth_req(_endpoint(rt=f"/logs?name={name}&mode={mode}")): return r.text

# %% ../nbs/00_cli.ipynb 42
@patch
def _is_dir_empty(self:Path): return next(self.iterdir(), None) is None

# %% ../nbs/00_cli.ipynb 46
@call_parse
def download(
    path:Path=Path('.'),                 # Path to project
    name:str=None,                       # Overrides the .plash file in project root if provided
    save_path:Path=Path("./download/")): # Save path (optional)
    'Download your deployed app'
    if not name: name = _get_app_name(path)
    save_path.mkdir(exist_ok=True)
    if not save_path._is_dir_empty(): return print(f'ERROR: Save path ({save_path}) is not empty.')
    if r := _mk_auth_req(_endpoint(rt=f'/download?name={name}')):
        with tarfile.open(fileobj=io.BytesIO(r.content), mode="r:gz") as tar: tar.extractall(path=save_path, filter='data')
        print(f"Downloaded your app to: {save_path}")        

# %% ../nbs/00_cli.ipynb 49
@call_parse
def apps(verbose:bool=False):
    "List your deployed apps (verbose shows status table: 1=running, 0=stopped)"
    r = _mk_auth_req(_endpoint(rt="/user_apps"))
    if r:
        apps = r.json()
        if not apps: return "You don't have any deployed Plash apps."
        if verbose: return [print(f"{a['running']} {a['name']}") for a in apps]
        else: return [print(a['name']) for a in apps]

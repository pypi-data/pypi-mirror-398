Metadata-Version: 2.4
Name: django-delete-guard
Version: 0.1.1
Summary: Blocks dangerous Django ORM QuerySet.delete() calls in production.
Project-URL: Homepage, https://github.com/yourname/django-delete-guard
Project-URL: Repository, https://github.com/yourname/django-delete-guard
Project-URL: Issues, https://github.com/yourname/django-delete-guard/issues
Author: Matt
License: MIT
Keywords: delete,django,guard,orm,production,safety
Classifier: Development Status :: 3 - Alpha
Classifier: Framework :: Django
Classifier: Framework :: Django :: 3.2
Classifier: Framework :: Django :: 4.2
Classifier: Framework :: Django :: 5.0
Classifier: Framework :: Django :: 5.1
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3 :: Only
Requires-Python: >=3.9
Requires-Dist: django<6.0,>=3.2
Provides-Extra: dev
Requires-Dist: pytest-django>=4.8.0; extra == 'dev'
Requires-Dist: pytest>=8.0.0; extra == 'dev'
Requires-Dist: ruff>=0.5.0; extra == 'dev'
Description-Content-Type: text/markdown

# django-delete-guard (DeleteGuard)

**Blocks dangerous Django ORM deletes in production — before they happen.**

Backups and alerts are too late.  
This stops risky `QuerySet.delete()` calls **at execution time**, unless the developer explicitly opts in.

---

## Why this exists

If you’ve ever:
- wiped production with a bad `.delete()`
- underestimated cascade deletes
- run a “quick cleanup” script in prod
- trusted migrations too much

…this is for you.

**Most catastrophic data loss is valid code with invalid intent.**  
Django makes bulk deletes deceptively easy. This guard makes them explicit.

---

## What it does (V1)

In **production only** (`APP_ENV=production|prod`), it blocks:

- ❌ **Unfiltered deletes**  
  `Model.objects.all().delete()`

- ❌ **Bulk deletes over 100 rows**

Unless you explicitly override with intent.

Everything else works normally.

---

## Install (60 seconds)

```bash
pip install django-delete-guard

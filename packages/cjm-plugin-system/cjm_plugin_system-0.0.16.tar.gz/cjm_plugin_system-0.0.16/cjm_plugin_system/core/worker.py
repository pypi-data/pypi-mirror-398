"""FastAPI server that runs inside isolated plugin environments"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/worker.ipynb.

# %% auto 0
__all__ = ['EnhancedJSONEncoder', 'parent_monitor', 'create_app', 'run_worker']

# %% ../../nbs/core/worker.ipynb 3
import argparse
import dataclasses
import importlib
import json
import os
import signal
import sys
import threading
import time
from typing import Any, Dict, Generator

import psutil
import uvicorn
from fastapi import FastAPI, HTTPException, Request
from fastapi.responses import StreamingResponse

import logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    force=True
)

# %% ../../nbs/core/worker.ipynb 6
class EnhancedJSONEncoder(json.JSONEncoder):
    """JSON encoder that handles dataclasses and other common types."""
    
    def default(
        self,
        o: Any # Object to encode
    ) -> Any: # JSON-serializable representation
        """Convert non-serializable objects to serializable form."""
        if dataclasses.is_dataclass(o) and not isinstance(o, type):
            return dataclasses.asdict(o)
        return super().default(o)

# %% ../../nbs/core/worker.ipynb 9
def parent_monitor(
    ppid: int # Parent process ID to monitor
) -> None:
    """Monitor parent process and terminate self if parent dies."""
    try:
        while True:
            parent = psutil.Process(ppid)
            if parent.status() == psutil.STATUS_ZOMBIE:
                raise psutil.NoSuchProcess(ppid)
            time.sleep(1)
    except (psutil.NoSuchProcess, ProcessLookupError):
        print(f"[Worker {os.getpid()}] Parent {ppid} gone. Shutting down.")
        os.kill(os.getpid(), signal.SIGTERM)

# %% ../../nbs/core/worker.ipynb 12
def create_app(
    module_name: str, # Python module path (e.g., "my_plugin.plugin")
    class_name: str   # Plugin class name (e.g., "WhisperPlugin")
) -> FastAPI: # Configured FastAPI application
    """Create FastAPI app that hosts the specified plugin."""
    app = FastAPI(title="Plugin Worker")
    plugin_instance = None

    # Dynamic Loading
    try:
        module = importlib.import_module(module_name)
        plugin_cls = getattr(module, class_name)
        plugin_instance = plugin_cls()
    except Exception as e:
        print(f"FATAL: Failed to load {module_name}:{class_name} - {e}")
        sys.exit(1)

    @app.get("/health")
    def health_check() -> Dict[str, Any]:
        """Health check endpoint."""
        return {
            "status": "running",
            "pid": os.getpid(),
            "name": getattr(plugin_instance, "name", "unknown"),
            "version": getattr(plugin_instance, "version", "unknown")
        }

    @app.get("/stats")
    def stats() -> Dict[str, Any]:
        """Return process resource usage for scheduling decisions."""
        proc = psutil.Process()
        return {
            "pid": os.getpid(),
            "cpu_percent": proc.cpu_percent(),
            "memory_rss_mb": proc.memory_info().rss / 1024 / 1024
        }

    @app.post("/initialize")
    async def initialize(request: Request) -> Dict[str, str]:
        """Initialize or reconfigure the plugin."""
        try:
            config = await request.json()
            plugin_instance.initialize(config)
            return {"status": "ok"}
        except Exception as e:
            raise HTTPException(status_code=400, detail=str(e))

    @app.get("/config_schema")
    def get_config_schema() -> Dict[str, Any]:
        """Return JSON Schema for plugin configuration."""
        if hasattr(plugin_instance, 'get_config_schema'):
            return plugin_instance.get_config_schema()
        return {}

    @app.get("/config")
    def get_config() -> Dict[str, Any]:
        """Return current plugin configuration."""
        if hasattr(plugin_instance, 'get_current_config'):
            cfg = plugin_instance.get_current_config()
            # Ensure dataclasses are serialized
            return json.loads(json.dumps(cfg, cls=EnhancedJSONEncoder))
        return {}

    @app.post("/execute")
    async def execute(request: Request) -> Any:
        """Execute plugin's main functionality."""
        data = await request.json()
        args = data.get("args", [])
        kwargs = data.get("kwargs", {})
        
        try:
            result = plugin_instance.execute(*args, **kwargs)
            # Serialize result (handles dataclasses)
            json_str = json.dumps(result, cls=EnhancedJSONEncoder)
            return json.loads(json_str)
        except Exception as e:
            import traceback
            traceback.print_exc()
            raise HTTPException(status_code=500, detail=str(e))

    @app.post("/execute_stream")
    async def execute_stream(request: Request) -> StreamingResponse:
        """Execute plugin with streaming response (NDJSON)."""
        data = await request.json()
        args = data.get("args", [])
        kwargs = data.get("kwargs", {})

        def iter_response() -> Generator[str, None, None]:
            try:
                if hasattr(plugin_instance, 'execute_stream'):
                    iterator = plugin_instance.execute_stream(*args, **kwargs)
                else:
                    # Fallback: wrap single result
                    iterator = [plugin_instance.execute(*args, **kwargs)]
                
                for chunk in iterator:
                    # Line-delimited JSON (NDJSON)
                    yield json.dumps(chunk, cls=EnhancedJSONEncoder) + "\n"
            except Exception as e:
                yield json.dumps({"error": str(e)}) + "\n"

        return StreamingResponse(iter_response(), media_type="application/x-ndjson")

    @app.post("/cleanup")
    def cleanup() -> Dict[str, str]:
        """Clean up plugin resources."""
        if hasattr(plugin_instance, 'cleanup'):
            plugin_instance.cleanup()
        return {"status": "cleaned"}

    return app

# %% ../../nbs/core/worker.ipynb 15
def run_worker() -> None:
    """CLI entry point for running the worker."""
    parser = argparse.ArgumentParser(description="Universal Plugin Worker")
    parser.add_argument("--module", required=True, help="Plugin module path")
    parser.add_argument("--class", dest="class_name", required=True, help="Plugin class name")
    parser.add_argument("--port", type=int, required=True, help="Port to listen on")
    parser.add_argument("--ppid", type=int, required=False, help="Parent PID to monitor")
    args = parser.parse_args()

    # Start watchdog if parent PID provided
    if args.ppid:
        watchdog = threading.Thread(
            target=parent_monitor,
            args=(args.ppid,),
            daemon=True
        )
        watchdog.start()

    app = create_app(args.module, args.class_name)
    uvicorn.run(app, host="127.0.0.1", port=args.port, log_level="warning")

# %% ../../nbs/core/worker.ipynb 17
#| eval: false
import sys

if __name__ == "__main__" and "ipykernel" not in sys.modules:
    run_worker()

"""Resource scheduling policies for plugin execution"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/scheduling.ipynb.

# %% auto 0
__all__ = ['ResourceScheduler', 'PermissiveScheduler', 'SafetyScheduler', 'QueueScheduler']

# %% ../../nbs/core/scheduling.ipynb 3
import time
import asyncio
import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, Callable, Awaitable

from .metadata import PluginMeta

# %% ../../nbs/core/scheduling.ipynb 5
class ResourceScheduler(ABC):
    """Abstract base class for resource allocation policies."""
    
    @abstractmethod
    def allocate(
        self,
        plugin_meta: PluginMeta,  # Metadata of the plugin requesting resources
        stats_provider: Callable[[], Dict[str, Any]]  # Function that returns fresh stats
    ) -> bool:  # True if execution is allowed
        """Decide if a plugin can start based on its requirements and system state."""
        ...

    async def allocate_async(
        self,
        plugin_meta: PluginMeta,  # Metadata of the plugin requesting resources
        stats_provider: Callable[[], Awaitable[Dict[str, Any]]]  # Async function returning stats
    ) -> bool:  # True if execution is allowed
        """Async allocation decision. Default delegates to sync allocate after fetching stats once."""
        stats = await stats_provider()
        return self.allocate(plugin_meta, lambda: stats)

    @abstractmethod
    def on_execution_start(
        self,
        plugin_name: str  # Name of the plugin starting execution
    ) -> None:
        """Notify scheduler that a task started (to reserve resources)."""
        ...

    @abstractmethod
    def on_execution_finish(
        self,
        plugin_name: str  # Name of the plugin finishing execution
    ) -> None:
        """Notify scheduler that a task finished (to release resources)."""
        ...

# %% ../../nbs/core/scheduling.ipynb 7
class PermissiveScheduler(ResourceScheduler):
    """Scheduler that allows all executions (Default / Dev Mode)."""
    
    def allocate(
        self,
        plugin_meta: PluginMeta,  # Metadata of the plugin requesting resources
        stats_provider: Callable[[], Dict[str, Any]]  # Stats provider (ignored)
    ) -> bool:  # Always returns True
        """Allow all plugin executions without checking resources."""
        return True

    def on_execution_start(
        self,
        plugin_name: str  # Name of the plugin starting execution
    ) -> None:
        """No-op for permissive scheduler."""
        pass

    def on_execution_finish(
        self,
        plugin_name: str  # Name of the plugin finishing execution
    ) -> None:
        """No-op for permissive scheduler."""
        pass

# %% ../../nbs/core/scheduling.ipynb 9
class SafetyScheduler(ResourceScheduler):
    """Scheduler that prevents execution if resources are insufficient."""
    
    def _check_resources(
        self,
        plugin_meta: PluginMeta,  # Plugin metadata with manifest
        stats: Dict[str, Any]  # Current system stats
    ) -> bool:  # True if resources available
        """Check if system has sufficient resources for the plugin."""
        reqs = {}
        if hasattr(plugin_meta, 'manifest'):
            reqs = plugin_meta.manifest.get('resources', {})
            
        if not reqs:
            return True  # No requirements defined

        # Check GPU Memory
        if reqs.get('requires_gpu', False):
            needed_vram = reqs.get('min_gpu_vram_mb', 0)
            available_vram = stats.get('gpu_free_memory_mb')
            
            if available_vram is None:
                print("[Scheduler] Warning: No GPU stats available.")
                return True

            if needed_vram > available_vram:
                print(f"[Scheduler] Blocked {plugin_meta.name}: Needs {needed_vram}MB VRAM, has {available_vram}MB")
                return False
                
        # Check System RAM
        needed_ram = reqs.get('min_system_ram_mb', 0)
        available_ram = stats.get('memory_available_mb')
        
        if available_ram is not None and needed_ram > available_ram:
            print(f"[Scheduler] Blocked {plugin_meta.name}: Needs {needed_ram}MB RAM, has {available_ram}MB")
            return False
            
        return True
    
    def allocate(
        self,
        plugin_meta: PluginMeta,  # Metadata of the plugin requesting resources
        stats_provider: Callable[[], Dict[str, Any]]  # Function returning current stats
    ) -> bool:  # True if resources are available
        """Check resource requirements against system state."""
        return self._check_resources(plugin_meta, stats_provider())

    def on_execution_start(
        self,
        plugin_name: str  # Name of the plugin starting execution
    ) -> None:
        """Called when execution starts (for future resource reservation)."""
        pass

    def on_execution_finish(
        self,
        plugin_name: str  # Name of the plugin finishing execution
    ) -> None:
        """Called when execution finishes (for future resource release)."""
        pass

# %% ../../nbs/core/scheduling.ipynb 11
class QueueScheduler(ResourceScheduler):
    """Scheduler that waits for resources to become available."""
    
    def __init__(
        self,
        timeout: float = 300.0,  # Max seconds to wait for resources
        poll_interval: float = 2.0  # Seconds between resource checks
    ):
        """Initialize queue scheduler with timeout and polling settings."""
        self.timeout = timeout
        self.poll_interval = poll_interval
        self.logger = logging.getLogger(f"{__name__}.{type(self).__name__}")

    def _check_resources(
        self,
        plugin_meta: PluginMeta,  # Plugin metadata with manifest
        stats: Dict[str, Any]  # Current system stats
    ) -> bool:  # True if resources available
        """Check if system has sufficient resources for the plugin."""
        reqs = {}
        if hasattr(plugin_meta, 'manifest'):
            reqs = plugin_meta.manifest.get('resources', {})
            
        if not reqs:
            return True

        # Check GPU Memory
        if reqs.get('requires_gpu', False):
            needed_vram = reqs.get('min_gpu_vram_mb', 0)
            available_vram = stats.get('gpu_free_memory_mb')
            if available_vram is not None and needed_vram > available_vram:
                return False
                
        # Check System RAM
        needed_ram = reqs.get('min_system_ram_mb', 0)
        available_ram = stats.get('memory_available_mb')
        if available_ram is not None and needed_ram > available_ram:
            return False
            
        return True
    
    def allocate(
        self,
        plugin_meta: PluginMeta,  # Metadata of the plugin requesting resources
        stats_provider: Callable[[], Dict[str, Any]]  # Function returning current stats
    ) -> bool:  # True if resources become available before timeout
        """Wait for resources using blocking sleep."""
        start_time = time.time()
        
        while True:
            stats = stats_provider()
            if self._check_resources(plugin_meta, stats):
                return True
            
            if time.time() - start_time > self.timeout:
                self.logger.error(f"Timeout waiting for resources for {plugin_meta.name}")
                return False
                
            self.logger.info(f"Resources busy. Waiting {self.poll_interval}s...")
            time.sleep(self.poll_interval)

    async def allocate_async(
        self,
        plugin_meta: PluginMeta,  # Metadata of the plugin requesting resources
        stats_provider: Callable[[], Awaitable[Dict[str, Any]]]  # Async stats function
    ) -> bool:  # True if resources become available before timeout
        """Wait for resources using non-blocking async sleep."""
        start_time = time.time()
        
        while True:
            stats = await stats_provider()
            if self._check_resources(plugin_meta, stats):
                return True
            
            if time.time() - start_time > self.timeout:
                self.logger.error(f"Timeout waiting for resources for {plugin_meta.name}")
                return False
                
            self.logger.info(f"Resources busy. Yielding {self.poll_interval}s...")
            await asyncio.sleep(self.poll_interval)

    def on_execution_start(
        self,
        plugin_name: str  # Name of the plugin starting execution
    ) -> None:
        """Called when execution starts."""
        pass

    def on_execution_finish(
        self,
        plugin_name: str  # Name of the plugin finishing execution
    ) -> None:
        """Called when execution finishes."""
        pass

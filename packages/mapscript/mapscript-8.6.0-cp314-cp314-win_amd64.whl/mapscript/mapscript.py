# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.4.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if getattr(globals().get("__spec__"), "parent", None) or __package__ or "." in __name__:
    from . import _mapscript
else:
    import _mapscript

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class intarray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _mapscript.intarray_swiginit(self, _mapscript.new_intarray(nelements))
    __swig_destroy__ = _mapscript.delete_intarray

    def __getitem__(self, index: "size_t") -> "int":
        return _mapscript.intarray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "int") -> "void":
        return _mapscript.intarray___setitem__(self, index, value)

    def cast(self) -> "int *":
        return _mapscript.intarray_cast(self)

    @staticmethod
    def frompointer(t: "int *") -> "intarray *":
        return _mapscript.intarray_frompointer(t)

# Register intarray in _mapscript:
_mapscript.intarray_swigregister(intarray)

MapServerError = _mapscript.MapServerError
MapServerChildError = _mapscript.MapServerChildError

MS_TRUE = _mapscript.MS_TRUE
MS_FALSE = _mapscript.MS_FALSE
MS_UNKNOWN = _mapscript.MS_UNKNOWN
MS_ON = _mapscript.MS_ON
MS_OFF = _mapscript.MS_OFF
MS_DEFAULT = _mapscript.MS_DEFAULT
MS_EMBED = _mapscript.MS_EMBED
MS_DELETE = _mapscript.MS_DELETE
MS_YES = _mapscript.MS_YES
MS_NO = _mapscript.MS_NO
MS_LAYER_ALLOCSIZE = _mapscript.MS_LAYER_ALLOCSIZE
MS_CLASS_ALLOCSIZE = _mapscript.MS_CLASS_ALLOCSIZE
MS_STYLE_ALLOCSIZE = _mapscript.MS_STYLE_ALLOCSIZE
MS_LABEL_ALLOCSIZE = _mapscript.MS_LABEL_ALLOCSIZE
MS_MAX_LABEL_PRIORITY = _mapscript.MS_MAX_LABEL_PRIORITY
MS_MAX_LABEL_FONTS = _mapscript.MS_MAX_LABEL_FONTS
MS_DEFAULT_LABEL_PRIORITY = _mapscript.MS_DEFAULT_LABEL_PRIORITY
MS_LABEL_FORCE_GROUP = _mapscript.MS_LABEL_FORCE_GROUP
MS_RENDER_WITH_SWF = _mapscript.MS_RENDER_WITH_SWF
MS_RENDER_WITH_RAWDATA = _mapscript.MS_RENDER_WITH_RAWDATA
MS_RENDER_WITH_IMAGEMAP = _mapscript.MS_RENDER_WITH_IMAGEMAP
MS_RENDER_WITH_TEMPLATE = _mapscript.MS_RENDER_WITH_TEMPLATE
MS_RENDER_WITH_OGR = _mapscript.MS_RENDER_WITH_OGR
MS_RENDER_WITH_PLUGIN = _mapscript.MS_RENDER_WITH_PLUGIN
MS_RENDER_WITH_CAIRO_RASTER = _mapscript.MS_RENDER_WITH_CAIRO_RASTER
MS_RENDER_WITH_CAIRO_PDF = _mapscript.MS_RENDER_WITH_CAIRO_PDF
MS_RENDER_WITH_CAIRO_SVG = _mapscript.MS_RENDER_WITH_CAIRO_SVG
MS_RENDER_WITH_OGL = _mapscript.MS_RENDER_WITH_OGL
MS_RENDER_WITH_AGG = _mapscript.MS_RENDER_WITH_AGG
MS_RENDER_WITH_KML = _mapscript.MS_RENDER_WITH_KML
MS_RENDER_WITH_UTFGRID = _mapscript.MS_RENDER_WITH_UTFGRID
MS_RENDER_WITH_MVT = _mapscript.MS_RENDER_WITH_MVT
MS_NUM_CHECK_NONE = _mapscript.MS_NUM_CHECK_NONE
MS_NUM_CHECK_RANGE = _mapscript.MS_NUM_CHECK_RANGE
MS_NUM_CHECK_GT = _mapscript.MS_NUM_CHECK_GT
MS_NUM_CHECK_GTE = _mapscript.MS_NUM_CHECK_GTE
MS_FILE_MAP = _mapscript.MS_FILE_MAP
MS_FILE_SYMBOL = _mapscript.MS_FILE_SYMBOL
MS_INCHES = _mapscript.MS_INCHES
MS_FEET = _mapscript.MS_FEET
MS_MILES = _mapscript.MS_MILES
MS_METERS = _mapscript.MS_METERS
MS_KILOMETERS = _mapscript.MS_KILOMETERS
MS_DD = _mapscript.MS_DD
MS_PIXELS = _mapscript.MS_PIXELS
MS_PERCENTAGES = _mapscript.MS_PERCENTAGES
MS_NAUTICALMILES = _mapscript.MS_NAUTICALMILES
MS_INHERIT = _mapscript.MS_INHERIT
MS_SHAPE_POINT = _mapscript.MS_SHAPE_POINT
MS_SHAPE_LINE = _mapscript.MS_SHAPE_LINE
MS_SHAPE_POLYGON = _mapscript.MS_SHAPE_POLYGON
MS_SHAPE_NULL = _mapscript.MS_SHAPE_NULL
MS_LAYER_POINT = _mapscript.MS_LAYER_POINT
MS_LAYER_LINE = _mapscript.MS_LAYER_LINE
MS_LAYER_POLYGON = _mapscript.MS_LAYER_POLYGON
MS_LAYER_RASTER = _mapscript.MS_LAYER_RASTER
MS_LAYER_ANNOTATION = _mapscript.MS_LAYER_ANNOTATION
MS_LAYER_QUERY = _mapscript.MS_LAYER_QUERY
MS_LAYER_CIRCLE = _mapscript.MS_LAYER_CIRCLE
MS_LAYER_TILEINDEX = _mapscript.MS_LAYER_TILEINDEX
MS_LAYER_CHART = _mapscript.MS_LAYER_CHART
MS_TRUETYPE = _mapscript.MS_TRUETYPE
MS_BITMAP = _mapscript.MS_BITMAP
MS_FIRST_MATCHING_CLASS = _mapscript.MS_FIRST_MATCHING_CLASS
MS_ALL_MATCHING_CLASSES = _mapscript.MS_ALL_MATCHING_CLASSES
MS_POSITIONS_LENGTH = _mapscript.MS_POSITIONS_LENGTH
MS_UL = _mapscript.MS_UL
MS_LR = _mapscript.MS_LR
MS_UR = _mapscript.MS_UR
MS_LL = _mapscript.MS_LL
MS_CR = _mapscript.MS_CR
MS_CL = _mapscript.MS_CL
MS_UC = _mapscript.MS_UC
MS_LC = _mapscript.MS_LC
MS_CC = _mapscript.MS_CC
MS_AUTO = _mapscript.MS_AUTO
MS_XY = _mapscript.MS_XY
MS_NONE = _mapscript.MS_NONE
MS_AUTO2 = _mapscript.MS_AUTO2
MS_FOLLOW = _mapscript.MS_FOLLOW
MS_TINY = _mapscript.MS_TINY
MS_SMALL = _mapscript.MS_SMALL
MS_MEDIUM = _mapscript.MS_MEDIUM
MS_LARGE = _mapscript.MS_LARGE
MS_GIANT = _mapscript.MS_GIANT
MS_NORMAL = _mapscript.MS_NORMAL
MS_HILITE = _mapscript.MS_HILITE
MS_SELECTED = _mapscript.MS_SELECTED
MS_INLINE = _mapscript.MS_INLINE
MS_SHAPEFILE = _mapscript.MS_SHAPEFILE
MS_TILED_SHAPEFILE = _mapscript.MS_TILED_SHAPEFILE
MS_UNUSED_2 = _mapscript.MS_UNUSED_2
MS_OGR = _mapscript.MS_OGR
MS_UNUSED_1 = _mapscript.MS_UNUSED_1
MS_POSTGIS = _mapscript.MS_POSTGIS
MS_WMS = _mapscript.MS_WMS
MS_ORACLESPATIAL = _mapscript.MS_ORACLESPATIAL
MS_WFS = _mapscript.MS_WFS
MS_GRATICULE = _mapscript.MS_GRATICULE
MS_MYSQL = _mapscript.MS_MYSQL
MS_RASTER = _mapscript.MS_RASTER
MS_PLUGIN = _mapscript.MS_PLUGIN
MS_UNION = _mapscript.MS_UNION
MS_UVRASTER = _mapscript.MS_UVRASTER
MS_CONTOUR = _mapscript.MS_CONTOUR
MS_KERNELDENSITY = _mapscript.MS_KERNELDENSITY
MS_IDW = _mapscript.MS_IDW
MS_FLATGEOBUF = _mapscript.MS_FLATGEOBUF
MS_RASTER_LABEL = _mapscript.MS_RASTER_LABEL
MS_DB_XBASE = _mapscript.MS_DB_XBASE
MS_DB_CSV = _mapscript.MS_DB_CSV
MS_DB_MYSQL = _mapscript.MS_DB_MYSQL
MS_DB_ORACLE = _mapscript.MS_DB_ORACLE
MS_DB_POSTGRES = _mapscript.MS_DB_POSTGRES
MS_JOIN_ONE_TO_ONE = _mapscript.MS_JOIN_ONE_TO_ONE
MS_JOIN_ONE_TO_MANY = _mapscript.MS_JOIN_ONE_TO_MANY
MS_SINGLE = _mapscript.MS_SINGLE
MS_MULTIPLE = _mapscript.MS_MULTIPLE
MS_QUERY_SINGLE = _mapscript.MS_QUERY_SINGLE
MS_QUERY_MULTIPLE = _mapscript.MS_QUERY_MULTIPLE
MS_QUERY_IS_NULL = _mapscript.MS_QUERY_IS_NULL
MS_QUERY_BY_POINT = _mapscript.MS_QUERY_BY_POINT
MS_QUERY_BY_RECT = _mapscript.MS_QUERY_BY_RECT
MS_QUERY_BY_SHAPE = _mapscript.MS_QUERY_BY_SHAPE
MS_QUERY_BY_ATTRIBUTE = _mapscript.MS_QUERY_BY_ATTRIBUTE
MS_QUERY_BY_INDEX = _mapscript.MS_QUERY_BY_INDEX
MS_QUERY_BY_FILTER = _mapscript.MS_QUERY_BY_FILTER
MS_ALIGN_DEFAULT = _mapscript.MS_ALIGN_DEFAULT
MS_ALIGN_LEFT = _mapscript.MS_ALIGN_LEFT
MS_ALIGN_CENTER = _mapscript.MS_ALIGN_CENTER
MS_ALIGN_RIGHT = _mapscript.MS_ALIGN_RIGHT
MS_CJC_NONE = _mapscript.MS_CJC_NONE
MS_CJC_BEVEL = _mapscript.MS_CJC_BEVEL
MS_CJC_BUTT = _mapscript.MS_CJC_BUTT
MS_CJC_MITER = _mapscript.MS_CJC_MITER
MS_CJC_ROUND = _mapscript.MS_CJC_ROUND
MS_CJC_SQUARE = _mapscript.MS_CJC_SQUARE
MS_CJC_TRIANGLE = _mapscript.MS_CJC_TRIANGLE
MS_CJC_DEFAULT_JOIN_MAXSIZE = _mapscript.MS_CJC_DEFAULT_JOIN_MAXSIZE
MS_SUCCESS = _mapscript.MS_SUCCESS
MS_FAILURE = _mapscript.MS_FAILURE
MS_DONE = _mapscript.MS_DONE
MS_IMAGEMODE_PC256 = _mapscript.MS_IMAGEMODE_PC256
MS_IMAGEMODE_RGB = _mapscript.MS_IMAGEMODE_RGB
MS_IMAGEMODE_RGBA = _mapscript.MS_IMAGEMODE_RGBA
MS_IMAGEMODE_INT16 = _mapscript.MS_IMAGEMODE_INT16
MS_IMAGEMODE_FLOAT32 = _mapscript.MS_IMAGEMODE_FLOAT32
MS_IMAGEMODE_BYTE = _mapscript.MS_IMAGEMODE_BYTE
MS_IMAGEMODE_FEATURE = _mapscript.MS_IMAGEMODE_FEATURE
MS_IMAGEMODE_NULL = _mapscript.MS_IMAGEMODE_NULL
MS_IMAGEMODE_FLOAT64 = _mapscript.MS_IMAGEMODE_FLOAT64
MS_GEOS_EQUALS = _mapscript.MS_GEOS_EQUALS
MS_GEOS_DISJOINT = _mapscript.MS_GEOS_DISJOINT
MS_GEOS_TOUCHES = _mapscript.MS_GEOS_TOUCHES
MS_GEOS_OVERLAPS = _mapscript.MS_GEOS_OVERLAPS
MS_GEOS_CROSSES = _mapscript.MS_GEOS_CROSSES
MS_GEOS_INTERSECTS = _mapscript.MS_GEOS_INTERSECTS
MS_GEOS_WITHIN = _mapscript.MS_GEOS_WITHIN
MS_GEOS_CONTAINS = _mapscript.MS_GEOS_CONTAINS
MS_GEOS_BEYOND = _mapscript.MS_GEOS_BEYOND
MS_GEOS_DWITHIN = _mapscript.MS_GEOS_DWITHIN
MS_TRANSFORM_NONE = _mapscript.MS_TRANSFORM_NONE
MS_TRANSFORM_ROUND = _mapscript.MS_TRANSFORM_ROUND
MS_TRANSFORM_SNAPTOGRID = _mapscript.MS_TRANSFORM_SNAPTOGRID
MS_TRANSFORM_FULLRESOLUTION = _mapscript.MS_TRANSFORM_FULLRESOLUTION
MS_TRANSFORM_SIMPLIFY = _mapscript.MS_TRANSFORM_SIMPLIFY
MS_COMPOP_CLEAR = _mapscript.MS_COMPOP_CLEAR
MS_COMPOP_SRC = _mapscript.MS_COMPOP_SRC
MS_COMPOP_DST = _mapscript.MS_COMPOP_DST
MS_COMPOP_SRC_OVER = _mapscript.MS_COMPOP_SRC_OVER
MS_COMPOP_DST_OVER = _mapscript.MS_COMPOP_DST_OVER
MS_COMPOP_SRC_IN = _mapscript.MS_COMPOP_SRC_IN
MS_COMPOP_DST_IN = _mapscript.MS_COMPOP_DST_IN
MS_COMPOP_SRC_OUT = _mapscript.MS_COMPOP_SRC_OUT
MS_COMPOP_DST_OUT = _mapscript.MS_COMPOP_DST_OUT
MS_COMPOP_SRC_ATOP = _mapscript.MS_COMPOP_SRC_ATOP
MS_COMPOP_DST_ATOP = _mapscript.MS_COMPOP_DST_ATOP
MS_COMPOP_XOR = _mapscript.MS_COMPOP_XOR
MS_COMPOP_PLUS = _mapscript.MS_COMPOP_PLUS
MS_COMPOP_MINUS = _mapscript.MS_COMPOP_MINUS
MS_COMPOP_MULTIPLY = _mapscript.MS_COMPOP_MULTIPLY
MS_COMPOP_SCREEN = _mapscript.MS_COMPOP_SCREEN
MS_COMPOP_OVERLAY = _mapscript.MS_COMPOP_OVERLAY
MS_COMPOP_DARKEN = _mapscript.MS_COMPOP_DARKEN
MS_COMPOP_LIGHTEN = _mapscript.MS_COMPOP_LIGHTEN
MS_COMPOP_COLOR_DODGE = _mapscript.MS_COMPOP_COLOR_DODGE
MS_COMPOP_COLOR_BURN = _mapscript.MS_COMPOP_COLOR_BURN
MS_COMPOP_HARD_LIGHT = _mapscript.MS_COMPOP_HARD_LIGHT
MS_COMPOP_SOFT_LIGHT = _mapscript.MS_COMPOP_SOFT_LIGHT
MS_COMPOP_DIFFERENCE = _mapscript.MS_COMPOP_DIFFERENCE
MS_COMPOP_EXCLUSION = _mapscript.MS_COMPOP_EXCLUSION
MS_COMPOP_CONTRAST = _mapscript.MS_COMPOP_CONTRAST
MS_COMPOP_INVERT = _mapscript.MS_COMPOP_INVERT
MS_COMPOP_INVERT_RGB = _mapscript.MS_COMPOP_INVERT_RGB
MS_COMPOP_HSL_HUE = _mapscript.MS_COMPOP_HSL_HUE
MS_COMPOP_HSL_LUMINOSITY = _mapscript.MS_COMPOP_HSL_LUMINOSITY
MS_COMPOP_HSL_SATURATION = _mapscript.MS_COMPOP_HSL_SATURATION
MS_COMPOP_HSL_COLOR = _mapscript.MS_COMPOP_HSL_COLOR
class CompositingFilter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    filter: "char *" = property(_mapscript.CompositingFilter_filter_get, _mapscript.CompositingFilter_filter_set)
    next: "struct _CompositingFilter *" = property(_mapscript.CompositingFilter_next_get, _mapscript.CompositingFilter_next_set)

    def __init__(self):
        _mapscript.CompositingFilter_swiginit(self, _mapscript.new_CompositingFilter())
    __swig_destroy__ = _mapscript.delete_CompositingFilter

# Register CompositingFilter in _mapscript:
_mapscript.CompositingFilter_swigregister(CompositingFilter)
class LayerCompositer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    comp_op: "CompositingOperation" = property(_mapscript.LayerCompositer_comp_op_get, _mapscript.LayerCompositer_comp_op_set)
    opacity: "int" = property(_mapscript.LayerCompositer_opacity_get, _mapscript.LayerCompositer_opacity_set)
    filter: "CompositingFilter *" = property(_mapscript.LayerCompositer_filter_get, _mapscript.LayerCompositer_filter_set)
    next: "struct _LayerCompositer *" = property(_mapscript.LayerCompositer_next_get, _mapscript.LayerCompositer_next_set)

    def __init__(self):
        _mapscript.LayerCompositer_swiginit(self, _mapscript.new_LayerCompositer())
    __swig_destroy__ = _mapscript.delete_LayerCompositer

# Register LayerCompositer in _mapscript:
_mapscript.LayerCompositer_swigregister(LayerCompositer)
MS_STYLE_BINDING_LENGTH = _mapscript.MS_STYLE_BINDING_LENGTH
MS_STYLE_BINDING_SIZE = _mapscript.MS_STYLE_BINDING_SIZE
MS_STYLE_BINDING_WIDTH = _mapscript.MS_STYLE_BINDING_WIDTH
MS_STYLE_BINDING_ANGLE = _mapscript.MS_STYLE_BINDING_ANGLE
MS_STYLE_BINDING_COLOR = _mapscript.MS_STYLE_BINDING_COLOR
MS_STYLE_BINDING_OUTLINECOLOR = _mapscript.MS_STYLE_BINDING_OUTLINECOLOR
MS_STYLE_BINDING_SYMBOL = _mapscript.MS_STYLE_BINDING_SYMBOL
MS_STYLE_BINDING_OUTLINEWIDTH = _mapscript.MS_STYLE_BINDING_OUTLINEWIDTH
MS_STYLE_BINDING_OPACITY = _mapscript.MS_STYLE_BINDING_OPACITY
MS_STYLE_BINDING_OFFSET_X = _mapscript.MS_STYLE_BINDING_OFFSET_X
MS_STYLE_BINDING_OFFSET_Y = _mapscript.MS_STYLE_BINDING_OFFSET_Y
MS_STYLE_BINDING_POLAROFFSET_PIXEL = _mapscript.MS_STYLE_BINDING_POLAROFFSET_PIXEL
MS_STYLE_BINDING_POLAROFFSET_ANGLE = _mapscript.MS_STYLE_BINDING_POLAROFFSET_ANGLE
MS_LABEL_BINDING_LENGTH = _mapscript.MS_LABEL_BINDING_LENGTH
MS_LABEL_BINDING_SIZE = _mapscript.MS_LABEL_BINDING_SIZE
MS_LABEL_BINDING_ANGLE = _mapscript.MS_LABEL_BINDING_ANGLE
MS_LABEL_BINDING_COLOR = _mapscript.MS_LABEL_BINDING_COLOR
MS_LABEL_BINDING_OUTLINECOLOR = _mapscript.MS_LABEL_BINDING_OUTLINECOLOR
MS_LABEL_BINDING_FONT = _mapscript.MS_LABEL_BINDING_FONT
MS_LABEL_BINDING_PRIORITY = _mapscript.MS_LABEL_BINDING_PRIORITY
MS_LABEL_BINDING_POSITION = _mapscript.MS_LABEL_BINDING_POSITION
MS_LABEL_BINDING_SHADOWSIZEX = _mapscript.MS_LABEL_BINDING_SHADOWSIZEX
MS_LABEL_BINDING_SHADOWSIZEY = _mapscript.MS_LABEL_BINDING_SHADOWSIZEY
MS_LABEL_BINDING_OFFSET_X = _mapscript.MS_LABEL_BINDING_OFFSET_X
MS_LABEL_BINDING_OFFSET_Y = _mapscript.MS_LABEL_BINDING_OFFSET_Y
MS_LABEL_BINDING_ALIGN = _mapscript.MS_LABEL_BINDING_ALIGN
class fontSetObj(object):
    r"""The :ref:`FONTSET <fontset>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    filename: "char *" = property(_mapscript.fontSetObj_filename_get, doc=r"""The filename of the fonset""")
    numfonts: "int" = property(_mapscript.fontSetObj_numfonts_get, doc=r"""The number of fonts in the fontset""")
    fonts: "hashTableObj" = property(_mapscript.fontSetObj_fonts_get, doc=r"""Key, value pairs of font name and font file""")

    def __init__(self):
        _mapscript.fontSetObj_swiginit(self, _mapscript.new_fontSetObj())
    __swig_destroy__ = _mapscript.delete_fontSetObj

# Register fontSetObj in _mapscript:
_mapscript.fontSetObj_swigregister(fontSetObj)
MS_TOKEN_LOGICAL_AND = _mapscript.MS_TOKEN_LOGICAL_AND
MS_TOKEN_LOGICAL_OR = _mapscript.MS_TOKEN_LOGICAL_OR
MS_TOKEN_LOGICAL_NOT = _mapscript.MS_TOKEN_LOGICAL_NOT
MS_TOKEN_LITERAL_NUMBER = _mapscript.MS_TOKEN_LITERAL_NUMBER
MS_TOKEN_LITERAL_STRING = _mapscript.MS_TOKEN_LITERAL_STRING
MS_TOKEN_LITERAL_TIME = _mapscript.MS_TOKEN_LITERAL_TIME
MS_TOKEN_LITERAL_SHAPE = _mapscript.MS_TOKEN_LITERAL_SHAPE
MS_TOKEN_LITERAL_BOOLEAN = _mapscript.MS_TOKEN_LITERAL_BOOLEAN
MS_TOKEN_COMPARISON_EQ = _mapscript.MS_TOKEN_COMPARISON_EQ
MS_TOKEN_COMPARISON_NE = _mapscript.MS_TOKEN_COMPARISON_NE
MS_TOKEN_COMPARISON_GT = _mapscript.MS_TOKEN_COMPARISON_GT
MS_TOKEN_COMPARISON_LT = _mapscript.MS_TOKEN_COMPARISON_LT
MS_TOKEN_COMPARISON_LE = _mapscript.MS_TOKEN_COMPARISON_LE
MS_TOKEN_COMPARISON_GE = _mapscript.MS_TOKEN_COMPARISON_GE
MS_TOKEN_COMPARISON_IEQ = _mapscript.MS_TOKEN_COMPARISON_IEQ
MS_TOKEN_COMPARISON_RE = _mapscript.MS_TOKEN_COMPARISON_RE
MS_TOKEN_COMPARISON_IRE = _mapscript.MS_TOKEN_COMPARISON_IRE
MS_TOKEN_COMPARISON_IN = _mapscript.MS_TOKEN_COMPARISON_IN
MS_TOKEN_COMPARISON_LIKE = _mapscript.MS_TOKEN_COMPARISON_LIKE
MS_TOKEN_COMPARISON_INTERSECTS = _mapscript.MS_TOKEN_COMPARISON_INTERSECTS
MS_TOKEN_COMPARISON_DISJOINT = _mapscript.MS_TOKEN_COMPARISON_DISJOINT
MS_TOKEN_COMPARISON_TOUCHES = _mapscript.MS_TOKEN_COMPARISON_TOUCHES
MS_TOKEN_COMPARISON_OVERLAPS = _mapscript.MS_TOKEN_COMPARISON_OVERLAPS
MS_TOKEN_COMPARISON_CROSSES = _mapscript.MS_TOKEN_COMPARISON_CROSSES
MS_TOKEN_COMPARISON_WITHIN = _mapscript.MS_TOKEN_COMPARISON_WITHIN
MS_TOKEN_COMPARISON_CONTAINS = _mapscript.MS_TOKEN_COMPARISON_CONTAINS
MS_TOKEN_COMPARISON_EQUALS = _mapscript.MS_TOKEN_COMPARISON_EQUALS
MS_TOKEN_COMPARISON_BEYOND = _mapscript.MS_TOKEN_COMPARISON_BEYOND
MS_TOKEN_COMPARISON_DWITHIN = _mapscript.MS_TOKEN_COMPARISON_DWITHIN
MS_TOKEN_FUNCTION_LENGTH = _mapscript.MS_TOKEN_FUNCTION_LENGTH
MS_TOKEN_FUNCTION_TOSTRING = _mapscript.MS_TOKEN_FUNCTION_TOSTRING
MS_TOKEN_FUNCTION_COMMIFY = _mapscript.MS_TOKEN_FUNCTION_COMMIFY
MS_TOKEN_FUNCTION_AREA = _mapscript.MS_TOKEN_FUNCTION_AREA
MS_TOKEN_FUNCTION_ROUND = _mapscript.MS_TOKEN_FUNCTION_ROUND
MS_TOKEN_FUNCTION_FROMTEXT = _mapscript.MS_TOKEN_FUNCTION_FROMTEXT
MS_TOKEN_FUNCTION_BUFFER = _mapscript.MS_TOKEN_FUNCTION_BUFFER
MS_TOKEN_FUNCTION_DIFFERENCE = _mapscript.MS_TOKEN_FUNCTION_DIFFERENCE
MS_TOKEN_FUNCTION_SIMPLIFY = _mapscript.MS_TOKEN_FUNCTION_SIMPLIFY
MS_TOKEN_FUNCTION_SIMPLIFYPT = _mapscript.MS_TOKEN_FUNCTION_SIMPLIFYPT
MS_TOKEN_FUNCTION_GENERALIZE = _mapscript.MS_TOKEN_FUNCTION_GENERALIZE
MS_TOKEN_FUNCTION_SMOOTHSIA = _mapscript.MS_TOKEN_FUNCTION_SMOOTHSIA
MS_TOKEN_FUNCTION_CENTERLINE = _mapscript.MS_TOKEN_FUNCTION_CENTERLINE
MS_TOKEN_FUNCTION_DENSIFY = _mapscript.MS_TOKEN_FUNCTION_DENSIFY
MS_TOKEN_FUNCTION_OUTER = _mapscript.MS_TOKEN_FUNCTION_OUTER
MS_TOKEN_FUNCTION_INNER = _mapscript.MS_TOKEN_FUNCTION_INNER
MS_TOKEN_FUNCTION_JAVASCRIPT = _mapscript.MS_TOKEN_FUNCTION_JAVASCRIPT
MS_TOKEN_FUNCTION_UPPER = _mapscript.MS_TOKEN_FUNCTION_UPPER
MS_TOKEN_FUNCTION_LOWER = _mapscript.MS_TOKEN_FUNCTION_LOWER
MS_TOKEN_FUNCTION_INITCAP = _mapscript.MS_TOKEN_FUNCTION_INITCAP
MS_TOKEN_FUNCTION_FIRSTCAP = _mapscript.MS_TOKEN_FUNCTION_FIRSTCAP
MS_TOKEN_BINDING_DOUBLE = _mapscript.MS_TOKEN_BINDING_DOUBLE
MS_TOKEN_BINDING_INTEGER = _mapscript.MS_TOKEN_BINDING_INTEGER
MS_TOKEN_BINDING_STRING = _mapscript.MS_TOKEN_BINDING_STRING
MS_TOKEN_BINDING_TIME = _mapscript.MS_TOKEN_BINDING_TIME
MS_TOKEN_BINDING_SHAPE = _mapscript.MS_TOKEN_BINDING_SHAPE
MS_TOKEN_BINDING_MAP_CELLSIZE = _mapscript.MS_TOKEN_BINDING_MAP_CELLSIZE
MS_TOKEN_BINDING_DATA_CELLSIZE = _mapscript.MS_TOKEN_BINDING_DATA_CELLSIZE
MS_PARSE_TYPE_BOOLEAN = _mapscript.MS_PARSE_TYPE_BOOLEAN
MS_PARSE_TYPE_STRING = _mapscript.MS_PARSE_TYPE_STRING
MS_PARSE_TYPE_SHAPE = _mapscript.MS_PARSE_TYPE_SHAPE
MS_PARSE_TYPE_SLD = _mapscript.MS_PARSE_TYPE_SLD
class clusterObj(object):
    r"""The :ref:`CLUSTER <cluster>` object. See :ref:`RFC 69 <rfc69>`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    maxdistance: "double" = property(_mapscript.clusterObj_maxdistance_get, _mapscript.clusterObj_maxdistance_set, doc=r"""
    Maximum distance between clusters - see
    :ref:`MAXDISTANCE <mapfile-cluster-maxdistance>`
    """)
    buffer: "double" = property(_mapscript.clusterObj_buffer_get, _mapscript.clusterObj_buffer_set, doc=r"""
    The buffer size around the selection area - see
    :ref:`BUFFER <mapfile-cluster-buffer>`
    """)
    region: "char *" = property(_mapscript.clusterObj_region_get, _mapscript.clusterObj_region_set, doc=r"""
    The type of the cluster region (rectangle or ellipse) - see
    :ref:`REGION <mapfile-cluster-region>`
    """)

    def updateFromString(self, snippet: "char *") -> "int":
        r"""Update a cluster from a string snippet. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.clusterObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Output the :ref:`cluster` as a Mapfile string"""
        return _mapscript.clusterObj_convertToString(self)

    def setGroup(self, group: "char *") -> "int":
        r"""
        Set :ref:`GROUP <mapfile-cluster-group>` string where `group` is a MapServer text expression.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.clusterObj_setGroup(self, group)

    def getGroupString(self) -> "char *":
        r"""Return a string representation of :ref:`GROUP <mapfile-cluster-group>`"""
        return _mapscript.clusterObj_getGroupString(self)

    def setFilter(self, filter: "char *") -> "int":
        r"""
        Set :ref:`FILTER <mapfile-cluster-filter>` string where `filter` is a MapServer text expression.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.clusterObj_setFilter(self, filter)

    def getFilterString(self) -> "char *":
        return _mapscript.clusterObj_getFilterString(self)

    def __init__(self):
        _mapscript.clusterObj_swiginit(self, _mapscript.new_clusterObj())
    __swig_destroy__ = _mapscript.delete_clusterObj

# Register clusterObj in _mapscript:
_mapscript.clusterObj_swigregister(clusterObj)
class outputFormatObj(object):
    r"""The :ref:`OUTPUTFORMAT <outputformat>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numformatoptions: "int" = property(_mapscript.outputFormatObj_numformatoptions_get, doc=r"""
    The number of option values set on this format - can be used to
    iterate over the options array in conjunction with
    :func:`outputFormatObj.getOptionAt`
    """)
    name: "char *" = property(_mapscript.outputFormatObj_name_get, _mapscript.outputFormatObj_name_set, doc=r"""See :ref:`NAME <mapfile-outputformat-name>`""")
    mimetype: "char *" = property(_mapscript.outputFormatObj_mimetype_get, _mapscript.outputFormatObj_mimetype_set, doc=r"""See :ref:`MIMETYPE <mapfile-outputformat-mimetype>`""")
    driver: "char *" = property(_mapscript.outputFormatObj_driver_get, _mapscript.outputFormatObj_driver_set, doc=r"""See :ref:`DRIVER <mapfile-outputformat-driver>`""")
    extension: "char *" = property(_mapscript.outputFormatObj_extension_get, _mapscript.outputFormatObj_extension_set, doc=r"""See :ref:`EXTENSION <mapfile-outputformat-extension>`""")
    renderer: "int" = property(_mapscript.outputFormatObj_renderer_get, _mapscript.outputFormatObj_renderer_set, doc=r"""
    A :ref:`render mode constant<mapfile-constants-render>` -
    normally set internally based on the driver and some other
    setting in the constructor.
    """)
    imagemode: "int" = property(_mapscript.outputFormatObj_imagemode_get, _mapscript.outputFormatObj_imagemode_set, doc=r"""
    An :ref:`Image mode constant<mapfile-constants-imagemode>`
    - see :ref:`IMAGEMODE <mapfile-outputformat-imagemode>`
    """)
    transparent: "int" = property(_mapscript.outputFormatObj_transparent_get, _mapscript.outputFormatObj_transparent_set, doc=r"""
    See :ref:`TRANSPARENT
    <mapfile-outputformat-transparent>`
    """)
    bands: "int" = property(_mapscript.outputFormatObj_bands_get, _mapscript.outputFormatObj_bands_set, doc=r"""
    The number of bands in the raster, normally set via the
    BAND_COUNT formatoption - this field should be considered
    read-only Only used for the "raw" modes, MS_IMAGEMODE_BYTE,
    MS_IMAGEMODE_INT16, and MS_IMAGEMODE_FLOAT32
    """)
    inmapfile: "int" = property(_mapscript.outputFormatObj_inmapfile_get, _mapscript.outputFormatObj_inmapfile_set, doc=r"""Boolean value indicating if the format is in the Mapfile""")

    def __init__(self, driver: "char const *", name: "char *"=None):
        r"""Create new instance. If name is not provided, the value of driver is used as a name."""
        _mapscript.outputFormatObj_swiginit(self, _mapscript.new_outputFormatObj(driver, name))
    __swig_destroy__ = _mapscript.delete_outputFormatObj

    def setExtension(self, extension: "char const *") -> "void":
        r"""
        Set file extension for output format such as  'png' or 'jpg'.
        Method could probably be deprecated since the extension attribute is mutable.
        Not in Java extension.
        """
        return _mapscript.outputFormatObj_setExtension(self, extension)

    def setMimetype(self, mimetype: "char const *") -> "void":
        r"""
        Set mimetype for output format such as ``image/png`` or ``image/jpeg``.
        Method could probably be deprecated since the mimetype attribute is mutable.
        Not in Java extension
        """
        return _mapscript.outputFormatObj_setMimetype(self, mimetype)

    def setOption(self, key: "char const *", value: "char const *") -> "void":
        r"""Set the format option at ``key`` to ``value``. Format options are mostly driver specific."""
        return _mapscript.outputFormatObj_setOption(self, key, value)

    def validate(self) -> "int":
        r"""
        Checks some internal consistency issues, and returns :data:`MS_TRUE`
        if things are OK and :data:`MS_FALSE` if there are problems.
        Some problems are fixed up internally. May produce debug output if issues encountered.
        """
        return _mapscript.outputFormatObj_validate(self)

    def getOption(self, *args) -> "char *":
        r"""
        Return the format option at ``key`` or ``defaultvalue``
        if key is not a valid hash index.
        """
        return _mapscript.outputFormatObj_getOption(self, *args)

    def getOptionAt(self, i: "int") -> "char *":
        r"""
        Returns the option at ``idx`` or NULL if the index is beyond the array bounds.
        The option is returned as the original KEY=VALUE string.
        The number of available options can be obtained via :attr:`outputFormatObj.numformatoptions`
        """
        return _mapscript.outputFormatObj_getOptionAt(self, i)

    def attachDevice(self, device: "void *") -> "void":
        r"""Set the device property of the output format"""
        return _mapscript.outputFormatObj_attachDevice(self, device)

# Register outputFormatObj in _mapscript:
_mapscript.outputFormatObj_swigregister(outputFormatObj)
MS_NOOVERRIDE = _mapscript.MS_NOOVERRIDE
class queryMapObj(object):
    r"""
    The :ref:`QUERYMAP <querymap>` object.
    Instances of querymapObj are always are always embedded inside the
    :class:`mapObj`.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    map: "struct mapObj *" = property(_mapscript.queryMapObj_map_get, doc=r"""Reference to parent :class:`mapObj`""")
    height: "int" = property(_mapscript.queryMapObj_height_get, _mapscript.queryMapObj_height_set, doc=r"""See :ref:`SIZE <mapfile-querymap-size>`""")
    width: "int" = property(_mapscript.queryMapObj_width_get, _mapscript.queryMapObj_width_set, doc=r"""See :ref:`SIZE <mapfile-querymap-size>`""")
    status: "int" = property(_mapscript.queryMapObj_status_get, _mapscript.queryMapObj_status_set, doc=r"""See :ref:`STATUS <mapfile-querymap-status>`""")
    style: "int" = property(_mapscript.queryMapObj_style_get, _mapscript.queryMapObj_style_set, doc=r"""
    ``HILITE``, ``SELECTED`` or ``NORMAL`` - see :ref:`STYLE
    <mapfile-querymap-style>`
    """)
    color: "colorObj" = property(_mapscript.queryMapObj_color_get, _mapscript.queryMapObj_color_set, doc=r"""See :ref:`COLOR <mapfile-querymap-color>`""")

    def updateFromString(self, snippet: "char *") -> "int":
        r"""
        Update a querymap from a string snippet.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.queryMapObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Saves the object to a string. Provides the inverse option for :func:`queryMapObj.updateFromString`."""
        return _mapscript.queryMapObj_convertToString(self)

    def __init__(self):
        _mapscript.queryMapObj_swiginit(self, _mapscript.new_queryMapObj())
    __swig_destroy__ = _mapscript.delete_queryMapObj

# Register queryMapObj in _mapscript:
_mapscript.queryMapObj_swigregister(queryMapObj)
class webObj(object):
    r"""
    The :ref:`WEB <web>` object.
    Has no other existence than as an attribute of a :class:`mapObj`.
    Serves as a container for various run-time web application definitions like
    temporary file paths, template paths, etc.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    metadata: "hashTableObj" = property(_mapscript.webObj_metadata_get, doc=r"""
    Metadata hash table - see :ref:`METADATA
    <mapfile-web-metadata>`
    """)
    validation: "hashTableObj" = property(_mapscript.webObj_validation_get, doc=r"""See :ref:`VALIDATION <mapfile-web-validation>`""")
    map: "struct mapObj *" = property(_mapscript.webObj_map_get, doc=r"""Reference to parent :class:`mapObj`""")
    imagepath: "char *" = property(_mapscript.webObj_imagepath_get, _mapscript.webObj_imagepath_set, doc=r"""
    Filesystem path to temporary image location - see
    :ref:`IMAGEPATH <mapfile-web-imagepath>`
    """)
    imageurl: "char *" = property(_mapscript.webObj_imageurl_get, _mapscript.webObj_imageurl_set, doc=r"""
    URL to temporary image location - see :ref:`IMAGEURL
    <mapfile-web-imageurl>`
    """)
    temppath: "char *" = property(_mapscript.webObj_temppath_get, _mapscript.webObj_temppath_set, doc=r"""See :ref:`TEMPPATH <mapfile-web-temppath>`""")
    header: "char *" = property(_mapscript.webObj_header_get, _mapscript.webObj_header_set, doc=r"""
    Path to header document - see :ref:`HEADER
    <mapfile-web-header>`
    """)
    footer: "char *" = property(_mapscript.webObj_footer_get, _mapscript.webObj_footer_set, doc=r"""
    Path to footer document - see :ref:`FOOTER
    <mapfile-web-footer>`
    """)
    empty: "char *" = property(_mapscript.webObj_empty_get, _mapscript.webObj_empty_set, doc=r"""See :ref:`EMPTY <mapfile-web-empty>`""")
    error: "char *" = property(_mapscript.webObj_error_get, _mapscript.webObj_error_set, doc=r"""Error handling - see :ref:`ERROR <mapfile-web-error>`""")
    minscaledenom: "double" = property(_mapscript.webObj_minscaledenom_get, _mapscript.webObj_minscaledenom_set, doc=r"""
    Maximum map scale - see :ref:`MINSCALEDENOM
    <mapfile-web-minscaledenom>`
    """)
    maxscaledenom: "double" = property(_mapscript.webObj_maxscaledenom_get, _mapscript.webObj_maxscaledenom_set, doc=r"""
    Minimum map scale - see :ref:`MAXSCALEDENOM
    <mapfile-web-maxscaledenom>`
    """)
    mintemplate: "char *" = property(_mapscript.webObj_mintemplate_get, _mapscript.webObj_mintemplate_set, doc=r"""See :ref:`MINTEMPLATE <mapfile-web-mintemplate>`""")
    maxtemplate: "char *" = property(_mapscript.webObj_maxtemplate_get, _mapscript.webObj_maxtemplate_set, doc=r"""See :ref:`MAXTEMPLATE <mapfile-web-maxtemplate>`""")
    queryformat: "char *" = property(_mapscript.webObj_queryformat_get, _mapscript.webObj_queryformat_set, doc=r"""
    See :ref:`QUERYFORMAT <mapfile-web-queryformat>` /*
    what format is the query to be returned, given as a
    MIME type
    """)
    legendformat: "char *" = property(_mapscript.webObj_legendformat_get, _mapscript.webObj_legendformat_set, doc=r"""See :ref:`LEGENDFORMAT <mapfile-web-legendformat>`""")
    browseformat: "char *" = property(_mapscript.webObj_browseformat_get, _mapscript.webObj_browseformat_set, doc=r"""See :ref:`BROWSEFORMAT <mapfile-web-browseformat>`""")
    template: "char *" = property(_mapscript.webObj_template_get, _mapscript.webObj_template_set, doc=r"""
    Path to template document - see :ref:`TEMPLATE
    <mapfile-web-template>`
    """)

    def __init__(self):
        r"""
        Instances of :class:`webObj` are always are always embedded inside the :class:`mapObj`.
        Has no other existence than as an attribute of a :class:`mapObj`. Serves as a container for various run-time
        web application definitions like temporary file paths, template paths, etc.
        """
        _mapscript.webObj_swiginit(self, _mapscript.new_webObj())
    __swig_destroy__ = _mapscript.delete_webObj

    def updateFromString(self, snippet: "char *") -> "int":
        r"""Update a :class:`webObj` from a string snippet. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.webObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Output the :ref:`web` object as a Mapfile string. Provides the inverse option for :func:`webObj.updateFromString`."""
        return _mapscript.webObj_convertToString(self)

# Register webObj in _mapscript:
_mapscript.webObj_swigregister(webObj)
class styleObj(object):
    r"""
    The :ref:`STYLE <style>` object. An instance of styleObj is associated with one
    instance of :class:`classObj`.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refcount: "int" = property(_mapscript.styleObj_refcount_get, doc=r"""number of references to this object""")
    symbolname: "char *" = property(_mapscript.styleObj_symbolname_get, doc=r"""
    Name of the style's symbol - see :ref:`symbolname
    <mapfile-style-symbol>`
    """)
    patternlength: "int" = property(_mapscript.styleObj_patternlength_get, doc=r"""Number of elements in the pattern attribute""")
    angle: "double" = property(_mapscript.styleObj_angle_get, _mapscript.styleObj_angle_set, doc=r"""
    Angle, given in degrees, to draw the line work, default is
    0, for symbols of Type HATCH, this is the angle of the
    hatched lines - see :ref:`ANGLE <mapfile-style-angle>`
    """)
    autoangle: "int" = property(_mapscript.styleObj_autoangle_get, _mapscript.styleObj_autoangle_set, doc=r"""
    If the angle is set to ``AUTO`` - see :ref:`ANGLE
    <mapfile-style-angle>`
    """)
    antialiased: "int" = property(_mapscript.styleObj_antialiased_get, _mapscript.styleObj_antialiased_set, doc=r"""See :ref:`ANTIALIAS <mapfile-style-antialias>`""")
    color: "colorObj" = property(_mapscript.styleObj_color_get, _mapscript.styleObj_color_set, doc=r"""
    Foreground or fill pen color - see :ref:`COLOR
    <mapfile-style-color>`
    """)
    outlinecolor: "colorObj" = property(_mapscript.styleObj_outlinecolor_get, _mapscript.styleObj_outlinecolor_set, doc=r"""
    Outline pen color - see :ref:`OUTLINECOLOR
    <mapfile-style-outlinecolor>`
    """)
    opacity: "int" = property(_mapscript.styleObj_opacity_get, _mapscript.styleObj_opacity_set, doc=r"""See :ref:`OPACITY <mapfile-style-opacity>`""")
    mincolor: "colorObj" = property(_mapscript.styleObj_mincolor_get, _mapscript.styleObj_mincolor_set, doc=r"""
    Minimum color in the :ref:`COLORRANGE
    <mapfile-style-colorrange>`
    """)
    maxcolor: "colorObj" = property(_mapscript.styleObj_maxcolor_get, _mapscript.styleObj_maxcolor_set, doc=r"""
    Maximum color in the :ref:`COLORRANGE
    <mapfile-style-colorrange>`
    """)
    minvalue: "double" = property(_mapscript.styleObj_minvalue_get, _mapscript.styleObj_minvalue_set, doc=r"""related to color ranges""")
    maxvalue: "double" = property(_mapscript.styleObj_maxvalue_get, _mapscript.styleObj_maxvalue_set, doc=r"""related to color ranges""")
    rangeitem: "char *" = property(_mapscript.styleObj_rangeitem_get, _mapscript.styleObj_rangeitem_set, doc=r"""
    Attribute/field that stores the values for the Color Range
    Mapping  - see :ref:`RANGEITEM <mapfile-style-rangeitem>`
    """)
    rangeitemindex: "int" = property(_mapscript.styleObj_rangeitemindex_get, _mapscript.styleObj_rangeitemindex_set, doc=r"""
    The index of the range item - see :ref:`RANGEITEM
    <mapfile-style-rangeitem>`
    """)
    symbol: "int" = property(_mapscript.styleObj_symbol_get, _mapscript.styleObj_symbol_set, doc=r"""
    The index within the map symbolset of the style's symbol -
    see :ref:`SYMBOL <mapfile-style-symbol>`
    """)
    size: "double" = property(_mapscript.styleObj_size_get, _mapscript.styleObj_size_set, doc=r"""
    Pixel width of the style's pen or symbol - see :ref:`SIZE
    <mapfile-style-size>`
    """)
    minsize: "double" = property(_mapscript.styleObj_minsize_get, _mapscript.styleObj_minsize_set, doc=r"""
    Minimum pen or symbol width for scaling styles - see
    :ref:`MINSIZE <mapfile-style-minsize>`
    """)
    maxsize: "double" = property(_mapscript.styleObj_maxsize_get, _mapscript.styleObj_maxsize_set, doc=r"""
    Maximum pen or symbol width for scaling - see
    :ref:`MAXSIZE <mapfile-style-maxsize>`
    """)
    gap: "double" = property(_mapscript.styleObj_gap_get, _mapscript.styleObj_gap_set, doc=r"""
    See :ref:`GAP <mapfile-style-gap>` - moved from symbolObj in
    version 6.0
    """)
    initialgap: "double" = property(_mapscript.styleObj_initialgap_get, _mapscript.styleObj_initialgap_set, doc=r"""See :ref:`INITIALGAP <mapfile-style-initialgap>`""")
    linecap: "int" = property(_mapscript.styleObj_linecap_get, _mapscript.styleObj_linecap_set, doc=r"""See :ref:`LINECAP <mapfile-style-linecap>`""")
    linejoin: "int" = property(_mapscript.styleObj_linejoin_get, _mapscript.styleObj_linejoin_set, doc=r"""
    See :ref:`LINEJOIN <mapfile-style-linejoin>` - moved from
    symbolObj in version 6.0
    """)
    linejoinmaxsize: "double" = property(_mapscript.styleObj_linejoinmaxsize_get, _mapscript.styleObj_linejoinmaxsize_set, doc=r"""
    See :ref:`LINEJOINMAXSIZE
    <mapfile-style-linejoinmaxsize>` - moved from
    symbolObj in version 6.0
    """)
    width: "double" = property(_mapscript.styleObj_width_get, _mapscript.styleObj_width_set, doc=r"""
    Width refers to the thickness of line work drawn, in pixels
    - default is 1, for symbols of type ``HATCH``, the with is
    how thick the hatched lines are - see :ref:`WIDTH
    <mapfile-style-width>`
    """)
    outlinewidth: "double" = property(_mapscript.styleObj_outlinewidth_get, _mapscript.styleObj_outlinewidth_set, doc=r"""See :ref:`OUTLINEWIDTH <mapfile-style-outlinewidth>`""")
    minwidth: "double" = property(_mapscript.styleObj_minwidth_get, _mapscript.styleObj_minwidth_set, doc=r"""
    Minimum width of the symbol - see :ref:`MINWIDTH
    <mapfile-style-minwidth>`
    """)
    maxwidth: "double" = property(_mapscript.styleObj_maxwidth_get, _mapscript.styleObj_maxwidth_set, doc=r"""
    Maximum width of the symbol - see :ref:`MAXWIDTH
    <mapfile-style-maxwidth>`
    """)
    offsetx: "double" = property(_mapscript.styleObj_offsetx_get, _mapscript.styleObj_offsetx_set, doc=r"""
    Draw with pen or symbol offset from map data, for
    shadows, hollow symbols, etc - see :ref:`OFFSET
    <mapfile-style-offset>`
    """)
    offsety: "double" = property(_mapscript.styleObj_offsety_get, _mapscript.styleObj_offsety_set, doc=r"""
    Draw with pen or symbol offset from map data, for
    shadows, hollow symbols, etc - see :ref:`OFFSET
    <mapfile-style-offset>`
    """)
    polaroffsetpixel: "double" = property(_mapscript.styleObj_polaroffsetpixel_get, _mapscript.styleObj_polaroffsetpixel_set, doc=r"""
    Specifies the radius/distance - see
    :ref:`POLAROFFSET <mapfile-style-polaroffset>`
    """)
    polaroffsetangle: "double" = property(_mapscript.styleObj_polaroffsetangle_get, _mapscript.styleObj_polaroffsetangle_set, doc=r"""
    Specified the angle - see :ref:`POLAROFFSET
    <mapfile-style-polaroffset>`
    """)
    minscaledenom: "double" = property(_mapscript.styleObj_minscaledenom_get, _mapscript.styleObj_minscaledenom_set, doc=r"""See :ref:`MINSCALEDENOM <mapfile-style-minscaledenom>`""")
    maxscaledenom: "double" = property(_mapscript.styleObj_maxscaledenom_get, _mapscript.styleObj_maxscaledenom_set, doc=r"""See :ref:`MAXSCALEDENOM <mapfile-style-maxscaledenom>`""")
    sizeunits: "int" = property(_mapscript.styleObj_sizeunits_get, _mapscript.styleObj_sizeunits_set, doc=r"""
    Supersedes class's :ref:`SIZEUNITS
    <mapfile-layer-sizeunits>` to allow fine-grained sizing
    for improved SLD (RFC 124)
    """)

    def __init__(self, parent_class: "classObj"=None):
        r"""Returns new default :class:`styleObj` instance. The ``parent_class`` is optional."""
        _mapscript.styleObj_swiginit(self, _mapscript.new_styleObj(parent_class))
    __swig_destroy__ = _mapscript.delete_styleObj

    def updateFromString(self, snippet: "char *") -> "int":
        r"""
        Update a style from a string snippet.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.styleObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Saves the object to a string. Provides the inverse option for :func:`styleObj.updateFromString`"""
        return _mapscript.styleObj_convertToString(self)

    def clone(self) -> "styleObj *":
        r"""
        Return an independent copy of the style with no parent class.

        .. note::

            In the Java & PHP modules this method is named ``cloneStyle``.
        """
        return _mapscript.styleObj_clone(self)

    def setSymbolByName(self, map: "mapObj", symbolname: "char *") -> "int":
        r"""
        Setting the symbol of the :class:`styleObj` given the reference of the map
        object and the symbol name.
        """
        return _mapscript.styleObj_setSymbolByName(self, map, symbolname)

    def removeBinding(self, binding: "int") -> "int":
        r"""Remove the attribute binding for a specified style property."""
        return _mapscript.styleObj_removeBinding(self, binding)

    def setBinding(self, binding: "int", item: "char const *") -> "int":
        r"""Remove the attribute binding for a specified style property."""
        return _mapscript.styleObj_setBinding(self, binding, item)

    def getBinding(self, binding: "int") -> "char const *":
        r"""
        Get the attribute binding for a specified style property.
        Returns NULL if there is no binding for this property.
        """
        return _mapscript.styleObj_getBinding(self, binding)

    def getGeomTransform(self) -> "char *":
        r"""Get the :ref:`GEOMTRANSFORM <mapfile-style-geomtransform>` for the style."""
        return _mapscript.styleObj_getGeomTransform(self)

    def setGeomTransform(self, transform: "char *") -> "void":
        r"""Set the :ref:`GEOMTRANSFORM <mapfile-style-geomtransform>` for the style."""
        return _mapscript.styleObj_setGeomTransform(self, transform)

    def pattern_set(self, nListSize: "int") -> "void":
        r"""Python Only** Set the pattern for the style."""
        return _mapscript.styleObj_pattern_set(self, nListSize)

    def pattern_get(self) -> "void":
        r"""Python Only** Get the pattern for the style."""
        return _mapscript.styleObj_pattern_get(self)


    pattern = property(pattern_get, pattern_set, doc=r"""pattern : list **Python Only**""")



# Register styleObj in _mapscript:
_mapscript.styleObj_swigregister(styleObj)
MS_STYLE_SINGLE_SIDED_OFFSET = _mapscript.MS_STYLE_SINGLE_SIDED_OFFSET
MS_STYLE_DOUBLE_SIDED_OFFSET = _mapscript.MS_STYLE_DOUBLE_SIDED_OFFSET
class labelLeaderObj(object):
    r"""The :ref:`LEADER <leader>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numstyles: "int" = property(_mapscript.labelLeaderObj_numstyles_get, doc=r"""Number of styles used""")
    maxdistance: "int" = property(_mapscript.labelLeaderObj_maxdistance_get, _mapscript.labelLeaderObj_maxdistance_set, doc=r"""See :ref:`MAXDISTANCE <mapfile-leader-maxdistance>`""")
    gridstep: "int" = property(_mapscript.labelLeaderObj_gridstep_get, _mapscript.labelLeaderObj_gridstep_set, doc=r"""See :ref:`GRIDSTEP <mapfile-leader-gridstep>`""")

    def __init__(self):
        _mapscript.labelLeaderObj_swiginit(self, _mapscript.new_labelLeaderObj())
    __swig_destroy__ = _mapscript.delete_labelLeaderObj

# Register labelLeaderObj in _mapscript:
_mapscript.labelLeaderObj_swigregister(labelLeaderObj)
class labelObj(object):
    r"""The :ref:`LABEL <label>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refcount: "int" = property(_mapscript.labelObj_refcount_get)
    font: "char *" = property(_mapscript.labelObj_font_get, _mapscript.labelObj_font_set, doc=r"""Name of TrueType font  see :ref:`FONT <mapfile-label-font>`""")
    color: "colorObj" = property(_mapscript.labelObj_color_get, _mapscript.labelObj_color_set, doc=r"""Foreground color - see :ref:`COLOR <mapfile-label-color>`""")
    outlinecolor: "colorObj" = property(_mapscript.labelObj_outlinecolor_get, _mapscript.labelObj_outlinecolor_set, doc=r"""
    Color of one point outline - see
    :ref:`OUTLINECOLOR <mapfile-label-outlinecolor>`
    """)
    outlinewidth: "int" = property(_mapscript.labelObj_outlinewidth_get, _mapscript.labelObj_outlinewidth_set, doc=r"""See :ref:`OUTLINEWIDTH <mapfile-label-outlinewidth>`""")
    shadowcolor: "colorObj" = property(_mapscript.labelObj_shadowcolor_get, _mapscript.labelObj_shadowcolor_set, doc=r"""See :ref:`SHADOWCOLOR <mapfile-label-shadowcolor>`""")
    shadowsizex: "int" = property(_mapscript.labelObj_shadowsizex_get, _mapscript.labelObj_shadowsizex_set, doc=r"""See :ref:`SHADOWSIZE <mapfile-label-shadowsize>`""")
    shadowsizey: "int" = property(_mapscript.labelObj_shadowsizey_get, _mapscript.labelObj_shadowsizey_set, doc=r"""See :ref:`SHADOWSIZE <mapfile-label-shadowsize>`""")
    size: "int" = property(_mapscript.labelObj_size_get, _mapscript.labelObj_size_set, doc=r"""
    Annotation height in pixels - see :ref:`SIZE
    <mapfile-label-size>`
    """)
    minsize: "int" = property(_mapscript.labelObj_minsize_get, _mapscript.labelObj_minsize_set, doc=r"""
    Minimum height in pixels - see :ref:`MINSIZE
    <mapfile-label-minsize>`
    """)
    maxsize: "int" = property(_mapscript.labelObj_maxsize_get, _mapscript.labelObj_maxsize_set, doc=r"""
    Maximum height in pixels for scaled labels. See
    :ref:`MAXSIZE <mapfile-label-maxsize>`
    """)
    position: "int" = property(_mapscript.labelObj_position_get, _mapscript.labelObj_position_set, doc=r"""See :ref:`POSITION <mapfile-label-position>`""")
    offsetx: "int" = property(_mapscript.labelObj_offsetx_get, _mapscript.labelObj_offsetx_set, doc=r"""
    Horizontal offset of label - see :ref:`OFFSET
    <mapfile-label-offset>`
    """)
    offsety: "int" = property(_mapscript.labelObj_offsety_get, _mapscript.labelObj_offsety_set, doc=r"""
    Vertical offset of label - see :ref:`OFFSET
    <mapfile-label-offset>`
    """)
    angle: "double" = property(_mapscript.labelObj_angle_get, _mapscript.labelObj_angle_set, doc=r"""See :ref:`ANGLE <mapfile-label-angle>`""")
    anglemode: "enum MS_POSITIONS_ENUM" = property(_mapscript.labelObj_anglemode_get, _mapscript.labelObj_anglemode_set, doc=r"""
    One of :data:`AUTO` :data:`AUTO2`, or :data:`FOLLOW` - see
    :ref:`ANGLE <mapfile-label-angle>`
    """)
    buffer: "int" = property(_mapscript.labelObj_buffer_get, _mapscript.labelObj_buffer_set, doc=r"""
    Space to reserve around a label (padding) - see :ref:`BUFFER
    <mapfile-label-buffer>`
    """)
    align: "int" = property(_mapscript.labelObj_align_get, _mapscript.labelObj_align_set, doc=r"""See :ref:`ALIGN <mapfile-label-align>`""")
    wrap: "char" = property(_mapscript.labelObj_wrap_get, _mapscript.labelObj_wrap_set, doc=r"""See :ref:`WRAP <mapfile-label-wrap>`""")
    maxlength: "int" = property(_mapscript.labelObj_maxlength_get, _mapscript.labelObj_maxlength_set, doc=r"""See :ref:`MAXLENGTH <mapfile-label-maxlength>`""")
    space_size_10: "double" = property(_mapscript.labelObj_space_size_10_get, _mapscript.labelObj_space_size_10_set, doc=r"""
    Cached size of a single space character used for
    label text alignment of rfc40
    """)
    minfeaturesize: "int" = property(_mapscript.labelObj_minfeaturesize_get, _mapscript.labelObj_minfeaturesize_set, doc=r"""
    Minimum feature size (in pixels) to label, features of this size or greater
    will be labeled - see :ref:`MINFEATURESIZE  <mapfile-label-minfeaturesize>`
    """)
    autominfeaturesize: "int" = property(_mapscript.labelObj_autominfeaturesize_get, _mapscript.labelObj_autominfeaturesize_set, doc=r""":data:`MS_TRUE` or :data:`MS_FALSE`""")
    minscaledenom: "double" = property(_mapscript.labelObj_minscaledenom_get, _mapscript.labelObj_minscaledenom_set, doc=r"""See :ref:`MINSCALEDENOM <mapfile-label-minscaledenom>`""")
    maxscaledenom: "double" = property(_mapscript.labelObj_maxscaledenom_get, _mapscript.labelObj_maxscaledenom_set, doc=r"""See :ref:`MAXSCALEDENOM <mapfile-label-maxscaledenom>`""")
    mindistance: "int" = property(_mapscript.labelObj_mindistance_get, _mapscript.labelObj_mindistance_set, doc=r"""
    Minimum distance in pixels between duplicate labels -
    see :ref:`MINDISTANCE <mapfile-label-mindistance>`
    """)
    repeatdistance: "int" = property(_mapscript.labelObj_repeatdistance_get, _mapscript.labelObj_repeatdistance_set, doc=r"""
    See :ref:`REPEATDISTANCE
    <mapfile-label-repeatdistance>`
    """)
    maxoverlapangle: "double" = property(_mapscript.labelObj_maxoverlapangle_get, _mapscript.labelObj_maxoverlapangle_set, doc=r"""
    See :ref:`MAXOVERLAPANGLE
    <mapfile-label-maxoverlapangle>`
    """)
    partials: "int" = property(_mapscript.labelObj_partials_get, _mapscript.labelObj_partials_set, doc=r"""
    Indicates if labels can run off the edge of an image, either :data:`MS_TRUE`
    or :data:`MS_FALSE` (default) - see :ref:`PARTIALS <mapfile-label-partials>`
    """)
    force: "int" = property(_mapscript.labelObj_force_get, _mapscript.labelObj_force_set, doc=r"""
    Indicates if labels **must** be drawn - see :ref:`FORCE
    <mapfile-label-force>`
    """)
    encoding: "char *" = property(_mapscript.labelObj_encoding_get, _mapscript.labelObj_encoding_set, doc=r"""
    Supported encoding format to be used for labels - see
    :ref:`ENCODING <mapfile-label-encoding>`
    """)
    priority: "int" = property(_mapscript.labelObj_priority_get, _mapscript.labelObj_priority_set, doc=r"""
    Priority level 1 to :data:`MS_MAX_LABEL_PRIORITY`,
    default=1 - see :ref:`PRIORITY <mapfile-label-priority>`
    """)
    numstyles: "int" = property(_mapscript.labelObj_numstyles_get, _mapscript.labelObj_numstyles_set, doc=r"""The number of styles associated with the label""")
    sizeunits: "int" = property(_mapscript.labelObj_sizeunits_get, _mapscript.labelObj_sizeunits_set, doc=r"""
    Supersedes class's sizeunits, defaults to
    :data:`MS_INHERIT`.
    """)

    def __init__(self):
        r"""
        Create a new :class:`labelObj`. A :class:`labelObj` is associated with a
        :class:`classObj` a :class:`scalebarObj` or a :class:`legendObj`.
        An instance of :class:`labelObj` can exist outside of a :class:`classObj` container and be
        explicitly inserted into the :class:`classObj`:

        >>> new_label = new labelObj()

        >>> the_class.addLabel(new_label)
        """
        _mapscript.labelObj_swiginit(self, _mapscript.new_labelObj())
    __swig_destroy__ = _mapscript.delete_labelObj

    def updateFromString(self, snippet: "char *") -> "int":
        r"""Update a :class:`labelObj` from a string snippet. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.labelObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Output the :class:`labelObj` object as a Mapfile string. Provides the inverse option for :func:`labelObj.updateFromString`."""
        return _mapscript.labelObj_convertToString(self)

    def removeBinding(self, binding: "int") -> "int":
        r"""Remove the attribute binding for a specified label property."""
        return _mapscript.labelObj_removeBinding(self, binding)

    def getBinding(self, binding: "int") -> "char const *":
        r"""Get the attribute binding for a specified label property. Returns NULL if there is no binding for this property."""
        return _mapscript.labelObj_getBinding(self, binding)

    def setBinding(self, binding: "int", item: "char const *") -> "int":
        r"""
        Set the attribute binding for a specified label property. Binding constants look like this: ``MS_LABEL_BINDING_[attribute name]``:

        >>> new_label.setBinding(MS_LABEL_BINDING_COLOR, "FIELD_NAME_COLOR")
        """
        return _mapscript.labelObj_setBinding(self, binding, item)

    def removeExpressionBinding(self, binding: "int") -> "int":
        r"""Remove an expression binding for a specified label property."""
        return _mapscript.labelObj_removeExpressionBinding(self, binding)

    def getExpressionBinding(self, binding: "int") -> "char const *":
        return _mapscript.labelObj_getExpressionBinding(self, binding)

    def setExpressionBinding(self, binding: "int", text: "char const *") -> "int":
        r"""
        Set the expression binding for a specified label property. Binding constants look like this: ``MS_LABEL_BINDING_[attribute name]``
        Expressions are automatically wrapped in brackets, so do not need to be added to the input string

        >>> new_label.setExpressionBinding(MS_LABEL_BINDING_PRIORITY, "[priority] * 2")
        """
        return _mapscript.labelObj_setExpressionBinding(self, binding, text)

    def setExpression(self, expression: "char *") -> "int":
        r"""Set the label expression property"""
        return _mapscript.labelObj_setExpression(self, expression)

    def getExpressionString(self) -> "char *":
        return _mapscript.labelObj_getExpressionString(self)

    def setText(self, text: "char *") -> "int":
        r"""Set the label text."""
        return _mapscript.labelObj_setText(self, text)

    def getTextString(self) -> "char *":
        return _mapscript.labelObj_getTextString(self)

    def getStyle(self, i: "int") -> "styleObj *":
        r"""Return a reference to the :class:`styleObj` at index *i* in the styles array."""
        return _mapscript.labelObj_getStyle(self, i)

    def insertStyle(self, style: "styleObj", index: "int"=-1) -> "int":
        r"""
        Insert a copy of style into the styles array at index *index*.
        Default is -1, or the end of the array. Returns the index at which the style was inserted.
        """
        return _mapscript.labelObj_insertStyle(self, style, index)

    def removeStyle(self, index: "int") -> "styleObj *":
        r"""Remove the styleObj at *index* from the styles array and return a copy."""
        return _mapscript.labelObj_removeStyle(self, index)

    def moveStyleUp(self, index: "int") -> "int":
        r"""Swap the styleObj at *index* with the styleObj index - 1."""
        return _mapscript.labelObj_moveStyleUp(self, index)

    def moveStyleDown(self, index: "int") -> "int":
        r"""Swap the styleObj at *index* with the styleObj index + 1."""
        return _mapscript.labelObj_moveStyleDown(self, index)

# Register labelObj in _mapscript:
_mapscript.labelObj_swigregister(labelObj)
MS_LABEL_PERPENDICULAR_OFFSET = _mapscript.MS_LABEL_PERPENDICULAR_OFFSET
MS_LABEL_PERPENDICULAR_TOP_OFFSET = _mapscript.MS_LABEL_PERPENDICULAR_TOP_OFFSET
class classObj(object):
    r"""
    The :ref:`CLASS <class>` object. Used for symbolization and classification
    information.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    metadata: "hashTableObj" = property(_mapscript.classObj_metadata_get, doc=r"""see :ref:`METADATA <mapfile-class-metadata>`""")
    validation: "hashTableObj" = property(_mapscript.classObj_validation_get, doc=r"""see :ref:`VALIDATION <mapfile-class-validation>`""")
    numstyles: "int" = property(_mapscript.classObj_numstyles_get, doc=r"""number of styles for class""")
    numlabels: "int" = property(_mapscript.classObj_numlabels_get, doc=r"""number of labels for class""")
    refcount: "int" = property(_mapscript.classObj_refcount_get, doc=r"""number of references to this object""")
    layer: "struct layerObj *" = property(_mapscript.classObj_layer_get, doc=r"""reference to the parent layer""")
    leader: "labelLeaderObj *" = property(_mapscript.classObj_leader_get, doc=r"""see :ref:`LEADER <mapfile-class-leader>`""")
    status: "int" = property(_mapscript.classObj_status_get, _mapscript.classObj_status_set, doc=r"""
    :data:`MS_ON` or :data:`MS_OFF` - draw features of this class
    or do not - see :ref:`STATUS <mapfile-class-status>`
    """)
    isfallback: "int" = property(_mapscript.classObj_isfallback_get, _mapscript.classObj_isfallback_set, doc=r"""
    :data:`MS_TRUE` or :data:`MS_FALSE` use :data:`MS_TRUE`
    if this class should be applied if and only if no other
    class is applicable
    """)
    name: "char *" = property(_mapscript.classObj_name_get, _mapscript.classObj_name_set, doc=r"""
    See :ref:`NAME <mapfile-class-name>` should be unique within
    a layer
    """)
    title: "char *" = property(_mapscript.classObj_title_get, _mapscript.classObj_title_set, doc=r"""See :ref:`TITLE <mapfile-class-title>`""")
    minscaledenom: "double" = property(_mapscript.classObj_minscaledenom_get, _mapscript.classObj_minscaledenom_set, doc=r"""See :ref:`MINSCALEDENOM <mapfile-class-minscaledenom>`""")
    maxscaledenom: "double" = property(_mapscript.classObj_maxscaledenom_get, _mapscript.classObj_maxscaledenom_set, doc=r"""See :ref:`MAXSCALEDENOM <mapfile-CLASS-maxscaledenom>`""")
    minfeaturesize: "int" = property(_mapscript.classObj_minfeaturesize_get, _mapscript.classObj_minfeaturesize_set, doc=r"""
    See :ref:`MINFEATURESIZE
    <mapfile-class-minfeaturesize>` minimum feature size
    in pixels
    """)
    debug: "int" = property(_mapscript.classObj_debug_get, _mapscript.classObj_debug_set, doc=r"""
    :data:`MS_TRUE` or :data:`MS_FALSE` - see :ref:`DEBUG
    <mapfile-class-debug>`
    """)
    keyimage: "char *" = property(_mapscript.classObj_keyimage_get, _mapscript.classObj_keyimage_set, doc=r"""See :ref:`KEYIMAGE <mapfile-class-keyimage>`""")
    group: "char *" = property(_mapscript.classObj_group_get, _mapscript.classObj_group_set, doc=r"""See :ref:`GROUP <mapfile-class-group>`""")
    sizeunits: "int" = property(_mapscript.classObj_sizeunits_get, _mapscript.classObj_sizeunits_set, doc=r"""
    Supersedes layer's sizeunits and applies to all styles and
    labels - see :ref:`LAYER SIZEUNITS
    <mapfile-layer-sizeunits>`
    """)
    template: "char *" = property(_mapscript.classObj_template_get, _mapscript.classObj_template_set, doc=r"""See :ref:`TEMPLATE <mapfile-class-template>`""")

    def __init__(self, layer: "layerObj"=None):
        r"""
        Create a new child classObj instance at the tail (highest index) of the
        class array of the parent_layer. A class can be created outside the
        context of a parent layer by omitting the layerObj constructor argument
        """
        _mapscript.classObj_swiginit(self, _mapscript.new_classObj(layer))

        self.p_layer = None
        if layer: 
            self.p_layer = layer


    __swig_destroy__ = _mapscript.delete_classObj

    def updateFromString(self, snippet: "char *") -> "int":
        r"""Update a class from a string snippet. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.classObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Output the CLASS as a Mapfile string"""
        return _mapscript.classObj_convertToString(self)

    def clone(self) -> "classObj *":
        r"""
        Return an independent copy of the class without a parent layer

        .. note::

            In the Java & PHP modules this method is named ``cloneClass``.
        """
        return _mapscript.classObj_clone(self)

    def setExpression(self, expression: "char *") -> "int":
        r"""
        Set :ref:`EXPRESSION <mapfile-class-expression>` string where `expression` is a MapServer regular,
        logical or string expression. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.classObj_setExpression(self, expression)

    def getExpressionString(self) -> "char *":
        r"""
        Return a string representation of the :ref:`EXPRESSION <mapfile-class-expression>` enclosed in
        the quote characters appropriate to the expression type
        """
        return _mapscript.classObj_getExpressionString(self)

    def setText(self, text: "char *") -> "int":
        r"""
        Set :ref:`TEXT <mapfile-class-text>` string where `text` is a MapServer text expression.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.classObj_setText(self, text)

    def getTextString(self) -> "char *":
        r"""Return a string representation of :ref:`TEXT <mapfile-class-text>`"""
        return _mapscript.classObj_getTextString(self)

    def drawLegendIcon(self, map: "mapObj", layer: "layerObj", width: "int", height: "int", dstImage: "imageObj", dstX: "int", dstY: "int") -> "int":
        r"""Draw the legend icon onto *image* at *dstx*, *dsty*.  Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.classObj_drawLegendIcon(self, map, layer, width, height, dstImage, dstX, dstY)

    def createLegendIcon(self, map: "mapObj", layer: "layerObj", width: "int", height: "int") -> "imageObj *":
        r"""Draw and return a new legend icon"""
        return _mapscript.classObj_createLegendIcon(self, map, layer, width, height)

    def getLabel(self, i: "int") -> "labelObj *":
        r"""Return a reference to the :class:`labelObj` at *index* in the labels array"""
        return _mapscript.classObj_getLabel(self, i)

    def addLabel(self, label: "labelObj") -> "int":
        r"""Add a :class:`labelObj` to the :class:`classObj` and return its index in the labels array"""
        return _mapscript.classObj_addLabel(self, label)

    def removeLabel(self, index: "int") -> "labelObj *":
        r"""
        Remove the :class:`labelObj` at *index* from the labels array and return a
        reference to the :class:`labelObj`. numlabels is decremented, and the array is updated
        """
        return _mapscript.classObj_removeLabel(self, index)

    def getStyle(self, i: "int") -> "styleObj *":
        r"""Return a reference to the :class:`styleObj` at *index* in the styles array"""
        return _mapscript.classObj_getStyle(self, i)

    def insertStyle(self, style: "styleObj", index: "int"=-1) -> "int":
        r"""
        Insert a **copy** of *style* into the styles array at index *index*
        Default is -1, or the end of the array.  Returns the index at which the style was inserted.
        """
        return _mapscript.classObj_insertStyle(self, style, index)

    def removeStyle(self, index: "int") -> "styleObj *":
        r"""Remove the :class:`styleObj` at *index* from the styles array and return a copy."""
        return _mapscript.classObj_removeStyle(self, index)

    def moveStyleUp(self, index: "int") -> "int":
        r"""Swap the :class:`styleObj` at *index* with the styleObj at *index* - 1"""
        return _mapscript.classObj_moveStyleUp(self, index)

    def moveStyleDown(self, index: "int") -> "int":
        r"""Swap the :class:`styleObj` at *index* with the :class:`styleObj` at *index* + 1"""
        return _mapscript.classObj_moveStyleDown(self, index)

# Register classObj in _mapscript:
_mapscript.classObj_swigregister(classObj)
class labelCacheMemberObj(object):
    r"""
    An individual feature label. The labelCacheMemberObj class is associated with
    labelCacheObj.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numtextsymbols: "int" = property(_mapscript.labelCacheMemberObj_numtextsymbols_get, doc=r"""Number of text symbols found in textsymbols""")
    layerindex: "int" = property(_mapscript.labelCacheMemberObj_layerindex_get, doc=r"""The index of the layer of the labelled feature""")
    classindex: "int" = property(_mapscript.labelCacheMemberObj_classindex_get, doc=r"""Index of the class of the labelled feature""")
    status: "int" = property(_mapscript.labelCacheMemberObj_status_get, doc=r"""Has this label been drawn or not?""")
    markerid: "int" = property(_mapscript.labelCacheMemberObj_markerid_get, doc=r"""Corresponding marker (POINT layers only)""")
    point: "pointObj" = property(_mapscript.labelCacheMemberObj_point_get, doc=r"""Label point""")
    bbox: "rectObj" = property(_mapscript.labelCacheMemberObj_bbox_get, doc=r"""
    Bounds of the whole cachePtr. Individual text and symbol
    sub bounds are found in textsymbols
    """)
    leaderline: "lineObj *" = property(_mapscript.labelCacheMemberObj_leaderline_get, doc=r"""Leader lineObj""")
    leaderbbox: "rectObj *" = property(_mapscript.labelCacheMemberObj_leaderbbox_get, doc=r"""Leader rectObj""")

    def __init__(self):
        _mapscript.labelCacheMemberObj_swiginit(self, _mapscript.new_labelCacheMemberObj())
    __swig_destroy__ = _mapscript.delete_labelCacheMemberObj

# Register labelCacheMemberObj in _mapscript:
_mapscript.labelCacheMemberObj_swigregister(labelCacheMemberObj)
class markerCacheMemberObj(object):
    r"""
    An individual marker. The markerCacheMemberObj class is associated with
    labelCacheObj.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id: "int" = property(_mapscript.markerCacheMemberObj_id_get, doc=r"""Corresponding label""")
    bounds: "rectObj" = property(_mapscript.markerCacheMemberObj_bounds_get, doc=r"""Bounds of the markerCacheMemberObj""")

    def __init__(self):
        _mapscript.markerCacheMemberObj_swiginit(self, _mapscript.new_markerCacheMemberObj())
    __swig_destroy__ = _mapscript.delete_markerCacheMemberObj

# Register markerCacheMemberObj in _mapscript:
_mapscript.markerCacheMemberObj_swigregister(markerCacheMemberObj)
class labelCacheSlotObj(object):
    r"""A cache slot to hold labels grouped by priority"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numlabels: "int" = property(_mapscript.labelCacheSlotObj_numlabels_get, doc=r"""Number of label members""")
    cachesize: "int" = property(_mapscript.labelCacheSlotObj_cachesize_get, doc=r"""TODO""")
    nummarkers: "int" = property(_mapscript.labelCacheSlotObj_nummarkers_get, doc=r"""Number of marker members""")
    markercachesize: "int" = property(_mapscript.labelCacheSlotObj_markercachesize_get, doc=r"""TODO""")
    labels: "labelCacheMemberObj *" = property(_mapscript.labelCacheSlotObj_labels_get)
    markers: "markerCacheMemberObj *" = property(_mapscript.labelCacheSlotObj_markers_get)

    def __init__(self):
        _mapscript.labelCacheSlotObj_swiginit(self, _mapscript.new_labelCacheSlotObj())
    __swig_destroy__ = _mapscript.delete_labelCacheSlotObj

# Register labelCacheSlotObj in _mapscript:
_mapscript.labelCacheSlotObj_swigregister(labelCacheSlotObj)
class labelCacheObj(object):
    r"""
    Set of a map's cached labels. Has no other existence other than as a labelcache
    attribute of a mapObj. Associated with labelCacheMemberObj and
    markerCacheMemberObj.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_rendered_members: "int" = property(_mapscript.labelCacheObj_num_rendered_members_get, doc=r"""Number of rendered labels""")

    def freeCache(self) -> "void":
        r"""Free the labelCache"""
        return _mapscript.labelCacheObj_freeCache(self)

    def __init__(self):
        _mapscript.labelCacheObj_swiginit(self, _mapscript.new_labelCacheObj())
    __swig_destroy__ = _mapscript.delete_labelCacheObj

# Register labelCacheObj in _mapscript:
_mapscript.labelCacheObj_swigregister(labelCacheObj)
class resultObj(object):
    r"""The result object is a handle, of sorts, for a feature of the layer"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    shapeindex: "long" = property(_mapscript.resultObj_shapeindex_get, doc=r"""The shape index of the result""")
    tileindex: "int" = property(_mapscript.resultObj_tileindex_get, doc=r"""The tile index of the result""")
    resultindex: "int" = property(_mapscript.resultObj_resultindex_get, doc=r"""The index of the result""")
    classindex: "int" = property(_mapscript.resultObj_classindex_get, doc=r"""The class index of the result""")

    def __init__(self, shapeindex: "long"):
        r"""
        The result object is a handle, of sorts, for a feature of the layer, having
        ``shapeindex`` and ``tileindex`` attributes that can be used as arguments to
        ``getFeature``
        """
        _mapscript.resultObj_swiginit(self, _mapscript.new_resultObj(shapeindex))
    __swig_destroy__ = _mapscript.delete_resultObj

# Register resultObj in _mapscript:
_mapscript.resultObj_swigregister(resultObj)
class resultCacheObj(object):
    r"""A cached result object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numresults: "int" = property(_mapscript.resultCacheObj_numresults_get, doc=r"""Length of result set""")
    hasnext: "int" = property(_mapscript.resultCacheObj_hasnext_get, doc=r"""If any there are any more features left""")
    bounds: "rectObj" = property(_mapscript.resultCacheObj_bounds_get, doc=r"""Bounding box of query results""")

    def getResult(self, i: "int") -> "resultObj *":
        r"""
        Returns the result at index i, like :meth:`layerObj.getResult`,
        or ``NULL`` if index is outside the range of results.
        """
        return _mapscript.resultCacheObj_getResult(self, i)

    def __init__(self):
        _mapscript.resultCacheObj_swiginit(self, _mapscript.new_resultCacheObj())
    __swig_destroy__ = _mapscript.delete_resultCacheObj

# Register resultCacheObj in _mapscript:
_mapscript.resultCacheObj_swigregister(resultCacheObj)
class symbolSetObj(object):
    r"""
    A :class:`symbolSetObj` is an attribute of a :class:`mapObj` and is associated
    with instances of :class:`symbolObj`.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numsymbols: "int" = property(_mapscript.symbolSetObj_numsymbols_get, doc=r"""Number of symbols in the set""")
    maxsymbols: "int" = property(_mapscript.symbolSetObj_maxsymbols_get, doc=r"""Maximum number of allowed symbols""")
    filename: "char *" = property(_mapscript.symbolSetObj_filename_get, _mapscript.symbolSetObj_filename_set, doc=r"""Symbolset filename""")
    imagecachesize: "int" = property(_mapscript.symbolSetObj_imagecachesize_get, _mapscript.symbolSetObj_imagecachesize_set, doc=r"""Symbols in the cache""")

    def __init__(self, symbolfile: "char const *"=None):
        r"""
        Create new :class:`symbolSetObj` instance. If symbolfile is specified, symbols will be
        loaded from the file.
        """
        _mapscript.symbolSetObj_swiginit(self, _mapscript.new_symbolSetObj(symbolfile))
    __swig_destroy__ = _mapscript.delete_symbolSetObj

    def getSymbol(self, i: "int") -> "symbolObj *":
        r"""Returns a reference to the symbol at index."""
        return _mapscript.symbolSetObj_getSymbol(self, i)

    def getSymbolByName(self, symbolname: "char *") -> "symbolObj *":
        r"""Returns a reference to the symbol named name."""
        return _mapscript.symbolSetObj_getSymbolByName(self, symbolname)

    def index(self, symbolname: "char *") -> "int":
        r"""
        Return the index of the symbol named name or -1 in the case that no such
        symbol is found.
        """
        return _mapscript.symbolSetObj_index(self, symbolname)

    def appendSymbol(self, symbol: "symbolObj") -> "int":
        r"""Add a copy of symbol to the symbolset and return its index."""
        return _mapscript.symbolSetObj_appendSymbol(self, symbol)

    def removeSymbol(self, index: "int") -> "symbolObj *":
        r"""Remove the symbol at index and return a copy of the symbol."""
        return _mapscript.symbolSetObj_removeSymbol(self, index)

    def save(self, filename: "char const *") -> "int":
        r"""Save symbol set to a file. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.symbolSetObj_save(self, filename)

# Register symbolSetObj in _mapscript:
_mapscript.symbolSetObj_swigregister(symbolSetObj)
class referenceMapObj(object):
    r"""The :ref:`REFERENCE <reference>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    map: "struct mapObj *" = property(_mapscript.referenceMapObj_map_get, doc=r"""Reference to parent :class:`mapObj`""")
    extent: "rectObj" = property(_mapscript.referenceMapObj_extent_get, _mapscript.referenceMapObj_extent_set, doc=r"""
    Spatial extent of reference in units of parent map - see
    :ref:`EXTENT <mapfile-reference-extent>`
    """)
    height: "int" = property(_mapscript.referenceMapObj_height_get, _mapscript.referenceMapObj_height_set, doc=r"""
    Height of reference map in pixels - see :ref:`SIZE
    <mapfile-reference-size>`
    """)
    width: "int" = property(_mapscript.referenceMapObj_width_get, _mapscript.referenceMapObj_width_set, doc=r"""
    Width of reference map in pixels - see :ref:`SIZE
    <mapfile-reference-size>`
    """)
    color: "colorObj" = property(_mapscript.referenceMapObj_color_get, _mapscript.referenceMapObj_color_set, doc=r"""
    Color of reference box - see :ref:`COLOR
    <mapfile-reference-color>`
    """)
    outlinecolor: "colorObj" = property(_mapscript.referenceMapObj_outlinecolor_get, _mapscript.referenceMapObj_outlinecolor_set, doc=r"""
    Outline color of reference box - see :ref:`OUTLINECOLOR
    <mapfile-reference-outlinecolor>`
    """)
    image: "char *" = property(_mapscript.referenceMapObj_image_get, _mapscript.referenceMapObj_image_set, doc=r"""
    Filename of reference map image - see :ref:`IMAGE
    <mapfile-reference-image>`
    """)
    status: "int" = property(_mapscript.referenceMapObj_status_get, _mapscript.referenceMapObj_status_set, doc=r"""
    :data:`MS_ON` or :data:`MS_OFF` - see :ref:`STATUS
    <mapfile-reference-status>`
    """)
    marker: "int" = property(_mapscript.referenceMapObj_marker_get, _mapscript.referenceMapObj_marker_set, doc=r"""
    Index of a symbol in the map symbol set to use for marker -
    see :ref:`MARKER <mapfile-reference-marker>`
    """)
    markername: "char *" = property(_mapscript.referenceMapObj_markername_get, _mapscript.referenceMapObj_markername_set, doc=r"""
    Name of a symbol - see :ref:`MARKER
    <mapfile-reference-marker>`
    """)
    markersize: "int" = property(_mapscript.referenceMapObj_markersize_get, _mapscript.referenceMapObj_markersize_set, doc=r"""
    Size of marker - see :ref:`MARKERSIZE
    <mapfile-reference-markersize>`
    """)
    minboxsize: "int" = property(_mapscript.referenceMapObj_minboxsize_get, _mapscript.referenceMapObj_minboxsize_set, doc=r"""
    In pixels - see :ref:`MINBOXSIZE
    <mapfile-reference-minboxsize>`
    """)
    maxboxsize: "int" = property(_mapscript.referenceMapObj_maxboxsize_get, _mapscript.referenceMapObj_maxboxsize_set, doc=r"""
    In pixels - see :ref:`MAXBOXSIZE
    <mapfile-reference-maxboxsize>`
    """)

    def updateFromString(self, snippet: "char *") -> "int":
        r"""
        Update a reference map from a string snippet.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.referenceMapObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Saves the object to a string. Provides the inverse option for :func:`referenceMapObj.updateFromString`."""
        return _mapscript.referenceMapObj_convertToString(self)

    def __init__(self):
        _mapscript.referenceMapObj_swiginit(self, _mapscript.new_referenceMapObj())
    __swig_destroy__ = _mapscript.delete_referenceMapObj

# Register referenceMapObj in _mapscript:
_mapscript.referenceMapObj_swigregister(referenceMapObj)
MS_SCALEBAR_INTERVALS_MIN = _mapscript.MS_SCALEBAR_INTERVALS_MIN
MS_SCALEBAR_INTERVALS_MAX = _mapscript.MS_SCALEBAR_INTERVALS_MAX
MS_SCALEBAR_WIDTH_MIN = _mapscript.MS_SCALEBAR_WIDTH_MIN
MS_SCALEBAR_WIDTH_MAX = _mapscript.MS_SCALEBAR_WIDTH_MAX
MS_SCALEBAR_HEIGHT_MIN = _mapscript.MS_SCALEBAR_HEIGHT_MIN
MS_SCALEBAR_HEIGHT_MAX = _mapscript.MS_SCALEBAR_HEIGHT_MAX
MS_SCALEBAR_OFFSET_MIN = _mapscript.MS_SCALEBAR_OFFSET_MIN
MS_SCALEBAR_OFFSET_MAX = _mapscript.MS_SCALEBAR_OFFSET_MAX
class scalebarObj(object):
    r"""The :ref:`SCALEBAR <scalebar>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    transparent: "int" = property(_mapscript.scalebarObj_transparent_get, _mapscript.scalebarObj_transparent_set, doc=r"""
    Allows transparency for an embedded scalebar - see
    :ref:`TRANSPARENT <mapfile-scalebar-transparent>`
    """)
    imagecolor: "colorObj" = property(_mapscript.scalebarObj_imagecolor_get, _mapscript.scalebarObj_imagecolor_set, doc=r"""
    Background color of scalebar - see :ref:`IMAGECOLOR
    <mapfile-scalebar-imagecolor>`
    """)
    height: "int" = property(_mapscript.scalebarObj_height_get, _mapscript.scalebarObj_height_set, doc=r"""Height in pixels - see :ref:`SIZE <mapfile-scalebar-size>`""")
    width: "int" = property(_mapscript.scalebarObj_width_get, _mapscript.scalebarObj_width_set, doc=r"""Height in pixels - see :ref:`SIZE <mapfile-scalebar-size>`""")
    style: "int" = property(_mapscript.scalebarObj_style_get, _mapscript.scalebarObj_style_set, doc=r"""0 or 1 - see :ref:`STYLE <mapfile-scalebar-style>`""")
    intervals: "int" = property(_mapscript.scalebarObj_intervals_get, _mapscript.scalebarObj_intervals_set, doc=r"""
    Number of intervals - see :ref:`INTERVALS
    <mapfile-scalebar-intervals>`
    """)
    label: "labelObj" = property(_mapscript.scalebarObj_label_get, _mapscript.scalebarObj_label_set, doc=r"""Scalebar label - see :ref:`LABEL <mapfile-scalebar-label>`""")
    color: "colorObj" = property(_mapscript.scalebarObj_color_get, _mapscript.scalebarObj_color_set, doc=r"""
    Scalebar foreground color - see :ref:`COLOR
    <mapfile-scalebar-color>`
    """)
    backgroundcolor: "colorObj" = property(_mapscript.scalebarObj_backgroundcolor_get, _mapscript.scalebarObj_backgroundcolor_set, doc=r"""
    Scalebar background color - see
    :ref:`BACKGROUNDCOLOR
    <mapfile-scalebar-backgroundcolor>`
    """)
    outlinecolor: "colorObj" = property(_mapscript.scalebarObj_outlinecolor_get, _mapscript.scalebarObj_outlinecolor_set, doc=r"""
    Foreground outline color - see :ref:`OUTLINECOLOR
    <mapfile-scalebar-outlinecolor>`
    """)
    units: "int" = property(_mapscript.scalebarObj_units_get, _mapscript.scalebarObj_units_set, doc=r"""See :ref:`UNITS <mapfile-scalebar-units>`""")
    status: "int" = property(_mapscript.scalebarObj_status_get, _mapscript.scalebarObj_status_set, doc=r"""
    ON, OFF or EMBED - see :ref:`STATUS
    <mapfile-scalebar-status>` - :data:`MS_ON`, :data:`MS_OFF`,
    or :data:`MS_EMBED`.
    """)
    position: "int" = property(_mapscript.scalebarObj_position_get, _mapscript.scalebarObj_position_set, doc=r"""
    For embedded scalebars - see :ref:`POSITION
    <mapfile-scalebar-position>` - :data:`MS_UL`,
    :data:`MS_UC`, :data:`MS_UR`, :data:`MS_LL`, :data:`MS_LC`,
    or :data:`MS_LR`
    """)
    postlabelcache: "int" = property(_mapscript.scalebarObj_postlabelcache_get, _mapscript.scalebarObj_postlabelcache_set, doc=r"""
    See :ref:`POSTLABELCACHE
    <mapfile-scalebar-postlabelcache>` - :data:`MS_TRUE`
    or :data:`MS_FALSE`
    """)
    align: "int" = property(_mapscript.scalebarObj_align_get, _mapscript.scalebarObj_align_set, doc=r"""See :ref:`ALIGN <mapfile-scalebar-align>`""")
    offsetx: "int" = property(_mapscript.scalebarObj_offsetx_get, _mapscript.scalebarObj_offsetx_set, doc=r"""See :ref:`OFFSET <mapfile-scalebar-offset>`""")
    offsety: "int" = property(_mapscript.scalebarObj_offsety_get, _mapscript.scalebarObj_offsety_set, doc=r"""See :ref:`OFFSET <mapfile-scalebar-offset>`""")

    def updateFromString(self, snippet: "char *") -> "int":
        r"""
        Update a scalebar from a string snippet.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.scalebarObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Saves the object to a string. Provides the inverse option for updateFromString."""
        return _mapscript.scalebarObj_convertToString(self)

    def __init__(self):
        _mapscript.scalebarObj_swiginit(self, _mapscript.new_scalebarObj())
    __swig_destroy__ = _mapscript.delete_scalebarObj

# Register scalebarObj in _mapscript:
_mapscript.scalebarObj_swigregister(scalebarObj)
MS_LEGEND_KEYSIZE_MIN = _mapscript.MS_LEGEND_KEYSIZE_MIN
MS_LEGEND_KEYSIZE_MAX = _mapscript.MS_LEGEND_KEYSIZE_MAX
MS_LEGEND_KEYSPACING_MIN = _mapscript.MS_LEGEND_KEYSPACING_MIN
MS_LEGEND_KEYSPACING_MAX = _mapscript.MS_LEGEND_KEYSPACING_MAX
class legendObj(object):
    r"""The :ref:`LEGEND <legend>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    label: "labelObj" = property(_mapscript.legendObj_label_get, doc=r"""See :ref:`LABEL <mapfile-legend-label>`""")
    map: "struct mapObj *" = property(_mapscript.legendObj_map_get, doc=r"""
    Instances of legendObj are always are always embedded
    inside the mapObj
    """)
    transparent: "int" = property(_mapscript.legendObj_transparent_get, _mapscript.legendObj_transparent_set, doc=r"""
    Allows transparency for an embedded legend - see
    :ref:`TRANSPARENT <mapfile-legend-transparent>`
    """)
    imagecolor: "colorObj" = property(_mapscript.legendObj_imagecolor_get, _mapscript.legendObj_imagecolor_set, doc=r"""
    Legend background color - see :ref:`IMAGECOLOR
    <mapfile-legend-imagecolor>`
    """)
    keysizex: "int" = property(_mapscript.legendObj_keysizex_get, _mapscript.legendObj_keysizex_set, doc=r"""
    Width in pixels of legend keys - see :ref:`KEYSIZE
    <mapfile-legend-keysize>`
    """)
    keysizey: "int" = property(_mapscript.legendObj_keysizey_get, _mapscript.legendObj_keysizey_set, doc=r"""
    Height in pixels of legend keys - see :ref:`KEYSIZE
    <mapfile-legend-keysize>`
    """)
    keyspacingx: "int" = property(_mapscript.legendObj_keyspacingx_get, _mapscript.legendObj_keyspacingx_set, doc=r"""
    Horizontal padding around keys in pixels - see
    :ref:`KEYSPACING <mapfile-legend-keyspacing>`
    """)
    keyspacingy: "int" = property(_mapscript.legendObj_keyspacingy_get, _mapscript.legendObj_keyspacingy_set, doc=r"""
    Vertical padding around keys in pixels - see
    :ref:`KEYSPACING <mapfile-legend-keyspacing>`
    """)
    outlinecolor: "colorObj" = property(_mapscript.legendObj_outlinecolor_get, _mapscript.legendObj_outlinecolor_set, doc=r"""
    Key outline color, -1 for no outline - see
    :ref:`OUTLINECOLOR <mapfile-legend-outlinecolor>`
    """)
    status: "int" = property(_mapscript.legendObj_status_get, _mapscript.legendObj_status_set, doc=r"""
    :data:`MS_ON`, :data:`MS_OFF` or :data:`MS_EMBED`- see
    :ref:`STATUS <mapfile-legend-status>`
    """)
    height: "int" = property(_mapscript.legendObj_height_get, _mapscript.legendObj_height_set, doc=r"""Legend height""")
    width: "int" = property(_mapscript.legendObj_width_get, _mapscript.legendObj_width_set, doc=r"""Legend width""")
    position: "int" = property(_mapscript.legendObj_position_get, _mapscript.legendObj_position_set, doc=r"""
    Used for embedded legends, see :ref:`POSITION
    <mapfile-legend-position>`
    """)
    postlabelcache: "int" = property(_mapscript.legendObj_postlabelcache_get, _mapscript.legendObj_postlabelcache_set, doc=r"""
    :data:`MS_TRUE`, :data:`MS_FALSE` - see
    :ref:`POSTLABELCACHE <mapfile-legend-postlabelcache>`
    """)
    template: "char *" = property(_mapscript.legendObj_template_get, _mapscript.legendObj_template_set, doc=r"""See :ref:`TEMPLATE <mapfile-legend-template>`""")

    def updateFromString(self, snippet: "char *") -> "int":
        r"""Update a :class:`legendObj` from a string snippet. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.legendObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Output the :class:`legendObj` object as a Mapfile string. Provides the inverse option for :func:`legendObj.updateFromString`."""
        return _mapscript.legendObj_convertToString(self)

    def __init__(self):
        _mapscript.legendObj_swiginit(self, _mapscript.new_legendObj())
    __swig_destroy__ = _mapscript.delete_legendObj

# Register legendObj in _mapscript:
_mapscript.legendObj_swigregister(legendObj)
class imageObj(object):
    r"""An image object is a wrapper for images generated by MapServer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    width: "int" = property(_mapscript.imageObj_width_get, doc=r"""image width in pixels""")
    height: "int" = property(_mapscript.imageObj_height_get, doc=r"""image height in pixels""")
    resolution: "double" = property(_mapscript.imageObj_resolution_get, doc=r"""image resolution in pixels per inch""")
    resolutionfactor: "double" = property(_mapscript.imageObj_resolutionfactor_get, doc=r"""resolution factor""")
    imagepath: "char *" = property(_mapscript.imageObj_imagepath_get, doc=r"""
    if image is drawn by :func:`mapObj.draw` this is
    :ref:`IMAGEPATH <mapfile-web-imagepath>`
    """)
    imageurl: "char *" = property(_mapscript.imageObj_imageurl_get, doc=r"""
    if image is drawn by :func:`mapObj.draw` this is
    :ref:`IMAGEURL <mapfile-web-imageurl>`
    """)
    format: "outputFormatObj *" = property(_mapscript.imageObj_format_get, doc=r"""
    an :class:`outputFormatObj` representing the
    output format of the image
    """)

    def __init__(self, *args):
        r"""
        Create a new :class:`imageObj` instance. If *filename* is specified, an imageObj
        is created from the file and any specified *width*, *height*, and *format* parameters
        will be overridden by values of the image in *filename*.  Otherwise, if *format* is specified (as an :class:`outputFormatObj`) an imageObj is created
        using that format. If *filename* is not specified, then *width* and *height* should be specified.
        The default resolution is currently 72 and defined by :data:`MS_DEFAULT_RESOLUTION` - this setting is
        not available in MapScript.
        """
        _mapscript.imageObj_swiginit(self, _mapscript.new_imageObj(*args))
    __swig_destroy__ = _mapscript.delete_imageObj

    def save(self, filename: "char *", map: "mapObj"=None) -> "void":
        r"""
        Save image to filename. The optional map parameter must be specified if
        saving GeoTIFF images.
        """
        return _mapscript.imageObj_save(self, filename, map)

    def getBytes(self) -> "gdBuffer":
        r"""
        Returns the image contents as a binary buffer. The exact form of this buffer will
        vary by MapScript language (e.g. a string in Python, byte[] array in Java and C#, unhandled in Perl)
        """
        return _mapscript.imageObj_getBytes(self)

    def getSize(self) -> "int":
        r"""
        Returns the size of the binary buffer representing the image buffer

        .. note::

            The getSize method is inefficient as it does a call to getBytes and
            then computes the size of the byte array. The byte array is then immediately discarded.
            In most cases it is more efficient to call getBytes directly.
        """
        return _mapscript.imageObj_getSize(self)

    def pasteImage(self, imageSrc: "imageObj", opacity: "double"=1.0, dstx: "int"=0, dsty: "int"=0) -> "int":
        r"""
        Pastes another imageObj on top of this imageObj.
        If optional dstx,dsty are provided then they define the position where the
        image should be copied (dstx,dsty = top-left corner position).
        """
        return _mapscript.imageObj_pasteImage(self, imageSrc, opacity, dstx, dsty)

    def saveWebImage(self) -> "char *":
        r"""
        Writes the image to temp directory.
        Returns the image URL.
        """
        return _mapscript.imageObj_saveWebImage(self)

    def write(self, *args) -> "int":
        r"""
        Write image data to an open file handle. Replaces
        the removed saveToString function.  See ``python/pyextend.i`` for the Python specific
        version of this method.
        """
        return _mapscript.imageObj_write(self, *args)

# Register imageObj in _mapscript:
_mapscript.imageObj_swigregister(imageObj)
class scaleTokenEntryObj(object):
    r"""
    An individual value within the :ref:`SCALETOKEN <mapfile-layer-scaletoken>`
    object
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    minscale: "double" = property(_mapscript.scaleTokenEntryObj_minscale_get, _mapscript.scaleTokenEntryObj_minscale_set, doc=r"""The minimum scale for the replacement""")
    maxscale: "double" = property(_mapscript.scaleTokenEntryObj_maxscale_get, _mapscript.scaleTokenEntryObj_maxscale_set, doc=r"""The maximum scale for the replacement""")
    value: "char *" = property(_mapscript.scaleTokenEntryObj_value_get, _mapscript.scaleTokenEntryObj_value_set, doc=r"""The token replacement value""")

    def __init__(self):
        _mapscript.scaleTokenEntryObj_swiginit(self, _mapscript.new_scaleTokenEntryObj())
    __swig_destroy__ = _mapscript.delete_scaleTokenEntryObj

# Register scaleTokenEntryObj in _mapscript:
_mapscript.scaleTokenEntryObj_swigregister(scaleTokenEntryObj)
class scaleTokenObj(object):
    r"""The :ref:`SCALETOKEN <mapfile-layer-scaletoken>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name: "char *" = property(_mapscript.scaleTokenObj_name_get, _mapscript.scaleTokenObj_name_set, doc=r"""
    The name of the token to replace in the :ref:`DATA
    <mapfile-layer-data>` statement
    """)
    n_entries: "int" = property(_mapscript.scaleTokenObj_n_entries_get, _mapscript.scaleTokenObj_n_entries_set, doc=r"""The number of values within the scaletoken""")
    tokens: "scaleTokenEntryObj *" = property(_mapscript.scaleTokenObj_tokens_get, _mapscript.scaleTokenObj_tokens_set, doc=r"""A reference to the values""")

    def __init__(self):
        _mapscript.scaleTokenObj_swiginit(self, _mapscript.new_scaleTokenObj())
    __swig_destroy__ = _mapscript.delete_scaleTokenObj

# Register scaleTokenObj in _mapscript:
_mapscript.scaleTokenObj_swigregister(scaleTokenObj)
class layerObj(object):
    r"""The :ref:`LAYER <layer>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refcount: "int" = property(_mapscript.layerObj_refcount_get, doc=r"""reference counting, RFC24""")
    numclasses: "int" = property(_mapscript.layerObj_numclasses_get, doc=r"""Number of layer classes""")
    maxclasses: "int" = property(_mapscript.layerObj_maxclasses_get, doc=r"""
    Used to track of the maximum number of classes - see
    RFC-17
    """)
    index: "int" = property(_mapscript.layerObj_index_get, doc=r"""Index of layer within parent map's layers array""")
    map: "struct mapObj *" = property(_mapscript.layerObj_map_get, doc=r"""Reference to parent map""")
    numitems: "int" = property(_mapscript.layerObj_numitems_get, doc=r"""Number of layer feature attributes (items)""")
    metadata: "hashTableObj" = property(_mapscript.layerObj_metadata_get, doc=r"""See :ref:`METADATA <mapfile-layer-metadata>`""")
    validation: "hashTableObj" = property(_mapscript.layerObj_validation_get, doc=r"""See :ref:`VALIDATION <mapfile-layer-validation>`""")
    bindvals: "hashTableObj" = property(_mapscript.layerObj_bindvals_get, doc=r"""Relates to RFC59""")
    connectionoptions: "hashTableObj" = property(_mapscript.layerObj_connectionoptions_get, doc=r"""
    See :ref:`CONNECTIONOPTIONS
    <mapfile-layer-connectionoptions>`
    """)
    cluster: "clusterObj" = property(_mapscript.layerObj_cluster_get, doc=r"""See :ref:`CLUSTER <mapfile-layer-cluster>`""")
    extent: "rectObj" = property(_mapscript.layerObj_extent_get, doc=r"""
    optional limiting extent for layer features - see
    :ref:`EXTENT <mapfile-layer-extent>`
    """)
    numjoins: "int" = property(_mapscript.layerObj_numjoins_get, doc=r"""Number of layer joins""")
    utfdata: "expressionObj" = property(_mapscript.layerObj_utfdata_get, doc=r"""See :ref:`UTFDATA <mapfile-layer-utfdata>`""")
    compositer: "LayerCompositer *" = property(_mapscript.layerObj_compositer_get, doc=r"""See :ref:`COMPOSITE <mapfile-layer-composite>`""")
    classitem: "char *" = property(_mapscript.layerObj_classitem_get, _mapscript.layerObj_classitem_set, doc=r"""
    the attribute used to classify layer data - see
    :ref:`CLASSITEM <mapfile-layer-classitem>`
    """)
    header: "char *" = property(_mapscript.layerObj_header_get, _mapscript.layerObj_header_set, doc=r"""
    filename to a template for result's header - see
    :ref:`HEADER <mapfile-layer-header>`
    """)
    footer: "char *" = property(_mapscript.layerObj_footer_get, _mapscript.layerObj_footer_set, doc=r"""
    filename to a template for result's footer - see
    :ref:`FOOTER <mapfile-layer-footer>`
    """)
    template: "char *" = property(_mapscript.layerObj_template_get, _mapscript.layerObj_template_set, doc=r"""
    See :ref:`TEMPLATE <mapfile-layer-template>` - global
    template, used across all classes
    """)
    name: "char *" = property(_mapscript.layerObj_name_get, _mapscript.layerObj_name_set, doc=r"""See :ref:`NAME <mapfile-layer-name>` - should be unique""")
    group: "char *" = property(_mapscript.layerObj_group_get, _mapscript.layerObj_group_set, doc=r"""
    Name of a group of layers - see :ref:`GROUP
    <mapfile-layer-group>`
    """)
    status: "int" = property(_mapscript.layerObj_status_get, _mapscript.layerObj_status_set, doc=r"""
    See :ref:`STATUS <mapfile-layer-status>`:data:`MS_ON`,
    :data:`MS_OFF` or :data:`MS_DEFAULT`
    """)
    rendermode: "enum MS_RENDER_MODE" = property(_mapscript.layerObj_rendermode_get, _mapscript.layerObj_rendermode_set, doc=r"""
    :data:`MS_FIRST_MATCHING_CLASS` - default and historic
    MapServer behavior, :data:`MS_ALL_MATCHING_CLASSES` - SLD
    behavior
    """)
    data: "char *" = property(_mapscript.layerObj_data_get, _mapscript.layerObj_data_set, doc=r"""
    Layer data definition, values depend upon connectiontype -
    see :ref:`DATA <mapfile-layer-data>`
    """)
    type: "enum MS_LAYER_TYPE" = property(_mapscript.layerObj_type_get, _mapscript.layerObj_type_set, doc=r"""the layer type - see :ref:`TYPE <mapfile-layer-type>`""")
    connectiontype: "enum MS_CONNECTION_TYPE" = property(_mapscript.layerObj_connectiontype_get, _mapscript.layerObj_connectiontype_set, doc=r"""
    the layer connection type - see :ref:`CONNECTIONTYPE
    <mapfile-layer-connectiontype>`
    """)
    tolerance: "double" = property(_mapscript.layerObj_tolerance_get, _mapscript.layerObj_tolerance_set, doc=r"""
    search buffer for point and line queries (in
    toleranceunits) - see :ref:`TOLERANCE
    <mapfile-layer-tolerance>`
    """)
    toleranceunits: "int" = property(_mapscript.layerObj_toleranceunits_get, _mapscript.layerObj_toleranceunits_set, doc=r"""
    See :ref:`TOLERANCEUNITS
    <mapfile-layer-toleranceunits>`
    """)
    identificationclassauto: "int" = property(_mapscript.layerObj_identificationclassauto_get, _mapscript.layerObj_identificationclassauto_set, doc=r"""
    whether we should use the style of the
    WMS GetFeatureInfo request to precisely
    identify features.
    """)
    identificationclassgroup: "char *" = property(_mapscript.layerObj_identificationclassgroup_get, _mapscript.layerObj_identificationclassgroup_set, doc=r"""
    name of the class group to use for
    WMS GetFeatureInfo request to precisely
    identify features.
    """)
    symbolscaledenom: "double" = property(_mapscript.layerObj_symbolscaledenom_get, _mapscript.layerObj_symbolscaledenom_set, doc=r"""
    scale at which symbols are default size - see
    :ref:`SYMBOLSCALEDENOM
    <mapfile-layer-symbolscaledenom>`
    """)
    minscaledenom: "double" = property(_mapscript.layerObj_minscaledenom_get, _mapscript.layerObj_minscaledenom_set, doc=r"""
    Maximum scale at which layer will be drawn - see
    :ref:`MINSCALEDENOM <mapfile-layer-minscaledenom>`
    """)
    maxscaledenom: "double" = property(_mapscript.layerObj_maxscaledenom_get, _mapscript.layerObj_maxscaledenom_set, doc=r"""
    Minimum scale at which layer will be drawn - see
    :ref:`MAXSCALEDENOM <mapfile-layer-maxscaledenom>`
    """)
    minfeaturesize: "int" = property(_mapscript.layerObj_minfeaturesize_get, _mapscript.layerObj_minfeaturesize_set, doc=r"""minimum feature size (in pixels) for shape""")
    labelminscaledenom: "double" = property(_mapscript.layerObj_labelminscaledenom_get, _mapscript.layerObj_labelminscaledenom_set, doc=r"""
    See :ref:`LABELMINSCALEDENOM
    <mapfile-layer-labelminscaledenom>`
    """)
    labelmaxscaledenom: "double" = property(_mapscript.layerObj_labelmaxscaledenom_get, _mapscript.layerObj_labelmaxscaledenom_set, doc=r"""
    See :ref:`LABELMAXSCALEDENOM
    <mapfile-layer-labelmaxscaledenom>`
    """)
    mingeowidth: "double" = property(_mapscript.layerObj_mingeowidth_get, _mapscript.layerObj_mingeowidth_set, doc=r"""
    min map width (in map units) at which the layer
    should be drawn - see :ref:`MAXGEOWIDTH
    <mapfile-layer-maxgeowidth>`
    """)
    maxgeowidth: "double" = property(_mapscript.layerObj_maxgeowidth_get, _mapscript.layerObj_maxgeowidth_set, doc=r"""
    max map width (in map units) at which the layer
    should be drawn - see :ref:`MAXGEOWIDTH
    <mapfile-layer-maxgeowidth>`
    """)
    sizeunits: "int" = property(_mapscript.layerObj_sizeunits_get, _mapscript.layerObj_sizeunits_set, doc=r"""
    applies to all classes - see :ref:`SIZEUNITS
    <mapfile-layer-sizeunits>`
    """)
    maxfeatures: "int" = property(_mapscript.layerObj_maxfeatures_get, _mapscript.layerObj_maxfeatures_set, doc=r"""
    Maximum number of layer features that will be drawn -
    see :ref:`MAXFEATURES <mapfile-layer-maxfeatures>`
    """)
    startindex: "int" = property(_mapscript.layerObj_startindex_get, _mapscript.layerObj_startindex_set, doc=r"""Feature start index - used for paging""")
    offsite: "colorObj" = property(_mapscript.layerObj_offsite_get, _mapscript.layerObj_offsite_set, doc=r"""
    transparent pixel value for raster images - see
    :ref:`OFFSITE <mapfile-layer-offsite>`
    """)
    transform: "int" = property(_mapscript.layerObj_transform_get, _mapscript.layerObj_transform_set, doc=r"""
    :data:`MS_TRUE` (default) or :data:`MS_FALSE` whether or not layer data is to
    be transformed to image units - see :ref:`TRANSFORM <mapfile-layer-transform>`
    """)
    labelcache: "int" = property(_mapscript.layerObj_labelcache_get, _mapscript.layerObj_labelcache_set, doc=r"""
    :data:`MS_ON` (default) or :data:`MS_OFF` - see
    :ref:`LABELCACHE <mapfile-layer-labelcache>`
    """)
    postlabelcache: "int" = property(_mapscript.layerObj_postlabelcache_get, _mapscript.layerObj_postlabelcache_set, doc=r"""
    :data:`MS_ON` or :data:`MS_OFF` (default) - see
    :ref:`POSTLABELCACHE <mapfile-layer-postlabelcache>`
    """)
    labelitem: "char *" = property(_mapscript.layerObj_labelitem_get, _mapscript.layerObj_labelitem_set, doc=r"""
    attribute defining feature label text - see
    :ref:`LABELITEM <mapfile-layer-labelitem>`
    """)
    tileitem: "char *" = property(_mapscript.layerObj_tileitem_get, _mapscript.layerObj_tileitem_set, doc=r"""
    attribute defining tile paths - see :ref:`TILEITEM
    <mapfile-layer-tileitem>`
    """)
    tileindex: "char *" = property(_mapscript.layerObj_tileindex_get, _mapscript.layerObj_tileindex_set, doc=r"""
    layer index file for tiling support - see
    :ref:`TILEINDEX <mapfile-layer-tileindex>`
    """)
    tilesrs: "char *" = property(_mapscript.layerObj_tilesrs_get, _mapscript.layerObj_tilesrs_set, doc=r"""
    name of the attribute that contains the SRS of an individual
    tile - see :ref:`TILESRS <mapfile-layer-tilesrs>`
    """)
    units: "int" = property(_mapscript.layerObj_units_get, _mapscript.layerObj_units_set, doc=r"""units of the layer - see :ref:`UNITS <mapfile-layer-units>`""")
    connection: "char *" = property(_mapscript.layerObj_connection_get, _mapscript.layerObj_connection_set, doc=r"""
    layer connection or data source name - see
    :ref:`CONNECTION <mapfile-layer-connection>`
    """)
    plugin_library: "char *" = property(_mapscript.layerObj_plugin_library_get, _mapscript.layerObj_plugin_library_set, doc=r"""Used to select the library to load by MapServer""")
    plugin_library_original: "char *" = property(_mapscript.layerObj_plugin_library_original_get, _mapscript.layerObj_plugin_library_original_set, doc=r"""this is needed for Mapfile writing""")
    bandsitem: "char *" = property(_mapscript.layerObj_bandsitem_get, _mapscript.layerObj_bandsitem_set, doc=r"""
    The attribute from the index file used to select the source raster band(s) to
    be used - normally NULL for default bands processing
    """)
    filteritem: "char *" = property(_mapscript.layerObj_filteritem_get, _mapscript.layerObj_filteritem_set, doc=r"""
    Attribute defining filter - see :ref:`FILTERITEM
    <mapfile-layer-filteritem>`
    """)
    styleitem: "char *" = property(_mapscript.layerObj_styleitem_get, _mapscript.layerObj_styleitem_set, doc=r"""
    item to be used for style lookup - can also be 'AUTO' -
    see :ref:`STYLEITEM <mapfile-layer-styleitem>`
    """)
    requires: "char *" = property(_mapscript.layerObj_requires_get, _mapscript.layerObj_requires_set, doc=r"""
    Context expressions, simple enough to not use expressionObj -
    see :ref:`REQUIRES <mapfile-layer-requires>`
    """)
    labelrequires: "char *" = property(_mapscript.layerObj_labelrequires_get, _mapscript.layerObj_labelrequires_set, doc=r"""
    Simple logical expression - see :ref:`LABELREQUIRES
    <mapfile-layer-labelrequires>`
    """)
    debug: "int" = property(_mapscript.layerObj_debug_get, _mapscript.layerObj_debug_set, doc=r"""
    Enable debugging of layer-  :data:`MS_ON` or :data:`MS_OFF`
    (default) - see :ref:`DEBUG <mapfile-layer-debug>`
    """)
    classgroup: "char *" = property(_mapscript.layerObj_classgroup_get, _mapscript.layerObj_classgroup_set, doc=r"""See :ref:`CLASSGROUP <mapfile-layer-classgroup>`""")
    mask: "char *" = property(_mapscript.layerObj_mask_get, _mapscript.layerObj_mask_set, doc=r"""See :ref:`MASK <mapfile-layer-mask>`""")
    encoding: "char *" = property(_mapscript.layerObj_encoding_get, _mapscript.layerObj_encoding_set, doc=r"""
    For iconving shape attributes, ignored if NULL or "utf-8"
    - see :ref:`ENCODING <mapfile-layer-encoding>`
    """)
    utfitem: "char *" = property(_mapscript.layerObj_utfitem_get, _mapscript.layerObj_utfitem_set, doc=r"""See :ref:`UTFITEM <mapfile-layer-utfitem>`""")
    utfitemindex: "int" = property(_mapscript.layerObj_utfitemindex_get, _mapscript.layerObj_utfitemindex_set, doc=r"""See :ref:`CLASSITEM <mapfile-layer-classitem>`""")
    numprocessing: "int" = property(_mapscript.layerObj_numprocessing_get)

    def __init__(self, map: "mapObj"=None):
        r"""
        A :class:`layerObj` is associated with :class:`mapObj`. An instance of
        :class:`layerObj` can exist outside of a :class:`mapObj`
        """
        _mapscript.layerObj_swiginit(self, _mapscript.new_layerObj(map))

        self.p_map = None
        if map: 
            self.p_map = map



    def setOpacity(self, opacity: "int") -> "void":
        r"""
        Sets an opacity for the layer, where the value is an integer in range [0, 100].
        A new :ref:`composite` block is generated, containing this ``OPACITY`` value.
        """
        return _mapscript.layerObj_setOpacity(self, opacity)

    def getOpacity(self) -> "int":
        r"""Returns the opacity value for the layer."""
        return _mapscript.layerObj_getOpacity(self)
    __swig_destroy__ = _mapscript.delete_layerObj

    def clone(self) -> "layerObj *":
        r"""
        Return an independent copy of the layer with no parent map.

        .. note::

            In the Java & PHP modules this method is named ``cloneLayer``.
        """
        return _mapscript.layerObj_clone(self)

    def updateFromString(self, snippet: "char *") -> "int":
        r"""Update a :class:`layerObj` from a string snippet. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.layerObj_updateFromString(self, snippet)

    def convertToString(self) -> "char *":
        r"""Output the :class:`layerObj` object as a Mapfile string. Provides the inverse option for :func:`layerObj.updateFromString`."""
        return _mapscript.layerObj_convertToString(self)

    def insertClass(*args):
        """
        Insert a **copy** of the class into the layer at the requested *index*. 
        Default index of -1 means insertion at the end of the array of classes. Returns the index at which the class was inserted.
        """
        actualIndex=_mapscript.layerObj_insertClass(*args)
        args[1].p_layer=args[0]
        return actualIndex


    def removeClass(self, index: "int") -> "classObj *":
        r"""
        Removes the class at *index* and returns a copy, or NULL in the case of a failure.
        Note that subsequent classes will be renumbered by this operation.
        The numclasses field contains the number of classes available.
        """
        return _mapscript.layerObj_removeClass(self, index)

    def open(self) -> "int":
        r"""
        Opens the underlying layer. This is required before operations like :func:`layerObj.getResult`
        will work, but is not required before a draw or query call.
        """
        return _mapscript.layerObj_open(self)

    def whichShapes(self, rect: "rectObj") -> "int":
        r"""
        Performs a spatial, and optionally an attribute based feature search.
        The function basically prepares things so that candidate features can be accessed by
        query or drawing functions (e.g using :func:`layerObj.nextShape` function).
        Returns :data:`MS_SUCCESS`, :data:`MS_FAILURE` or :data:`MS_DONE`.
        MS_DONE is returned if the layer extent does not overlap *rect*.
        """
        return _mapscript.layerObj_whichShapes(self, rect)

    def nextShape(self) -> "shapeObj *":
        r"""
        Called after :func:`layerObj.whichShapes` has been called to actually
        retrieve shapes within a given area returns a shape object or :data:`MS_FALSE`
        Example of usage:

        .. code-block::

            mapObj map = new mapObj("d:/msapps/gmap-ms40/htdocs/gmap75.map");
            layerObj layer = map.getLayerByName('road');
            int status = layer.open();
            status = layer.whichShapes(map.extent);
            shapeObj shape;
            while ((shape = layer.nextShape()) != null)
            {
              ...
            }
            layer.close();
        """
        return _mapscript.layerObj_nextShape(self)

    def close(self) -> "void":
        r"""Close the underlying layer."""
        return _mapscript.layerObj_close(self)

    def getShape(self, record: "resultObj") -> "shapeObj *":
        r"""Get a shape from layer data. Argument is a result cache member from :func:`layerObj.getResult`"""
        return _mapscript.layerObj_getShape(self, record)

    def getNumResults(self) -> "int":
        r"""Returns the number of entries in the query result cache for this layer."""
        return _mapscript.layerObj_getNumResults(self)

    def getResultsBounds(self) -> "rectObj *":
        r"""Returns the bounds of the features in the result cache."""
        return _mapscript.layerObj_getResultsBounds(self)

    def getResult(self, i: "int") -> "resultObj *":
        r"""
        Fetches the requested query result cache entry, or NULL if the index is outside
        the range of available results. This method would normally only be used after
        issuing a query operation.
        """
        return _mapscript.layerObj_getResult(self, i)

    def getClass(*args):
        """
        Fetch the requested class object at *i*. Returns NULL if the class index is out of the legal range. 
        The numclasses field contains the number of classes available, and the first class is index 0.
        """
        clazz = _mapscript.layerObj_getClass(*args)
        if clazz:
            if args and len(args)!=0:
                clazz.p_layer=args[0]
            else:
                clazz.p_layer=None
        return clazz


    def getItem(self, i: "int") -> "char *":
        r"""
        Returns the requested item. Items are attribute fields, and this method returns the
        item name (field name). The numitems field contains the number of items available, and the first item is index zero.
        """
        return _mapscript.layerObj_getItem(self, i)

    def setItems(self, items: "char **", numitems: "int") -> "int":
        r"""Set the items to be retrieved with a particular shape."""
        return _mapscript.layerObj_setItems(self, items, numitems)

    def draw(self, map: "mapObj", image: "imageObj") -> "int":
        r"""
        Renders this layer into the target image, adding labels to the cache if required.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.layerObj_draw(self, map, image)

    def drawQuery(self, map: "mapObj", image: "imageObj") -> "int":
        r"""
        Draw query map for a single layer into the target image.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.layerObj_drawQuery(self, map, image)

    def queryByFilter(self, map: "mapObj", string: "char *") -> "int":
        r"""
        Query by the filter *string*.
        For querying, we switch layer status ON and then back to original
        value before returning.
        """
        return _mapscript.layerObj_queryByFilter(self, map, string)

    def queryByAttributes(self, map: "mapObj", qitem: "char *", qstring: "char *", mode: "int") -> "int":
        r"""
        Query layer for shapes that intersect current map extents. *qitem* is the item (attribute)
        on which the query is performed, and *qstring* is the expression to match.
        The query is performed on all the shapes that are part of a CLASS that contains a TEMPLATE value or that match any class in a layer that contains a LAYER TEMPLATE value.
        Note that the layer's FILTER/FILTERITEM are ignored by this function. *mode* is :data:`MS_SINGLE` or :data:`MS_MULTIPLE` depending on number of results you want.
        Returns :data:`MS_SUCCESS` if the query was successfully performed, regardless of whether any shapes were found, or :data:`MS_FAILURE` if an error occurred.
        """
        return _mapscript.layerObj_queryByAttributes(self, map, qitem, qstring, mode)

    def queryByPoint(self, map: "mapObj", point: "pointObj", mode: "int", buffer: "double") -> "int":
        r"""
        Query layer at point location specified in georeferenced map coordinates (i.e. not pixels).
        The query is performed on all the shapes that are part of a CLASS that contains a TEMPLATE value or that match any class in a layer that contains a LAYER TEMPLATE value.
        Note that the layer's FILTER/FILTERITEM are ignored by this function. *mode* is :data:`MS_SINGLE` or :data:`MS_MULTIPLE` depending on number of results you want.
        Returns :data:`MS_SUCCESS` if the query was successfully performed, regardless of whether any shapes were found, or :data:`MS_FAILURE` if an error occurred.
        """
        return _mapscript.layerObj_queryByPoint(self, map, point, mode, buffer)

    def queryByRect(self, map: "mapObj", rect: "rectObj") -> "int":
        r"""
        Query layer using a rectangle specified in georeferenced map coordinates (i.e. not pixels).
        The query is performed on all the shapes that are part of a CLASS that contains a TEMPLATE value or that match any class in a layer that contains a LAYER TEMPLATE value.
        Note that the layer's FILTER/FILTERITEM are ignored by this function. The :data:`MS_MULTIPLE` mode is set by default.
        Returns :data:`MS_SUCCESS` if the query was successfully performed, regardless of whether any shapes were found, or :data:`MS_FAILURE` if an error occurred.
        """
        return _mapscript.layerObj_queryByRect(self, map, rect)

    def queryByFeatures(self, map: "mapObj", slayer: "int") -> "int":
        r"""
        Perform a query set based on a previous set of results from another layer.
        At present the results MUST be based on a polygon layer.
        Returns :data:`MS_SUCCESS` if the query was successfully performed, regardless of whether any shapes were found, or :data:`MS_FAILURE` if an error occurred.
        """
        return _mapscript.layerObj_queryByFeatures(self, map, slayer)

    def queryByShape(self, map: "mapObj", shape: "shapeObj") -> "int":
        r"""
        Query layer based on a single shape, the shape has to be a polygon at this point.
        Returns :data:`MS_SUCCESS` if the query was successfully performed, regardless of whether any shapes were found, or :data:`MS_FAILURE` if an error occurred.
        """
        return _mapscript.layerObj_queryByShape(self, map, shape)

    def queryByIndex(self, map: "mapObj", tileindex: "int", shapeindex: "int", bAddToQuery: "int"=0) -> "int":
        r"""
        Pop a query result member into the layer's result cache. By default clobbers existing cache.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.layerObj_queryByIndex(self, map, tileindex, shapeindex, bAddToQuery)

    def getResults(self) -> "resultCacheObj *":
        r"""Returns a reference to layer's result cache. Should be NULL prior to any query, or after a failed query or query with no results."""
        return _mapscript.layerObj_getResults(self)

    def setFilter(self, filter: "char *") -> "int":
        r"""
        Sets a filter expression similarly to the FILTER expression in a map file.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE` if the expression fails to parse.
        """
        return _mapscript.layerObj_setFilter(self, filter)

    def getFilterString(self) -> "char *":
        r"""Returns the current filter expression."""
        return _mapscript.layerObj_getFilterString(self)

    def setWKTProjection(self, wkt: "char *") -> "int":
        r"""
        Set the layer projection using OpenGIS Well Known Text format.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.layerObj_setWKTProjection(self, wkt)

    def getProjection(self) -> "char *":
        r"""Returns the PROJ definition of the layer's projection."""
        return _mapscript.layerObj_getProjection(self)

    def setProjection(self, proj4: "char *") -> "int":
        r"""
        Set the layer projection using a PROJ format projection definition
        (i.e. "+proj=utm +zone=11 +datum=WGS84" or "init=EPSG:26911").
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.layerObj_setProjection(self, proj4)

    def addFeature(self, shape: "shapeObj") -> "int":
        r"""
        Add a new inline feature on a layer. Returns -1 on error.
        TODO: Is this similar to inline features in a mapfile? Does it work for any kind of layer or connection type?
        """
        return _mapscript.layerObj_addFeature(self, shape)

    def getNumFeatures(self) -> "int":
        r"""
        Returns the number of inline features in a layer.
        TODO: is this really only online features or will it return the number of non-inline features on a regular layer?
        """
        return _mapscript.layerObj_getNumFeatures(self)

    def getExtent(self) -> "rectObj *":
        r"""Fetches the extents of the data in the layer. This normally requires a full read pass through the features of the layer and does not work for raster layers."""
        return _mapscript.layerObj_getExtent(self)

    def setExtent(self, minx: "double"=-1.0, miny: "double"=-1.0, maxx: "double"=-1.0, maxy: "double"=-1.0) -> "int":
        r"""
        Sets the extent of a layer.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.layerObj_setExtent(self, minx, miny, maxx, maxy)

    def getWMSFeatureInfoURL(self, map: "mapObj", click_x: "int", click_y: "int", feature_count: "int", info_format: "char *") -> "char *":
        r"""
        Return a WMS GetFeatureInfo URL (works only for WMS layers) *clickX*, *clickY*
        is the location of to query in pixel coordinates with (0,0) at the top
        left of the image. *featureCount* is the number of results to return. *infoFormat*
        is the format the format in which the result should be requested.
        Depends on remote server's capabilities. MapServer WMS servers support only "MIME"
        (and should support "GML.1" soon). Returns "" and outputs a warning if layer is not a
        WMS layer or if it is not queryable.
        """
        return _mapscript.layerObj_getWMSFeatureInfoURL(self, map, click_x, click_y, feature_count, info_format)

    def executeWFSGetFeature(self) -> "char *":
        r"""Executes a GetFeature request on a WFS layer and returns the name of the temporary GML file created. Returns an empty string on error."""
        return _mapscript.layerObj_executeWFSGetFeature(self)

    def applySLD(self, sld: "char *", stylelayer: "char *") -> "int":
        r"""
        Apply the SLD document to the layer object. The matching between the SLD document and the
        layer will be done using the layer's name. If a *stylelayer* argument is passed (argument is optional),
        the NamedLayer in the SLD that matches it will be used to style the layer.
        See SLD HOWTO for more information on the SLD support.
        """
        return _mapscript.layerObj_applySLD(self, sld, stylelayer)

    def applySLDURL(self, sld: "char *", stylelayer: "char *") -> "int":
        r"""
        Apply the SLD document pointed by the URL to the layer object. The matching between the SLD document and the
        layer will be done using the layer's name. If a *stylelayer* argument is passed (argument is optional),
        the NamedLayer in the SLD that matches it will be used to style the layer.
        See SLD HOWTO for more information on the SLD support.
        """
        return _mapscript.layerObj_applySLDURL(self, sld, stylelayer)

    def generateSLD(self) -> "char *":
        r"""Returns an SLD XML string based on all the classes found in the layer (the layer must have ``STATUS ON```)."""
        return _mapscript.layerObj_generateSLD(self)

    def isVisible(self) -> "int":
        r"""
        Returns :data:`MS_TRUE` or :data:`MS_FALSE` after considering the layer status,
        minscaledenom, and maxscaledenom within the context of the parent map.
        """
        return _mapscript.layerObj_isVisible(self)

    def moveClassUp(self, index: "int") -> "int":
        r"""
        The class specified by the class index will be moved up in the array of classes.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`. For example ``moveClassUp(1)`` will have the effect
        of moving class 1 up to position 0, and the class at position 0 will be moved to position 1.
        """
        return _mapscript.layerObj_moveClassUp(self, index)

    def moveClassDown(self, index: "int") -> "int":
        r"""
        The class specified by the class index will be moved up into the array of classes.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`. For example ``moveClassDown(1)`` will have the effect
        of moving class 1 down to position 2, and the class at position 2 will be moved to position 1.
        """
        return _mapscript.layerObj_moveClassDown(self, index)

    def setProcessingKey(self, key: "char const *", value: "char const *") -> "void":
        r"""
        Adds or replaces a processing directive of the form "key=value".
        Unlike the :func:`layerObj.addProcessing` function, this will replace an existing processing directive
        for the given key value. Processing directives supported are specific to the layer type
        and underlying renderer.
        """
        return _mapscript.layerObj_setProcessingKey(self, key, value)

    def addProcessing(self, directive: "char const *") -> "void":
        r"""
        Adds a new processing directive line to a layer, similar to the PROCESSING directive
        in a map file. Processing directives supported are specific to the layer type and
        underlying renderer.
        """
        return _mapscript.layerObj_addProcessing(self, directive)

    def getNumProcessing(self) -> "int":
        r"""Return the number of processing directives"""
        return _mapscript.layerObj_getNumProcessing(self)

    def getProcessing(self, index: "int") -> "char *":
        r"""Return the raster processing directive at *index*."""
        return _mapscript.layerObj_getProcessing(self, index)

    def getProcessingKey(self, key: "char const *") -> "char *":
        r"""Return the processing directive specified by *key*."""
        return _mapscript.layerObj_getProcessingKey(self, key)

    def clearProcessing(self) -> "int":
        r"""
        Clears the layer's raster processing directives.
        Returns the subsequent number of directives, which will equal :data:`MS_SUCCESS` if the
        directives have been cleared.
        """
        return _mapscript.layerObj_clearProcessing(self)

    def setConnectionType(self, connectiontype: "int", library_str: "char const *") -> "int":
        r"""
        Changes the connectiontype of the layer and recreates the vtable according to the new
        connection type. This method should be used instead of setting the *connectiontype*
        parameter directly. In case when the layer.connectiontype = :data:`MS_PLUGIN` the *library_str*
        parameter should also be specified so as to select the library to load by MapServer.
        For the other connection types this parameter should be set to an empty string "".
        """
        return _mapscript.layerObj_setConnectionType(self, connectiontype, library_str)

    def getClassIndex(self, map: "mapObj", shape: "shapeObj", classgroup: "int *"=None, numclasses: "int"=0) -> "int":
        r"""Get the class index for a shape in the layer."""
        return _mapscript.layerObj_getClassIndex(self, map, shape, classgroup, numclasses)

    def getGeomTransform(self) -> "char *":
        r"""Return the geomtransform string for the layer."""
        return _mapscript.layerObj_getGeomTransform(self)

    def setGeomTransform(self, transform: "char *") -> "void":
        r"""Set the geomtransform string for the layer."""
        return _mapscript.layerObj_setGeomTransform(self, transform)

    def getItemType(self, i: "int") -> "char *":
        r"""
        Returns the requested item's field type.
        A layer must be open to retrieve the item definition.

        Pass in the attribute index to retrieve the type. The
        layer's numitems property contains the number of items
        available, and the first item is index zero.
        """
        return _mapscript.layerObj_getItemType(self, i)


    def getItemDefinitions(self):
        """
        **Python MapScript only**

        Return item (field) names and their types if available.
        Field types are specified using GML metadata and can be one of the following:

        ``Integer|Long|Real|Character|Date|Boolean``

        """
        item_names = [self.getItem(idx) for idx in range(0, self.numitems)]
        item_types = [self.getItemType(idx) for idx in range(0, self.numitems)]
        return zip(item_names, item_types)



# Register layerObj in _mapscript:
_mapscript.layerObj_swigregister(layerObj)
MS_RESOLUTION_MAX = _mapscript.MS_RESOLUTION_MAX
MS_RESOLUTION_MIN = _mapscript.MS_RESOLUTION_MIN
class mapObj(object):
    r"""The :ref:`MAP <map>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refcount: "int" = property(_mapscript.mapObj_refcount_get, doc=r"""Used for reference counting see RFC24""")
    numlayers: "int" = property(_mapscript.mapObj_numlayers_get, doc=r"""Number of layers in mapfile""")
    maxlayers: "int" = property(_mapscript.mapObj_maxlayers_get, doc=r"""Allocated size of layers[] array""")
    configoptions: "hashTableObj" = property(_mapscript.mapObj_configoptions_get, doc=r"""
    A hash table of configuration options from CONFIG keywords
    in the map - see :ref:`CONFIG <mapfile-map-config>`
    """)
    symbolset: "symbolSetObj" = property(_mapscript.mapObj_symbolset_get, doc=r"""See :ref:`SYMBOLSET <mapfile-map-symbolset>`""")
    fontset: "fontSetObj" = property(_mapscript.mapObj_fontset_get, doc=r"""See :ref:`FONTSET <mapfile-map-fontset>`""")
    labelcache: "labelCacheObj" = property(_mapscript.mapObj_labelcache_get, doc=r"""
    We need this here so multiple feature
    processors can access it
    """)
    numoutputformats: "int" = property(_mapscript.mapObj_numoutputformats_get, doc=r"""Number of output formats available in the map""")
    outputformat: "outputFormatObj *" = property(_mapscript.mapObj_outputformat_get, doc=r"""See :ref:`OUTPUTFORMAT <mapfile-map-outputformat>`""")
    imagetype: "char *" = property(_mapscript.mapObj_imagetype_get, doc=r"""Name of current outputformat""")
    reference: "referenceMapObj" = property(_mapscript.mapObj_reference_get, doc=r"""See :ref:`SCALEBAR <mapfile-map-scalebar>`""")
    scalebar: "scalebarObj" = property(_mapscript.mapObj_scalebar_get, doc=r"""See :ref:`SCALEBAR <mapfile-map-scalebar>`""")
    legend: "legendObj" = property(_mapscript.mapObj_legend_get, doc=r"""See :ref:`LEGEND <mapfile-map-legend>`""")
    querymap: "queryMapObj" = property(_mapscript.mapObj_querymap_get, doc=r"""See :ref:`QUERYMAP <mapfile-map-querymap>`""")
    web: "webObj" = property(_mapscript.mapObj_web_get, doc=r"""See :ref:`WEB <mapfile-map-web>`""")
    config: "configObj const *" = property(_mapscript.mapObj_config_get)
    datapattern: "char *" = property(_mapscript.mapObj_datapattern_get, _mapscript.mapObj_datapattern_set, doc=r"""TODO - Deprecated use VALIDATION ... END block instead""")
    templatepattern: "char *" = property(_mapscript.mapObj_templatepattern_get, _mapscript.mapObj_templatepattern_set, doc=r"""
    TODO - Deprecated use VALIDATION ... END block
    instead
    """)
    name: "char *" = property(_mapscript.mapObj_name_get, _mapscript.mapObj_name_set, doc=r"""
    Small identifier for naming etc - see :ref:`NAME
    <mapfile-map-name>`
    """)
    status: "int" = property(_mapscript.mapObj_status_get, _mapscript.mapObj_status_set, doc=r"""
    Is map creation on or off - see :ref:`STATUS
    <mapfile-map-status>`
    """)
    height: "int" = property(_mapscript.mapObj_height_get, _mapscript.mapObj_height_set, doc=r"""See :ref:`SIZE <mapfile-map-size>`""")
    width: "int" = property(_mapscript.mapObj_width_get, _mapscript.mapObj_width_set, doc=r"""See :ref:`SIZE <mapfile-map-size>`""")
    maxsize: "int" = property(_mapscript.mapObj_maxsize_get, _mapscript.mapObj_maxsize_set, doc=r"""See :ref:`MAXSIZE  <mapfile-map-maxsize>`""")
    extent: "rectObj" = property(_mapscript.mapObj_extent_get, _mapscript.mapObj_extent_set, doc=r"""Map extent array - see :ref:`EXTENT <mapfile-map-extent>`""")
    cellsize: "double" = property(_mapscript.mapObj_cellsize_get, _mapscript.mapObj_cellsize_set, doc=r"""Pixel size in map units""")
    units: "enum MS_UNITS" = property(_mapscript.mapObj_units_get, _mapscript.mapObj_units_set, doc=r"""Units of the projection - see :ref:`UNITS <mapfile-map-units>`""")
    scaledenom: "double" = property(_mapscript.mapObj_scaledenom_get, _mapscript.mapObj_scaledenom_set, doc=r"""
    The nominal map scale, a value of 25000 means 1:25000
    scale - see :ref:`SCALEDENOM <mapfile-map-scaledenom>`
    """)
    resolution: "double" = property(_mapscript.mapObj_resolution_get, _mapscript.mapObj_resolution_set, doc=r"""See :ref:`RESOLUTION <mapfile-map-resolution>`""")
    defresolution: "double" = property(_mapscript.mapObj_defresolution_get, _mapscript.mapObj_defresolution_set, doc=r"""
    Default resolution - used to calculate the
    scalefactor, see :ref:`DEFRESOLUTION
    <mapfile-map-defresolution>`
    """)
    shapepath: "char *" = property(_mapscript.mapObj_shapepath_get, _mapscript.mapObj_shapepath_set, doc=r"""
    Where are the shape files located - see :ref:`SHAPEPATH
    <mapfile-map-shapepath>`
    """)
    mappath: "char *" = property(_mapscript.mapObj_mappath_get, _mapscript.mapObj_mappath_set, doc=r"""Path of the mapfile, all paths are relative to this path""")
    sldurl: "char *" = property(_mapscript.mapObj_sldurl_get, _mapscript.mapObj_sldurl_set, doc=r"""
    URL of SLD document as specified with "&SLD=..." WMS parameter d- currently
    this reference is used only in mapogcsld.c and has a NULL value outside that
    context
    """)
    imagecolor: "colorObj" = property(_mapscript.mapObj_imagecolor_get, _mapscript.mapObj_imagecolor_set, doc=r"""
    Holds the initial image color value - see
    :ref:`IMAGECOLOR <mapfile-map-imagecolor>`
    """)
    layerorder: "int *" = property(_mapscript.mapObj_layerorder_get, _mapscript.mapObj_layerorder_set, doc=r"""
    Used to modify the order in which the layers are drawn -
    TODO should be immutable?
    """)
    debug: "int" = property(_mapscript.mapObj_debug_get, _mapscript.mapObj_debug_set, doc=r"""See :ref:`DEBUG <mapfile-map-debug>`""")

    def __init__(self, *args):
        r"""Create a new instance of :class:`mapObj`. Note that the *filename* is optional."""
        _mapscript.mapObj_swiginit(self, _mapscript.new_mapObj(*args))
    __swig_destroy__ = _mapscript.delete_mapObj

    def clone(self) -> "mapObj *":
        r"""
        Return an independent copy of the map, less any caches.

        .. note::

            In the Java & PHP modules this method is named ``cloneMap``.
        """
        return _mapscript.mapObj_clone(self)

    def insertLayer(*args):
        """
        Insert a copy of *layer* into the map at *index*.
        The default value of *index* is -1, which means the last possible index. 
        Returns the index of the new layer, or -1 in the case of a failure.
        """
        actualIndex=_mapscript.mapObj_insertLayer(*args)
        args[1].p_map=args[0]
        return actualIndex


    def removeLayer(self, index: "int") -> "layerObj *":
        r"""Remove the layer at *index*. Returns the :class:`layerObj`."""
        return _mapscript.mapObj_removeLayer(self, index)

    def setExtent(self, minx: "double", miny: "double", maxx: "double", maxy: "double") -> "int":
        r"""
        Set the map extent, returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        This method will correct the extents (width/height ratio) before setting the
        minx, miny, maxx, maxy values. See extent properties to set up a custom extent from :class:`rectObj`.
        """
        return _mapscript.mapObj_setExtent(self, minx, miny, maxx, maxy)

    def offsetExtent(self, x: "double", y: "double") -> "int":
        r"""
        Offset the map extent based on the given distances in map coordinates.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_offsetExtent(self, x, y)

    def scaleExtent(self, zoomfactor: "double", minscaledenom: "double", maxscaledenom: "double") -> "int":
        r"""
        Scale the map extent using the *zoomfactor* and ensure the extent within
        the *minscaledenom* and *maxscaledenom* domain. If *minscaledenom* and/or *maxscaledenom*
        is 0 then the parameter is not taken into account.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_scaleExtent(self, zoomfactor, minscaledenom, maxscaledenom)

    def setCenter(self, center: "pointObj") -> "int":
        r"""
        Set the map center to the given map point.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_setCenter(self, center)

    def setSize(self, width: "int", height: "int") -> "int":
        return _mapscript.mapObj_setSize(self, width, height)

    def pixelToGeoref(self, pixPosX: "double", pixPosY: "double", geoPos: "pointObj") -> "void":
        r"""TODO"""
        return _mapscript.mapObj_pixelToGeoref(self, pixPosX, pixPosY, geoPos)

    def getRotation(self) -> "double":
        r"""Returns the map rotation angle."""
        return _mapscript.mapObj_getRotation(self)

    def setRotation(self, rotation_angle: "double") -> "int":
        r"""
        Set map rotation angle. The map view rectangle (specified in EXTENTS) will be rotated by
        the indicated angle in the counter- clockwise direction. Note that this implies the
        rendered map will be rotated by the angle in the clockwise direction.

        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_setRotation(self, rotation_angle)

    def getLayer(*args):
        """
        Returns a reference to the layer at index *i*.
        """
        layer = _mapscript.mapObj_getLayer(*args)
        if layer:
            if args and len(args)!=0:
                layer.p_map=args[0]
            else:
                layer.p_map=None
        return layer


    def getLayerByName(*args):
        """
        Returns a reference to the named layer.
        """
        layer = _mapscript.mapObj_getLayerByName(*args)
        if layer:
            if args and len(args)!=0:
                layer.p_map=args[0]
            else:
                layer.p_map=None
        return layer


    def getSymbolByName(self, name: "char *") -> "int":
        r"""
        Return the index of the named symbol in the map's symbolset.

        .. note::

            This method is poorly named and too indirect. It is preferable to use the
            getSymbolByName method of :class:`symbolSetObj`, which really does return a :class:`symbolObj`
            reference, or use the index method of symbolSetObj to get a symbol's index number.
        """
        return _mapscript.mapObj_getSymbolByName(self, name)

    def prepareQuery(self) -> "void":
        r"""**TODO** this function only calculates the scale or am I missing something?"""
        return _mapscript.mapObj_prepareQuery(self)

    def prepareImage(self) -> "imageObj *":
        r"""Returns an :class:`imageObj` initialized to map extents and outputformat."""
        return _mapscript.mapObj_prepareImage(self)

    def setImageType(self, imagetype: "char const *") -> "void":
        r"""
        Sets map outputformat to the named format.

        .. note::

            :func:`mapObj.setImageType` remains in the module but its use
            is deprecated in favor of :func:`mapObj.selectOutputFormat`.
        """
        return _mapscript.mapObj_setImageType(self, imagetype)

    def selectOutputFormat(self, imagetype: "char const *") -> "void":
        r"""
        Set the map's active output format to the internal format named imagetype.
        Built-in formats are "PNG", "PNG24", "JPEG", "GIF", "GTIFF".
        """
        return _mapscript.mapObj_selectOutputFormat(self, imagetype)

    def getOutputFormat(self, i: "int") -> "outputFormatObj *":
        r"""
        Returns the output format at the specified *i* index from the output formats array or
        null if *i* is beyond the array bounds. The number of outpuFormats can be
        retrieved by calling :func:`mapObj.getNumoutputformats`.
        """
        return _mapscript.mapObj_getOutputFormat(self, i)

    def setOutputFormat(self, format: "outputFormatObj") -> "void":
        r"""Sets map outputformat."""
        return _mapscript.mapObj_setOutputFormat(self, format)

    def draw(self) -> "imageObj *":
        r"""
        Draw the map, processing layers according to their defined order and status.
        Return an :class:`imageObj`.
        """
        return _mapscript.mapObj_draw(self)

    def drawQuery(self) -> "imageObj *":
        r"""Draw query map, returning an :class:`imageObj`."""
        return _mapscript.mapObj_drawQuery(self)

    def drawLegend(self, scale_independent: "int"=0) -> "imageObj *":
        r"""Draw map legend, returning an :class:`imageObj`."""
        return _mapscript.mapObj_drawLegend(self, scale_independent)

    def drawScalebar(self) -> "imageObj *":
        r"""Draw scale bar, returning an :class:`imageObj`."""
        return _mapscript.mapObj_drawScalebar(self)

    def drawReferenceMap(self) -> "imageObj *":
        r"""Draw reference map, returning an :class:`imageObj`."""
        return _mapscript.mapObj_drawReferenceMap(self)

    def embedScalebar(self, image: "imageObj") -> "int":
        r"""
        Embed map's legend in *image*.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_embedScalebar(self, image)

    def embedLegend(self, image: "imageObj") -> "int":
        r"""
        Embed map's legend in *image*.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_embedLegend(self, image)

    def drawLabelCache(self, image: "imageObj") -> "int":
        r"""
        Draw map's label cache on *image*.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_drawLabelCache(self, image)

    def queryByFilter(self, string: "char *") -> "int":
        r"""
        Query map layers using the filter *string*.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_queryByFilter(self, string)

    def queryByPoint(self, point: "pointObj", mode: "int", buffer: "double") -> "int":
        r"""
        Query map layers, result sets contain one or more features, depending on mode,
        that intersect *point* within a tolerance *buffer*.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_queryByPoint(self, point, mode, buffer)

    def queryByRect(self, rect: "rectObj") -> "int":
        r"""
        Query map layers, result sets contain features that intersect or are contained within
        the features in the result set of the :data:`MS_LAYER_POLYGON` type layer at layer index *slayer*.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_queryByRect(self, rect)

    def queryByFeatures(self, slayer: "int") -> "int":
        r"""
        Query map layers, result sets contain features that intersect or are contained within
        the features in the result set of the :data:`MS_LAYER_POLYGON` type layer at layer index *slayer*.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`.
        """
        return _mapscript.mapObj_queryByFeatures(self, slayer)

    def queryByShape(self, shape: "shapeObj") -> "int":
        r"""
        Query layer based on a single shape, the shape has to be a polygon at this point.
        Returns :data:`MS_SUCCESS` if shapes were found or :data:`MS_FAILURE` if nothing was found
        or if some other error happened
        """
        return _mapscript.mapObj_queryByShape(self, shape)

    def setWKTProjection(self, wkt: "char *") -> "int":
        r"""Sets map projection from OGC definition *wkt*."""
        return _mapscript.mapObj_setWKTProjection(self, wkt)

    def getProjection(self) -> "char *":
        r"""Returns the PROJ definition of the map's projection."""
        return _mapscript.mapObj_getProjection(self)

    def setProjection(self, proj4: "char *") -> "int":
        r"""Set map projection from PROJ definition string proj4."""
        return _mapscript.mapObj_setProjection(self, proj4)

    def save(self, filename: "char *") -> "int":
        r"""
        Save map to disk as a new map file.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_save(self, filename)

    def saveQuery(self, filename: "char *", results: "int"=0) -> "int":
        r"""
        Save query to disk.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_saveQuery(self, filename, results)

    def loadQuery(self, filename: "char *") -> "int":
        r"""
        Load a saved query.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_loadQuery(self, filename)

    def freeQuery(self, qlayer: "int"=-1) -> "void":
        r"""Clear layer query result caches. Default is -1, or all layers."""
        return _mapscript.mapObj_freeQuery(self, qlayer)

    def saveQueryAsGML(self, *args) -> "int":
        r"""
        Save query to disk.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_saveQueryAsGML(self, *args)

    def setSymbolSet(self, szFileName: "char *") -> "int":
        r"""
        Load symbols defined in filename into map symbolset. The existing symbolset is cleared.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_setSymbolSet(self, szFileName)

    def getNumSymbols(self) -> "int":
        r"""Return the number of symbols in map"""
        return _mapscript.mapObj_getNumSymbols(self)

    def setFontSet(self, filename: "char *") -> "int":
        r"""
        . Load fonts defined in filename into map fontset. The existing fontset is cleared.
         Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_setFontSet(self, filename)

    def saveMapContext(self, szFileName: "char *") -> "int":
        r"""
        Save map definition to disk as OGC-compliant XML.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_saveMapContext(self, szFileName)

    def loadMapContext(self, szFileName: "char *", useUniqueNames: "int"=0) -> "int":
        r"""
        Load an OGC map context file to define extents and layers of a map
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_loadMapContext(self, szFileName, useUniqueNames)

    def moveLayerUp(self, layerindex: "int") -> "int":
        r"""
        Move the layer at layerindex up in the drawing order array, meaning
        that it is drawn earlier.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_moveLayerUp(self, layerindex)

    def moveLayerDown(self, layerindex: "int") -> "int":
        r"""
        Move the layer at layerindex down in the drawing order array, meaning
        that it is drawn later.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_moveLayerDown(self, layerindex)

    def getLayersDrawingOrder(self) -> "intarray *":
        r"""
        Returns an array of layer indexes in drawing order.
        Note Unless the proper typemap is implemented for the module's language
        a user is more likely to get back an unusable SWIG pointer to the integer array.
        """
        return _mapscript.mapObj_getLayersDrawingOrder(self)

    def setLayersDrawingOrder(self, panIndexes: "int *") -> "int":
        r"""
        Set map layer drawing order.
        Note Unless the proper typemap is implemented for the module's language
        users will not be able to pass arrays or lists to this method and it will be unusable.
        """
        return _mapscript.mapObj_setLayersDrawingOrder(self, panIndexes)

    def setConfigOption(self, key: "char *", value: "char *") -> "void":
        r"""
        Set the indicated key configuration option to the indicated value.
        Equivalent to including a CONFIG keyword in a map file.
        """
        return _mapscript.mapObj_setConfigOption(self, key, value)

    def getConfigOption(self, key: "char *") -> "char *":
        r"""
        Fetches the value of the requested configuration key if set.
        Returns NULL if the key is not set.
        """
        return _mapscript.mapObj_getConfigOption(self, key)

    def applyConfigOptions(self) -> "void":
        r"""Apply the defined configuration options set by setConfigOption()"""
        return _mapscript.mapObj_applyConfigOptions(self)

    def applySLD(self, sld: "char *") -> "int":
        r"""
        Parse the SLD XML string sldxml and apply to map layers.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_applySLD(self, sld)

    def applySLDURL(self, sld: "char *") -> "int":
        r"""
        Fetch SLD XML from the URL sldurl and apply to map layers.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_applySLDURL(self, sld)

    def generateSLD(self, sldVersion: "char *"=None) -> "char *":
        r"""Return SLD XML as a string for map layers that have STATUS on."""
        return _mapscript.mapObj_generateSLD(self, sldVersion)

    def processTemplate(self, bGenerateImages: "int", names: "char **", values: "char **", numentries: "int") -> "char *":
        r"""
        Process MapServer template and return HTML.
        Note none of the three template processing methods will be usable unless the proper
        typemaps are implemented in the module for the target language.Currently the typemaps
        are not implemented.
        """
        return _mapscript.mapObj_processTemplate(self, bGenerateImages, names, values, numentries)

    def processLegendTemplate(self, names: "char **", values: "char **", numentries: "int") -> "char *":
        r"""
        Process MapServer legend template and return HTML.
        Note none of the three template processing methods will be usable unless the proper
        typemaps are implemented in the module for the target language.Currently the typemaps
        are not implemented.
        """
        return _mapscript.mapObj_processLegendTemplate(self, names, values, numentries)

    def processQueryTemplate(self, names: "char **", values: "char **", numentries: "int") -> "char *":
        r"""
        Process MapServer query template and return HTML.
        Note none of the three template processing methods will be usable unless the proper
        typemaps are implemented in the module for the target language.Currently the typemaps
        are not implemented.
        """
        return _mapscript.mapObj_processQueryTemplate(self, names, values, numentries)

    def getOutputFormatByName(self, name: "char const *") -> "outputFormatObj *":
        r"""
        Return the output format corresponding to driver name imagetype or to format name
        imagetype. This works exactly the same as the IMAGETYPE directive in a mapfile, is
        case insensitive and allows an output format to be found either by driver
        (like 'AGG/PNG') or name (like 'png').
        """
        return _mapscript.mapObj_getOutputFormatByName(self, name)

    def appendOutputFormat(self, format: "outputFormatObj") -> "int":
        r"""
        Attach format to the map's output format list.
        Returns the updated number of output formats.
        """
        return _mapscript.mapObj_appendOutputFormat(self, format)

    def removeOutputFormat(self, name: "char const *") -> "int":
        r"""
        Removes the format named name from the map's output format list.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_removeOutputFormat(self, name)

    def loadOWSParameters(self, *args) -> "int":
        r"""
        Load OWS request parameters (BBOX, LAYERS, &c.) into map.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_loadOWSParameters(self, *args)

    def OWSDispatch(self, req: "OWSRequest") -> "int":
        r"""
        Processes and executes the passed OpenGIS Web Services request on the map.
        Returns :data:`MS_DONE` (2) if there is no valid OWS request in the req object,
        :data:`MS_SUCCESS` (0) if an OWS request was successfully processed and :data:`MS_FAILURE` (1)
        if an OWS request was not successfully processed. OWS requests include WMS, WFS, WCS
        and SOS requests supported by MapServer. Results of a dispatched request are written to
        stdout and can be captured using the msIO services (i.e. :func:`mapscript.msIO_installStdoutToBuffer`
        and :func:`mapscript.msIO_getStdoutBufferString()`
        """
        return _mapscript.mapObj_OWSDispatch(self, req)

    def convertToString(self) -> "char *":
        r"""Saves the object to a string. Provides the inverse option for updateFromString."""
        return _mapscript.mapObj_convertToString(self)

    def applyDefaultSubstitutions(self) -> "void":
        r"""Apply any default values defined in a VALIDATION block used for runtime substitutions"""
        return _mapscript.mapObj_applyDefaultSubstitutions(self)

    def applySubstitutions(self, names: "char **") -> "void":
        r"""
        Pass in runtime substitution keys and values and apply them to the map.
        Note - this method is currently enabled for Python only.
        Typemaps are needed for other MapScript languages.
        """
        return _mapscript.mapObj_applySubstitutions(self, names)

    def zoomPoint(self, zoomfactor: "int", poPixPos: "pointObj", width: "int", height: "int", poGeorefExt: "rectObj", poMaxGeorefExt: "rectObj") -> "int":
        r"""
        Zoom by the given factor to a pixel position within the width
        and height bounds. If max_extent is not NULL, the zoom is
        constrained to the max_extents

        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.mapObj_zoomPoint(self, zoomfactor, poPixPos, width, height, poGeorefExt, poMaxGeorefExt)

    def zoomRectangle(self, poPixRect: "rectObj", width: "int", height: "int", poGeorefExt: "rectObj", poMaxGeorefExt: "rectObj") -> "int":
        r"""
        Set the map extents to a given extents.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE` on error
        """
        return _mapscript.mapObj_zoomRectangle(self, poPixRect, width, height, poGeorefExt, poMaxGeorefExt)

    def zoomScale(self, scale: "double", poPixPos: "pointObj", width: "int", height: "int", poGeorefExt: "rectObj", poMaxGeorefExt: "rectObj") -> "int":
        r"""
        Zoom by the given factor to a pixel position within the width
        and height bounds.  If max_extent is not NULL, the zoom is
        constrained to the max_extents
        """
        return _mapscript.mapObj_zoomScale(self, scale, poPixPos, width, height, poGeorefExt, poMaxGeorefExt)

    def getLayerOrder(self) -> "PyObject *":
        r"""**Python MapScript only**  - returns the map layer order as a native sequence"""
        return _mapscript.mapObj_getLayerOrder(self)

    def setLayerOrder(self, order: "PyObject *") -> "int":
        r"""**Python MapScript only** - sets the map layer order using a native sequence"""
        return _mapscript.mapObj_setLayerOrder(self, order)

    def getSize(self) -> "PyObject *":
        r"""**Python MapScript only** - gets the map size as a tuple"""
        return _mapscript.mapObj_getSize(self)


    def get_height(self):
        """
        **Python MapScript only**
        Return the map height from the map size
        """
        return self.getSize()[1] # <-- second member is the height

    def get_width(self):
        """
        **Python MapScript only**
        Return the map width from the map size
        """
        return self.getSize()[0] # <-- first member is the width

    def set_height(self, value):
        """
        **Python MapScript only**
        Set the map height value of the map size
        """
        return self.setSize(self.getSize()[0], value)

    def set_width(self, value):
        """
        **Python MapScript only**
        Set the map width value of the map size
        """
        return self.setSize(value, self.getSize()[1])

    width = property(get_width, set_width, doc="See :ref:`SIZE <mapfile-map-size>`")
    height = property(get_height, set_height, doc = "See :ref:`SIZE <mapfile-map-size>`")



# Register mapObj in _mapscript:
_mapscript.mapObj_swigregister(mapObj)

def msSaveImage(map: "mapObj", img: "imageObj", filename: "char const *") -> "int":
    r"""Saves a map image to a file"""
    return _mapscript.msSaveImage(map, img, filename)

def msFreeImage(img: "imageObj") -> "void":
    r"""Generic function to free a imageObj"""
    return _mapscript.msFreeImage(img)

def msSetup() -> "int":
    r"""Sets up threads and font cache - called when MapScript is initialized"""
    return _mapscript.msSetup()

def msCleanup() -> "void":
    r"""
    Attempts to recover all dynamically allocated resources allocated by MapServer
    code and dependent libraries. It is used primarily for final clean-up in scripts
    that need to do memory leak testing to get rid of "noise" one-time allocations.
    It should not normally be used by production code.
    """
    return _mapscript.msCleanup()

def msLoadMapFromString(buffer: "char *", new_mappath: "char *", config: "configObj") -> "mapObj *":
    r"""Sets up string-based mapfile loading and calls loadMapInternal to do the work"""
    return _mapscript.msLoadMapFromString(buffer, new_mappath, config)
MS_VERSION_MAJOR = _mapscript.MS_VERSION_MAJOR
MS_VERSION_MINOR = _mapscript.MS_VERSION_MINOR
MS_VERSION_REV = _mapscript.MS_VERSION_REV
MS_VERSION = _mapscript.MS_VERSION
MS_VERSION_NUM = _mapscript.MS_VERSION_NUM
class rectObj(object):
    r"""
    A rectObj represents a rectangle or bounding box.
    A rectObj may be a lone object or an attribute of another object and has no
    other associations.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    minx: "double" = property(_mapscript.rectObj_minx_get, _mapscript.rectObj_minx_set, doc=r"""Minimum easting""")
    miny: "double" = property(_mapscript.rectObj_miny_get, _mapscript.rectObj_miny_set, doc=r"""Minimum northing""")
    maxx: "double" = property(_mapscript.rectObj_maxx_get, _mapscript.rectObj_maxx_set, doc=r"""Maximum easting""")
    maxy: "double" = property(_mapscript.rectObj_maxy_get, _mapscript.rectObj_maxy_set, doc=r"""Maximum northing""")

    def __init__(self, minx: "double"=-1.0, miny: "double"=-1.0, maxx: "double"=-1.0, maxy: "double"=-1.0, imageunits: "int"=0):
        r"""
        Create new instance. The four easting and northing arguments are optional and
        default to -1.0. Note the new optional fifth argument which allows creation
        of rectangles in image (pixel/line) units which are also tested for validity.
        """
        _mapscript.rectObj_swiginit(self, _mapscript.new_rectObj(minx, miny, maxx, maxy, imageunits))
    __swig_destroy__ = _mapscript.delete_rectObj

    def project(self, *args) -> "int":
        r"""
        *Overload 1:*
        Reproject rectangle from proj_in to proj_out. Transformation is done in place.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`

        |

        *Overload 2:*
        Reproject rectangle given a reprojection object. Transformation is done in place.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.rectObj_project(self, *args)

    def fit(self, width: "int", height: "int") -> "double":
        r"""Adjust the rect to fit the width and height. Returns cellsize of rect."""
        return _mapscript.rectObj_fit(self, width, height)

    def draw(self, map: "mapObj", layer: "layerObj", image: "imageObj", classindex: "int", text: "char *") -> "int":
        r"""
        Draw rectangle into img using style defined by the classindex class of layer.
        The rectangle is labeled with the string text.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.rectObj_draw(self, map, layer, image, classindex, text)

    def getCenter(self) -> "pointObj *":
        r"""Return the center point of the rectangle."""
        return _mapscript.rectObj_getCenter(self)

    def toPolygon(self) -> "shapeObj *":
        r"""Convert to a polygon of five vertices."""
        return _mapscript.rectObj_toPolygon(self)

    def toString(self) -> "char *":
        r"""
        Return a string formatted like: ``{ 'minx': %f , 'miny': %f , 'maxx': %f , 'maxy': %f }``
        with the bounding values substituted appropriately. Python users can get the same effect
        via the rectObj __str__ method:

        >>> r = mapscript.rectObj(0, 0, 1, 1)

        >>> str(r)
        { 'minx': 0 , 'miny': 0 , 'maxx': 1 , 'maxy': 1 }
        """
        return _mapscript.rectObj_toString(self)


    def __str__(self):
        return self.toString()

    def __contains__(self, item):
        item_type = item.__class__.__name__
        if item_type == "pointObj":
            if item.x >= self.minx and item.x <= self.maxx \
            and item.y >= self.miny and item.y <= self.maxy:
                return True
            else:
                return False
        else:
            raise TypeError('__contains__ does not yet handle %s' % (item_type))



# Register rectObj in _mapscript:
_mapscript.rectObj_swigregister(rectObj)
class pointObj(object):
    r"""
    A :class:`pointObj` has an x, y, z and m values.
    A :class:`pointObj` instance may be associated with a :class:`lineObj`.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "double" = property(_mapscript.pointObj_x_get, _mapscript.pointObj_x_set, doc=r"""The x coordinate of the point""")
    y: "double" = property(_mapscript.pointObj_y_get, _mapscript.pointObj_y_set, doc=r"""The y coordinate of the point""")
    z: "double" = property(_mapscript.pointObj_z_get, _mapscript.pointObj_z_set, doc=r"""The z (height) coordinate of the point""")
    m: "double" = property(_mapscript.pointObj_m_get, _mapscript.pointObj_m_set, doc=r"""The m (measure) of the point, used for linear referencing""")

    def __init__(self, x: "double"=0.0, y: "double"=0.0, z: "double"=0.0, m: "double"=-2e38):
        r"""
        Create new instance. Easting, northing, and measure arguments are optional.
        Java pointObj constructors are in java/javaextend.i
        See https://github.com/mapserver/mapserver/issues/1106
        """
        _mapscript.pointObj_swiginit(self, _mapscript.new_pointObj(x, y, z, m))
    __swig_destroy__ = _mapscript.delete_pointObj

    def project(self, *args) -> "int":
        r"""
        *Overload 1:*
        Reproject point from proj_in to proj_out. Transformation is done in place.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`

        |

        *Overload 2:*
        Reproject point given a reprojection object. Transformation is done in place.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.pointObj_project(self, *args)

    def draw(self, map: "mapObj", layer: "layerObj", image: "imageObj", classindex: "int", text: "char *") -> "int":
        r"""
        Draw the point using the styles defined by the classindex class of layer and
        labelled with string text.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.pointObj_draw(self, map, layer, image, classindex, text)

    def distanceToPoint(self, point: "pointObj") -> "double":
        r"""Returns the distance to point."""
        return _mapscript.pointObj_distanceToPoint(self, point)

    def distanceToSegment(self, a: "pointObj", b: "pointObj") -> "double":
        r"""
        Returns the minimum distance to a hypothetical line segment connecting point1
        and point2.
        """
        return _mapscript.pointObj_distanceToSegment(self, a, b)

    def distanceToShape(self, shape: "shapeObj") -> "double":
        r"""Returns the minimum distance to shape."""
        return _mapscript.pointObj_distanceToShape(self, shape)

    def setXY(self, x: "double", y: "double", m: "double"=-2e38) -> "int":
        r"""
        Set spatial coordinate and, optionally, measure values simultaneously.
        The measure will be set only if the value of m is greater than the ESRI measure
        no-data value of -1e38.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.pointObj_setXY(self, x, y, m)

    def setXYZ(self, x: "double", y: "double", z: "double", m: "double"=-2e38) -> "int":
        r"""
        Set spatial coordinate and, optionally, measure values simultaneously.
        The measure will be set only if the value of m is greater than the ESRI measure
        no-data value of -1e38.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.pointObj_setXYZ(self, x, y, z, m)

    def setXYZM(self, x: "double", y: "double", z: "double", m: "double") -> "int":
        r"""
        Set spatial coordinate and, optionally, measure values simultaneously.
        The measure will be set only if the value of m is greater than the ESRI measure
        no-data value of -1e38.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.pointObj_setXYZM(self, x, y, z, m)

    def toString(self) -> "char *":
        r"""
        Return a string formatted like: ``{ 'x': %f , 'y': %f, 'z': %f }``
        with the coordinate values substituted appropriately. Python users can get the same effect
        via the pointObj  __str__ method:

        >>> p = mapscript.pointObj(1, 1)

        >>> str(p)
        { 'x': 1.000000 , 'y': 1.000000, 'z': 1.000000 }
        """
        return _mapscript.pointObj_toString(self)

    def toShape(self) -> "shapeObj *":
        r"""Convert to a new :class:`shapeObj`"""
        return _mapscript.pointObj_toShape(self)


    def __str__(self):
        return self.toString()

    @property
    def __geo_interface__(self):

        if hasattr(self, "z"):
            coords = (self.x, self.y, self.z)
        else:
            coords = (self.x, self.y)

        return {"type": "Point", "coordinates": coords}



# Register pointObj in _mapscript:
_mapscript.pointObj_swigregister(pointObj)
class lineObj(object):
    r"""A :class:`lineObj` is composed of one or more :class:`pointObj` instances"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numpoints: "int" = property(_mapscript.lineObj_numpoints_get, doc=r"""Number of points in the line""")

    def __init__(self):
        r"""A :class:`lineObj` is composed of one or more :class:`pointObj` instances"""
        _mapscript.lineObj_swiginit(self, _mapscript.new_lineObj())
    __swig_destroy__ = _mapscript.delete_lineObj

    def project(self, *args) -> "int":
        r"""
        *Overload 1:*
        Transform line in place from proj_in to proj_out.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`

        |

        *Overload 2:*
        Reproject line given a reprojection object. Transformation is done in place.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.lineObj_project(self, *args)

    def get(self, i: "int") -> "pointObj *":
        r"""Return reference to point at index *i*."""
        return _mapscript.lineObj_get(self, i)

    def add(self, p: "pointObj") -> "int":
        r"""
        Add point *p* to the line.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.lineObj_add(self, p)

    def set(self, i: "int", p: "pointObj") -> "int":
        r"""
        Set the point at index *i* to point *p*.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.lineObj_set(self, i, p)


    @property
    def __geo_interface__(self):

        coords = []

        for idx in range(0, self.numpoints):
            pt = self.get(idx)
            geom = pt.__geo_interface__
            coords.append(geom["coordinates"])

        return {"type": "LineString", "coordinates": coords}



# Register lineObj in _mapscript:
_mapscript.lineObj_swigregister(lineObj)
class shapeObj(object):
    r"""
    Each feature of a layer's data is a :class:`shapeObj`. Each part of the shape is
    a closed :class:`lineObj`.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numlines: "int" = property(_mapscript.shapeObj_numlines_get, doc=r"""Number of parts""")
    numvalues: "int" = property(_mapscript.shapeObj_numvalues_get, doc=r"""Number of shape attributes""")
    bounds: "rectObj" = property(_mapscript.shapeObj_bounds_get, _mapscript.shapeObj_bounds_set, doc=r"""Bounding box of shape""")
    type: "int" = property(_mapscript.shapeObj_type_get, _mapscript.shapeObj_type_set, doc=r"""
    MS_SHAPE_POINT, MS_SHAPE_LINE, MS_SHAPE_POLYGON, or
    MS_SHAPE_NULL
    """)
    index: "long" = property(_mapscript.shapeObj_index_get, _mapscript.shapeObj_index_set, doc=r"""Feature index within the layer""")
    tileindex: "int" = property(_mapscript.shapeObj_tileindex_get, _mapscript.shapeObj_tileindex_set, doc=r"""Index of tiled file for tile-indexed layers""")
    classindex: "int" = property(_mapscript.shapeObj_classindex_get, _mapscript.shapeObj_classindex_set, doc=r"""The class index for features of a classified layer""")
    text: "char *" = property(_mapscript.shapeObj_text_get, _mapscript.shapeObj_text_set, doc=r"""Shape annotation""")
    scratch: "int" = property(_mapscript.shapeObj_scratch_get, _mapscript.shapeObj_scratch_set)
    resultindex: "int" = property(_mapscript.shapeObj_resultindex_get, _mapscript.shapeObj_resultindex_set, doc=r"""Index within a query result set""")

    def __init__(self, type: "int"=MS_SHAPE_NULL):
        r"""
        Return a new shapeObj of the specified type. See the type attribute.
        No attribute values created by default.
        initValues should be explicitly called to create the required number of values.
        Each feature of a layer's data is a shapeObj. Each part of the shape is a
        closed :class:`lineObj`
        """
        _mapscript.shapeObj_swiginit(self, _mapscript.new_shapeObj(type))
    __swig_destroy__ = _mapscript.delete_shapeObj

    @staticmethod
    def fromWKT(wkt: "char *") -> "shapeObj *":
        r"""
        Returns a new shapeObj based on a well-known text representation of a geometry.
        Requires GEOS support. Returns NULL/undef on failure.
        """
        return _mapscript.shapeObj_fromWKT(wkt)

    def project(self, *args) -> "int":
        r"""
        *Overload 1:*
        Reproject shape from proj_in to proj_out. Transformation is done in place.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`

        |

        *Overload 2:*
        Reproject shape given a reprojection object. Transformation is done in place.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.shapeObj_project(self, *args)

    def get(self, i: "int") -> "lineObj *":
        r"""
        Returns a reference to part at index. Reference is valid only during
        the life of the shapeObj.
        """
        return _mapscript.shapeObj_get(self, i)

    def add(self, line: "lineObj") -> "int":
        r"""
        Add line (i.e. a part) to the shape.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.shapeObj_add(self, line)

    def draw(self, map: "mapObj", layer: "layerObj", image: "imageObj") -> "int":
        r"""
        Draws the individual shape using layer.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.shapeObj_draw(self, map, layer, image)

    def setBounds(self) -> "void":
        r"""
        Must be called to calculate new bounding box after new parts have been added.
        TODO: should return int and set msSetError.
        """
        return _mapscript.shapeObj_setBounds(self)

    def clone(self) -> "shapeObj *":
        r"""
        Return an independent copy of the shape.

        .. note::

            In the Java & PHP modules this method is named ``cloneShape``.
        """
        return _mapscript.shapeObj_clone(self)

    def copy(self, dest: "shapeObj") -> "int":
        r"""
        Copy the shape to shape_copy.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.shapeObj_copy(self, dest)

    def toWKT(self) -> "char *":
        r"""
        Returns the well - known text representation of a shapeObj.
        Requires GEOS support.Returns NULL / undefined on failure.
        """
        return _mapscript.shapeObj_toWKT(self)

    def buffer(self, width: "double") -> "shapeObj *":
        r"""
        Returns a new buffered shapeObj based on the supplied distance
        (given in the coordinates of the existing shapeObj).
        Requires GEOS support. Returns NULL/undefined on failure.
        """
        return _mapscript.shapeObj_buffer(self, width)

    def simplify(self, tolerance: "double") -> "shapeObj *":
        r"""
        Given a tolerance, returns a simplified shape object or NULL on error.
        Requires GEOS support (>=3.0).
        """
        return _mapscript.shapeObj_simplify(self, tolerance)

    def topologyPreservingSimplify(self, tolerance: "double") -> "shapeObj *":
        r"""
        Given a tolerance, returns a simplified shape object or NULL on error.
        Requires GEOS support (>=3.0).
        """
        return _mapscript.shapeObj_topologyPreservingSimplify(self, tolerance)

    def convexHull(self) -> "shapeObj *":
        r"""
        Returns the convex hull of the existing shape.
        Requires GEOS support. Returns NULL/undef on failure.
        """
        return _mapscript.shapeObj_convexHull(self)

    def boundary(self) -> "shapeObj *":
        r"""
        Returns the boundary of the existing shape.
        Requires GEOS support. Returns NULL/undef on failure.
        """
        return _mapscript.shapeObj_boundary(self)

    def getCentroid(self) -> "pointObj *":
        r"""
        Returns the centroid for the existing shape.
        Requires GEOS support. Returns NULL/undef on failure.
        """
        return _mapscript.shapeObj_getCentroid(self)

    def Union(self, shape: "shapeObj") -> "shapeObj *":
        r"""
        Returns the union of the existing and supplied shape.
        Shapes must be of the same type.
        Requires GEOS support. Returns NULL/undef on failure.
        """
        return _mapscript.shapeObj_Union(self, shape)

    def intersection(self, shape: "shapeObj") -> "shapeObj *":
        r"""
        Returns the computed intersection of the supplied and existing shape.
        Requires GEOS support. Returns NULL/undef on failure.
        """
        return _mapscript.shapeObj_intersection(self, shape)

    def difference(self, shape: "shapeObj") -> "shapeObj *":
        r"""
        Returns the computed difference of the supplied and existing shape.
        Requires GEOS support. Returns NULL/undef on failure.
        """
        return _mapscript.shapeObj_difference(self, shape)

    def symDifference(self, shape: "shapeObj") -> "shapeObj *":
        r"""
        Returns the computed symmetric difference of the supplied and existing shape.
        Requires GEOS support. Returns NULL/undef on failure.
        """
        return _mapscript.shapeObj_symDifference(self, shape)

    def overlaps(self, shape: "shapeObj") -> "int":
        r"""
        Returns :data:`MS_TRUE` if shape2 overlaps shape, returns -1 on error and :data:`MS_FALSE` otherwise.
        Requires GEOS support.
        """
        return _mapscript.shapeObj_overlaps(self, shape)

    def within(self, shape: "shapeObj") -> "int":
        r"""
        Returns :data:`MS_TRUE` if shape is entirely within shape2, returns -1 on error and :data:`MS_FALSE` otherwise.
        Requires GEOS support.
        """
        return _mapscript.shapeObj_within(self, shape)

    def crosses(self, shape: "shapeObj") -> "int":
        r"""
        Returns :data:`MS_TRUE` if shape2 crosses the shape, returns -1 on error and :data:`MS_FALSE` otherwise.
        Requires GEOS support.
        """
        return _mapscript.shapeObj_crosses(self, shape)

    def intersects(self, shape: "shapeObj") -> "int":
        r"""
        Returns :data:`MS_TRUE` if shape and shape2 intersect, and :data:`MS_FALSE` otherwise.
        Does not require GEOS support but will use GEOS functions if available.
        """
        return _mapscript.shapeObj_intersects(self, shape)

    def touches(self, shape: "shapeObj") -> "int":
        r"""
        Returns :data:`MS_TRUE` if shape and shape2 touch, returns -1 on error and :data:`MS_FALSE` otherwise.
        Requires GEOS support.
        """
        return _mapscript.shapeObj_touches(self, shape)

    def equals(self, shape: "shapeObj") -> "int":
        r"""
        Returns :data:`MS_TRUE` if shape and shape2 are equal (geometry only), returns -1 on error and :data:`MS_FALSE` otherwise.
        Requires GEOS support.
        """
        return _mapscript.shapeObj_equals(self, shape)

    def disjoint(self, shape: "shapeObj") -> "int":
        r"""
        Returns :data:`MS_TRUE` if shape and shape2 are disjoint, returns -1 on error and :data:`MS_FALSE` otherwise.
        Requires GEOS support.
        """
        return _mapscript.shapeObj_disjoint(self, shape)

    def getArea(self) -> "double":
        r"""Returns the area of the shape (if applicable). Requires GEOS support."""
        return _mapscript.shapeObj_getArea(self)

    def getLength(self) -> "double":
        r"""Returns the length (or perimeter) of the shape. Requires GEOS support."""
        return _mapscript.shapeObj_getLength(self)

    def getValue(self, i: "int") -> "char *":
        r"""Return the shape attribute at index i."""
        return _mapscript.shapeObj_getValue(self, i)

    def contains(self, *args) -> "int":
        r"""
        *Overload 1:*
        Returns :data:`MS_TRUE` if shape2 is entirely inside the shape, returns -1 on error and :data:`MS_FALSE` otherwise.
        Requires GEOS support.

        |

        *Overload 2:*
        Returns :data:`MS_TRUE` if the point is inside the shape, :data:`MS_FALSE` otherwise
        """
        return _mapscript.shapeObj_contains(self, *args)

    def distanceToPoint(self, point: "pointObj") -> "double":
        r"""Returns the distance to point."""
        return _mapscript.shapeObj_distanceToPoint(self, point)

    def distanceToShape(self, shape: "shapeObj") -> "double":
        r"""Returns the minimum distance to shape."""
        return _mapscript.shapeObj_distanceToShape(self, shape)

    def getLabelPoint(self) -> "pointObj *":
        r"""Given a shape, return a point object suitable for labeling it."""
        return _mapscript.shapeObj_getLabelPoint(self)

    def setValue(self, i: "int", value: "char *") -> "int":
        r"""Set the shape value at index i to value."""
        return _mapscript.shapeObj_setValue(self, i, value)

    def initValues(self, numvalues: "int") -> "void":
        r"""Allocates memory for the requested number of values."""
        return _mapscript.shapeObj_initValues(self, numvalues)


    def _convert_item_values(self, property_values, property_types):
        """
        **Python MapScript only**

        Convert an item value, which is always stored as a string, into a
        Python type, based on an attributes GML metadata type. These can be one
        of the following:

        ``Integer|Long|Real|Character|Date|Boolean``
        """

        typed_values = []

        for value, type_ in zip(property_values, property_types):
            try:
                if type_.lower() == "integer":
                    value = int(value)
                elif type_.lower() == "long":
                    value = long(value)
                elif type_.lower() == "real":
                    value = float(value)
                else:
                    pass
            except ValueError:
                pass

            typed_values.append(value)

        return typed_values

    @property
    def __geo_interface__(self):

        bounds = self.bounds
        ms_geom_type = self.type

    # see https://tools.ietf.org/html/rfc7946 for GeoJSON types

        if ms_geom_type == MS_SHAPE_POINT or ms_geom_type == MS_SHP_POINTZ or ms_geom_type == MS_SHP_POINTM:
            geom_type = "Point"
        elif ms_geom_type == MS_SHP_MULTIPOINTZ or ms_geom_type == MS_SHP_MULTIPOINTM:
            geom_type = "MultiPoint"
        elif ms_geom_type == MS_SHAPE_LINE or ms_geom_type == MS_SHP_ARCZ or ms_geom_type == MS_SHP_ARCM:
            if self.numlines == 1:
                geom_type = "LineString"
            else:
                geom_type = "MultiLineString"
        elif ms_geom_type == MS_SHAPE_POLYGON or ms_geom_type == MS_SHP_POLYGONZ or ms_geom_type == MS_SHP_POLYGONM:
            if self.numlines == 1:
                geom_type = "Polygon"
            else:
                geom_type = "MultiPolygon"
        elif ms_geom_type == MS_SHAPE_NULL:
            return None
        else:
            raise TypeError("Shape type {} not supported".format(geom_type))

        properties = {}
        coords = []

    # property names are stored at the layer level
    # https://github.com/mapserver/mapserver/issues/130

        property_values = [self.getValue(idx) for idx in range(0, self.numvalues)]

        if hasattr(self, "_item_definitions"):
            property_names, property_types = zip(*self._item_definitions)
            property_values = self._convert_item_values(property_values, property_types)
        else:
            property_names = [str(idx) for idx in range(0, self.numvalues)]

        properties = dict(zip(property_names, property_values))

        for idx in range(0, self.numlines):
            line = self.get(idx)
            geom = line.__geo_interface__
            coords.append(geom["coordinates"])

        return {
                "type": "Feature",
                "bbox": (bounds.minx, bounds.miny, bounds.maxx, bounds.maxy),
                "properties": properties,
                "geometry": {
                    "type": geom_type,
                    "coordinates": coords
                    }
                }

    @property
    def itemdefinitions(self):
        return self._item_definitions

    @itemdefinitions.setter
    def itemdefinitions(self, item_definitions):
        self._item_definitions = item_definitions



# Register shapeObj in _mapscript:
_mapscript.shapeObj_swigregister(shapeObj)
MS_NOERR = _mapscript.MS_NOERR
MS_IOERR = _mapscript.MS_IOERR
MS_MEMERR = _mapscript.MS_MEMERR
MS_TYPEERR = _mapscript.MS_TYPEERR
MS_SYMERR = _mapscript.MS_SYMERR
MS_REGEXERR = _mapscript.MS_REGEXERR
MS_TTFERR = _mapscript.MS_TTFERR
MS_DBFERR = _mapscript.MS_DBFERR
MS_IDENTERR = _mapscript.MS_IDENTERR
MS_EOFERR = _mapscript.MS_EOFERR
MS_PROJERR = _mapscript.MS_PROJERR
MS_MISCERR = _mapscript.MS_MISCERR
MS_CGIERR = _mapscript.MS_CGIERR
MS_WEBERR = _mapscript.MS_WEBERR
MS_IMGERR = _mapscript.MS_IMGERR
MS_HASHERR = _mapscript.MS_HASHERR
MS_JOINERR = _mapscript.MS_JOINERR
MS_NOTFOUND = _mapscript.MS_NOTFOUND
MS_SHPERR = _mapscript.MS_SHPERR
MS_PARSEERR = _mapscript.MS_PARSEERR
MS_UNUSEDERR = _mapscript.MS_UNUSEDERR
MS_OGRERR = _mapscript.MS_OGRERR
MS_QUERYERR = _mapscript.MS_QUERYERR
MS_WMSERR = _mapscript.MS_WMSERR
MS_WMSCONNERR = _mapscript.MS_WMSCONNERR
MS_ORACLESPATIALERR = _mapscript.MS_ORACLESPATIALERR
MS_WFSERR = _mapscript.MS_WFSERR
MS_WFSCONNERR = _mapscript.MS_WFSCONNERR
MS_MAPCONTEXTERR = _mapscript.MS_MAPCONTEXTERR
MS_HTTPERR = _mapscript.MS_HTTPERR
MS_CHILDERR = _mapscript.MS_CHILDERR
MS_WCSERR = _mapscript.MS_WCSERR
MS_GEOSERR = _mapscript.MS_GEOSERR
MS_RECTERR = _mapscript.MS_RECTERR
MS_TIMEERR = _mapscript.MS_TIMEERR
MS_GMLERR = _mapscript.MS_GMLERR
MS_SOSERR = _mapscript.MS_SOSERR
MS_NULLPARENTERR = _mapscript.MS_NULLPARENTERR
MS_AGGERR = _mapscript.MS_AGGERR
MS_OWSERR = _mapscript.MS_OWSERR
MS_OGLERR = _mapscript.MS_OGLERR
MS_RENDERERERR = _mapscript.MS_RENDERERERR
MS_V8ERR = _mapscript.MS_V8ERR
MS_OGCAPIERR = _mapscript.MS_OGCAPIERR
MS_FGBERR = _mapscript.MS_FGBERR
MS_NUMERRORCODES = _mapscript.MS_NUMERRORCODES
MESSAGELENGTH = _mapscript.MESSAGELENGTH
ROUTINELENGTH = _mapscript.ROUTINELENGTH
HTTPSTATUSLENGTH = _mapscript.HTTPSTATUSLENGTH
MS_ERROR_LANGUAGE = _mapscript.MS_ERROR_LANGUAGE
MS_HTTP_400_BAD_REQUEST = _mapscript.MS_HTTP_400_BAD_REQUEST
MS_HTTP_500_INTERNAL_SERVER_ERROR = _mapscript.MS_HTTP_500_INTERNAL_SERVER_ERROR
class errorObj(object):
    r"""
    This class allows inspection of the MapServer error stack.
    Instances of errorObj are created internally by MapServer as errors happen.
    Errors are managed as a chained list with the first item being the most recent
    error.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code: "int" = property(_mapscript.errorObj_code_get, _mapscript.errorObj_code_set, doc=r"""MapServer error code such as :data:`MS_IMGERR`""")
    routine: "char [64]" = property(_mapscript.errorObj_routine_get, _mapscript.errorObj_routine_set, doc=r"""MapServer function in which the error was set""")
    message: "char [2048]" = property(_mapscript.errorObj_message_get, _mapscript.errorObj_message_set, doc=r"""Context-dependent error message""")
    http_status: "char [128]" = property(_mapscript.errorObj_http_status_get, _mapscript.errorObj_http_status_set)
    isreported: "int" = property(_mapscript.errorObj_isreported_get, _mapscript.errorObj_isreported_set, doc=r"""
    :data:`MS_TRUE` or :data:`MS_FALSE` flag indicating if
    the error has been output
    """)
    errorcount: "int" = property(_mapscript.errorObj_errorcount_get, _mapscript.errorObj_errorcount_set, doc=r"""Number of subsequent errors""")

    def __init__(self):
        r"""Create a new instance"""
        _mapscript.errorObj_swiginit(self, _mapscript.new_errorObj())
    __swig_destroy__ = _mapscript.delete_errorObj

    def next(self) -> "errorObj *":
        r"""Returns the next error in the stack or NULL if the end has been reached"""
        return _mapscript.errorObj_next(self)

# Register errorObj in _mapscript:
_mapscript.errorObj_swigregister(errorObj)

def msGetErrorObj() -> "errorObj *":
    r"""Get the MapServer error object"""
    return _mapscript.msGetErrorObj()

def msResetErrorList() -> "void":
    r"""Clear the list of error objects"""
    return _mapscript.msResetErrorList()

def msGetVersion() -> "char *":
    r"""
    Returns a string containing MapServer version information, and details on what
    optional components are built in - the same report as produced by ``mapserv -v``
    """
    return _mapscript.msGetVersion()

def msGetVersionInt() -> "int":
    r"""
    Returns the MapServer version number (x.y.z) as an integer (x*10000 + y*100 + z)
    e.g. V7.4.2 would return 70402
    """
    return _mapscript.msGetVersionInt()

def msGetErrorString(delimiter: "char const *") -> "char *":
    r"""Return a string of all errors"""
    return _mapscript.msGetErrorString(delimiter)
MS_DEBUGLEVEL_ERRORSONLY = _mapscript.MS_DEBUGLEVEL_ERRORSONLY
MS_DEBUGLEVEL_DEBUG = _mapscript.MS_DEBUGLEVEL_DEBUG
MS_DEBUGLEVEL_TUNING = _mapscript.MS_DEBUGLEVEL_TUNING
MS_DEBUGLEVEL_V = _mapscript.MS_DEBUGLEVEL_V
MS_DEBUGLEVEL_VV = _mapscript.MS_DEBUGLEVEL_VV
MS_DEBUGLEVEL_VVV = _mapscript.MS_DEBUGLEVEL_VVV
MS_DEBUGLEVEL_DEVDEBUG = _mapscript.MS_DEBUGLEVEL_DEVDEBUG
SHX_BUFFER_PAGE = _mapscript.SHX_BUFFER_PAGE
MS_SHAPEFILE_POINT = _mapscript.MS_SHAPEFILE_POINT
MS_SHAPEFILE_ARC = _mapscript.MS_SHAPEFILE_ARC
MS_SHAPEFILE_POLYGON = _mapscript.MS_SHAPEFILE_POLYGON
MS_SHAPEFILE_MULTIPOINT = _mapscript.MS_SHAPEFILE_MULTIPOINT
MS_SHP_POINTZ = _mapscript.MS_SHP_POINTZ
MS_SHP_ARCZ = _mapscript.MS_SHP_ARCZ
MS_SHP_POLYGONZ = _mapscript.MS_SHP_POLYGONZ
MS_SHP_MULTIPOINTZ = _mapscript.MS_SHP_MULTIPOINTZ
MS_SHP_POINTM = _mapscript.MS_SHP_POINTM
MS_SHP_ARCM = _mapscript.MS_SHP_ARCM
MS_SHP_POLYGONM = _mapscript.MS_SHP_POLYGONM
MS_SHP_MULTIPOINTM = _mapscript.MS_SHP_MULTIPOINTM
class DBFInfo(object):
    r"""An object containing information about a DBF file"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nRecords: "int" = property(_mapscript.DBFInfo_nRecords_get, doc=r"""Number of records in the DBF""")
    nFields: "int" = property(_mapscript.DBFInfo_nFields_get, doc=r"""Number of fields in the DBF""")

    def getFieldName(self, iField: "int") -> "char *":
        r"""Get the field name of a DBF using the field index ``iField``"""
        return _mapscript.DBFInfo_getFieldName(self, iField)

    def getFieldWidth(self, iField: "int") -> "int":
        r"""Get the field width of a DBF using the field index ``iField``"""
        return _mapscript.DBFInfo_getFieldWidth(self, iField)

    def getFieldDecimals(self, iField: "int") -> "int":
        r"""Get the field decimals of a DBF using the field index ``iField``"""
        return _mapscript.DBFInfo_getFieldDecimals(self, iField)

    def getFieldType(self, iField: "int") -> "int":
        r"""
        Get the field type of a DBF using the field index ``iField``.
        Field types are one of FTString, FTInteger, FTDouble, FTInvalid
        """
        return _mapscript.DBFInfo_getFieldType(self, iField)

    def __init__(self):
        _mapscript.DBFInfo_swiginit(self, _mapscript.new_DBFInfo())
    __swig_destroy__ = _mapscript.delete_DBFInfo

# Register DBFInfo in _mapscript:
_mapscript.DBFInfo_swigregister(DBFInfo)
FTString = _mapscript.FTString
FTInteger = _mapscript.FTInteger
FTDouble = _mapscript.FTDouble
FTInvalid = _mapscript.FTInvalid
class shapefileObj(object):
    r"""
    An object representing a Shapefile. There is no write access to this object
    using MapScript.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type: "int" = property(_mapscript.shapefileObj_type_get, doc=r"""Shapefile type - see mapshape.h for values of type""")
    numshapes: "int" = property(_mapscript.shapefileObj_numshapes_get, doc=r"""Number of shapes""")
    bounds: "rectObj" = property(_mapscript.shapefileObj_bounds_get, doc=r"""Extent of shapes""")

    def __init__(self, filename: "char *", type: "int"=-1):
        r"""
        Create a new instance. Omit the type argument or use a value of -1 to open
        an existing shapefile.

        Type should be one of :data:`MS_SHAPEFILE_POINT`, :data:`MS_SHAPEFILE_ARC`,
        :data:`MS_SHAPEFILE_POLYGON` or :data:`MS_SHAPEFILE_MULTIPOINT`
        """
        _mapscript.shapefileObj_swiginit(self, _mapscript.new_shapefileObj(filename, type))
    __swig_destroy__ = _mapscript.delete_shapefileObj

    def get(self, i: "int", shape: "shapeObj") -> "int":
        r"""
        Get the shapefile feature from index i and store it in shape.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.shapefileObj_get(self, i, shape)

    def getShape(self, i: "int") -> "shapeObj *":
        r"""Returns the shapefile feature at index i. More efficient than get."""
        return _mapscript.shapefileObj_getShape(self, i)

    def getPoint(self, i: "int", point: "pointObj") -> "int":
        r"""Returns the point feature at index i and store it in pointObj."""
        return _mapscript.shapefileObj_getPoint(self, i, point)

    def getTransformed(self, map: "mapObj", i: "int", shape: "shapeObj") -> "int":
        r"""
        Returns the feature at index i, simplify it, and store it in shape. Uses the
        map extent and cellsize for simplification.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.shapefileObj_getTransformed(self, map, i, shape)

    def getExtent(self, i: "int", rect: "rectObj") -> "void":
        r"""Retrieve a shape's bounding box by index and stores it in rect."""
        return _mapscript.shapefileObj_getExtent(self, i, rect)

    def add(self, shape: "shapeObj") -> "int":
        r"""
        Appends a shape to the open shapefile.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.shapefileObj_add(self, shape)

    def addPoint(self, point: "pointObj") -> "int":
        r"""
        Appends a point to the open shapefile.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.shapefileObj_addPoint(self, point)

    def getDBF(self) -> "DBFInfo *":
        r"""Returns a :class:`DBFInfo` object containing information on the associated DBF"""
        return _mapscript.shapefileObj_getDBF(self)

# Register shapefileObj in _mapscript:
_mapscript.shapefileObj_swigregister(shapefileObj)
wkp_none = _mapscript.wkp_none
wkp_lonlat = _mapscript.wkp_lonlat
wkp_gmerc = _mapscript.wkp_gmerc
class projectionObj(object):
    r"""
    The :ref:`PROJECTION <projection>` object
    MapServer's Maps and Layers have Projection attributes, and these are C
    projectionObj structures, but are not directly exposed by the mapscript module
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numargs: "int" = property(_mapscript.projectionObj_numargs_get, doc=r"""Actual number of projection args""")
    generation_number: "unsigned short" = property(_mapscript.projectionObj_generation_number_get, doc=r"""
    To be incremented when the content of the object
    changes, so that a reprojector can be invalidated
    """)
    wellknownprojection: "int" = property(_mapscript.projectionObj_wellknownprojection_get, _mapscript.projectionObj_wellknownprojection_set, doc=r"""
    One of ``wkp_none 0``, ``wkp_lonlat 1``, or
    ``wkp_gmerc 2``
    """)

    def __init__(self, proj4: "char *"):
        r"""
        Create new instance of projectionObj. Input parameter proj4 is a
        PROJ definition string such as 'init=EPSG:4269'
        """
        _mapscript.projectionObj_swiginit(self, _mapscript.new_projectionObj(proj4))
    __swig_destroy__ = _mapscript.delete_projectionObj

    def setWKTProjection(self, wkt: "char *") -> "int":
        r"""
        Update the projectionObj using an OGC WKT definition
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.projectionObj_setWKTProjection(self, wkt)

    def getUnits(self) -> "int":
        r"""Returns the units of a projection object. Returns -1 on error."""
        return _mapscript.projectionObj_getUnits(self)

# Register projectionObj in _mapscript:
_mapscript.projectionObj_swigregister(projectionObj)
class reprojectionObj(object):
    r"""
    A holder object for projection coordinate transformations, introduced in RFC
    126. This allows caching of reprojections improving performance.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generation_number_in: "unsigned short" = property(_mapscript.reprojectionObj_generation_number_in_get, _mapscript.reprojectionObj_generation_number_in_set, doc=r"""
    A counter that is incremented when
    the input projectionObj changes
    """)
    generation_number_out: "unsigned short" = property(_mapscript.reprojectionObj_generation_number_out_get, _mapscript.reprojectionObj_generation_number_out_set, doc=r"""
    A counter that is incremented when
    the output projectionObj changes
    """)

    def __init__(self, _in: "projectionObj", out: "projectionObj"):
        r"""Create new instance of reprojectionObj. Input parameters are two projectionsObj's - in and out."""
        _mapscript.reprojectionObj_swiginit(self, _mapscript.new_reprojectionObj(_in, out))
    __swig_destroy__ = _mapscript.delete_reprojectionObj

# Register reprojectionObj in _mapscript:
_mapscript.reprojectionObj_swigregister(reprojectionObj)
MS_SYMBOL_SIMPLE = _mapscript.MS_SYMBOL_SIMPLE
MS_SYMBOL_VECTOR = _mapscript.MS_SYMBOL_VECTOR
MS_SYMBOL_ELLIPSE = _mapscript.MS_SYMBOL_ELLIPSE
MS_SYMBOL_PIXMAP = _mapscript.MS_SYMBOL_PIXMAP
MS_SYMBOL_TRUETYPE = _mapscript.MS_SYMBOL_TRUETYPE
MS_SYMBOL_HATCH = _mapscript.MS_SYMBOL_HATCH
MS_SYMBOL_SVG = _mapscript.MS_SYMBOL_SVG
MS_SYMBOL_ALLOCSIZE = _mapscript.MS_SYMBOL_ALLOCSIZE
MS_MAXVECTORPOINTS = _mapscript.MS_MAXVECTORPOINTS
MS_MAXPATTERNLENGTH = _mapscript.MS_MAXPATTERNLENGTH
MS_IMAGECACHESIZE = _mapscript.MS_IMAGECACHESIZE
class colorObj(object):
    r"""An object representing a color."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    red: "int" = property(_mapscript.colorObj_red_get, _mapscript.colorObj_red_set, doc=r"""Red component of color in range [0-255]""")
    green: "int" = property(_mapscript.colorObj_green_get, _mapscript.colorObj_green_set, doc=r"""Green component of color in range [0-255]""")
    blue: "int" = property(_mapscript.colorObj_blue_get, _mapscript.colorObj_blue_set, doc=r"""Blue component of color in range [0-255]""")
    alpha: "int" = property(_mapscript.colorObj_alpha_get, _mapscript.colorObj_alpha_set, doc=r"""Alpha (opacity) component of color in range [0-255]""")

    def __init__(self, red: "int"=0, green: "int"=0, blue: "int"=0, alpha: "int"=255):
        r"""An object representing a color."""
        _mapscript.colorObj_swiginit(self, _mapscript.new_colorObj(red, green, blue, alpha))
    __swig_destroy__ = _mapscript.delete_colorObj

    def setRGB(self, red: "int", green: "int", blue: "int", alpha: "int"=255) -> "int":
        r"""Set all four RGBA components. Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`"""
        return _mapscript.colorObj_setRGB(self, red, green, blue, alpha)

    def setHex(self, psHexColor: "char *") -> "int":
        r"""
        Set the color to values specified in case-independent hexadecimal notation.
        hex must start with a '#' followed by three or four hex bytes, e.g. '#ffffff'
        or '#ffffffff'. If only three hex bytes are supplied, the alpha will be set
        to 255. Calling setHex('#ffffff') therefore assigns values of 255 to each
        color component, including the alpha.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.colorObj_setHex(self, psHexColor)

    def toHex(self) -> "char *":
        r"""
        Complement to setHex, returning a hexadecimal representation of the color
        components. If alpha is 255 then this is three hex bytes '#rrggbb',
        otherwise four hex bytes '#rrggbbaa'
        """
        return _mapscript.colorObj_toHex(self)

# Register colorObj in _mapscript:
_mapscript.colorObj_swigregister(colorObj)
class symbolObj(object):
    r"""The :ref:`SYMBOL <symbol>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refcount: "int" = property(_mapscript.symbolObj_refcount_get, doc=r"""Reference counter""")
    numpoints: "int" = property(_mapscript.symbolObj_numpoints_get, doc=r"""Number of points of a vector symbol""")
    imagepath: "char *" = property(_mapscript.symbolObj_imagepath_get, doc=r"""
    Path to pixmap file - see :ref:`IMAGE
    <mapfile-symbol-image>`
    """)
    name: "char *" = property(_mapscript.symbolObj_name_get, _mapscript.symbolObj_name_set, doc=r"""Symbol name - see :ref:`NAME <mapfile-symbol-name>`""")
    type: "int" = property(_mapscript.symbolObj_type_get, _mapscript.symbolObj_type_set, doc=r"""See :ref:`TYPE <mapfile-symbol-type>`""")
    inmapfile: "int" = property(_mapscript.symbolObj_inmapfile_get, _mapscript.symbolObj_inmapfile_set, doc=r"""
    Boolean value for writing - if set to :data:`TRUE`, the
    symbol will be saved inside the Mapfile. Added in
    MapServer 5.6.1
    """)
    sizex: "double" = property(_mapscript.symbolObj_sizex_get, _mapscript.symbolObj_sizex_set, doc=r""":data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option""")
    sizey: "double" = property(_mapscript.symbolObj_sizey_get, _mapscript.symbolObj_sizey_set, doc=r""":data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option""")
    minx: "double" = property(_mapscript.symbolObj_minx_get, _mapscript.symbolObj_minx_set, doc=r""":data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option""")
    miny: "double" = property(_mapscript.symbolObj_miny_get, _mapscript.symbolObj_miny_set, doc=r""":data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option""")
    maxx: "double" = property(_mapscript.symbolObj_maxx_get, _mapscript.symbolObj_maxx_set, doc=r""":data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option""")
    maxy: "double" = property(_mapscript.symbolObj_maxy_get, _mapscript.symbolObj_maxy_set, doc=r""":data:`MS_SYMBOL_VECTOR` and :data:`MS_SYMBOL_ELLIPSE` option""")
    filled: "int" = property(_mapscript.symbolObj_filled_get, _mapscript.symbolObj_filled_set, doc=r"""
    :data:`MS_TRUE` or :data:`MS_FALSE` - see :ref:`FILLED
    <mapfile-symbol-filled>`
    """)
    anchorpoint_x: "double" = property(_mapscript.symbolObj_anchorpoint_x_get, _mapscript.symbolObj_anchorpoint_x_set, doc=r"""See :ref:`ANCHORPOINT <mapfile-symbol-anchorpoint>`""")
    anchorpoint_y: "double" = property(_mapscript.symbolObj_anchorpoint_y_get, _mapscript.symbolObj_anchorpoint_y_set, doc=r"""See :ref:`ANCHORPOINT <mapfile-symbol-anchorpoint>`""")
    transparent: "int" = property(_mapscript.symbolObj_transparent_get, _mapscript.symbolObj_transparent_set, doc=r"""**TODO** Remove""")
    transparentcolor: "int" = property(_mapscript.symbolObj_transparentcolor_get, _mapscript.symbolObj_transparentcolor_set, doc=r"""**TODO** Remove""")
    character: "char *" = property(_mapscript.symbolObj_character_get, _mapscript.symbolObj_character_set, doc=r"""
    For TrueType symbols - see :ref:`CHARACTER
    <mapfile-symbol-character>`
    """)
    font: "char *" = property(_mapscript.symbolObj_font_get, _mapscript.symbolObj_font_set, doc=r"""For TrueType symbols - see :ref:`FONT <mapfile-symbol-font>`""")

    def __init__(self, symbolname: "char *", imagefile: "char const *"=None):
        r"""
        Create new default :class:`symbolObj` named ``symbolname``. If ``imagefile`` is specified, then the symbol
        will be of type :data:`MS_SYMBOL_PIXMAP`.
        """
        _mapscript.symbolObj_swiginit(self, _mapscript.new_symbolObj(symbolname, imagefile))
    __swig_destroy__ = _mapscript.delete_symbolObj

    def setImagepath(self, imagefile: "char const *") -> "int":
        r"""
        Sets the ``imagefile`` path for a :data:`MS_SYMBOL_PIXMAP`.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.symbolObj_setImagepath(self, imagefile)

    def setPoints(self, line: "lineObj") -> "int":
        r"""Sets the symbol points from the points of line. Returns the updated number of points."""
        return _mapscript.symbolObj_setPoints(self, line)

    def getPoints(self) -> "lineObj *":
        r"""Returns the symbol points as a :class:`lineObj`."""
        return _mapscript.symbolObj_getPoints(self)

    def getImage(self, input_format: "outputFormatObj") -> "imageObj *":
        r"""Returns a pixmap symbol's imagery as an :class:`imageObj`."""
        return _mapscript.symbolObj_getImage(self, input_format)

    def setImage(self, image: "imageObj") -> "int":
        r"""
        Set a pixmap symbol's imagery from image.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.symbolObj_setImage(self, image)

# Register symbolObj in _mapscript:
_mapscript.symbolObj_swigregister(symbolObj)
MS_HASHSIZE = _mapscript.MS_HASHSIZE
class hashTableObj(object):
    r"""An object to store key-value pairs"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    numitems: "int" = property(_mapscript.hashTableObj_numitems_get, doc=r"""**immutable** number of items""")

    def __init__(self):
        r"""Create a new instance"""
        _mapscript.hashTableObj_swiginit(self, _mapscript.new_hashTableObj())
    __swig_destroy__ = _mapscript.delete_hashTableObj

    def set(self, key: "char *", value: "char *") -> "int":
        r"""
        Set a hash item given key and value.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.hashTableObj_set(self, key, value)

    def get(self, key: "char *", default_value: "char *"=None) -> "char *":
        r"""Returns the value of the item by its key, or default if the key does not exist"""
        return _mapscript.hashTableObj_get(self, key, default_value)

    def remove(self, key: "char *") -> "int":
        r"""
        Removes the hash item by its key.
        Returns :data:`MS_SUCCESS` or :data:`MS_FAILURE`
        """
        return _mapscript.hashTableObj_remove(self, key)

    def clear(self) -> "void":
        r"""Empties the table of all items"""
        return _mapscript.hashTableObj_clear(self)

    def nextKey(self, prevkey: "char *"=None) -> "char const *":
        r"""
        Returns the name of the next key or NULL if there is no valid next key.
        If the input key is NULL, returns the first key
        """
        return _mapscript.hashTableObj_nextKey(self, prevkey)


    def __getitem__(self, key):
        return self.get(key)

    def __setitem__(self, key, value):
        return self.set(key, value)

    def __delitem__(self, key) :
        return self.remove(key)

    def __contains__(self, key):
        return key.lower() in [k.lower() for k in self.keys()]

    def __len__(self):
        return self.numitems

    def keys(self):
        """
        **Python-only**. In Python MapScript the ``hashTableObj`` can be used and accessed
        as a dictionary. The ``keys`` method returns a view of all the keys in the ``hashTableObj``.
        """

        keys = []
        k = None

        while True :
            k = self.nextKey(k)
            if k :
                keys.append(k)
            else :
                break

        return keys



# Register hashTableObj in _mapscript:
_mapscript.hashTableObj_swigregister(hashTableObj)
MS_CONFIG_SECTION = _mapscript.MS_CONFIG_SECTION
MS_CONFIG_SECTION_ENV = _mapscript.MS_CONFIG_SECTION_ENV
MS_CONFIG_SECTION_MAPS = _mapscript.MS_CONFIG_SECTION_MAPS
MS_CONFIG_SECTION_PLUGINS = _mapscript.MS_CONFIG_SECTION_PLUGINS
class configObj(object):
    r"""The :ref:`CONFIG <config>` object"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    env: "hashTableObj" = property(_mapscript.configObj_env_get, _mapscript.configObj_env_set, doc=r"""Key-value pairs of environment variables and values""")
    maps: "hashTableObj" = property(_mapscript.configObj_maps_get, _mapscript.configObj_maps_set, doc=r"""Key-value pairs of Mapfile names and paths""")
    plugins: "hashTableObj" = property(_mapscript.configObj_plugins_get, _mapscript.configObj_plugins_set, doc=r"""Key-value pairs of plugin names and paths""")

    def __init__(self, filename: "char *"=None):
        r"""Create a new instance of :class:`configObj`"""
        _mapscript.configObj_swiginit(self, _mapscript.new_configObj(filename))
    __swig_destroy__ = _mapscript.delete_configObj

# Register configObj in _mapscript:
_mapscript.configObj_swigregister(configObj)

def msLoadConfig(ms_config_file: "char const *") -> "configObj *":
    return _mapscript.msLoadConfig(ms_config_file)

def msFreeConfig(config: "configObj") -> "void":
    return _mapscript.msFreeConfig(config)

def msConfigGetEnv(config: "configObj", key: "char const *") -> "char const *":
    return _mapscript.msConfigGetEnv(config, key)

def msConfigGetMap(config: "configObj", key: "char const *", pszReturnPath: "char *") -> "char const *":
    return _mapscript.msConfigGetMap(config, key, pszReturnPath)

def msConfigGetPlugin(config: "configObj", key: "char const *") -> "char const *":
    return _mapscript.msConfigGetPlugin(config, key)
MS_DEFAULT_CGI_PARAMS = _mapscript.MS_DEFAULT_CGI_PARAMS
MS_GET_REQUEST = _mapscript.MS_GET_REQUEST
MS_POST_REQUEST = _mapscript.MS_POST_REQUEST
class OWSRequest(object):
    r"""Class for programming OWS services"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    NumParams: "int" = property(_mapscript.OWSRequest_NumParams_get, doc=r"""The number of querystring parameters""")
    type: "enum MS_REQUEST_TYPE" = property(_mapscript.OWSRequest_type_get, _mapscript.OWSRequest_type_set, doc=r"""A :ref:`request type constant<mapfile-constants-requesttype>`""")
    contenttype: "char *" = property(_mapscript.OWSRequest_contenttype_get, _mapscript.OWSRequest_contenttype_set, doc=r"""The content type of the request""")
    postrequest: "char *" = property(_mapscript.OWSRequest_postrequest_get, _mapscript.OWSRequest_postrequest_set, doc=r"""Any POST data request""")
    httpcookiedata: "char *" = property(_mapscript.OWSRequest_httpcookiedata_get, _mapscript.OWSRequest_httpcookiedata_set, doc=r"""Any cookie data associated with the request""")

    def __init__(self):
        r"""
        Not associated with other mapscript classes. Serves as a message intermediary
        between an application and MapServer's OWS capabilities. Using it permits creation
        of lightweight WMS services.
        """
        _mapscript.OWSRequest_swiginit(self, _mapscript.new_OWSRequest())
    __swig_destroy__ = _mapscript.delete_OWSRequest

    def loadParams(self) -> "int":
        r"""
        Initializes the OWSRequest object from the cgi environment variables
        ``REQUEST_METHOD``, ``QUERY_STRING`` and ``HTTP_COOKIE``.
        Returns the number of name/value pairs collected.
        Warning: most errors will result in a process exit!
        """
        return _mapscript.OWSRequest_loadParams(self)

    def loadParamsFromURL(self, url: "char const *") -> "int":
        r"""
        Initializes the OWSRequest object from the provided URL which is
        treated like a ``QUERY_STRING``.
        Note that ``REQUEST_METHOD=GET`` and no post data is assumed in this case.
        """
        return _mapscript.OWSRequest_loadParamsFromURL(self, url)

    def loadParamsFromPost(self, postData: "char *", url: "char const *") -> "int":
        r"""
        Initializes the OWSRequest object with POST data, along with a the provided URL which is
        treated like a ``QUERY_STRING``.
        Note that ``REQUEST_METHOD=POST`` and the caller is responsible for setting the correct
        content type e.g. ``req.contenttype = "application/xml"``
        """
        return _mapscript.OWSRequest_loadParamsFromPost(self, postData, url)

    def setParameter(self, name: "char *", value: "char *") -> "void":
        r"""
        Set a request parameter. For example:

        request.setParameter('REQUEST', 'GetMap')
        request.setParameter('BBOX', '-107.0,40.0,-106.0,41.0')
        """
        return _mapscript.OWSRequest_setParameter(self, name, value)

    def addParameter(self, name: "char *", value: "char *") -> "void":
        r"""
        Add a request parameter, even if the parameter key was previously set.
        This is useful when multiple parameters with the same key are required.
        For example:
        request.addParameter('SIZE', 'x(100)')
        request.addParameter('SIZE', 'y(100)')
        """
        return _mapscript.OWSRequest_addParameter(self, name, value)

    def getName(self, index: "int") -> "char *":
        r"""
        Return the name of the parameter at ``index`` in the request's
        array of parameter names.
        """
        return _mapscript.OWSRequest_getName(self, index)

    def getValue(self, index: "int") -> "char *":
        r"""
        Return the value of the parameter at ``index`` in the request's
        array of parameter values.
        """
        return _mapscript.OWSRequest_getValue(self, index)

    def getValueByName(self, name: "char const *") -> "char *":
        r"""Return the value associated with the parameter ``name``"""
        return _mapscript.OWSRequest_getValueByName(self, name)

# Register OWSRequest in _mapscript:
_mapscript.OWSRequest_swigregister(OWSRequest)

def msConnPoolCloseUnreferenced() -> "void":
    r"""
    Some memory leaks can be avoided by closing any unreferenced
    connections from time to time. See https://github.com/mapserver/mapserver/issues/1661
    """
    return _mapscript.msConnPoolCloseUnreferenced()

def msIO_resetHandlers() -> "void":
    r"""Resets the default stdin and stdout handlers in place of buffer based handlers."""
    return _mapscript.msIO_resetHandlers()

def msIO_installStdoutToBuffer() -> "void":
    r"""Installs a mapserver IO handler directing future stdout output to a memory buffer."""
    return _mapscript.msIO_installStdoutToBuffer()

def msIO_installStdinFromBuffer() -> "void":
    r"""
    Installs a mapserver IO handler directing future stdin reading
    (i.e. post request capture) to come from a buffer.
    """
    return _mapscript.msIO_installStdinFromBuffer()

def msIO_stripStdoutBufferContentType() -> "char const *":
    r"""
    Strip the Content-type header off the stdout buffer if it has one, and if a content type
    is found it is returned (otherwise NULL/None/etc).
    """
    return _mapscript.msIO_stripStdoutBufferContentType()

def msIO_stripStdoutBufferContentHeaders() -> "void":
    r"""Strip all Content-* headers off the stdout buffer if it has any."""
    return _mapscript.msIO_stripStdoutBufferContentHeaders()

def msIO_getStdoutBufferString() -> "char const *":
    r"""
    Fetch the current stdout buffer contents as a string.
    This method does not clear the buffer.
    """
    return _mapscript.msIO_getStdoutBufferString()

def msIO_getStdoutBufferBytes() -> "gdBuffer":
    r"""
    Fetch the current stdout buffer contents as a binary buffer. The exact form of this buffer will vary by
    MapScript language (e/g. string in Python, byte[] array in Java and C#, unhandled in Perl).
    """
    return _mapscript.msIO_getStdoutBufferBytes()

def msIO_getAndStripStdoutBufferMimeHeaders() -> "hashTableObj *":
    r"""Strip off all MIME headers and return them in a hashTableObj"""
    return _mapscript.msIO_getAndStripStdoutBufferMimeHeaders()

def fromstring(data, mappath=None, configpath=None):
    """Creates map objects from mapfile strings.

    Parameters
    ==========
    data : string
        Mapfile in a string.
    mappath : string
        Optional root map path, enabling relative paths in mapfile.

    Example
    =======
    >>> mo = fromstring("MAP\nNAME 'test'\nEND")
    >>> mo.name
    'test'
    """
    import re
    if re.search(r"^\s*MAP", data, re.I):
# create a config object if a path is supplied
        if configpath:
             config = configObj(configpath)
        else:
             config = None
        return msLoadMapFromString(data, mappath, config)
    elif re.search(r"^\s*LAYER", data, re.I):
        ob = layerObj()
        ob.updateFromString(data)
        return ob
    elif re.search(r"^\s*CLASS", data, re.I):
        ob = classObj()
        ob.updateFromString(data)
        return ob
    elif re.search(r"^\s*STYLE", data, re.I):
        ob = styleObj()
        ob.updateFromString(data)
        return ob
    else:
        raise ValueError("No map, layer, class, or style found. Can not load from provided string")



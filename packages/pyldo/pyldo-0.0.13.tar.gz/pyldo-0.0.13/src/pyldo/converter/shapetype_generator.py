"""
ShapeType Generator

Generates ShapeType objects that bundle together:
- schema: The parsed ShEx schema as JSON
- shape: The shape ID (IRI)
- context: The JSON-LD context

This is equivalent to the .shapeTypes.ts files in @ldo/cli.
"""

import json
import re
from typing import Any

from .shex_parser import ShExSchema


def generate_shapetypes_file(
    schema: ShExSchema,
    types_module: str,
    context_module: str,
    schema_module: str,
) -> str:
    """
    Generate Python source code for ShapeType definitions.

    Args:
        schema: Parsed ShEx schema
        types_module: Module name for the types (e.g., "profile_types")
        context_module: Module name for the context (e.g., "profile_context")
        schema_module: Module name for the schema (e.g., "profile_schema")

    Returns:
        Python source code as a string
    """
    lines = [
        '"""',
        "Generated ShapeType definitions from ShEx schema.",
        "",
        "This file was auto-generated by pyldo. Do not edit manually.",
        "",
        "ShapeTypes bundle together the schema, shape ID, and context",
        "needed to create typed Linked Data Objects.",
        '"""',
        "",
        "from typing import Any, Generic, TypeVar",
        "",
        "from pydantic import BaseModel",
        "",
        f"from .{types_module} import (",
    ]

    # Import all shape types
    shape_names = [_get_shape_name(shape.id) for shape in schema.shapes]
    for name in shape_names:
        lines.append(f"    {name},")
    lines.append(")")

    lines.extend([
        f"from .{context_module} import {_get_context_var_name(context_module)}",
        f"from .{schema_module} import {_get_schema_var_name(schema_module)}",
        "",
        "",
        "T = TypeVar('T', bound=BaseModel)",
        "",
        "",
        "class ShapeType(Generic[T]):",
        '    """',
        "    A ShapeType bundles together everything needed to create",
        "    typed Linked Data Objects from RDF data.",
        "",
        "    Attributes:",
        "        schema: The ShEx schema as a dictionary",
        "        shape: The shape ID (IRI) within the schema",
        "        context: The JSON-LD context for property mapping",
        "        type_class: The Pydantic model class for this shape",
        '    """',
        "",
        "    def __init__(",
        "        self,",
        "        schema: dict[str, Any],",
        "        shape: str,",
        "        context: dict[str, Any],",
        "        type_class: type[T],",
        "    ):",
        "        self.schema = schema",
        "        self.shape = shape",
        "        self.context = context",
        "        self.type_class = type_class",
        "",
        "    def __repr__(self) -> str:",
        "        shape_name = self.shape.rsplit('#', 1)[-1].rsplit('/', 1)[-1]",
        '        return f"ShapeType({shape_name})"',
        "",
        "",
    ])

    # Generate ShapeType for each shape
    context_var = _get_context_var_name(context_module)
    schema_var = _get_schema_var_name(schema_module)

    for shape in schema.shapes:
        shape_name = _get_shape_name(shape.id)
        var_name = f"{shape_name}ShapeType"

        lines.extend([
            f"# ShapeType for {shape_name}",
            f"{var_name}: ShapeType[{shape_name}] = ShapeType(",
            f"    schema={schema_var},",
            f'    shape="{shape.id}",',
            f"    context={context_var},",
            f"    type_class={shape_name},",
            ")",
            "",
        ])

    # Export all ShapeTypes
    lines.append("")
    lines.append("__all__ = [")
    lines.append('    "ShapeType",')
    for shape in schema.shapes:
        shape_name = _get_shape_name(shape.id)
        lines.append(f'    "{shape_name}ShapeType",')
    lines.append("]")

    return "\n".join(lines)


def generate_schema_file(schema: ShExSchema, variable_name: str = "schema") -> str:
    """
    Generate Python source code for the ShEx schema as JSON.

    Args:
        schema: Parsed ShEx schema
        variable_name: Name for the schema variable

    Returns:
        Python source code as a string
    """
    # Convert schema to JSON-serializable format
    schema_dict = _schema_to_dict(schema)

    lines = [
        '"""',
        "Generated ShEx schema as JSON.",
        "",
        "This file was auto-generated by pyldo. Do not edit manually.",
        '"""',
        "",
        "from typing import Any",
        "",
        f"{variable_name}: dict[str, Any] = " + json.dumps(schema_dict, indent=4),
    ]

    return "\n".join(lines)


def _schema_to_dict(schema: ShExSchema) -> dict[str, Any]:
    """Convert a ShExSchema to a JSON-serializable dictionary."""
    return {
        "type": "Schema",
        "prefixes": schema.prefixes,
        "shapes": [_shape_to_dict(shape) for shape in schema.shapes],
    }


def _shape_to_dict(shape) -> dict[str, Any]:
    """Convert a Shape to a dictionary."""
    return {
        "id": shape.id,
        "type": "ShapeDecl",
        "shapeExpr": _expr_to_dict(shape.expression) if shape.expression else None,
    }


def _expr_to_dict(expr) -> dict[str, Any]:
    """Convert an expression to a dictionary."""
    from .shex_parser import EachOf, NodeConstraint, OneOf, ShapeRef, TripleConstraint

    if isinstance(expr, TripleConstraint):
        result = {
            "type": "TripleConstraint",
            "predicate": expr.predicate,
        }
        if expr.value_expr:
            result["valueExpr"] = _expr_to_dict(expr.value_expr)
        if expr.cardinality:
            result["cardinality"] = expr.cardinality.value
        return result

    elif isinstance(expr, EachOf):
        return {
            "type": "EachOf",
            "expressions": [_expr_to_dict(e) for e in expr.expressions],
        }

    elif isinstance(expr, OneOf):
        return {
            "type": "OneOf",
            "expressions": [_expr_to_dict(e) for e in expr.expressions],
        }

    elif isinstance(expr, NodeConstraint):
        result: dict[str, Any] = {"type": "NodeConstraint"}
        if expr.datatype:
            result["datatype"] = expr.datatype
        if expr.node_kind:
            result["nodeKind"] = expr.node_kind.value
        if expr.values:
            result["values"] = expr.values
        return result

    elif isinstance(expr, ShapeRef):
        return {
            "type": "ShapeRef",
            "reference": expr.shape_iri,
        }

    return {}


def _get_shape_name(shape_id: str) -> str:
    """Extract a valid Python class name from a shape IRI."""
    name = shape_id.rsplit("#", 1)[-1]
    name = name.rsplit("/", 1)[-1]
    name = re.sub(r"[^a-zA-Z0-9_]", "_", name)
    if name and name[0].isdigit():
        name = "_" + name
    return name or "UnnamedShape"


def _get_context_var_name(module_name: str) -> str:
    """Get the context variable name from module name."""
    return f"{module_name}"


def _get_schema_var_name(module_name: str) -> str:
    """Get the schema variable name from module name."""
    return f"{module_name}"

"""
This auxiliary module provides helper functions to build and load simplified
country polygons for the whole world, based on down-sampled `level0_100m`
rasters from WorldPop.
"""

import logging
import warnings
from functools import lru_cache

import geopandas as gpd
import numpy as np
import pandas as pd
import rioxarray  # noqa
import xarray as xr
from pqdm.threads import pqdm
from shapely.geometry import shape

from worldpoppy.config import *
from worldpoppy.config import get_cache_dir
from worldpoppy.manifest_loader import get_all_isos

_border_res_arc_secs = 15

# --- Border File Configuration ---
# 1. The Raw Geo-Asset (Shipped with Library):
#    A small Feather file (~6MB) containing simplified, unbuffered country polygons.
#    We ship this file to minimise the installation size of `worldpoppy`.
_border_raw_fpath = ASSET_DIR / 'level0_500m_2000_2020_simplified_world.feather'

# 2. The Buffered Cache (Auto-Built Locally):
#    A heavier version of the raw geo-asset where geometries are buffered by ~1km.
#    This file is automatically generated and saved to the local cache directory
#    the first time `load_country_borders` is called. We add a buffer to handle
#    effects.
_border_buffered_fpath = get_cache_dir() / 'level0_500m_2000_2020_simplified_world_buffered.feather'

try:
    from osgeo import gdal  # noqa

    GDAL_AVAILABLE = True
except ModuleNotFoundError:
    GDAL_AVAILABLE = False

logger = logging.getLogger(__name__)


@lru_cache
def load_country_borders():
    """
    Return a GeoDataFrame with simplified, buffered country polygons extracted from
    WorldPop `level0_100m` rasters.

    If the cached border file does not exist, this function will trigger the build
    process.

    Returns
    -------
    geopandas.GeoDataFrame
        A GeoDataFrame with simplified, buffered polygons for all countries and an
        'iso3' column.
    """
    if not _border_buffered_fpath.is_file():
        logger.warning('Buffered country borders not found in cache. Rebuilding...')

        # Fetch un-buffered simplified country polygons
        build_country_borders()  # only triggers if cache is cold
        gdf = gpd.read_feather(_border_raw_fpath)

        # Apply a small buffer to country borders equivalent to approx. 1 km
        # at the equator. Doing so will help to avoid empty downstream user
        # queries due to small inaccuracies in the border data. Note that we
        # do not ship buffered country polygons as part of the initial `worldpoppy`
        # installation since they take up much more space than the unbuffered ones.
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            gdf['geometry'] = gdf.buffer(0.01)

        if not np.all(gdf.is_valid):
            raise ValueError('Adding buffer yielded invalid geometries.')
            # > Workaround: reduce buffer size

        # Make sure the cache directory exists
        # (dir creation may be necessary after fresh library install)
        _border_buffered_fpath.parent.mkdir(parents=True, exist_ok=True)

        # Save the buffered data for re-use
        gdf.to_feather(_border_buffered_fpath)
        logger.warning('Done.')

    return gpd.read_feather(_border_buffered_fpath)


def build_country_borders(overwrite=False):
    """
    Build a GeoDataFrame with country borders for the whole world by converting
    WorldPop `admin0` rasters into simplified vector polygons. The output is
    saved to disk as a Feather file for future use.

    Notes
    -----
        - The border data generated by this function is *not* intended for display
          or any geo-data analysis. Its sole purpose is to power raster-data queries
          in `worldpoppy.WorldPopDownloader`.
        - This function requires an installation of `osgeo.gdal`.

    Parameters
    ----------
    overwrite : bool, optional
        If True, force regeneration of the border polygons even if they already
        exist on disk. Default is False.

    Raises
    ------
    ModuleNotFoundError
        If an installation of the optional `ogeo.gdal` library is not available.
    """
    # TODO Document the standard users will not need to call this function.

    from worldpoppy.download import WorldPopDownloader  # avoid circularity

    if _border_raw_fpath.is_file() and not overwrite:
        return None

    if not GDAL_AVAILABLE:
        raise ModuleNotFoundError(
            "Error: An installation of 'ogeo.gdal' is required to build country "
            "borders from scratch. Please install `gdal` using pip, conda, or "
            "mamba (e.g., `conda install -c conda-forge gdal`)."
        )

    all_isos = get_all_isos()
    isos_without_admin_rasters = ['CCK', 'CXR']  # Cocos Islands, Christmas Island
    supported_isos = set(all_isos) - set(isos_without_admin_rasters)

    # Download high-resolution country rasters from WorldPop
    _ = WorldPopDownloader().download(
        'admin0',  # resolution of 3 arc seconds
        iso3_codes=supported_isos
    )

    # Asynchronously downsample the raster data and convert
    # it into simplified country polygons
    res = pqdm(
        supported_isos,
        _extract_simplified_borders,
        n_jobs=get_max_concurrency(),
        desc='Extracting simplified country borders...',
        leave=False
    )

    # Concatenate results in a GeoDataFrame
    gdf = gpd.GeoDataFrame(pd.concat(res), crs=WGS84_CRS)

    # Simplify country geometries further to save even more disk space
    gdf['geometry'] = gdf.simplify(tolerance=0.005)  # approx. 500 metres tolerance
    if not np.all(gdf.is_valid):
        raise ValueError('Border simplification yielded invalid geometries.')
        # workaround: reduce `tolerance`

    gdf.to_feather(_border_raw_fpath, compression='zstd')


def _extract_simplified_borders(iso3):
    """
    Convert a high-resolution country raster from WorldPop into simplified
    vector polygons by first down-sampling (using `gdal.Warp`) and then
    applying `rasterio.features.shapes`.

    Parameters
    ----------
    iso3 : str
        The three-letter ISO code of the country for which to extract
        simplified borders.

    Returns
    -------
    geopandas.GeoDataFrame
        A GeoDataFrame of polygons representing country borders for the given
        ISO code. Includes an 'iso3' column for country identification.
    """
    from osgeo import gdal  # noqa; avoid global dependency
    from rasterio.features import shapes  # noqa; ''

    # Convert target resolution to decimal degrees
    tgt_res = 1 / (3600 / _border_res_arc_secs)

    # Set required paths
    in_path = get_cache_dir() / f'admin0_{iso3.upper()}.tif'
    tmp_path = get_cache_dir() / f'tmp_admin0_500m_{iso3.upper()}.tif'

    with warnings.catch_warnings():
        warnings.simplefilter('ignore')

        # Handle the temp-file overwrite.
        # Python bindings for GDAL may not always handle the '-overwrite'
        # flag gracefully. So we clear the path manually.
        if tmp_path.exists():
            tmp_path.unlink()

        # Prepare arguments for gdal.Warp.
        # Crucial: We use nearest-neighbour resampling to the target resolution.
        opts = gdal.WarpOptions(
            format='GTiff',
            # set source and target CRS
            srcSRS=WGS84_CRS,
            dstSRS=WGS84_CRS,
            # set target resolution
            xRes=tgt_res,
            yRes=tgt_res,
            # set resampling method
            resampleAlg='near',
            # set "Creation Options"
            creationOptions=['BIGTIFF=YES'],
            multithread=False,
        )

        # Call warp.
        # Note: Warp returns a Dataset object. By de-referencing
        # this object, we flush the write to disk immediately.
        _ = gdal.Warp(str(tmp_path), str(in_path), options=opts)  # paths MUST be strings
        _ = None  # de-reference

        # Load the result
        da = xr.open_dataarray(tmp_path, mask_and_scale=True)
        da.rio.write_crs(WGS84_CRS, inplace=True)  # ensure CRS is set

        # Extract country polygons
        country_polys = []
        for geom, value in shapes(da.data, transform=da.rio.transform(recalc=True)):
            if np.isfinite(value):
                country_polys.append(shape(geom))

    # Convert into a GeoDataFrame
    gdf = gpd.GeoDataFrame(geometry=country_polys, crs=WGS84_CRS)
    gdf['iso3'] = iso3

    # Remove the down-sampled country raster
    tmp_path.unlink()

    if not np.all(gdf.is_valid):
        raise ValueError(f'Border extraction for {iso3} yielded invalid geometries.')
        # workaround: reduce `_border_res_arc_secs`

    return gdf

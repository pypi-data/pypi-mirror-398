from typing import Literal, SupportsIndex
from typing_extensions import overload, Self, TypeVar
import datetime
import numpy as np
from time import struct_time
from zoneinfo import ZoneInfo
from cytimes.parser import Configs
from cytimes.utils import SENTINEL

# Types
_DateT = TypeVar("_DateT", bound=datetime.date)
_DatetimeT = TypeVar("_DatetimeT", bound=datetime.datetime)
_TimedeltaT = TypeVar("_TimedeltaT", bound=datetime.timedelta)
DatetimeLike = TypeVar(
    "DatetimeLike", str, datetime.date, datetime.datetime, np.datetime64
)

# Pydt
class _Pydt(datetime.datetime):
    # Constructor ------------------------------------------------------
    @classmethod
    def parse(
        cls,
        dtobj: DatetimeLike,
        default: object | None = None,
        yearfirst: bool | None = None,
        dayfirst: bool | None = None,
        ignoretz: bool = True,
        isoformat: bool = True,
        cfg: Configs | None = None,
    ) -> Self: ...
    @classmethod
    def now(cls, tz: datetime.tzinfo | str | None = None) -> Self: ...
    @classmethod
    def utcnow(cls) -> Self: ...
    @classmethod
    def today(cls) -> Self: ...
    @classmethod
    def combine(
        cls,
        date: datetime.date | str | None = None,
        time: datetime.time | str | None = None,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def fromordinal(
        cls,
        ordinal: int,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def fromseconds(
        cls,
        seconds: int | float,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def frommicroseconds(
        cls,
        us: int,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def fromtimestamp(
        cls,
        ts: int | float,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def utcfromtimestamp(cls, ts: int | float) -> Self: ...
    @classmethod
    def fromisoformat(cls, dtstr: str) -> Self: ...
    @classmethod
    def fromisocalendar(
        cls,
        year: int,
        week: int,
        weekday: int,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def fromdayofyear(
        cls,
        year: int,
        doy: int,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def fromdate(
        cls,
        date: datetime.date,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def fromdatetime(
        cls,
        dt: datetime.datetime,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def fromdatetime64(
        cls,
        dt64: np.datetime64,
        tz: datetime.tzinfo | str | None = None,
    ) -> Self: ...
    @classmethod
    def strptime(cls, dtstr: str, fmt: str) -> Self: ...
    # Convertor --------------------------------------------------------
    def ctime(self) -> str: ...
    def strftime(self, fmt: str) -> str: ...
    def isoformat(self, sep: str = "T") -> str: ...
    def timedict(self) -> dict[str, int]: ...
    def utctimedict(self) -> dict[str, int]: ...
    def timetuple(self) -> struct_time: ...
    def utctimetuple(self) -> struct_time: ...
    def toordinal(self) -> int: ...
    def toseconds(self, utc: bool = False) -> float: ...
    def tomicroseconds(self, utc: bool = False) -> int: ...
    def timestamp(self) -> float: ...
    def date(self) -> datetime.date: ...
    def time(self) -> datetime.time: ...
    def timetz(self) -> datetime.time: ...
    # Manipulator ------------------------------------------------------
    def replace(
        self,
        year: int = SENTINEL,
        month: int = SENTINEL,
        day: int = SENTINEL,
        hour: int = SENTINEL,
        minute: int = SENTINEL,
        second: int = SENTINEL,
        microsecond: int = SENTINEL,
        tzinfo: datetime.tzinfo | str | None = SENTINEL,
        fold: int = SENTINEL,
    ) -> Self: ...
    # . year
    def to_curr_year(
        self,
        month: int | str | None = None,
        day: int = SENTINEL,
    ) -> Self: ...
    def to_prev_year(
        self,
        month: int | str | None = None,
        day: int = SENTINEL,
    ) -> Self: ...
    def to_next_year(
        self,
        month: int | str | None = None,
        day: int = SENTINEL,
    ) -> Self: ...
    def to_year(
        self,
        offset: int,
        month: int | str | None = None,
        day: int = SENTINEL,
    ) -> Self: ...
    # . quarter
    def to_curr_quarter(self, month: int = SENTINEL, day: int = SENTINEL) -> Self: ...
    def to_prev_quarter(self, month: int = SENTINEL, day: int = SENTINEL) -> Self: ...
    def to_next_quarter(self, month: int = SENTINEL, day: int = SENTINEL) -> Self: ...
    def to_quarter(
        self,
        offset: int,
        month: int = SENTINEL,
        day: int = SENTINEL,
    ) -> Self: ...
    # . month
    def to_curr_month(self, day: int = SENTINEL) -> Self: ...
    def to_prev_month(self, day: int = SENTINEL) -> Self: ...
    def to_next_month(self, day: int = SENTINEL) -> Self: ...
    def to_month(self, offset: int, day: int = SENTINEL) -> Self: ...
    # . weekday
    def to_monday(self) -> Self: ...
    def to_tuesday(self) -> Self: ...
    def to_wednesday(self) -> Self: ...
    def to_thursday(self) -> Self: ...
    def to_friday(self) -> Self: ...
    def to_saturday(self) -> Self: ...
    def to_sunday(self) -> Self: ...
    def to_curr_weekday(self, weekday: int | str | None = None) -> Self: ...
    def to_prev_weekday(self, weekday: int | str | None = None) -> Self: ...
    def to_next_weekday(self, weekday: int | str | None = None) -> Self: ...
    def to_weekday(self, offset: int, weekday: int | str | None = None) -> Self: ...
    # . day
    def to_yesterday(self) -> Self: ...
    def to_tomorrow(self) -> Self: ...
    def to_day(self, offset: int) -> Self: ...
    # . date&time
    def normalize(self) -> Self: ...
    def to_datetime(
        self,
        year: int = SENTINEL,
        month: int = SENTINEL,
        day: int = SENTINEL,
        hour: int = SENTINEL,
        minute: int = SENTINEL,
        second: int = SENTINEL,
        microsecond: int = SENTINEL,
    ) -> Self: ...
    def to_date(
        self,
        year: int = SENTINEL,
        month: int = SENTINEL,
        day: int = SENTINEL,
    ) -> Self: ...
    def to_time(
        self,
        hour: int = SENTINEL,
        minute: int = SENTINEL,
        second: int = SENTINEL,
        microsecond: int = SENTINEL,
    ) -> Self: ...
    def to_first_of(self, unit: str | Literal["Y", "Q", "M", "W"]) -> Self: ...
    def to_last_of(self, unit: str | Literal["Y", "Q", "M", "W"]) -> Self: ...
    def to_start_of(
        self,
        unit: str | Literal["Y", "Q", "M", "W", "D", "h", "m", "s", "ms", "us"],
    ) -> Self: ...
    def to_end_of(
        self,
        unit: str | Literal["Y", "Q", "M", "W", "D", "h", "m", "s", "ms", "us"],
    ) -> Self: ...
    def is_first_of(self, unit: str | Literal["Y", "Q", "M", "W"]) -> bool: ...
    def is_last_of(self, unit: str | Literal["Y", "Q", "M", "W"]) -> bool: ...
    def is_start_of(
        self,
        unit: str | Literal["Y", "Q", "M", "W", "D", "h", "m", "s", "ms", "us"],
    ) -> bool: ...
    def is_end_of(
        self,
        unit: str | Literal["Y", "Q", "M", "W", "D", "h", "m", "s", "ms", "us"],
    ) -> bool: ...
    # . round / ceil / floor
    def round(self, unit: Literal["D", "h", "m", "s", "ms", "us"]) -> Self: ...
    def ceil(self, unit: Literal["D", "h", "m", "s", "ms", "us"]) -> Self: ...
    def floor(self, unit: Literal["D", "h", "m", "s", "ms", "us"]) -> Self: ...
    # . fsp (fractional seconds precision)
    def fsp(self, precision: int) -> Self: ...
    # Calendar ---------------------------------------------------------
    # . iso
    def isocalendar(self) -> dict[str, int]: ...
    def isoyear(self) -> int: ...
    def isoweek(self) -> int: ...
    def isoweekday(self) -> int: ...
    # . year
    @property
    def year(self) -> int: ...
    def access_year(self) -> int: ...
    def is_year(self, year: int) -> bool: ...
    def is_leap_year(self) -> bool: ...
    def is_long_year(self) -> bool: ...
    def leap_bt_year(self, year: int) -> int: ...
    def days_in_year(self) -> int: ...
    def days_bf_year(self) -> int: ...
    def day_of_year(self) -> int: ...
    # . quarter
    @property
    def quarter(self) -> int: ...
    def access_quarter(self) -> int: ...
    def is_quarter(self, quarter: int) -> bool: ...
    def days_in_quarter(self) -> int: ...
    def days_bf_quarter(self) -> int: ...
    def day_of_quarter(self) -> int: ...
    # . month
    @property
    def month(self) -> int: ...
    def access_month(self) -> int: ...
    def is_month(self, month: int | str) -> bool: ...
    def days_in_month(self) -> int: ...
    def days_bf_month(self) -> int: ...
    def day_of_month(self) -> int: ...
    def month_name(self, locale: str | None = None) -> str: ...
    # . weekday
    @property
    def weekday(self) -> int: ...
    def access_weekday(self) -> int: ...
    def is_weekday(self, weekday: int | str) -> bool: ...
    def weekday_name(self, locale: str | None = None) -> str: ...
    # . day
    @property
    def day(self) -> int: ...
    def access_day(self) -> int: ...
    def is_day(self, day: int) -> bool: ...
    # . time
    @property
    def hour(self) -> int: ...
    def access_hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    def access_minute(self) -> int: ...
    @property
    def second(self) -> int: ...
    def access_second(self) -> int: ...
    @property
    def millisecond(self) -> int: ...
    def access_millisecond(self) -> int: ...
    @property
    def microsecond(self) -> int: ...
    def access_microsecond(self) -> int: ...
    # Timezone ---------------------------------------------------------
    @property
    def tz_available(self) -> set[str]: ...
    @property
    def tz(self) -> datetime.timezone | ZoneInfo | None: ...
    @property
    def tzinfo(self) -> datetime.timezone | ZoneInfo | None: ...
    def access_tzinfo(self) -> datetime.timezone | ZoneInfo | None: ...
    @property
    def fold(self) -> int: ...
    def access_fold(self) -> int: ...
    def is_local(self) -> bool: ...
    def is_utc(self) -> bool: ...
    def is_dst(self) -> bool: ...
    def tzname(self) -> str | None: ...
    def utcoffset(self) -> datetime.timedelta | None: ...
    def utcoffset_seconds(self) -> int | None: ...
    def dst(self) -> datetime.timedelta | None: ...
    def astimezone(self, tz: datetime.tzinfo | str | None = None) -> Self: ...
    def tz_localize(self, tz: datetime.tzinfo | str | None) -> Self: ...
    def tz_convert(self, tz: datetime.tzinfo | str | None) -> Self: ...
    def tz_switch(
        self,
        targ_tz: datetime.tzinfo | str | None,
        base_tz: datetime.tzinfo | str | None = None,
        naive: bool = False,
    ) -> Self: ...
    # Arithmetic -------------------------------------------------------
    def add(
        self,
        years: int = 0,
        quarters: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
    ) -> Self: ...
    def sub(
        self,
        years: int = 0,
        quarters: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        milliseconds: int = 0,
        microseconds: int = 0,
    ) -> Self: ...
    def diff(
        self,
        dtobj: object,
        unit: Literal["Y", "Q", "M", "W", "D", "h", "m", "s", "ms", "us"],
        absolute: bool = False,
        inclusive: Literal["one", "both", "neither"] = "one",
    ) -> int: ...
    # . addition
    @overload
    def __add__(self, o: _TimedeltaT) -> Self: ...
    @overload
    def __add__(self, o: np.timedelta64) -> Self: ...
    # . right addition
    @overload
    def __radd__(self, o: _TimedeltaT) -> Self: ...
    # . subtraction
    @overload
    def __sub__(self, o: _TimedeltaT) -> Self: ...
    @overload
    def __sub__(self, o: np.timedelta64) -> Self: ...
    @overload
    def __sub__(self, o: _DatetimeT) -> datetime.timedelta: ...
    @overload
    def __sub__(self, o: _DateT) -> datetime.timedelta: ...
    @overload
    def __sub__(self, o: str) -> datetime.timedelta: ...
    @overload
    def __sub__(self, o: np.datetime64) -> datetime.timedelta: ...
    # Comparison -------------------------------------------------------
    def is_past(self) -> bool: ...
    def is_future(self) -> bool: ...
    # Representation ---------------------------------------------------
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __format__(self, fmt: str) -> str: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> Self: ...
    def __deepcopy__(self, _: dict) -> Self: ...
    # Pickle -----------------------------------------------------------
    def __reduce__(self) -> str | tuple: ...
    def __reduce_ex__(self, protocol: SupportsIndex, /) -> str | tuple: ...

class Pydt(_Pydt):
    def __new__(
        cls,
        year: int = 1,
        month: int = 1,
        day: int = 1,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        microsecond: int = 0,
        tzinfo: datetime.tzinfo | str | None = None,
        *,
        fold: int = 1,
    ) -> Self: ...

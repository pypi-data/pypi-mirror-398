{
  "permissions": {
    "allow": [
      "Bash(gh issue create --title \"ACP client auto-approves all permission requests instead of showing them to users\" --body \"$(cat <<''EOF''\n## Problem\n\nPermission requests from ACP agents are being automatically approved instead of being presented to users for manual approval. This means users never see permission prompts and have no control over what the agent is allowed to do.\n\n## Root Cause\n\nIn `textual_chat/llm_adapter_acp.py:245-253`, the `request_permission` callback is implemented with auto-approval:\n\n```python\nasync def request_permission(\n    self, options: Any, session_id: str, tool_call: Any, **kwargs: Any\n) -> RequestPermissionResponse:\n    \"\"\"Handle permission requests - auto-approve for now.\"\"\"\n    # Auto-approve by selecting the first option if available\n    option_id = options[0].id if options and len(options) > 0 else \"approved\"\n    return RequestPermissionResponse(\n        outcome=AllowedOutcome(option_id=option_id, outcome=\"selected\")\n    )\n```\n\nThe comment \"auto-approve for now\" indicates this was a placeholder implementation.\n\n## Required Changes\n\nTo properly handle permission requests, we need to:\n\n### 1. Add a new event type for permission requests\n\n**File:** `textual_chat/events.py`\n\nAdd a new event class:\n```python\n@dataclass\nclass PermissionRequest:\n    \"\"\"Permission request from agent.\"\"\"\n    \n    options: list[Any]  # Permission options from ACP\n    session_id: str\n    tool_call: Any\n    # Future to signal user''s response\n    response_future: asyncio.Future[RequestPermissionResponse]\n```\n\nUpdate the `StreamEvent` union to include `PermissionRequest`.\n\n### 2. Modify the permission handler\n\n**File:** `textual_chat/llm_adapter_acp.py`\n\nUpdate `request_permission` method to:\n- Create a `PermissionRequest` event with a response future\n- Queue the event so the UI can display it\n- Wait for the user''s response via the future\n- Return the user''s choice\n\nExample implementation:\n```python\nasync def request_permission(\n    self, options: Any, session_id: str, tool_call: Any, **kwargs: Any\n) -> RequestPermissionResponse:\n    \"\"\"Handle permission requests - prompt user for approval.\"\"\"\n    # Create future for response\n    response_future = asyncio.Future()\n    \n    # Queue permission request event for UI\n    await self._events.put(\n        PermissionRequest(\n            options=options,\n            session_id=session_id,\n            tool_call=tool_call,\n            response_future=response_future\n        )\n    )\n    \n    # Wait for user response\n    response = await response_future\n    return response\n```\n\n### 3. Update UI to handle permission requests\n\nThe UI component needs to:\n- Listen for `PermissionRequest` events in the event stream\n- Display permission options to the user (similar to how tool calls are displayed)\n- Provide UI elements for the user to approve/deny/select options\n- Set the response on the `response_future` when user makes a choice\n\n### 4. Handle timeout/cancellation\n\nConsider adding:\n- A timeout for permission requests (auto-deny after X seconds)\n- Cancellation handling if the user closes the app\n- Clear UI feedback showing what permission is being requested\n\n## Testing\n\nAfter implementation, test with an ACP agent that requests permissions to verify:\n- Permission prompts appear in the UI\n- User can approve/deny\n- Agent receives the correct response\n- Timeout/cancellation works properly\n\n## Related Files\n\n- `textual_chat/events.py` - Event definitions\n- `textual_chat/llm_adapter_acp.py` - ACP client handler\n- UI component (TUI) - Needs to display and handle permission requests\nEOF\n)\")"
    ]
  }
}

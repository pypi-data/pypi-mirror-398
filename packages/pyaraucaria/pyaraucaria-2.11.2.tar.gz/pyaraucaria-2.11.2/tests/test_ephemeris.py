import unittest
import numpy as np
from datetime import datetime, timezone
from astropy.time import Time
from astropy.coordinates import EarthLocation, get_body, SkyCoord
import astropy.units as u
from pyaraucaria.ephemeris import moon_phase, calculate_sun_rise_set, moon_separation
from pyaraucaria.ephemeris import Sun, Moon, Star, Stars


class TestAzAlt2RaDecAstropy(unittest.TestCase):

    def test_ra_dec_2_az_alt_astropy(self):
        OCA = {'latitude': -24.59855, 'longitude': -70.20126, 'elevation': 2817}
        latitude = OCA['latitude']
        longitude = OCA['longitude']
        elevation = OCA['elevation']
        tim = datetime.fromisoformat('2024-08-11T00:00:00Z')
        test_phase = 34.6
        mp = moon_phase(date_utc=tim, latitude=latitude, longitude=longitude, elevation=elevation)
        self.assertAlmostEqual(mp, test_phase, places=1)


class TestEphemerisFunctions(unittest.TestCase):

    def setUp(self):
        """
        Set up common test fixtures.
        Using coordinates for OCA Observatory (Chile) as a realistic test case.
        """
        self.lat = -24.6
        self.lon = -70.2
        self.elev = 2800.0

        # A fixed reference time: Noon UTC
        # This ensures 'next' sunset is likely later same day,
        # and 'next' sunrise is likely the next day.
        self.ref_date = datetime(2024, 5, 20, 12, 0, 0, tzinfo=timezone.utc)
        self.ref_time_astropy = Time(self.ref_date)

    # ==========================================
    # Tests for calculate_sun_rise_set
    # ==========================================

    def test_sun_rise_set_returns_datetime(self):
        """Test that the function returns a standard python datetime object."""
        result = calculate_sun_rise_set(
            date=self.ref_date,
            horiz_height=0.0,
            sunrise=True,
            latitude=self.lat,
            longitude=self.lon,
            elevation=self.elev
        )
        self.assertIsInstance(result, datetime)

    def test_sun_rise_set_logic_sequence(self):
        """
        Test that 'next' sunset is after the current time,
        and 'next' sunrise is after that (during local night/next morning).
        """
        # Calculate next Sunset
        sunset = calculate_sun_rise_set(
            self.ref_date, 0.0, sunrise=False,
            latitude=self.lat, longitude=self.lon, elevation=self.elev
        )

        # Calculate next Sunrise
        sunrise = calculate_sun_rise_set(
            self.ref_date, 0.0, sunrise=True,
            latitude=self.lat, longitude=self.lon, elevation=self.elev
        )

        # Sanity check 1: Events must be in the future
        # Note: We compare timestamps to ensure timezone compatibility or ignore it if naive
        # astropy .to_datetime() usually returns non-aware datetime unless configured otherwise,
        # so we might need to strip tzinfo from ref_date if result is naive.

        # Handle potential timezone naivety from astroplan output
        ref_naive = self.ref_date.replace(tzinfo=None)
        res_naive_set = sunset.replace(tzinfo=None)
        res_naive_rise = sunrise.replace(tzinfo=None)

        self.assertGreater(res_naive_set, ref_naive, "Next sunset should be in the future")
        self.assertGreater(res_naive_rise, ref_naive, "Next sunrise should be in the future")

    def test_sun_horizon_heights(self):
        """Test that different horizon heights (Civil/Nautical) result in different times."""
        # Sunset at 0 degrees (Horizon)
        sunset_0 = calculate_sun_rise_set(
            self.ref_date, 0.0, False, self.lat, self.lon, self.elev
        )
        # Sunset at -12 degrees (Nautical Twilight)
        sunset_12 = calculate_sun_rise_set(
            self.ref_date, -12.0, False, self.lat, self.lon, self.elev
        )

        # The sun sets at 0 BEFORE it reaches -12
        self.assertLess(sunset_0, sunset_12)

    def test_sun_accuracy_against_reference_table(self):
        """
        Verify accuracy against a known 'truth table' generated by ocacal CLI.
        Reference data:
          Observer: Lat -24.59866, Lon -70.20128, Elev 0.0 (default CLI)
          Date: 2025-12-27
        """
        # Table parameters (more precise than setUp)
        lat = -24.59866
        lon = -70.20128
        elev = 0.0  # Table generated with default elevation=0

        # Allowable error (algorithm differences: spline vs astroplan minimization)
        # We allow 2 minutes tolerance, which is a safe margin.
        delta_tolerance = 120  # seconds

        # ---------------------------------------------------------
        # CASE 1: Sunrise at 0.0 degrees (Horizon)
        # Table: 2025-12-27 09:56:26 UTC
        # ---------------------------------------------------------
        target_rise = datetime(2025, 12, 27, 9, 56, 26, tzinfo=timezone.utc)

        # Start calculations from the beginning of the day
        start_date = datetime(2025, 12, 27, 0, 0, 0, tzinfo=timezone.utc)

        # Function returns astropy.Time
        calc_rise_dt = calculate_sun_rise_set(
            date=start_date,
            horiz_height=0.0,
            sunrise=True,
            latitude=lat,
            longitude=lon,
            elevation=elev
        )

        diff_rise = abs((calc_rise_dt - target_rise).total_seconds())
        self.assertLess(
            diff_rise,
            delta_tolerance,
            f"Sunrise time deviation {diff_rise}s is too high (Expected ~{target_rise}, got {calc_rise_dt})"
        )

        # ---------------------------------------------------------
        # CASE 2: Sunset at 0.0 degrees (Horizon)
        # Table: 2025-12-27 23:27:37 UTC
        # ---------------------------------------------------------
        target_set = datetime(2025, 12, 27, 23, 27, 37, tzinfo=timezone.utc)

        # Start from noon to find the nearest sunset
        start_date_noon = datetime(2025, 12, 27, 12, 0, 0, tzinfo=timezone.utc)

        calc_set_dt = calculate_sun_rise_set(
            date=start_date_noon,
            horiz_height=0.0,
            sunrise=False,
            latitude=lat,
            longitude=lon,
            elevation=elev
        )

        diff_set = abs((calc_set_dt - target_set).total_seconds())
        self.assertLess(
            diff_set,
            delta_tolerance,
            f"Sunset time deviation {diff_set}s is too high (Expected ~{target_set}, got {calc_set_dt})"
        )

        # ---------------------------------------------------------
        # CASE 3: Astronomical Twilight Set (-18 degrees)
        # Table: 2025-12-28 01:00:21 UTC (Next Day!)
        # ---------------------------------------------------------
        target_astro_twilight = datetime(2025, 12, 28, 1, 0, 21, tzinfo=timezone.utc)

        calc_astro_set_dt = calculate_sun_rise_set(
            date=start_date_noon,  # Still looking for 'next' from noon on the 27th
            horiz_height=-18.0,
            sunrise=False,
            latitude=lat,
            longitude=lon,
            elevation=elev
        )

        diff_astro = abs((calc_astro_set_dt - target_astro_twilight).total_seconds())
        self.assertLess(
            diff_astro,
            delta_tolerance,
            f"Astro twilight deviation {diff_astro}s is too high (Expected ~{target_astro_twilight}, got {calc_astro_set_dt})"
        )
    # ==========================================
    # Tests for moon_separation
    # ==========================================

    def test_moon_separation_zero(self):
        """Test that the separation from the Moon to itself is ~0."""

        actual_moon_gcrs = get_body("moon", self.ref_time_astropy)

        ra_moon = actual_moon_gcrs.ra.deg
        dec_moon = actual_moon_gcrs.dec.deg

        sep = moon_separation(ra_moon, dec_moon, self.ref_time_astropy)

        self.assertAlmostEqual(sep, 0.0, places=2) # diff on the aberration level


    def test_moon_separation_calculation(self):
        """Test distance to a point roughly 90 degrees away."""
        # Get moon pos
        actual_moon = get_body("moon", self.ref_time_astropy)

        # Create a target 90 deg offset in Declination (simplest separation)
        # If Moon dec is close to 0, adding 90 works.
        # If Moon is at +20, target at -70 is 90 deg away.
        # Safe bet: Point 'opposite' in RA (180 deg away) on celestial equator vs moon.
        # Let's just check it returns a float and is > 0.

        sep = moon_separation(0.0, 0.0, self.ref_time_astropy)

        self.assertIsInstance(sep, float)
        self.assertGreater(sep, 0.0)
        self.assertLessEqual(sep, 180.0)

    # ==========================================
    # Tests for moon_phase
    # ==========================================

    def test_moon_phase_range(self):
        """Test that moon phase is between 0 and 100."""
        phase = moon_phase(self.ref_date, self.lat, self.lon, self.elev)
        self.assertGreaterEqual(phase, 0.0)
        self.assertLessEqual(phase, 100.0)

    def test_moon_phase_accuracy_full_moon(self):
        """Test a known Full Moon date (e.g., Jan 25, 2024)."""
        # Full Moon: 2024-01-25 ~17:54 UTC
        full_moon_date = datetime(2024, 1, 25, 18, 0, 0)
        phase = moon_phase(full_moon_date, self.lat, self.lon, self.elev)

        # Should be very close to 100%
        self.assertGreater(phase, 98.0)

    def test_moon_phase_accuracy_new_moon(self):
        """Test a known New Moon date (e.g., Jan 11, 2024)."""
        # New Moon: 2024-01-11 ~11:57 UTC
        new_moon_date = datetime(2024, 1, 11, 12, 0, 0)
        phase = moon_phase(new_moon_date, self.lat, self.lon, self.elev)

        # Should be very close to 0%
        self.assertLess(phase, 2.0)

class TestOcacal(unittest.TestCase):

    def setUp(self):
        """Set up the location and time for reproducible tests."""
        self.location = EarthLocation(lat=-24.6 * u.deg, lon=-70.2 * u.deg, height=2800 * u.m)
        self.now = Time("2024-05-20 12:00:00", scale='utc')

    # ==========================================
    # Tests (Existing)
    # ==========================================

    def test_sun_ephemeris_structure(self):
        """Check if Sun ephemeris returns correct keys and data types."""
        sun = Sun(self.location)

        # Test for a single time
        result = sun.get_ephemeris(self.now)
        self.assertEqual(len(result), 1)
        item = result[0]

        expected_keys = {'time_utc', 'alt', 'az', 'ra', 'dec', 'body'}
        self.assertTrue(expected_keys.issubset(item.keys()))
        self.assertEqual(item['body'], 'Sun')
        self.assertIsInstance(item['alt'], float)

        # Basic sanity check: At 12:00 UTC in Chile (May), Sun should be visible (Alt > 0)
        # 12:00 UTC is roughly 8:00 AM in Chile.
        self.assertGreater(item['alt'], 0)

    def test_sun_events(self):
        """Check if Sun events (sunset/sunrise) are found."""
        sun = Sun(self.location)
        start_time = Time("2024-01-01 12:00:00")  # Summer in southern hemisphere

        # Check for horizon crossing (0 degrees)
        events = sun.get_events_by_altitude([0], start_time=start_time)

        # In 24h there should be at least a sunset and a sunrise
        self.assertGreaterEqual(len(events), 2)

        for event in events:
            self.assertEqual(event['target_alt'], 0)
            # The actual found altitude should be very close to 0
            self.assertLess(abs(event['actual_alt']), 0.1)

    def test_moon_phase(self):
        """Check if Moon calculations include phase."""
        moon = Moon(self.location)
        result = moon.get_ephemeris(self.now)

        self.assertIn('phase', result[0])
        phase = result[0]['phase']
        self.assertTrue(0.0 <= phase <= 1.0)

    def test_single_star_coords(self):
        """Check if a single Star preserves its RA/Dec and calculates Alt/Az."""
        # Sirius coordinates
        ra = 101.28
        dec = -16.71
        sirius = Star(self.location, ra=ra, dec=dec, name="Sirius")

        result = sirius.get_ephemeris(self.now)
        item = result[0]

        # RA/Dec should be effectively constant (ignoring minor precession differences if strictly J2000 vs current)
        # We check if they are close to input
        np.testing.assert_allclose(item['ra'], ra, atol=0.01)
        np.testing.assert_allclose(item['dec'], dec, atol=0.01)
        self.assertEqual(item['body'], "Sirius")

    def test_multiple_stars_vectorization(self):
        """Check if the Stars class handles multiple targets correctly."""
        catalog = [
            {'id': 'StarA', 'ra': 100.0, 'dec': -10.0},
            {'id': 'StarB', 'ra': 200.0, 'dec': 45.0}
        ]
        stars = Stars(self.location, catalog)

        # Get positions for 2 timestamps
        times = self.now + [0, 1] * u.hour
        results = stars.get_ephemeris(times)

        # Check structure
        self.assertIn('StarA', results)
        self.assertIn('StarB', results)
        self.assertEqual(len(results['StarA']), 2)

        # Check values
        self.assertEqual(results['StarA'][0]['body'], 'StarA')
        np.testing.assert_allclose(results['StarA'][0]['ra'], 100.0)

    def test_events_empty_for_impossible_altitude(self):
        """Check that asking for an impossible altitude returns an empty list."""
        sun = Sun(self.location)
        start_time = Time.now()

        # Sun never reaches 90 degrees (zenith) at -24 latitude
        # (It reaches max ~89 in tropics, but let's take 95 to be sure)
        events = sun.get_events_by_altitude([95], start_time=start_time)

        self.assertIsInstance(events, list)
        self.assertEqual(len(events), 0)

    def test_interpolation_accuracy(self):
        """Verify that the event finder is reasonably precise."""
        # Create a synthetic case or just check Sun at 0
        # If the solver says Sun is at 0 deg at time T,
        # calculating exact position at T should yield ~0 deg.

        sun = Sun(self.location)
        start_time = Time("2024-03-20 10:00:00")  # Equinox approx

        events = sun.get_events_by_altitude([0], start_time=start_time)

        if events:
            first_event = events[0]
            # The 'actual_alt' in the event dict comes from an exact recalculation
            self.assertLess(abs(first_event['actual_alt']), 0.01)
            self.assertLess(abs(first_event['actual_alt'] - first_event['target_alt']), 0.01)

    # ==========================================
    # New Tests for Pyaraucaria Integration
    # ==========================================

    def test_pyaraucaria_dependency_exists(self):
        """Sanity check: ensure pyaraucaria functions are importable and working."""
        from pyaraucaria.coordinates import ra_to_decimal, dec_to_decimal
        # Simple check: 12h = 180 degrees
        self.assertEqual(ra_to_decimal("12:00:00"), 180.0)
        self.assertEqual(dec_to_decimal("00:00:00"), 0.0)

    def test_star_sexagesimal_colon(self):
        """
        Test initializing Star with 'HH:MM:SS' strings.
        Using Sirius as example: ~ 06h 45m 09s, -16d 42m 58s.
        Expected degrees approx: 101.287, -16.716
        """
        # Note: Exact values depend on epoch, but we check if string parsing works mathematically.
        # 06:45:09 = 6.7525 hours * 15 = 101.2875 deg
        # -16:42:58 = -(16 + 42/60 + 58/3600) = -16.7161 deg

        star = Star(self.location, ra="06:45:09", dec="-16:42:58", name="Sirius_Str")

        np.testing.assert_allclose(star.coord.ra.deg, 101.2875, atol=0.001)
        np.testing.assert_allclose(star.coord.dec.deg, -16.7161, atol=0.001)

    def test_star_sexagesimal_space(self):
        """
        Test initializing Star with space-separated strings 'HH MM SS'.
        This validates pyaraucaria's robust parsing capabilities.
        """
        # Vega: 18 36 56 | +38 47 01
        # 18.61555 h * 15 = 279.2333 deg
        # 38.7836 deg

        star = Star(self.location, ra="18 36 56", dec="+38 47 01", name="Vega_Space")

        np.testing.assert_allclose(star.coord.ra.deg, 279.2333, atol=0.001)
        np.testing.assert_allclose(star.coord.dec.deg, 38.7836, atol=0.001)

    def test_star_mixed_input_types(self):
        """
        Ensure Star class can handle both floats (legacy/API) and strings transparently.
        """
        # Case 1: Floats
        s_float = Star(self.location, ra=180.0, dec=0.0)
        self.assertEqual(s_float.coord.ra.deg, 180.0)

        # Case 2: Strings (12h = 180deg)
        s_str = Star(self.location, ra="12:00:00", dec="00:00:00")
        self.assertEqual(s_str.coord.ra.deg, 180.0)

        # They should be identical
        np.testing.assert_allclose(s_float.coord.ra.deg, s_str.coord.ra.deg)


if __name__ == '__main__':
    unittest.main()
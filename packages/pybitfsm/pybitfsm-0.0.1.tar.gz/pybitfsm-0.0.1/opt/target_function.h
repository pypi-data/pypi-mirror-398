#ifndef BITFSM_OPT_TARGET_FUNCTION_H_
#define BITFSM_OPT_TARGET_FUNCTION_H_

#include <cstddef>
#include <cstdint>

#include <array>
#include <vector>

#include <xoshiro256pp.h>

#include "directives.h"
#include "options.h"

namespace bitfsm_opt {

enum class SampleMethod {
  // The sample used for the initial input is all zeros.
  // Should only be used for testing.
  kZero,

  // The sample used for the initial input is generated randomly.
  kRandom,
};

// TODO: Use an option to control the number of bits, and validate
//       it to make sure that parameter_bits >= 2 + max_carries.

// Returns the number of bits that must be generated for each parameter in order
// to distinguish all possible functions that perform at most 'max_carries'
// carry-generating operations.
BITFSM_ALWAYS_INLINE
static unsigned GetParameterBits(unsigned max_carries) {
  // We need 'max_carries + 2' bits to distinguish bitwise functions.
  // See https://math.stackexchange.com/questions/4976971/how-many-bits-are-needed-to-distinguish-functions-over-bit-vectors-given-a-maxim
  return 2 + max_carries;
}

// A collection of inputs and outputs that can be used to exhaustively
// verify if programs generated by the superoptimizer match the
// user-provided function.
template<typename Vec>
class TargetFunction {
 private:
  // A block of inputs and outputs that is sized to fit in a single Vec.
  using Block = std::array<std::uint8_t, Vec::kNumElements>;

  // Input and output data is stored in blocks for vectorized execution.
  // Each block contains 'stride' Vecs, arranged as follows:
  //
  // - block[0]: expected output from the function
  // - block[1]: expected output mask, which has a '1' bit set in each
  //   bit position of the result to compared to the generated function.
  // - block[2..N+1]: values of the N parameters to the function.
  //
  // Elements of each block are processed element-wise, so that for a
  // three-argument function 'func' with 'i' in [0, Vec::kNumElements),
  //
  //   func(block[2][i], block[3][i], block[4][i], &mask) == block[0][i]
  //   mask == block[1][i]

  // The generated data, laid out in blocks.
  //
  // The first block is the initial random sample, while the remaining
  // blocks contain an exhaustive set of inputs, outputs, and masks.
  std::vector<Vec> data_;

  // The number of blocks of data.
  std::size_t size_;

  // The number of Vecs stored for each block of data.
  unsigned stride_;

  // True if at least one case masks off a bit; false if all of the cases
  // must check every bit of the output.
  bool masked_;

  BITFSM_ALWAYS_INLINE
  static unsigned Stride(const Options& options) {
    return 2 + options.num_parameters;
  }

  // Generates a single block of inputs and outputs. This block will be
  // used as the initial check for each generated program before running
  // exhaustive checks.
  static bool Sample(const Options& options, SampleMethod sample_method,
                     xoshiro256pp_state& rng, std::vector<Vec>& data) {
    // TODO: Optimize this method for size. (Eliminate vectors?)
    const unsigned num_parameters = options.num_parameters;
    Block expected;
    Block masks;
    std::vector<Block> parameters(num_parameters);
    std::vector<std::uint8_t> arguments(num_parameters);

    // We need at most 32 bits of randomness per input.
    assert(sizeof(typename Block::value_type) == 1 &&
           num_parameters <= 4);

    data.reserve(Stride(options));
    bool masked = false;
    for (unsigned i = 0; i < Vec::kNumElements; i++) {
      std::uint32_t rand_bits =
          sample_method == SampleMethod::kZero ? 0 : xoshiro256pp_next(&rng);
      for (unsigned j = 0; j < num_parameters; j++) {
        std::uint8_t arg = rand_bits;
        rand_bits >>= 8;
        arguments[j] = arg;
      }
      std::uint8_t mask = std::uint8_t(-1);
      std::uint8_t result = options.func(arguments.data(), &mask);
      for (unsigned j = 0; j < num_parameters; j++) {
        parameters[j][i] = arguments[j];
      }
      expected[i] = result & mask;
      masks[i] = mask;
      masked |= mask != std::uint8_t(-1);
    }

    data.push_back(Vec::Create(expected.data()));
    data.push_back(Vec::Create(masks.data()));
    for (unsigned j = 0; j < num_parameters; j++) {
      data.push_back(Vec::Create(parameters[j].data()));
    }

    return masked;
  }

  // Exhaustively enumerates all inputs and outputs required by 'options',
  // and stores them in 'full' using the block-based layout.
  //
  // Returns 'true' is comparisons must be masked, or 'false' otherwise.
  static bool Enumerate(const Options& options, SampleMethod sample_method,
                        xoshiro256pp_state& rng, std::vector<Vec>& data) {
    // TODO: Optimize this method for size. (Eliminate vectors?)
    Block expected;
    Block masks;
    std::vector<Block> parameters(options.num_parameters);
    std::vector<std::uint8_t> arguments(options.num_parameters);

    const unsigned num_bits = GetParameterBits(options.max_carries);
    const unsigned num_rand_bits = 8 - num_bits;
    const std::size_t count =
        std::size_t(1) << (num_bits * options.num_parameters);
    const std::uint8_t arg_mask = (1 << num_bits) - 1;

    // We need at most 32 bits of randomness per input.
    assert(sizeof(typename Block::value_type) == 1 &&
           options.num_parameters <= 4);

    // Reserve space for the exhaustive set of inputs, plus the sample
    // that has already been generated.
    const std::size_t padded = count + (count % Vec::kNumElements != 0);
    data.reserve(data.size() + padded * Stride(options));

    unsigned buffered = 0;
    bool masked = false;
    for (std::size_t i = 0; i < count; i++) {
      std::uint32_t rand_bits =
          sample_method == SampleMethod::kZero ? 0 : xoshiro256pp_next(&rng);
      for (unsigned j = 0; j < options.num_parameters; j++) {
        // Each low bits 'num_bits' of each argument contain unique bit
        // combinations that distinguish bitwise functions. The remaining
        // bits are filled with random values, since this makes it more
        // likely that any given case will not match.
        unsigned n = (i >> (num_bits * j)) & arg_mask;
        unsigned r = (rand_bits >> (num_rand_bits * j)) << num_bits;
        std::uint8_t arg = r | n;
        arguments[j] = arg;
      }
      std::uint8_t mask = -1;
      std::uint8_t result = options.func(arguments.data(), &mask);
      for (unsigned j = 0; j < options.num_parameters; j++) {
        parameters[j][buffered] = arguments[j];
      }
      expected[buffered] = result & mask;
      masks[buffered] = mask;
      masked |= mask != std::uint8_t(-1);
      if (++buffered == Vec::kNumElements) {
        data.push_back(Vec::Create(expected.data()));
        data.push_back(Vec::Create(masks.data()));
        for (unsigned j = 0; j < options.num_parameters; j++) {
          data.push_back(Vec::Create(parameters[j].data()));
        }
        buffered = 0;
      }
    }
    if (buffered != 0) {
      // Pad out the buffer with copies of the first element of the block
      // to ensure that all elements of the Vec are valid. This is
      // necessary for non-power-of-two Vec sizes, e.g. for 64-bit SWAR.
      for (; buffered < Vec::kNumElements; buffered++) {
        expected[buffered] = expected[0];
        masks[buffered] = masks[0];
        for (unsigned j = 0; j < options.num_parameters; j++) {
          parameters[j][buffered] = parameters[j][0];
        }
      }
      data.push_back(Vec::Create(expected.data()));
      data.push_back(Vec::Create(masks.data()));
      for (unsigned j = 0; j < options.num_parameters; j++) {
        data.push_back(Vec::Create(parameters[j].data()));
      }
    }
    return masked;
  }

 public:
  // Constructs a collection of inputs and outputs representing the function
  // described by 'options'.
  //
  // The 'sample_method' parameter controls how the initial input vector and
  // any unused bits are populated.
  TargetFunction(const Options& options,
                 SampleMethod sample_method = SampleMethod::kRandom) {
    stride_ = Stride(options);
    bool masked = false;
    struct xoshiro256pp_state rng = {
      .s = {
        0x6a1567effa189c45ULL, 0x6ae5ec0b330738d9ULL,
        0x17dd5a2ef5258964ULL, 0x849d329e5446d956ULL,
      }
    };
    masked |= Sample(options, sample_method, rng, data_);
    masked |= Enumerate(options, sample_method, rng, data_);
    masked_ = masked;
    size_ = data_.size() / stride_;
    assert(size_ * stride_ == data_.size());
  }

  // TODO: DOCUMENT THIS
  BITFSM_ALWAYS_INLINE
  std::size_t Size() const {
    return size_;
  }

  BITFSM_ALWAYS_INLINE
  bool Masked() const {
    return masked_;
  }

  BITFSM_ALWAYS_INLINE
  Vec Expected(std::size_t i) const {
    return data_[stride_ * i];
  }

  BITFSM_ALWAYS_INLINE
  Vec Mask(std::size_t i) const {
    return data_[stride_ * i + 1];
  }

  BITFSM_ALWAYS_INLINE
  const Vec* Parameters(std::size_t i) const {
    return &data_[stride_ * i + 2];
  }
};

}; // namespace bitfsm_opt

#endif // BITFSM_OPT_TARGET_FUNCTION_H_

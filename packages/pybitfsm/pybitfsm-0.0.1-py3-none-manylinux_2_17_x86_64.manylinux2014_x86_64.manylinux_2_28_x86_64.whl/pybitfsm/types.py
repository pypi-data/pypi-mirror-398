import dataclasses
import inspect
from typing import Protocol

from . import c_api


class TargetFunction(Protocol):
    '''A function that can be superoptimized.'''
    def __call__(self, k: int, *args: int) -> int:
        '''The superoptimizable function.

        :param k: number of bits in each of the arguments
        :param args: between 1 and 3 `k`-bit arguments

        '''
        ...


@dataclasses.dataclass
class Instruction:
    '''An instruction in a program generated by the superoptimizer.'''
    name: str #: Instruction mnemonic, e.g. 'add'.

    #: Arguments to the instruction. Their interpretation depends on the
    #: instruction name:
    #: - If the name is 'const', then the sole argument is the constant value.
    #: - If the name is 'param', then the sole argument is the parameter index.
    #:   (The first parameter to the function has index 0.)
    #: - Otherwise, each argument is the index of another instruction, the
    #:   output of which is used as input to the corresponding parameter.
    arguments: tuple[int, ...]

    #: Number of other instructions that consume the output of this one.
    #: The final instruction has ``num_uses == 1``, since it is the output.
    num_uses: int

    @staticmethod
    def from_c(isn: c_api.Instruction) -> 'Instruction':
        args = tuple(isn.args[i] for i in range(isn.num_args))
        return Instruction(isn.name, args, isn.num_uses)


@dataclasses.dataclass
class Program:
    '''A program generated by the superoptimizer.'''

    #: The original function being superoptimized.
    function: TargetFunction

    #: The signature of the original function being superoptimized.
    signature: inspect.Signature

    #: The program returned from the optimizer's C API.
    #: Use the 'instructions' property instead, since it's easy to read
    #: uninitialized memory from the C result and trigger a segfault.
    _asm: c_api.AssemblyProgram

    #: Cached list of instruction objects.
    _instructions: tuple[Instruction, ...] = None

    #: Cached list of parameters to the input function.
    _parameters: tuple[inspect.Parameter, ...] = None

    @property
    def instructions(self) -> list[Instruction]:
        if self._instructions is None:
            self._instructions = tuple(Instruction.from_c(self._asm.instructions[i])
                                       for i in range(self._asm.size))
        return self._instructions

    def get_parameter(self, index: int) -> inspect.Parameter:
        if self._parameters is None:
            self._parameters = tuple(self.signature.parameters.values())

        # The first parameter of the function is a bit count, which isn't
        # reflected in the program generated by the superoptimizer.
        return self._parameters[index + 1]

    def __repr__(self) -> str:
        return f'Program(function={self.function!r}, size={self._asm.size!r})'

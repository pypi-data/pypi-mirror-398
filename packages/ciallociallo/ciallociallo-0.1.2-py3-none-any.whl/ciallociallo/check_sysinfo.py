# generated by gpt-5
import os, sys, shutil, platform

def get_size_chars_portable():
    """字符网格尺寸（列, 行）。跨平台首选。"""
    try:
        sz = shutil.get_terminal_size()
        return sz.columns, sz.lines
    except Exception:
        return None, None

# --------- *nix: 通过 CSI “t” 查询窗口/单元尺寸（像素 & 字符） ---------
def _unix_query_csi_t(opcode, timeout_sec=0.2):
    """
    发送 CSI {opcode} t，读取终端响应。
    常见：
      14t -> 报告窗口像素尺寸（应答: CSI 4;H;Wt）
      16t -> 报告字符单元像素尺寸（应答: CSI 6;H;Wt）
      18t -> 报告网格字符尺寸（应答: CSI 8;H;Wt）
    返回: (tag, H, W) 或 None
    """
    import termios, tty, select
    if not sys.stdin.isatty() or not sys.stdout.isatty():
        return None
    fd_in = sys.stdin.fileno()
    fd_out = sys.stdout.fileno()
    old_settings = termios.tcgetattr(fd_in)
    try:
        tty.setcbreak(fd_in)
        os.write(fd_out, f"\x1b[{opcode}t".encode())
        sys.stdout.flush()

        buf = b""
        r, _, _ = select.select([fd_in], [], [], timeout_sec)
        if not r:
            return None
        # 读一点够解析的即可
        while True:
            chunk = os.read(fd_in, 64)
            if not chunk:
                break
            buf += chunk
            if b"t" in chunk:
                break
        # 解析类似 ESC [ number ; H ; W t
        import re
        m = re.search(rb"\x1b\[(\d+);(\d+);(\d+)t", buf)
        if not m:
            return None
        tag, H, W = map(int, m.groups())
        return tag, H, W
    finally:
        termios.tcsetattr(fd_in, termios.TCSADRAIN, old_settings)

def get_cell_pixels_unix():
    """返回 (cell_w_px, cell_h_px) 或 None。"""
    ans = _unix_query_csi_t(16)  # 期望应答 tag=6;H;W
    if ans and ans[0] == 6:
        _, H, W = ans
        return W, H
    return None

def get_win_pixels_unix():
    """返回 (win_w_px, win_h_px) 或 None。"""
    ans = _unix_query_csi_t(14)  # 期望应答 tag=4;H;W
    if ans and ans[0] == 4:
        _, H, W = ans
        return W, H
    return None

def get_grid_chars_unix():
    """返回 (cols, rows) 或 None（优先从 CSI 18 t 取）"""
    ans = _unix_query_csi_t(18)  # 期望应答 tag=8;H;W
    if ans and ans[0] == 8:
        _, rows, cols = ans
        return cols, rows
    return None

# --------- Windows：用 Win32 API 拿字体像素和网格尺寸 ---------
def get_windows_console_info():
    """
    返回 ((cols, rows), (cell_w_px, cell_h_px))，若缺失则用 None。
    """
    try:
        import ctypes
        from ctypes import wintypes

        kernel32 = ctypes.WinDLL("kernel32", use_last_error=True)

        # 获取标准输出句柄
        STD_OUTPUT_HANDLE = -11
        h = kernel32.GetStdHandle(STD_OUTPUT_HANDLE)

        # 结构：控制台缓冲区/窗口信息
        class COORD(ctypes.Structure):
            _fields_ = [("X", wintypes.SHORT), ("Y", wintypes.SHORT)]

        class SMALL_RECT(ctypes.Structure):
            _fields_ = [("Left", wintypes.SHORT), ("Top", wintypes.SHORT),
                        ("Right", wintypes.SHORT), ("Bottom", wintypes.SHORT)]

        class CONSOLE_SCREEN_BUFFER_INFO(ctypes.Structure):
            _fields_ = [("dwSize", COORD),
                        ("dwCursorPosition", COORD),
                        ("wAttributes", wintypes.WORD),
                        ("srWindow", SMALL_RECT),
                        ("dwMaximumWindowSize", COORD)]

        csbi = CONSOLE_SCREEN_BUFFER_INFO()
        cols_rows = (None, None)
        if kernel32.GetConsoleScreenBufferInfo(h, ctypes.byref(csbi)):
            # 可视窗口宽高（字符）
            cols = csbi.srWindow.Right - csbi.srWindow.Left + 1
            rows = csbi.srWindow.Bottom - csbi.srWindow.Top + 1
            cols_rows = (cols, rows)

        # 字体尺寸（像素）
        class CONSOLE_FONT_INFOEX(ctypes.Structure):
            _fields_ = [
                ("cbSize", wintypes.ULONG),
                ("nFont", wintypes.DWORD),
                ("dwFontSize", COORD),
                ("FontFamily", wintypes.UINT),
                ("FontWeight", wintypes.UINT),
                ("FaceName", wintypes.WCHAR * 32),
            ]

        GetCurrentConsoleFontEx = kernel32.GetCurrentConsoleFontEx
        GetCurrentConsoleFontEx.argtypes = [wintypes.HANDLE, wintypes.BOOL, ctypes.POINTER(CONSOLE_FONT_INFOEX)]
        GetCurrentConsoleFontEx.restype = wintypes.BOOL

        cfi = CONSOLE_FONT_INFOEX()
        cfi.cbSize = ctypes.sizeof(CONSOLE_FONT_INFOEX)
        cell = (None, None)
        if GetCurrentConsoleFontEx(h, False, ctypes.byref(cfi)):
            # 注意：dwFontSize.X 是字符宽像素，dwFontSize.Y 是字符高像素
            cell = (int(cfi.dwFontSize.X), int(cfi.dwFontSize.Y))

        return cols_rows, cell
    except Exception:
        return (None, None), (None, None)

# --------- 统一对外 API ---------
def probe_terminal():
    system = platform.system()
    cols, rows = get_size_chars_portable()

    cell_w = cell_h = None
    win_w = win_h = None

    if system == "Windows":
        (c2, r2), (cw, ch) = get_windows_console_info()
        cols = c2 or cols
        rows = r2 or rows
        cell_w, cell_h = cw, ch
    else:
        # 尝试从终端查询
        cw_ch = get_cell_pixels_unix()
        if cw_ch:
            cell_w, cell_h = cw_ch
        # 如果没拿到 cell 像素，但拿到了窗口像素与网格字符，可反推 cell 像素
        if (cell_w is None or cell_h is None):
            gw = get_grid_chars_unix()
            wp = get_win_pixels_unix()
            if gw and wp:
                gcols, grows = gw
                wpx, hpx = wp
                if gcols > 0 and grows > 0:
                    cell_w = wpx // gcols
                    cell_h = hpx // grows

    # 计算比例与建议系数（给 ASCII 画）
    aspect = None
    height_correction = None
    if cell_w and cell_h and cell_w > 0 and cell_h > 0:
        # aspect = 宽:高 的数值（w/h）；height_correction = 高/宽（常用于把图像高度乘这个系数）
        aspect = cell_w / cell_h
        height_correction = cell_h / cell_w

    return {
        "columns": cols,
        "rows": rows,
        "cell_width_px": cell_w,
        "cell_height_px": cell_h,
        "window_width_px": win_w,
        "window_height_px": win_h,
        "cell_aspect_w_over_h": aspect,
        "ascii_height_correction": height_correction,
    }

if __name__ == "__main__":
    info = probe_terminal()
    print(info)
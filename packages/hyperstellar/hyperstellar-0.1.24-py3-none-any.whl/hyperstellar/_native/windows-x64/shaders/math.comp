#version 430 core

/*
 * ============================================================================
 * PHYSICS ENGINE COMPUTE SHADER - EXTENDED COMPLEX SUPPORT + STABLE INTEGRATOR
 * ============================================================================
 */

layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

// ============================================================================
// DATA STRUCTURES (std430 layout)
// ============================================================================

struct Object {
    vec2 position;           // offset 0
    vec2 velocity;           // offset 8
    float mass;              // offset 16
    float charge;            // offset 20
    int visualSkinType;      // offset 24
    int collisionShapeType;  // offset 28
    vec4 visualData;         // offset 32 (.x=width, .y=height, .z=rotation, .w=omega)
    vec4 collisionData;      // offset 48 (.x=ax, .y=ay, .z/.w=user)
    vec4 color;              // offset 64 (r, g, b, a)
    int equationID;          // offset 80
    int _pad1;               // offset 84
    int _padEnd[2];          // offset 88
};

struct EquationMapping {
    int tokenOffset_ax;      int tokenCount_ax;      int constantOffset_ax;      int _pad1;
    int tokenOffset_ay;      int tokenCount_ay;      int constantOffset_ay;      int _pad2;
    int tokenOffset_angular; int tokenCount_angular; int constantOffset_angular; int _pad3;
    int tokenOffset_r;       int tokenCount_r;       int constantOffset_r;       int _pad4;
    int tokenOffset_g;       int tokenCount_g;       int constantOffset_g;       int _pad5;
    int tokenOffset_b;       int tokenCount_b;       int constantOffset_b;       int _pad6;
    int tokenOffset_a;       int tokenCount_a;       int constantOffset_a;       int _pad7;
};

struct Constraint {
    int type;
    int targetObjectID;
    float param1;
    float param2;
    float param3;
    float param4;
    int _pad1;
    int _pad2;
};

struct ObjectConstraints {
    int objectID;
    int numConstraints;
    int constraintOffset;
    int _pad;
};

// ============================================================================
// SHADER STORAGE BUFFERS (SSBOs)
// ============================================================================

layout(std430, binding = 0) readonly buffer ObjectsIn { Object objectsIn[]; };
layout(std430, binding = 1) writeonly buffer ObjectsOut { Object objectsOut[]; };
layout(std430, binding = 2) readonly buffer AllEquationTokens { int allTokens[]; };
layout(std430, binding = 3) readonly buffer AllEquationConstants { float allConstants[]; };
layout(std430, binding = 4) readonly buffer EquationMappings { EquationMapping mappings[256]; };
layout(std430, binding = 5) readonly buffer Constraints { Constraint constraints[]; };
layout(std430, binding = 6) readonly buffer ObjectConstraintMappings { ObjectConstraints objectConstraints[]; };

// ============================================================================
// UNIFORMS
// ============================================================================
uniform float uDt;
uniform float uTime;
uniform float k;
uniform float b;
uniform float g;
uniform vec2 uGravityDir;
uniform float uRestitution;
uniform float uCoupling;
uniform vec2 uExternalForce;
uniform float uDriveFreq;
uniform float uDriveAmp;
uniform int uEquationMode;
uniform int uNumObjects;

// ============================================================================
// CONSTANTS
// ============================================================================
const int TOKEN_NUMBER = 0;
const int TOKEN_VARIABLE = 1;
const int TOKEN_OBJECT_REF = 2;
const int TOKEN_ADD = 3;
const int TOKEN_SUB = 4;
const int TOKEN_MUL = 5;
const int TOKEN_DIV = 6;
const int TOKEN_NEG = 7;
const int TOKEN_POW = 8;
const int TOKEN_SIN = 9;
const int TOKEN_COS = 10;
const int TOKEN_TAN = 11;
const int TOKEN_SQRT = 12;
const int TOKEN_LOG = 13;
const int TOKEN_EXP = 14;
const int TOKEN_ABS = 15;
const int TOKEN_MIN = 16;
const int TOKEN_MAX = 17;
const int TOKEN_CLAMP = 18;
const int TOKEN_FLOOR = 19;
const int TOKEN_CEIL = 20;
const int TOKEN_FRAC = 21;
const int TOKEN_MOD = 22;
const int TOKEN_ATAN2 = 23;
const int TOKEN_REAL = 24;
const int TOKEN_IMAG = 25;
const int TOKEN_CONJ = 26;
const int TOKEN_ARG = 27;
const int TOKEN_SIGN = 28;
const int TOKEN_STEP = 29;
const int TOKEN_OPEN_PAREN = 30;
const int TOKEN_CLOSE_PAREN = 31;
const int TOKEN_COMMA = 32;
const int TOKEN_DERIVATIVE = 33;

const int VAR_HASH_X = 1;
const int VAR_HASH_Y = 2;
const int VAR_HASH_VX = 3;
const int VAR_HASH_VY = 4;
const int VAR_HASH_AX = 5;
const int VAR_HASH_AY = 6;
const int VAR_HASH_T = 7;
const int VAR_HASH_THETA = 8;
const int VAR_HASH_OMEGA = 27;
const int VAR_HASH_MASS = 22;
const int VAR_HASH_CHARGE = 23;
const int VAR_HASH_R = 9;
const int VAR_HASH_G = 10;
const int VAR_HASH_B = 11;
const int VAR_HASH_A = 12;
const int VAR_HASH_VIS_X = 100;
const int VAR_HASH_VIS_Y = 101;
const int VAR_HASH_PI = 17;
const int VAR_HASH_E = 18;
const int VAR_HASH_I = 16;
const int VAR_HASH_K = 19;
const int VAR_HASH_B_DAMP = 20;
const int VAR_HASH_G_GRAV = 21;
const int VAR_HASH_COUPLING = 24;
const int VAR_HASH_FREQ = 25;
const int VAR_HASH_AMP = 26;

const int MAX_RPN_STACK_SIZE = 64;
const int MAX_TOKEN_BUFFER_SIZE = 10000;
const int MAX_CONSTANT_BUFFER_SIZE = 10000;
const int MAX_EQUATION_COUNT = 256;
const float PI = 3.14159265359;
const float E = 2.71828182846;
const float EPSILON = 1e-6;
const float SAFE_MIN_VALUE = 1e-6;
const float SAFE_MAX_EXP = 50.0;
const float DERIVATIVE_H = 1e-4;
const int MAX_DERIV_EXPR_SIZE = 500;
const int CONSTRAINT_DISTANCE = 0;
const int CONSTRAINT_BOUNDARY = 1;
const int CONSTRAINT_ANGLE = 2;
const float CONSTRAINT_STIFFNESS = 0.8;
const int MAX_CONSTRAINT_ITERATIONS = 3;

// ============================================================================
// UTILITY FUNCTIONS (REAL)
// ============================================================================

float safeDivide(float numerator, float denominator) { 
    return (abs(denominator) < EPSILON) ? 0.0 : (numerator / denominator);
}
float safePow(float base, float exponent) { 
    return pow(max(0.0, base), exponent);
}
float safeLog(float value) { 
    return log(max(SAFE_MIN_VALUE, value));
}
float safeExp(float value) { 
    return exp(clamp(value, -SAFE_MAX_EXP, SAFE_MAX_EXP));
}
bool isInvalidFloat(float value) { 
    return isinf(value) || isnan(value);
}
vec2 sanitizeVec2(vec2 v) { 
    if (isInvalidFloat(v.x)) v.x = 0.0;
    if (isInvalidFloat(v.y)) v.y = 0.0; 
    return v;
}
vec4 sanitizeVec4(vec4 v) { 
    if (isInvalidFloat(v.x)) v.x = 0.0;
    if (isInvalidFloat(v.y)) v.y = 0.0;
    if (isInvalidFloat(v.z)) v.z = 0.0; 
    if (isInvalidFloat(v.w)) v.w = 0.0; 
    return v;
}
float signFunc(float x) { return (x > 0.0) ? 1.0 : ((x < 0.0) ? -1.0 : 0.0);
}
float stepFunc(float x) { return (x >= 0.0) ? 1.0 : 0.0;
}

// ============================================================================
// COMPLEX MATH UTILITIES
// ============================================================================

// Complex Addition
vec2 cAdd(vec2 a, vec2 b) { return a + b; }
// Complex Subtraction
vec2 cSub(vec2 a, vec2 b) { return a - b; }
// Complex Multiplication: (a+bi)(c+di) = (ac-bd) + (ad+bc)i
vec2 cMul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}
// Complex Division
vec2 cDiv(vec2 a, vec2 b) {
    float denom = b.x * b.x + b.y * b.y;
    if (abs(denom) < EPSILON) return vec2(0.0);
    return vec2((a.x * b.x + a.y * b.y) / denom, (a.y * b.x - a.x * b.y) / denom);
}
// Complex Log: ln(z) = ln|z| + i*arg(z)
vec2 cLog(vec2 z) {
    float r = length(z);
    float theta = atan(z.y, z.x);
    return vec2(safeLog(r), theta);
}
// Complex Exp: e^(a+bi) = e^a * (cos(b) + i*sin(b))
vec2 cExp(vec2 z) {
    float ea = safeExp(z.x);
    return vec2(ea * cos(z.y), ea * sin(z.y));
}
// Complex Power: a^b = exp(b * ln(a))
vec2 cPow(vec2 base, vec2 exponent) {
    if (length(base) < EPSILON) return vec2(0.0);
    return cExp(cMul(exponent, cLog(base)));
}
// Complex Sine: sin(a+bi) = sin(a)cosh(b) + i*cos(a)sinh(b)
vec2 cSin(vec2 z) {
    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));
}
// Complex Cosine: cos(a+bi) = cos(a)cosh(b) - i*sin(a)sinh(b)
vec2 cCos(vec2 z) {
    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));
}

// ============================================================================
// OBJECT PROPERTY ACCESSOR
// ============================================================================
float getObjectProperty(int targetIndex, int propertyHash, int currentObject) {
    if (targetIndex < 0 || targetIndex >= uNumObjects) return 0.0;
    if (targetIndex == currentObject) return 0.0; 
    
    Object p = objectsIn[targetIndex];
    switch (propertyHash) {
        case VAR_HASH_X: return p.position.x;
        case VAR_HASH_Y: return p.position.y;
        case VAR_HASH_VX: return p.velocity.x;
        case VAR_HASH_VY: return p.velocity.y;
        case VAR_HASH_AX: return p.collisionData.x;
        case VAR_HASH_AY: return p.collisionData.y;
        case VAR_HASH_MASS: return p.mass;
        case VAR_HASH_CHARGE: return p.charge;
        case VAR_HASH_THETA: return p.visualData.z;
        case VAR_HASH_OMEGA: return p.visualData.w;
        case VAR_HASH_R: return p.color.r;
        case VAR_HASH_G: return p.color.g;
        case VAR_HASH_B: return p.color.b;
        case VAR_HASH_A: return p.color.a;
        case VAR_HASH_VIS_X: return p.visualData.x;
        case VAR_HASH_VIS_Y: return p.visualData.y;
    }
    return 0.0;
}

// ============================================================================
// INLINE RPN EVALUATOR (For Numerical Derivatives)
// ============================================================================
vec2 evaluateDerivativeExpression(
    float x, float y, float vx, float vy, float ax_prev, float ay_prev,
    float rotation, float angular_vel, vec4 color,
    float mass, float charge, int objectIndex,
    int componentType, int exprOffset, int exprCount, int constantOffset
) {
    if (exprCount <= 0 || exprCount > MAX_DERIV_EXPR_SIZE) return vec2(0.0);
    // Local stack: Size 128 to hold 64 complex numbers (2 floats each)
    float dstack[128]; 
    bool dIsComplex[64];
    int dstackPtr = 0;
    int dComplexPtr = 0;
    int dtokenIdx = exprOffset;
    for (int di = 0; di < exprCount; ++di) {
        if (dtokenIdx >= MAX_TOKEN_BUFFER_SIZE) break;
        if (dstackPtr >= 126) return vec2(0.0); // Safety margin

        int dtoken = allTokens[dtokenIdx++];
        // --- LITERALS AND VARIABLES ---
        if (dtoken == TOKEN_NUMBER) {
            int dconstIdx = allTokens[dtokenIdx++];
            int dglobalConstIdx = constantOffset + dconstIdx;
            float val = 0.0;
            if (dglobalConstIdx >= 0 && dglobalConstIdx < MAX_CONSTANT_BUFFER_SIZE) {
                val = allConstants[dglobalConstIdx];
            }
            dstack[dstackPtr++] = isInvalidFloat(val) ? 0.0 : val;
            dIsComplex[dComplexPtr++] = false;
        }
        else if (dtoken == TOKEN_VARIABLE) {
            int dvarHash = allTokens[dtokenIdx++];
            // Handle 'i' inside derivative
            if (dvarHash == VAR_HASH_I) {
                dstack[dstackPtr++] = 0.0; // real
                dstack[dstackPtr++] = 1.0; // imag
                dIsComplex[dComplexPtr++] = true;
                continue;
            }

            float dvalue = 0.0;
            switch(dvarHash) {
                case VAR_HASH_X: dvalue = x; break;
                case VAR_HASH_Y: dvalue = y; break;
                case VAR_HASH_VX: dvalue = vx; break;
                case VAR_HASH_VY: dvalue = vy; break;
                case VAR_HASH_AX: dvalue = ax_prev; break;
                case VAR_HASH_AY: dvalue = ay_prev; break;
                case VAR_HASH_T: dvalue = uTime; break;
                case VAR_HASH_THETA: dvalue = rotation; break;
                case VAR_HASH_OMEGA: dvalue = angular_vel; break;
                case VAR_HASH_R: dvalue = color.r; break;
                case VAR_HASH_G: dvalue = color.g; break;
                case VAR_HASH_B: dvalue = color.b; break;
                case VAR_HASH_A: dvalue = color.a; break;
                case VAR_HASH_PI: dvalue = PI; break;
                case VAR_HASH_E: dvalue = E; break;
                case VAR_HASH_K: dvalue = k; break;
                case VAR_HASH_B_DAMP: dvalue = b; break;
                case VAR_HASH_G_GRAV: dvalue = g; break;
                case VAR_HASH_MASS: dvalue = mass; break;
                case VAR_HASH_CHARGE: dvalue = charge; break;
                case VAR_HASH_COUPLING: dvalue = uCoupling; break;
                case VAR_HASH_FREQ: dvalue = uDriveFreq; break;
                case VAR_HASH_AMP: dvalue = uDriveAmp; break;
            }
            dstack[dstackPtr++] = dvalue;
            dIsComplex[dComplexPtr++] = false;
        }
        else if (dtoken == TOKEN_OBJECT_REF) {
            int dobjIndex = allTokens[dtokenIdx++];
            int dpropHash = allTokens[dtokenIdx++];
            float dvalue = getObjectProperty(dobjIndex, dpropHash, objectIndex);
            dstack[dstackPtr++] = isInvalidFloat(dvalue) ? 0.0 : dvalue;
            dIsComplex[dComplexPtr++] = false;
        }
        // --- BINARY OPERATORS ---
        else if (dtoken == TOKEN_ADD || dtoken == TOKEN_SUB || dtoken == TOKEN_MUL || dtoken == TOKEN_DIV || dtoken == TOKEN_POW) {
            if (dComplexPtr < 2) { dstack[0]=0.0; dstackPtr=1; dComplexPtr=1; continue; }
            
            bool b_c = dIsComplex[--dComplexPtr];
            bool a_c = dIsComplex[dComplexPtr-1];
            
            vec2 b_val = b_c ? vec2(dstack[dstackPtr-2], dstack[dstackPtr-1]) : vec2(dstack[dstackPtr-1], 0.0);
            dstackPtr -= (b_c ? 2 : 1);
            vec2 a_val = a_c ? vec2(dstack[dstackPtr-2], dstack[dstackPtr-1]) : vec2(dstack[dstackPtr-1], 0.0);
            dstackPtr -= (a_c ? 2 : 1);
            
            vec2 res = vec2(0.0);
            bool res_c = (a_c || b_c);
            if (dtoken == TOKEN_ADD) res = cAdd(a_val, b_val);
            else if (dtoken == TOKEN_SUB) res = cSub(a_val, b_val);
            else if (dtoken == TOKEN_MUL) {
                res = cMul(a_val, b_val);
                res_c = true;
            }
            else if (dtoken == TOKEN_DIV) {
                res = cDiv(a_val, b_val);
                res_c = true;
            }
            else if (dtoken == TOKEN_POW) {
                if (a_c || b_c) {
                    res = cPow(a_val, b_val);
                    res_c = true;
                } else {
                    if (a_val.x < 0.0) {
                        res = cPow(a_val, b_val);
                        res_c = true;
                    } else {
                        res = vec2(safePow(a_val.x, b_val.x), 0.0);
                        res_c = false;
                    }
                }
            }

            if (res_c) {
                dstack[dstackPtr++] = res.x;
                dstack[dstackPtr++] = res.y;
                dIsComplex[dComplexPtr-1] = true;
            } else {
                dstack[dstackPtr++] = res.x;
                dIsComplex[dComplexPtr-1] = false;
            }
        }
        // --- UNARY OPERATORS ---
        else if (dtoken == TOKEN_SIN || dtoken == TOKEN_COS || dtoken == TOKEN_EXP || dtoken == TOKEN_NEG) {
            if (dComplexPtr < 1) { dstack[0]=0.0; dstackPtr=1; dComplexPtr=1; continue; }
            bool a_c = dIsComplex[dComplexPtr-1];
            vec2 a_val = a_c ? vec2(dstack[dstackPtr-2], dstack[dstackPtr-1]) : vec2(dstack[dstackPtr-1], 0.0);
            dstackPtr -= (a_c ? 2 : 1);
            vec2 res = vec2(0.0);
            bool res_c = a_c;

            if (dtoken == TOKEN_NEG) { res = vec2(-a_val.x, -a_val.y); }
            else if (dtoken == TOKEN_SIN) { res = cSin(a_val); res_c = true; }
            else if (dtoken == TOKEN_COS) { res = cCos(a_val); res_c = true; }
            else if (dtoken == TOKEN_EXP) { res = cExp(a_val); res_c = true; }

            if (res_c) {
                dstack[dstackPtr++] = res.x;
                dstack[dstackPtr++] = res.y;
                dIsComplex[dComplexPtr-1] = true;
            } else {
                dstack[dstackPtr++] = res.x;
                dIsComplex[dComplexPtr-1] = false;
            }
        }
        else if (dtoken == TOKEN_DERIVATIVE) {
            // Nested derivatives skipped
            if (dtokenIdx + 3 < MAX_TOKEN_BUFFER_SIZE) {
                dtokenIdx += 3;
                int nested_count = allTokens[dtokenIdx++];
                dtokenIdx += nested_count;
                di += nested_count + 3;
            }
            dstack[dstackPtr++] = 0.0;
            dIsComplex[dComplexPtr++] = false;
        }
        else {
             // Fallback for real-only ops
        }
    }
    
    if (dstackPtr <= 0) return vec2(0.0);
    if (dIsComplex[0]) return vec2(dstack[0], dstack[1]);
    return vec2(dstack[0], 0.0);
}

// ============================================================================
// MAIN RPN EVALUATOR (Full Feature Set)
// ============================================================================
float evaluateRPNComponent(
    float x, float y, float vx, float vy, float ax_prev, float ay_prev,
    float rotation, float angular_vel, vec4 color,
    float mass, float charge, int objectIndex,
    int componentType,
    int tokenOffset, int tokenCount, int constantOffset
) {
    if (tokenCount <= 0 || tokenCount > 1000) {
        if (componentType == 2) return 0.0;
        if (componentType >= 3 && componentType <= 6) return 1.0;
        return 0.0;
    }
    
    // Stack: 128 floats (64 Complex numbers)
    float stack[128];
    int stackPtr = 0;
    bool isComplex[64];
    int complexStackPtr = 0;
    
    int tokenIdx = tokenOffset;
    for (int i = 0; i < tokenCount; ++i) {
        if (tokenIdx >= MAX_TOKEN_BUFFER_SIZE) return 0.0;
        if (stackPtr >= 126) return 0.0; // Stack overflow guard
        
        int tokenType = allTokens[tokenIdx++];
        // ====================================================================
        // LITERALS AND VARIABLES
        // ====================================================================
        if (tokenType == TOKEN_NUMBER) {
            int constIdx = allTokens[tokenIdx++];
            int globalConstIdx = constantOffset + constIdx;
            float value = 0.0;
            if (globalConstIdx >= 0 && globalConstIdx < MAX_CONSTANT_BUFFER_SIZE) {
                value = allConstants[globalConstIdx];
            }
            if (isInvalidFloat(value)) value = 0.0;
            stack[stackPtr++] = value;
            isComplex[complexStackPtr++] = false;
        }
        else if (tokenType == TOKEN_VARIABLE) {
            int varHash = allTokens[tokenIdx++];
            float value = 0.0;
            
            // Handle imaginary 'i'
            if (varHash == VAR_HASH_I) {
                stack[stackPtr++] = 0.0; // real
                stack[stackPtr++] = 1.0; // imag
                isComplex[complexStackPtr++] = true;
                continue; 
            }
            
            switch(varHash) {
                case VAR_HASH_X: value = x; break;
                case VAR_HASH_Y: value = y; break;
                case VAR_HASH_VX: value = vx; break;
                case VAR_HASH_VY: value = vy; break;
                case VAR_HASH_AX: value = ax_prev; break;
                case VAR_HASH_AY: value = ay_prev; break;
                case VAR_HASH_T: value = uTime; break;
                case VAR_HASH_THETA: value = rotation; break;
                case VAR_HASH_OMEGA: value = angular_vel; break;
                case VAR_HASH_R: value = color.r; break;
                case VAR_HASH_G: value = color.g; break;
                case VAR_HASH_B: value = color.b; break;
                case VAR_HASH_A: value = color.a; break;
                case VAR_HASH_PI: value = PI; break;
                case VAR_HASH_E: value = E; break;
                case VAR_HASH_K: value = k; break;
                case VAR_HASH_B_DAMP: value = b; break;
                case VAR_HASH_G_GRAV: value = g; break;
                case VAR_HASH_MASS: value = mass; break;
                case VAR_HASH_CHARGE: value = charge; break;
                case VAR_HASH_COUPLING: value = uCoupling; break;
                case VAR_HASH_FREQ: value = uDriveFreq; break;
                case VAR_HASH_AMP: value = uDriveAmp; break;
            }
            stack[stackPtr++] = value;
            isComplex[complexStackPtr++] = false;
        }
        else if (tokenType == TOKEN_OBJECT_REF) {
            int objIndex = allTokens[tokenIdx++];
            int propHash = allTokens[tokenIdx++];
            float value = getObjectProperty(objIndex, propHash, objectIndex);
            if (isInvalidFloat(value)) value = 0.0;
            stack[stackPtr++] = value;
            isComplex[complexStackPtr++] = false;
        }
        // ====================================================================
        // NUMERICAL DERIVATIVE (Upgraded for Complex)
        // ====================================================================
        else if (tokenType == TOKEN_DERIVATIVE) {
            int wrtVarHash = allTokens[tokenIdx++];
            int order = allTokens[tokenIdx++];
            int method = allTokens[tokenIdx++];
            int exprCount = allTokens[tokenIdx++];
            int exprOffset = tokenIdx;
            
            float h = DERIVATIVE_H;
            vec2 derivValue = vec2(0.0);
            
            if (order == 1 && exprCount > 0 && exprCount <= MAX_DERIV_EXPR_SIZE) {
                float x_orig = x, y_orig = y, vx_orig = vx, vy_orig = vy;
                float ax_orig = ax_prev, ay_orig = ay_prev;
                float rotation_orig = rotation, angular_vel_orig = angular_vel;
                vec4 color_orig = color;
                // Function to perturb variable
                #define PERTURB(var, delta) \
                if (wrtVarHash == VAR_HASH_X) x = x_orig + delta; \
                else if (wrtVarHash == VAR_HASH_Y) y = y_orig + delta; \
                else if (wrtVarHash == VAR_HASH_VX) vx = vx_orig + delta; \
                else if (wrtVarHash == VAR_HASH_VY) vy = vy_orig + delta; \
                else if (wrtVarHash == VAR_HASH_AX) ax_prev = ax_orig + delta; \
                else if (wrtVarHash == VAR_HASH_AY) ay_prev = ay_orig + delta; \
                else if (wrtVarHash == VAR_HASH_THETA) rotation = rotation_orig + delta; \
                else if (wrtVarHash == VAR_HASH_OMEGA) angular_vel = angular_vel_orig + delta; \
                else if (wrtVarHash == VAR_HASH_R) color.r = color_orig.r + delta; \
                else if (wrtVarHash == VAR_HASH_G) color.g = color_orig.g + delta; \
                else if (wrtVarHash == VAR_HASH_B) color.b = color_orig.b + delta; \
                else if (wrtVarHash == VAR_HASH_A) color.a = color_orig.a + delta;
                // f(x+h)
                PERTURB(wrtVarHash, h);
                vec2 val_plus = evaluateDerivativeExpression(
                    x, y, vx, vy, ax_prev, ay_prev, rotation, angular_vel, color,
                    mass, charge, objectIndex, componentType, exprOffset, exprCount, constantOffset
                );
                // f(x-h)
                PERTURB(wrtVarHash, -h);
                vec2 val_minus = evaluateDerivativeExpression(
                    x, y, vx, vy, ax_prev, ay_prev, rotation, angular_vel, color,
                    mass, charge, objectIndex, componentType, exprOffset, exprCount, constantOffset
                );
                // Restore
                x = x_orig;
                y = y_orig; vx = vx_orig; vy = vy_orig;
                ax_prev = ax_orig; ay_prev = ay_orig;
                rotation = rotation_orig;
                angular_vel = angular_vel_orig;
                color = color_orig;

                // (f(x+h) - f(x-h)) / 2h
                derivValue = (val_plus - val_minus) / (2.0 * h);
            }
            
            // Push result (always complex logic to be safe)
            stack[stackPtr++] = derivValue.x;
            stack[stackPtr++] = derivValue.y;
            isComplex[complexStackPtr++] = true;
            
            tokenIdx += exprCount;
            i += exprCount + 3;
        }
        // ====================================================================
        // BINARY OPERATORS (Updated with Helpers)
        // ====================================================================
        else if (tokenType == TOKEN_ADD || tokenType == TOKEN_SUB || tokenType == TOKEN_MUL || tokenType == TOKEN_DIV) {
            if (complexStackPtr < 2) { stack[0] = 0.0; stackPtr = 1; complexStackPtr = 1; continue; }
            
            bool b_c = isComplex[--complexStackPtr];
            bool a_c = isComplex[complexStackPtr-1];
            
            // Extract operands
            vec2 b_val = b_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (b_c ? 2 : 1);
            vec2 a_val = a_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (a_c ? 2 : 1);
            
            vec2 res = vec2(0.0);
            bool res_c = (a_c || b_c); 

            if (tokenType == TOKEN_ADD) res = cAdd(a_val, b_val);
            else if (tokenType == TOKEN_SUB) res = cSub(a_val, b_val);
            else if (tokenType == TOKEN_MUL) {
                res = cMul(a_val, b_val);
                res_c = true; 
            }
            else if (tokenType == TOKEN_DIV) {
                res = cDiv(a_val, b_val);
                res_c = true;
            }

            if (res_c) {
                stack[stackPtr++] = res.x;
                stack[stackPtr++] = res.y;
                isComplex[complexStackPtr-1] = true;
            } else {
                stack[stackPtr++] = res.x;
                isComplex[complexStackPtr-1] = false;
            }
        }
        // ====================================================================
        // POW (Updated for Complex Base & Exponent)
        // ====================================================================
        else if (tokenType == TOKEN_POW) {
            if (complexStackPtr < 2) { stack[0] = 0.0; stackPtr = 1; complexStackPtr = 1; continue; }
            
            bool b_c = isComplex[--complexStackPtr];
            bool a_c = isComplex[complexStackPtr-1];
            
            vec2 b_val = b_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (b_c ? 2 : 1);
            vec2 a_val = a_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (a_c ? 2 : 1);
            
            // If any complex involved OR base is negative (sqrt(-1)), use complex pow
            if (a_c || b_c || a_val.x < 0.0) {
                vec2 res = cPow(a_val, b_val);
                stack[stackPtr++] = res.x;
                stack[stackPtr++] = res.y;
                isComplex[complexStackPtr-1] = true;
            } else {
                // Real safe pow (matches original behavior for positives)
                stack[stackPtr++] = safePow(a_val.x, b_val.x);
                isComplex[complexStackPtr-1] = false;
            }
        }
        // ====================================================================
        // UNARY OPERATORS (Updated for Complex Support)
        // ====================================================================
        else if (tokenType == TOKEN_NEG || tokenType == TOKEN_SIN || tokenType == TOKEN_COS || 
                 tokenType == TOKEN_TAN || tokenType == TOKEN_EXP || tokenType == TOKEN_LOG ||
                 tokenType == TOKEN_SQRT || tokenType == TOKEN_ABS) {
            
            if (complexStackPtr < 1) { stack[0] = 0.0; stackPtr = 1; complexStackPtr = 1; continue; }
            bool a_c = isComplex[complexStackPtr-1];
            vec2 a_val = a_c ? vec2(stack[stackPtr-2], stack[stackPtr-1]) : vec2(stack[stackPtr-1], 0.0);
            stackPtr -= (a_c ? 2 : 1);
            vec2 res = vec2(0.0);
            bool res_c = a_c; // Inherit complexity by default

            if (tokenType == TOKEN_NEG) { res = vec2(-a_val.x, -a_val.y); }
            else if (tokenType == TOKEN_SIN) { res = cSin(a_val); res_c = true; }
            else if (tokenType == TOKEN_COS) { res = cCos(a_val); res_c = true; }
            else if (tokenType == TOKEN_EXP) { res = cExp(a_val); res_c = true; }
            else if (tokenType == TOKEN_LOG) { res = cLog(a_val); res_c = true; }
            else if (tokenType == TOKEN_SQRT) { res = cPow(a_val, vec2(0.5, 0.0)); res_c = true; }
            else if (tokenType == TOKEN_TAN) { 
                 vec2 s = cSin(a_val);
                 vec2 c = cCos(a_val);
                 res = cDiv(s, c);
                 res_c = true;
            }
            else if (tokenType == TOKEN_ABS) {
                res.x = length(a_val);
                res_c = false; // Magnitude is real
            }

            if (res_c) {
                stack[stackPtr++] = res.x;
                stack[stackPtr++] = res.y;
                isComplex[complexStackPtr-1] = true;
            } else {
                stack[stackPtr++] = res.x;
                isComplex[complexStackPtr-1] = false;
            }
        }
        else if (tokenType == TOKEN_FLOOR) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = floor(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_CEIL) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = ceil(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_FRAC) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = fract(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_SIGN) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = signFunc(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_STEP) {
            if (!isComplex[complexStackPtr-1]) stack[stackPtr-1] = stepFunc(stack[stackPtr-1]);
        }
        else if (tokenType == TOKEN_MOD) {
            if (complexStackPtr < 2) continue;
            complexStackPtr--;
            float b = stack[--stackPtr], a = stack[--stackPtr];
            stack[stackPtr++] = (abs(b) < EPSILON) ? 0.0 : mod(a, b);
            isComplex[complexStackPtr-1] = false;
        }
        else if (tokenType == TOKEN_MIN || tokenType == TOKEN_MAX) {
            if (complexStackPtr < 2) continue;
            complexStackPtr--;
            float b = stack[--stackPtr], a = stack[--stackPtr];
            stack[stackPtr++] = (tokenType == TOKEN_MIN) ? min(a, b) : max(a, b);
            isComplex[complexStackPtr-1] = false;
        }
        else if (tokenType == TOKEN_ATAN2) {
             if (complexStackPtr < 2) continue;
             complexStackPtr--;
             float x_val = stack[--stackPtr], y_val = stack[--stackPtr];
             stack[stackPtr++] = atan(y_val, x_val);
             isComplex[complexStackPtr-1] = false;
        }
        else if (tokenType == TOKEN_CLAMP) {
            if (complexStackPtr < 3) continue;
            complexStackPtr -= 2;
            float max_val = stack[--stackPtr];
            float min_val = stack[--stackPtr];
            float val = stack[--stackPtr];
            stack[stackPtr++] = clamp(val, min_val, max_val);
            isComplex[complexStackPtr-1] = false;
        }
        // ====================================================================
        // COMPLEX SPECIFIC OPS
        // ====================================================================
        else if (tokenType == TOKEN_REAL) {
            if (complexStackPtr < 1) continue;
            if (isComplex[complexStackPtr-1]) {
                stackPtr--;
                // Pop imag
                isComplex[--complexStackPtr] = false;
            }
        }
        else if (tokenType == TOKEN_IMAG) {
            if (complexStackPtr < 1) continue;
            if (isComplex[complexStackPtr-1]) {
                float imag = stack[stackPtr-1];
                stackPtr--; 
                stack[stackPtr-1] = imag; // Real part becomes imag
                isComplex[--complexStackPtr] = false;
            } else {
                stack[stackPtr-1] = 0.0;
                // Real numbers have 0 imaginary part
            }
        }
        else if (tokenType == TOKEN_CONJ) {
            if (complexStackPtr < 1) continue;
            if (isComplex[complexStackPtr-1]) {
                stack[stackPtr-1] = -stack[stackPtr-1];
                // Negate imag
            }
        }
        else if (tokenType == TOKEN_ARG) {
            if (complexStackPtr < 1) continue;
            if (isComplex[complexStackPtr-1]) {
                float imag = stack[--stackPtr], real = stack[stackPtr-1];
                stack[stackPtr-1] = atan(imag, real);
                isComplex[--complexStackPtr] = false;
            } else {
                stack[stackPtr-1] = (stack[stackPtr-1] >= 0.0) ? 0.0 : PI;
            }
        }
    }
    
    float result = (stackPtr > 0) ? stack[0] : 0.0;
    if (isInvalidFloat(result)) {
        if (componentType >= 3 && componentType <= 6) return 1.0;
        return 0.0;
    }
    if (componentType >= 3 && componentType <= 6) result = clamp(result, 0.0, 1.0);
    return result;
}

// ============================================================================
// DEFAULT PHYSICS
// ============================================================================
vec2 calculateDefaultPhysics(vec2 pos, vec2 vel, float mass) {
    vec2 acceleration = vec2(0.0);
    acceleration += uGravityDir * g;
    acceleration -= vel * b;
    return acceleration;
}

// ============================================================================
// CONSTRAINT SOLVERS
// ============================================================================
void solveDistanceConstraint(inout vec2 pos, inout vec2 vel, Constraint c, int objectIndex) {
    if (c.targetObjectID < 0 || c.targetObjectID >= uNumObjects) return;
    if (c.targetObjectID == objectIndex) return;
    Object target = objectsIn[c.targetObjectID];
    vec2 targetPos = target.position;
    float desiredDx = c.param1;
    float desiredDy = c.param2;
    vec2 currentOffset = pos - targetPos;
    vec2 desiredOffset = vec2(desiredDx, desiredDy);
    vec2 error = currentOffset - desiredOffset;
    pos -= error * CONSTRAINT_STIFFNESS;
    vec2 targetVel = target.velocity;
    vec2 relativeVel = vel - targetVel;
    float damping = 0.8;
    vel -= dot(relativeVel, normalize(error + vec2(EPSILON))) * normalize(error + vec2(EPSILON)) * damping;
}

void solveBoundaryConstraint(inout vec2 pos, inout vec2 vel, Constraint c) {
    float x1 = c.param1;
    float x2 = c.param2;
    float y1 = c.param3; float y2 = c.param4;
    float minX = min(x1, x2);
    float maxX = max(x1, x2);
    float minY = min(y1, y2); float maxY = max(y1, y2);
    const float elasticity = 0.7;
    const float friction = 0.95;
    if (pos.x < minX) { pos.x = minX; vel.x = abs(vel.x) * elasticity; vel.y *= friction; } 
    else if (pos.x > maxX) { pos.x = maxX; vel.x = -abs(vel.x) * elasticity; vel.y *= friction; }
    if (pos.y < minY) { pos.y = minY; vel.y = abs(vel.y) * elasticity; vel.x *= friction; } 
    else if (pos.y > maxY) { pos.y = maxY; vel.y = -abs(vel.y) * elasticity; vel.x *= friction; }
}

void solveAngleConstraint(inout vec2 pos, inout vec2 vel, Constraint c, vec2 originalPos) {
    float minAngle = c.param1;
    float maxAngle = c.param2;
    vec2 dir = pos - originalPos;
    float radius = length(dir);
    if (radius < EPSILON) return;
    float currentAngle = atan(dir.y, dir.x);
    currentAngle = mod(currentAngle + 2.0 * PI, 2.0 * PI);
    float normMinAngle = mod(minAngle + 2.0 * PI, 2.0 * PI);
    float normMaxAngle = mod(maxAngle + 2.0 * PI, 2.0 * PI);
    bool outsideBounds = false;
    float correctedAngle = currentAngle;
    if (normMinAngle <= normMaxAngle) {
        if (currentAngle < normMinAngle || currentAngle > normMaxAngle) {
            outsideBounds = true;
            float distToMin = abs(currentAngle - normMinAngle);
            float distToMax = abs(currentAngle - normMaxAngle);
            correctedAngle = (distToMin < distToMax) ? normMinAngle : normMaxAngle;
        }
    } else {
        if (currentAngle < normMinAngle && currentAngle > normMaxAngle) {
            outsideBounds = true;
            float distToMin = abs(currentAngle - normMinAngle);
            float distToMax = abs(currentAngle - normMaxAngle);
            correctedAngle = (distToMin < distToMax) ? normMinAngle : normMaxAngle;
        }
    }
    if (outsideBounds) {
        pos = originalPos + vec2(cos(correctedAngle), sin(correctedAngle)) * radius;
        vec2 radialDir = normalize(pos - originalPos);
        vec2 tangentDir = vec2(-radialDir.y, radialDir.x);
        vel = tangentDir * dot(vel, tangentDir) * 0.9;
    }
}

void applyConstraints(inout vec2 pos, inout vec2 vel, int objectIndex, vec2 originalPos) {
    ObjectConstraints pc = objectConstraints[objectIndex];
    if (pc.numConstraints <= 0) return;
    for (int iter = 0; iter < MAX_CONSTRAINT_ITERATIONS; iter++) {
        for (int i = 0; i < pc.numConstraints; i++) {
            int constraintIdx = pc.constraintOffset + i;
            Constraint c = constraints[constraintIdx];
            if (c.type == CONSTRAINT_DISTANCE) solveDistanceConstraint(pos, vel, c, objectIndex);
            else if (c.type == CONSTRAINT_BOUNDARY) solveBoundaryConstraint(pos, vel, c);
            else if (c.type == CONSTRAINT_ANGLE) solveAngleConstraint(pos, vel, c, originalPos);
        }
    }
}

// ============================================================================
// MAIN COMPUTE SHADER
// ============================================================================
void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (int(gid) >= uNumObjects) return;
    
    Object p = objectsIn[gid];
    vec2 pos = p.position;
    vec2 vel = p.velocity;
    float mass = max(EPSILON, p.mass);
    float charge = p.charge;
    float rotation = p.visualData.z;
    float angular_vel = p.visualData.w;
    vec4 color = p.color;
    int objectIndex = int(gid);
    vec2 originalPos = pos;
    vec2 acceleration = vec2(0.0);
    float angular_accel = 0.0;
    vec4 new_color = color;

    if (uEquationMode == 0) {
        int eqID = p.equationID;
        bool isValidEquation = (eqID >= 0 && eqID < MAX_EQUATION_COUNT) && 
                              (mappings[eqID].tokenCount_ax > 0 || 
                               mappings[eqID].tokenCount_ay > 0 ||
                               mappings[eqID].tokenCount_angular > 0 ||
                               mappings[eqID].tokenCount_r > 0 ||
                               mappings[eqID].tokenCount_g > 0 ||
                               mappings[eqID].tokenCount_b > 0 ||
                               mappings[eqID].tokenCount_a > 0);
        if (!isValidEquation) {
            acceleration = calculateDefaultPhysics(pos, vel, mass);
        } else {
            EquationMapping mapping = mappings[eqID];
            float ax = 0.0;
            float ay = 0.0;
            
            if (mapping.tokenCount_ax > 0) {
                ax = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                        rotation, angular_vel, color, mass, charge, objectIndex,
                                        0, mapping.tokenOffset_ax, mapping.tokenCount_ax, mapping.constantOffset_ax);
            }
            if (mapping.tokenCount_ay > 0) {
                ay = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                        rotation, angular_vel, color, mass, charge, objectIndex,
                                        1, mapping.tokenOffset_ay, mapping.tokenCount_ay, mapping.constantOffset_ay);
            }
            acceleration = sanitizeVec2(vec2(ax, ay));
            if (mapping.tokenCount_angular > 0) {
                angular_accel = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                   rotation, angular_vel, color, mass, charge, objectIndex,
                                                   2, mapping.tokenOffset_angular, mapping.tokenCount_angular, mapping.constantOffset_angular);
                angular_accel = isInvalidFloat(angular_accel) ? 0.0 : angular_accel;
            }
            if (mapping.tokenCount_r > 0) {
                new_color.r = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                 rotation, angular_vel, color, mass, charge, objectIndex,
                                                 3,mapping.tokenOffset_r, mapping.tokenCount_r, mapping.constantOffset_r);
            }
            if (mapping.tokenCount_g > 0) {
                new_color.g = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                 rotation, angular_vel, color, mass, charge, objectIndex,
                                                 4, mapping.tokenOffset_g, mapping.tokenCount_g, mapping.constantOffset_g);
            }
            if (mapping.tokenCount_b > 0) {
                new_color.b = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                 rotation, angular_vel, color, mass, charge, objectIndex,
                                                 5, mapping.tokenOffset_b, mapping.tokenCount_b, mapping.constantOffset_b);
            }
            if (mapping.tokenCount_a > 0) {
                new_color.a = evaluateRPNComponent(pos.x, pos.y, vel.x, vel.y, p.collisionData.x, p.collisionData.y,
                                                 rotation, angular_vel, color, mass, charge, objectIndex,
                                                 6, mapping.tokenOffset_a, mapping.tokenCount_a, mapping.constantOffset_a);
            }
            new_color = sanitizeVec4(new_color);
        }
    } else {
        acceleration = calculateDefaultPhysics(pos, vel, mass);
    }
    
    acceleration = sanitizeVec2(acceleration);

    // ============================================================================
    // STABLE INTEGRATION FIX (SYMPLECTIC EULER)
    // ============================================================================
    // 1. Update VELOCITY first
    vec2 new_vel = vel + acceleration * uDt;
    new_vel = sanitizeVec2(new_vel);

    // 2. Use NEW VELOCITY to update POSITION (Energy Conserving)
    vec2 new_pos = pos + new_vel * uDt;
    new_pos = sanitizeVec2(new_pos);

    // 3. Same for Angular
    float new_angular_vel = angular_vel + angular_accel * uDt;
    float new_rotation = rotation + new_angular_vel * uDt; // Use new_angular_vel
    new_rotation = mod(new_rotation, 2.0 * PI);
    
    // World Bounds
    const vec2 world_min = vec2(-100.0, -100.0);
    const vec2 world_max = vec2(100.0, 100.0);
    const float friction = 0.95;

    if (new_pos.x < world_min.x) { new_pos.x = world_min.x; new_vel.x = abs(new_vel.x) * uRestitution; new_vel.y *= friction; } 
    else if (new_pos.x > world_max.x) { new_pos.x = world_max.x; new_vel.x = -abs(new_vel.x) * uRestitution; new_vel.y *= friction; }
    
    if (new_pos.y < world_min.y) { new_pos.y = world_min.y; new_vel.y = abs(new_vel.y) * uRestitution; new_vel.x *= friction; } 
    else if (new_pos.y > world_max.y) { new_pos.y = world_max.y; new_vel.y = -abs(new_vel.y) * uRestitution; new_vel.x *= friction; }
    
    applyConstraints(new_pos, new_vel, objectIndex, originalPos);
    
    new_pos = sanitizeVec2(new_pos);
    new_vel = sanitizeVec2(new_vel);

    objectsOut[gid].position = new_pos;
    objectsOut[gid].velocity = new_vel;
    objectsOut[gid].mass = mass;
    objectsOut[gid].charge = charge;
    objectsOut[gid].visualSkinType = p.visualSkinType;
    objectsOut[gid].collisionShapeType = p.collisionShapeType;
    objectsOut[gid].visualData.x = p.visualData.x;
    objectsOut[gid].visualData.y = p.visualData.y;
    objectsOut[gid].visualData.z = new_rotation;
    objectsOut[gid].visualData.w = new_angular_vel;
    objectsOut[gid].collisionData.x = acceleration.x;
    objectsOut[gid].collisionData.y = acceleration.y;  
    objectsOut[gid].collisionData.z = p.collisionData.z;  
    objectsOut[gid].collisionData.w = p.collisionData.w;
    objectsOut[gid].color = new_color;
    objectsOut[gid].equationID = p.equationID;
    objectsOut[gid]._pad1 = 0;
    objectsOut[gid]._padEnd[0] = 0;  
    objectsOut[gid]._padEnd[1] = 0;
}
"""
Tests for Rust resolver.
"""

from unittest.mock import MagicMock, patch

import pytest

from oss_sustain_guard.resolvers.rust import RustResolver


class TestRustResolver:
    """Test RustResolver class."""

    def test_ecosystem_name(self):
        """Test ecosystem name."""
        resolver = RustResolver()
        assert resolver.ecosystem_name == "rust"

    def test_get_manifest_files(self):
        """Test manifest files for Rust."""
        resolver = RustResolver()
        manifests = resolver.get_manifest_files()
        assert "Cargo.toml" in manifests

    @patch("httpx.Client.get")
    def test_resolve_github_url_success(self, mock_get):
        """Test resolving GitHub URL from crates.io."""
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "crate": {
                "repository": "https://github.com/tokio-rs/tokio",
            }
        }
        mock_get.return_value = mock_response

        resolver = RustResolver()
        result = resolver.resolve_github_url("tokio")
        assert result == ("tokio-rs", "tokio")

    @patch("httpx.Client.get")
    def test_resolve_github_url_with_git_suffix(self, mock_get):
        """Test resolving URL with .git suffix."""
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "crate": {
                "repository": "https://github.com/serde-rs/serde.git",
            }
        }
        mock_get.return_value = mock_response

        resolver = RustResolver()
        result = resolver.resolve_github_url("serde")
        assert result == ("serde-rs", "serde")

    @patch("httpx.Client.get")
    def test_resolve_github_url_not_found(self, mock_get):
        """Test resolving crate with no GitHub URL."""
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "crate": {
                "repository": None,
            }
        }
        mock_get.return_value = mock_response

        resolver = RustResolver()
        result = resolver.resolve_github_url("some-crate")
        assert result is None

    @patch("httpx.Client.get")
    def test_resolve_github_url_network_error(self, mock_get):
        """Test resolving with network error."""
        import httpx

        mock_get.side_effect = httpx.RequestError("Network error")

        resolver = RustResolver()
        result = resolver.resolve_github_url("tokio")
        assert result is None

    def test_detect_lockfiles(self, tmp_path):
        """Test detecting Rust lockfiles."""
        (tmp_path / "Cargo.lock").touch()
        (tmp_path / "Cargo.toml").touch()

        resolver = RustResolver()
        lockfiles = resolver.detect_lockfiles(str(tmp_path))

        assert len(lockfiles) == 1
        assert lockfiles[0].name == "Cargo.lock"

    def test_parse_cargo_lock(self, tmp_path):
        """Test parsing Cargo.lock."""
        cargo_lock_content = """# This file is automatically @generated by Cargo.

[[package]]
name = "tokio"
version = "1.32.0"

[[package]]
name = "serde"
version = "1.0.164"

[[package]]
name = "regex"
version = "1.9.0"
"""
        lock_file = tmp_path / "Cargo.lock"
        lock_file.write_text(cargo_lock_content)

        resolver = RustResolver()
        packages = resolver.parse_lockfile(str(lock_file))

        assert len(packages) == 3
        names = {p.name for p in packages}
        assert "tokio" in names
        assert "serde" in names
        assert "regex" in names
        assert all(p.ecosystem == "rust" for p in packages)

    def test_parse_lockfile_not_found(self):
        """Test parsing non-existent lockfile."""
        resolver = RustResolver()
        with pytest.raises(FileNotFoundError):
            resolver.parse_lockfile("/nonexistent/Cargo.lock")

    def test_parse_lockfile_unknown_type(self, tmp_path):
        """Test parsing unknown lockfile type."""
        unknown_file = tmp_path / "unknown.lock"
        unknown_file.touch()

        resolver = RustResolver()
        with pytest.raises(ValueError, match="Unknown Rust lockfile type"):
            resolver.parse_lockfile(str(unknown_file))

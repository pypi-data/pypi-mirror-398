/**
 * Wu Forensics - Fixed-Point FFT (Q15) Implementation
 *
 * Radix-2 decimation-in-time FFT using Q15 fixed-point arithmetic.
 * All operations are integer-only to guarantee deterministic results.
 *
 * Based on the Cooley-Tukey algorithm with precomputed twiddle factors.
 */

#include "wu_fft_q15.h"

/* ============================================================================
 * PRECOMPUTED TWIDDLE FACTORS
 *
 * cos and sin values in Q15 format for N=512.
 * Generated offline to avoid any floating-point at runtime.
 * ============================================================================ */

/* Twiddle factors for 512-point FFT (quarter wave, exploit symmetry) */
static const q15_t twiddle_cos_512[256] = {
    32767, 32757, 32728, 32678, 32609, 32521, 32412, 32285,
    32137, 31971, 31785, 31580, 31356, 31113, 30852, 30571,
    30273, 29956, 29621, 29268, 28898, 28510, 28105, 27683,
    27245, 26790, 26319, 25832, 25329, 24811, 24279, 23731,
    23170, 22594, 22005, 21403, 20787, 20159, 19519, 18868,
    18204, 17530, 16846, 16151, 15446, 14732, 14010, 13279,
    12539, 11793, 11039, 10278,  9512,  8739,  7962,  7179,
     6393,  5602,  4808,  4011,  3212,  2410,  1608,   804,
        0,  -804, -1608, -2410, -3212, -4011, -4808, -5602,
    -6393, -7179, -7962, -8739, -9512,-10278,-11039,-11793,
   -12539,-13279,-14010,-14732,-15446,-16151,-16846,-17530,
   -18204,-18868,-19519,-20159,-20787,-21403,-22005,-22594,
   -23170,-23731,-24279,-24811,-25329,-25832,-26319,-26790,
   -27245,-27683,-28105,-28510,-28898,-29268,-29621,-29956,
   -30273,-30571,-30852,-31113,-31356,-31580,-31785,-31971,
   -32137,-32285,-32412,-32521,-32609,-32678,-32728,-32757,
   -32767,-32757,-32728,-32678,-32609,-32521,-32412,-32285,
   -32137,-31971,-31785,-31580,-31356,-31113,-30852,-30571,
   -30273,-29956,-29621,-29268,-28898,-28510,-28105,-27683,
   -27245,-26790,-26319,-25832,-25329,-24811,-24279,-23731,
   -23170,-22594,-22005,-21403,-20787,-20159,-19519,-18868,
   -18204,-17530,-16846,-16151,-15446,-14732,-14010,-13279,
   -12539,-11793,-11039,-10278, -9512, -8739, -7962, -7179,
    -6393, -5602, -4808, -4011, -3212, -2410, -1608,  -804,
        0,   804,  1608,  2410,  3212,  4011,  4808,  5602,
     6393,  7179,  7962,  8739,  9512, 10278, 11039, 11793,
    12539, 13279, 14010, 14732, 15446, 16151, 16846, 17530,
    18204, 18868, 19519, 20159, 20787, 21403, 22005, 22594,
    23170, 23731, 24279, 24811, 25329, 25832, 26319, 26790,
    27245, 27683, 28105, 28510, 28898, 29268, 29621, 29956,
    30273, 30571, 30852, 31113, 31356, 31580, 31785, 31971,
    32137, 32285, 32412, 32521, 32609, 32678, 32728, 32757
};

static const q15_t twiddle_sin_512[256] = {
        0,   804,  1608,  2410,  3212,  4011,  4808,  5602,
     6393,  7179,  7962,  8739,  9512, 10278, 11039, 11793,
    12539, 13279, 14010, 14732, 15446, 16151, 16846, 17530,
    18204, 18868, 19519, 20159, 20787, 21403, 22005, 22594,
    23170, 23731, 24279, 24811, 25329, 25832, 26319, 26790,
    27245, 27683, 28105, 28510, 28898, 29268, 29621, 29956,
    30273, 30571, 30852, 31113, 31356, 31580, 31785, 31971,
    32137, 32285, 32412, 32521, 32609, 32678, 32728, 32757,
    32767, 32757, 32728, 32678, 32609, 32521, 32412, 32285,
    32137, 31971, 31785, 31580, 31356, 31113, 30852, 30571,
    30273, 29956, 29621, 29268, 28898, 28510, 28105, 27683,
    27245, 26790, 26319, 25832, 25329, 24811, 24279, 23731,
    23170, 22594, 22005, 21403, 20787, 20159, 19519, 18868,
    18204, 17530, 16846, 16151, 15446, 14732, 14010, 13279,
    12539, 11793, 11039, 10278,  9512,  8739,  7962,  7179,
     6393,  5602,  4808,  4011,  3212,  2410,  1608,   804,
        0,  -804, -1608, -2410, -3212, -4011, -4808, -5602,
    -6393, -7179, -7962, -8739, -9512,-10278,-11039,-11793,
   -12539,-13279,-14010,-14732,-15446,-16151,-16846,-17530,
   -18204,-18868,-19519,-20159,-20787,-21403,-22005,-22594,
   -23170,-23731,-24279,-24811,-25329,-25832,-26319,-26790,
   -27245,-27683,-28105,-28510,-28898,-29268,-29621,-29956,
   -30273,-30571,-30852,-31113,-31356,-31580,-31785,-31971,
   -32137,-32285,-32412,-32521,-32609,-32678,-32728,-32757,
   -32767,-32757,-32728,-32678,-32609,-32521,-32412,-32285,
   -32137,-31971,-31785,-31580,-31356,-31113,-30852,-30571,
   -30273,-29956,-29621,-29268,-28898,-28510,-28105,-27683,
   -27245,-26790,-26319,-25832,-25329,-24811,-24279,-23731,
   -23170,-22594,-22005,-21403,-20787,-20159,-19519,-18868,
   -18204,-17530,-16846,-16151,-15446,-14732,-14010,-13279,
   -12539,-11793,-11039,-10278, -9512, -8739, -7962, -7179,
    -6393, -5602, -4808, -4011, -3212, -2410, -1608,  -804
};

/* Hamming window coefficients for 512 samples (Q15) */
static const q15_t hamming_512[512] = {
    2621, 2627, 2645, 2675, 2717, 2771, 2837, 2915,
    3005, 3107, 3220, 3346, 3483, 3632, 3793, 3966,
    4150, 4346, 4554, 4773, 5004, 5246, 5500, 5765,
    6041, 6329, 6628, 6938, 7259, 7591, 7934, 8288,
    8653, 9028, 9414, 9810,10217,10634,11061,11498,
   11945,12402,12868,13344,13830,14325,14829,15342,
   15864,16394,16933,17481,18036,18600,19171,19750,
   20336,20930,21530,22137,22751,23371,23997,24629,
   25266,25909,26557,27210,27868,28530,29196,29866,
   30540,31217,31898,32581,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32767,32767,32767,32767,32767,32767,32767,32767,
   32581,31898,31217,30540,29866,29196,28530,27868,
   27210,26557,25909,25266,24629,23997,23371,22751,
   22137,21530,20930,20336,19750,19171,18600,18036,
   17481,16933,16394,15864,15342,14829,14325,13830,
   13344,12868,12402,11945,11498,11061,10634,10217,
    9810, 9414, 9028, 8653, 8288, 7934, 7591, 7259,
    6938, 6628, 6329, 6041, 5765, 5500, 5246, 5004,
    4773, 4554, 4346, 4150, 3966, 3793, 3632, 3483,
    3346, 3220, 3107, 3005, 2915, 2837, 2771, 2717,
    2675, 2645, 2627, 2621, 2621, 2627, 2645, 2675
};

/* ============================================================================
 * HELPER FUNCTIONS
 * ============================================================================ */

/**
 * Q15 saturating multiply: (a * b) >> 15 with saturation.
 * This is the core fixed-point operation.
 */
static inline q15_t q15_mul(q15_t a, q15_t b) {
    q31_t result = ((q31_t)a * (q31_t)b) >> 15;
    /* Saturate to Q15 range */
    if (result > 32767) return 32767;
    if (result < -32768) return -32768;
    return (q15_t)result;
}

/**
 * Q15 saturating add.
 */
static inline q15_t q15_add(q15_t a, q15_t b) {
    q31_t result = (q31_t)a + (q31_t)b;
    if (result > 32767) return 32767;
    if (result < -32768) return -32768;
    return (q15_t)result;
}

/**
 * Q15 saturating subtract.
 */
static inline q15_t q15_sub(q15_t a, q15_t b) {
    q31_t result = (q31_t)a - (q31_t)b;
    if (result > 32767) return 32767;
    if (result < -32768) return -32768;
    return (q15_t)result;
}

/**
 * Bit-reversal permutation for in-place FFT.
 */
static void bit_reverse(q15_t* real, q15_t* imag, size_t n) {
    size_t j = 0;
    for (size_t i = 0; i < n - 1; i++) {
        if (i < j) {
            /* Swap real[i] and real[j] */
            q15_t tmp = real[i];
            real[i] = real[j];
            real[j] = tmp;
            /* Swap imag[i] and imag[j] */
            tmp = imag[i];
            imag[i] = imag[j];
            imag[j] = tmp;
        }
        size_t k = n >> 1;
        while (k <= j) {
            j -= k;
            k >>= 1;
        }
        j += k;
    }
}

/**
 * Integer square root (deterministic).
 * Uses binary search - no floating point.
 */
static uint16_t isqrt32(uint32_t x) {
    if (x == 0) return 0;

    uint32_t result = 0;
    uint32_t bit = 1UL << 30;  /* Start with highest power of 4 <= x */

    while (bit > x) bit >>= 2;

    while (bit != 0) {
        if (x >= result + bit) {
            x -= result + bit;
            result = (result >> 1) + bit;
        } else {
            result >>= 1;
        }
        bit >>= 2;
    }
    return (uint16_t)result;
}

/* ============================================================================
 * FFT IMPLEMENTATION
 * ============================================================================ */

void wu_fft_q15(q15_t* real, q15_t* imag, size_t n) {
    if (n == 0 || (n & (n - 1)) != 0) return;  /* Must be power of 2 */
    if (n > 512) return;  /* Maximum supported size */

    /* Bit-reversal permutation */
    bit_reverse(real, imag, n);

    /* Cooley-Tukey radix-2 DIT */
    size_t twiddle_step = 512 / n;  /* Scale factor for twiddle lookup */

    for (size_t stage = 1; stage < n; stage <<= 1) {
        size_t step = stage << 1;
        size_t twiddle_inc = 256 / stage;  /* Twiddle index increment */

        for (size_t group = 0; group < n; group += step) {
            size_t twiddle_idx = 0;

            for (size_t pair = 0; pair < stage; pair++) {
                size_t i = group + pair;
                size_t j = i + stage;

                /* Get twiddle factor (W_n^k = cos - j*sin) */
                q15_t cos_val = twiddle_cos_512[twiddle_idx * twiddle_step];
                q15_t sin_val = twiddle_sin_512[twiddle_idx * twiddle_step];

                /* Butterfly operation:
                 * t = W * x[j]
                 * x[j] = x[i] - t
                 * x[i] = x[i] + t
                 *
                 * Where t_real = cos*real[j] + sin*imag[j]
                 *       t_imag = cos*imag[j] - sin*real[j]
                 */
                q31_t t_real = ((q31_t)cos_val * real[j] + (q31_t)sin_val * imag[j]) >> 15;
                q31_t t_imag = ((q31_t)cos_val * imag[j] - (q31_t)sin_val * real[j]) >> 15;

                /* Apply scaling (divide by 2 each stage to prevent overflow) */
                q15_t scaled_i_real = real[i] >> 1;
                q15_t scaled_i_imag = imag[i] >> 1;
                q15_t scaled_t_real = (q15_t)(t_real >> 1);
                q15_t scaled_t_imag = (q15_t)(t_imag >> 1);

                real[j] = q15_sub(scaled_i_real, scaled_t_real);
                imag[j] = q15_sub(scaled_i_imag, scaled_t_imag);
                real[i] = q15_add(scaled_i_real, scaled_t_real);
                imag[i] = q15_add(scaled_i_imag, scaled_t_imag);

                twiddle_idx += twiddle_inc;
            }
        }
    }
}

void wu_ifft_q15(q15_t* real, q15_t* imag, size_t n) {
    /* IFFT: negate imaginary, do FFT, negate imaginary, scale */
    for (size_t i = 0; i < n; i++) {
        imag[i] = -imag[i];
    }

    wu_fft_q15(real, imag, n);

    for (size_t i = 0; i < n; i++) {
        imag[i] = -imag[i];
    }
    /* Note: Scaling already applied in forward FFT */
}

void wu_fft_magnitude_q15(
    const q15_t* real,
    const q15_t* imag,
    q15_t* magnitude,
    size_t n
) {
    for (size_t i = 0; i < n; i++) {
        /* Compute re² + im² */
        q31_t re = (q31_t)real[i];
        q31_t im = (q31_t)imag[i];
        uint32_t sum_sq = (uint32_t)(re * re + im * im);

        /* Integer square root */
        uint16_t mag = isqrt32(sum_sq);

        /* Clamp to Q15 range */
        magnitude[i] = (mag > 32767) ? 32767 : (q15_t)mag;
    }
}

void wu_apply_hamming_q15(q15_t* samples, size_t n) {
    if (n != 512) return;  /* Only 512 supported currently */

    for (size_t i = 0; i < n; i++) {
        samples[i] = q15_mul(samples[i], hamming_512[i]);
    }
}

/* ============================================================================
 * SIGNAL PROCESSING UTILITIES
 * ============================================================================ */

void wu_median3_q15(const q15_t* in, q15_t* out, size_t n) {
    if (n < 3) {
        for (size_t i = 0; i < n; i++) out[i] = in[i];
        return;
    }

    /* First element: median of [in[0], in[0], in[1]] */
    out[0] = (in[0] < in[1]) ? in[0] : in[1];
    if (out[0] < in[0]) out[0] = in[0];

    /* Middle elements */
    for (size_t i = 1; i < n - 1; i++) {
        q15_t a = in[i - 1];
        q15_t b = in[i];
        q15_t c = in[i + 1];

        /* Find median of three values */
        if (a <= b) {
            if (b <= c) out[i] = b;
            else if (a <= c) out[i] = c;
            else out[i] = a;
        } else {
            if (a <= c) out[i] = a;
            else if (b <= c) out[i] = c;
            else out[i] = b;
        }
    }

    /* Last element */
    out[n - 1] = (in[n - 2] < in[n - 1]) ? in[n - 2] : in[n - 1];
    if (out[n - 1] < in[n - 1]) out[n - 1] = in[n - 1];
}

size_t wu_find_peaks_q15(
    const q15_t* data,
    size_t n,
    size_t min_idx,
    size_t max_idx,
    q15_t threshold,
    size_t* peaks_out,
    size_t max_peaks
) {
    if (max_idx > n) max_idx = n;
    if (min_idx >= max_idx || max_peaks == 0) return 0;

    size_t peak_count = 0;

    for (size_t i = min_idx + 1; i < max_idx - 1 && peak_count < max_peaks; i++) {
        /* Check if local maximum and above threshold */
        if (data[i] > data[i - 1] &&
            data[i] > data[i + 1] &&
            data[i] >= threshold) {
            peaks_out[peak_count++] = i;
        }
    }

    return peak_count;
}

int32_t wu_xcorr_q15(
    const q15_t* a,
    const q15_t* b,
    size_t n,
    size_t max_lag,
    q15_t* corr_out
) {
    if (max_lag >= n) max_lag = n - 1;

    int32_t best_lag = 0;
    q31_t best_corr = -2147483647;  /* INT32_MIN + 1 */

    /* Compute correlation for each lag */
    for (int32_t lag = -(int32_t)max_lag; lag <= (int32_t)max_lag; lag++) {
        q31_t sum = 0;
        size_t count = 0;

        for (size_t i = 0; i < n; i++) {
            int32_t j = (int32_t)i + lag;
            if (j >= 0 && j < (int32_t)n) {
                sum += ((q31_t)a[i] * (q31_t)b[j]) >> 8;  /* Scale down to avoid overflow */
                count++;
            }
        }

        /* Normalise by count */
        if (count > 0) {
            sum = sum / (q31_t)count;
        }

        if (sum > best_corr) {
            best_corr = sum;
            best_lag = lag;
        }
    }

    /* Convert best correlation to Q15 (approximate) */
    if (corr_out) {
        if (best_corr > 32767) *corr_out = 32767;
        else if (best_corr < -32768) *corr_out = -32768;
        else *corr_out = (q15_t)best_corr;
    }

    return best_lag;
}

# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

@typing.final
class AnalysisResults:
    @property
    def string_combis(self) -> builtins.dict[builtins.str, Combination]: ...
    @string_combis.setter
    def string_combis(self, value: builtins.dict[builtins.str, Combination]) -> None: ...
    @property
    def string_superrules(self) -> builtins.list[Combination]: ...
    @string_superrules.setter
    def string_superrules(self, value: builtins.list[Combination]) -> None: ...
    @property
    def utf16_combis(self) -> builtins.dict[builtins.str, Combination]: ...
    @utf16_combis.setter
    def utf16_combis(self, value: builtins.dict[builtins.str, Combination]) -> None: ...
    @property
    def utf16_superrules(self) -> builtins.list[Combination]: ...
    @utf16_superrules.setter
    def utf16_superrules(self, value: builtins.list[Combination]) -> None: ...
    @property
    def opcode_combis(self) -> builtins.dict[builtins.str, Combination]: ...
    @opcode_combis.setter
    def opcode_combis(self, value: builtins.dict[builtins.str, Combination]) -> None: ...
    @property
    def opcode_superrules(self) -> builtins.list[Combination]: ...
    @opcode_superrules.setter
    def opcode_superrules(self, value: builtins.list[Combination]) -> None: ...
    @property
    def file_strings(self) -> builtins.dict[builtins.str, builtins.list[TokenInfo]]: ...
    @file_strings.setter
    def file_strings(self, value: builtins.dict[builtins.str, builtins.list[TokenInfo]]) -> None: ...
    @property
    def file_opcodes(self) -> builtins.dict[builtins.str, builtins.list[TokenInfo]]: ...
    @file_opcodes.setter
    def file_opcodes(self, value: builtins.dict[builtins.str, builtins.list[TokenInfo]]) -> None: ...
    @property
    def file_utf16strings(self) -> builtins.dict[builtins.str, builtins.list[TokenInfo]]: ...
    @file_utf16strings.setter
    def file_utf16strings(self, value: builtins.dict[builtins.str, builtins.list[TokenInfo]]) -> None: ...
    @property
    def file_infos(self) -> builtins.dict[builtins.str, FileInfo]: ...
    @file_infos.setter
    def file_infos(self, value: builtins.dict[builtins.str, FileInfo]) -> None: ...

@typing.final
class Combination:
    @property
    def count(self) -> builtins.int: ...
    @count.setter
    def count(self, value: builtins.int) -> None: ...
    @property
    def strings(self) -> builtins.list[TokenInfo]: ...
    @strings.setter
    def strings(self, value: builtins.list[TokenInfo]) -> None: ...
    @property
    def files(self) -> builtins.set[builtins.str]: ...
    @files.setter
    def files(self, value: builtins.set[builtins.str]) -> None: ...

@typing.final
class Config:
    @property
    def min_string_len(self) -> builtins.int: ...
    @min_string_len.setter
    def min_string_len(self, value: builtins.int) -> None: ...
    @property
    def max_string_len(self) -> builtins.int: ...
    @max_string_len.setter
    def max_string_len(self, value: builtins.int) -> None: ...
    @property
    def max_file_size_mb(self) -> builtins.int: ...
    @max_file_size_mb.setter
    def max_file_size_mb(self, value: builtins.int) -> None: ...
    @property
    def max_file_count(self) -> builtins.int: ...
    @max_file_count.setter
    def max_file_count(self, value: builtins.int) -> None: ...
    @property
    def recursive(self) -> builtins.bool: ...
    @recursive.setter
    def recursive(self, value: builtins.bool) -> None: ...
    @property
    def extensions(self) -> typing.Optional[builtins.list[builtins.str]]: ...
    @extensions.setter
    def extensions(self, value: typing.Optional[builtins.list[builtins.str]]) -> None: ...
    @property
    def extract_opcodes(self) -> builtins.bool: ...
    @extract_opcodes.setter
    def extract_opcodes(self, value: builtins.bool) -> None: ...
    @property
    def debug(self) -> builtins.bool: ...
    @debug.setter
    def debug(self, value: builtins.bool) -> None: ...
    def __new__(cls, min_string_len: typing.Optional[builtins.int] = None, max_string_len: typing.Optional[builtins.int] = None, max_file_size_mb: typing.Optional[builtins.int] = None, recursive: typing.Optional[builtins.bool] = None, extensions: typing.Optional[typing.Sequence[builtins.str]] = None, extract_opcodes: typing.Optional[builtins.bool] = None, debug: typing.Optional[builtins.bool] = None, max_file_count: typing.Optional[builtins.int] = None) -> Config: ...
    @staticmethod
    def create(min_string_len: typing.Optional[builtins.int], max_string_len: typing.Optional[builtins.int], max_file_size_mb: typing.Optional[builtins.int], recursive: typing.Optional[builtins.bool], extensions: typing.Optional[typing.Sequence[builtins.str]], extract_opcodes: typing.Optional[builtins.bool], debug: typing.Optional[builtins.bool], max_file_count: typing.Optional[builtins.int]) -> Config: ...
    def validate(self) -> None: ...

@typing.final
class FileInfo:
    @property
    def imphash(self) -> builtins.str: ...
    @imphash.setter
    def imphash(self, value: builtins.str) -> None: ...
    @property
    def exports(self) -> builtins.list[builtins.str]: ...
    @exports.setter
    def exports(self, value: builtins.list[builtins.str]) -> None: ...
    @property
    def sha256(self) -> builtins.str: ...
    @sha256.setter
    def sha256(self, value: builtins.str) -> None: ...
    @property
    def size(self) -> builtins.int: ...
    @size.setter
    def size(self, value: builtins.int) -> None: ...
    @property
    def magic(self) -> builtins.list[builtins.int]: ...
    @magic.setter
    def magic(self, value: builtins.list[builtins.int]) -> None: ...

@typing.final
class FileProcessor:
    def __new__(cls, config: typing.Optional[Config] = None) -> FileProcessor: ...
    def parse_sample_dir(self, dir: builtins.str) -> ProcessingResults: ...
    def clear_context(self) -> None: ...
    def process_file_with_checks(self, file_path: builtins.str) -> builtins.bool: ...
    def deduplicate_strings(self) -> None: ...
    def process_single_file(self, file_path: builtins.str) -> tuple[FileInfo, builtins.dict[builtins.str, TokenInfo], builtins.dict[builtins.str, TokenInfo], builtins.dict[builtins.str, TokenInfo]]: ...

@typing.final
class ProcessingResults:
    @property
    def file_infos(self) -> builtins.dict[builtins.str, FileInfo]: ...
    @file_infos.setter
    def file_infos(self, value: builtins.dict[builtins.str, FileInfo]) -> None: ...
    @property
    def strings(self) -> builtins.dict[builtins.str, TokenInfo]: ...
    @strings.setter
    def strings(self, value: builtins.dict[builtins.str, TokenInfo]) -> None: ...
    @property
    def utf16strings(self) -> builtins.dict[builtins.str, TokenInfo]: ...
    @utf16strings.setter
    def utf16strings(self, value: builtins.dict[builtins.str, TokenInfo]) -> None: ...
    @property
    def opcodes(self) -> builtins.dict[builtins.str, TokenInfo]: ...
    @opcodes.setter
    def opcodes(self, value: builtins.dict[builtins.str, TokenInfo]) -> None: ...
    def __new__(cls) -> ProcessingResults: ...
    def get_file_count(self) -> builtins.int: ...
    def get_string_count(self) -> builtins.int: ...
    def get_utf16string_count(self) -> builtins.int: ...
    def get_opcode_count(self) -> builtins.int: ...
    def deduplicate(self) -> None: ...
    def merge(self, other: ProcessingResults) -> None: ...

@typing.final
class ScoringEngine:
    @property
    def good_strings_db(self) -> builtins.dict[builtins.str, builtins.int]: ...
    @good_strings_db.setter
    def good_strings_db(self, value: builtins.dict[builtins.str, builtins.int]) -> None: ...
    @property
    def good_imphashes_db(self) -> builtins.dict[builtins.str, builtins.int]: ...
    @good_imphashes_db.setter
    def good_imphashes_db(self, value: builtins.dict[builtins.str, builtins.int]) -> None: ...
    @property
    def good_exports_db(self) -> builtins.dict[builtins.str, builtins.int]: ...
    @good_exports_db.setter
    def good_exports_db(self, value: builtins.dict[builtins.str, builtins.int]) -> None: ...
    @property
    def string_scores(self) -> builtins.dict[builtins.str, TokenInfo]: ...
    @string_scores.setter
    def string_scores(self, value: builtins.dict[builtins.str, TokenInfo]) -> None: ...
    @property
    def good_opcodes_db(self) -> builtins.dict[builtins.str, builtins.int]: ...
    @good_opcodes_db.setter
    def good_opcodes_db(self, value: builtins.dict[builtins.str, builtins.int]) -> None: ...
    @property
    def pestudio_strings(self) -> builtins.dict[builtins.str, tuple[builtins.int, builtins.str]]: ...
    @pestudio_strings.setter
    def pestudio_strings(self, value: builtins.dict[builtins.str, tuple[builtins.int, builtins.str]]) -> None: ...
    @property
    def pestudio_marker(self) -> builtins.dict[builtins.str, builtins.str]: ...
    @pestudio_marker.setter
    def pestudio_marker(self, value: builtins.dict[builtins.str, builtins.str]) -> None: ...
    @property
    def base64strings(self) -> builtins.dict[builtins.str, builtins.str]: ...
    @base64strings.setter
    def base64strings(self, value: builtins.dict[builtins.str, builtins.str]) -> None: ...
    @property
    def hex_enc_strings(self) -> builtins.dict[builtins.str, builtins.str]: ...
    @hex_enc_strings.setter
    def hex_enc_strings(self, value: builtins.dict[builtins.str, builtins.str]) -> None: ...
    @property
    def reversed_strings(self) -> builtins.dict[builtins.str, builtins.str]: ...
    @reversed_strings.setter
    def reversed_strings(self, value: builtins.dict[builtins.str, builtins.str]) -> None: ...
    @property
    def excludegood(self) -> builtins.bool: ...
    @excludegood.setter
    def excludegood(self, value: builtins.bool) -> None: ...
    @property
    def min_score(self) -> builtins.int: ...
    @min_score.setter
    def min_score(self, value: builtins.int) -> None: ...
    @property
    def superrule_overlap(self) -> builtins.int: ...
    @superrule_overlap.setter
    def superrule_overlap(self, value: builtins.int) -> None: ...
    def generate_rule_strings(self, high_scoring: builtins.float, strings_per_rule: builtins.int, string_elements: typing.Sequence[TokenInfo], comments: builtins.bool) -> tuple[builtins.list[builtins.str], builtins.int]: ...
    def filter_opcode_set(self, opcode_set: typing.Sequence[TokenInfo]) -> builtins.list[TokenInfo]: ...
    def clear_context(self) -> None: ...
    def filter_string_set(self, tokens: typing.Sequence[TokenInfo]) -> builtins.list[TokenInfo]: ...
    def sample_string_evaluation(self, token_stats: typing.Mapping[builtins.str, TokenInfo]) -> tuple[builtins.dict[builtins.str, Combination], builtins.list[Combination], builtins.dict[builtins.str, builtins.list[TokenInfo]]]: ...

@typing.final
class TokenInfo:
    @property
    def reprz(self) -> builtins.str: ...
    @reprz.setter
    def reprz(self, value: builtins.str) -> None: ...
    @property
    def count(self) -> builtins.int: ...
    @count.setter
    def count(self, value: builtins.int) -> None: ...
    @property
    def typ(self) -> TokenType: ...
    @typ.setter
    def typ(self, value: TokenType) -> None: ...
    @property
    def files(self) -> builtins.set[builtins.str]: ...
    @files.setter
    def files(self, value: builtins.set[builtins.str]) -> None: ...
    @property
    def notes(self) -> builtins.list[builtins.str]: ...
    @notes.setter
    def notes(self, value: builtins.list[builtins.str]) -> None: ...
    @property
    def score(self) -> builtins.int: ...
    @score.setter
    def score(self, value: builtins.int) -> None: ...
    @property
    def fullword(self) -> builtins.bool: ...
    @fullword.setter
    def fullword(self, value: builtins.bool) -> None: ...
    @property
    def b64(self) -> builtins.bool: ...
    @b64.setter
    def b64(self, value: builtins.bool) -> None: ...
    @property
    def hexed(self) -> builtins.bool: ...
    @hexed.setter
    def hexed(self, value: builtins.bool) -> None: ...
    @property
    def reversed(self) -> builtins.bool: ...
    @reversed.setter
    def reversed(self, value: builtins.bool) -> None: ...
    @property
    def from_pestudio(self) -> builtins.bool: ...
    @from_pestudio.setter
    def from_pestudio(self, value: builtins.bool) -> None: ...
    @property
    def also_wide(self) -> builtins.bool: ...
    @also_wide.setter
    def also_wide(self, value: builtins.bool) -> None: ...
    @property
    def good_string(self) -> builtins.bool: ...
    @good_string.setter
    def good_string(self, value: builtins.bool) -> None: ...
    def __new__(cls, reprz: builtins.str, count: builtins.int, typ: TokenType, files: builtins.set[builtins.str], notes: typing.Optional[typing.Sequence[builtins.str]]) -> TokenInfo: ...
    def contains(self, right: TokenInfo) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def generate_string_repr(self, i: builtins.int, is_super_string: builtins.bool, comments: builtins.bool) -> builtins.str: ...
    def merge(self, value: TokenInfo) -> None: ...
    def merge_existed(self, value: TokenInfo) -> None: ...
    def add_file(self, value: builtins.str) -> None: ...
    def add_note(self, value: builtins.str) -> None: ...

class TokenType:
    def __eq__(self, val: TokenType) -> builtins.bool: ...
    @typing.final
    class ASCII(TokenType):
        __match_args__ = ()
        def __new__(cls) -> TokenType.ASCII: ...
    
    @typing.final
    class UTF16LE(TokenType):
        __match_args__ = ()
        def __new__(cls) -> TokenType.UTF16LE: ...
    
    @typing.final
    class BINARY(TokenType):
        __match_args__ = ()
        def __new__(cls) -> TokenType.BINARY: ...
    

def analyze_buffers_comprehensive(buffers: typing.Sequence[typing.Sequence[builtins.int]], fp: FileProcessor, scoring_engine: ScoringEngine) -> AnalysisResults: ...

def extract_strings(file_data: typing.Sequence[builtins.int], min_len: builtins.int, max_len: typing.Optional[builtins.int]) -> tuple[builtins.dict[builtins.str, TokenInfo], builtins.dict[builtins.str, TokenInfo]]: ...

def init_analysis(config: typing.Optional[Config] = None, excludegood: builtins.bool = False, min_score: builtins.int = 5, superrule_overlap: builtins.int = 5, good_strings_db: typing.Optional[typing.Mapping[builtins.str, builtins.int]] = None, good_opcodes_db: typing.Optional[typing.Mapping[builtins.str, builtins.int]] = None, good_imphashes_db: typing.Optional[typing.Mapping[builtins.str, builtins.int]] = None, good_exports_db: typing.Optional[typing.Mapping[builtins.str, builtins.int]] = None, pestudio_strings: typing.Optional[typing.Mapping[builtins.str, tuple[builtins.int, builtins.str]]] = None) -> tuple[FileProcessor, ScoringEngine]: ...

def process_file(malware_path: builtins.str, fp: FileProcessor, scoring_engine: ScoringEngine) -> tuple[builtins.list[TokenInfo], builtins.list[TokenInfo], builtins.list[TokenInfo], builtins.dict[builtins.str, FileInfo]]: ...

def process_malware(malware_path: builtins.str, fp: FileProcessor, scoring_engine: ScoringEngine) -> AnalysisResults: ...


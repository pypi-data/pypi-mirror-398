"""Jenkins API client wrapper using api4jenkins."""

import os
import sys
from typing import Optional, Dict, Any
from api4jenkins import Jenkins


def get_env_file_path() -> str:
    """Get the path to the .env file."""
    home = os.path.expanduser("~")
    ngen_j_dir = os.path.join(home, ".ngen-japi")
    return os.path.join(ngen_j_dir, ".env")


def load_env_file() -> dict:
    """Load environment variables from ~/.ngen-japi/.env file."""
    env_file = get_env_file_path()
    env_vars = {}

    if os.path.exists(env_file):
        try:
            with open(env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        if '=' in line:
                            key, value = line.split('=', 1)
                            env_vars[key.strip()] = value.strip()
        except Exception as e:
            print(f"Warning: Could not read .env file: {e}", file=sys.stderr)

    return env_vars


def save_env_file(env_vars: dict) -> bool:
    """Save environment variables to ~/.ngen-japi/.env file."""
    env_file = get_env_file_path()

    try:
        # Create directory if it doesn't exist
        os.makedirs(os.path.dirname(env_file), exist_ok=True)

        with open(env_file, 'w') as f:
            f.write("# ngen-japi Jenkins credentials\n")
            f.write("# Generated by: japi login\n")
            f.write("\n")
            for key, value in env_vars.items():
                f.write(f"{key}={value}\n")

        # Set restrictive permissions (readable only by owner)
        os.chmod(env_file, 0o600)
        return True
    except Exception as e:
        print(f"Error: Could not save .env file: {e}", file=sys.stderr)
        return False


class JenkinsClient:
    """Jenkins API client wrapper."""

    def __init__(self):
        """Initialize Jenkins client from environment variables."""
        # Load from .env file first, then override with current env vars
        env_vars = load_env_file()
        self.url = os.getenv("JENKINS_URL") or env_vars.get("JENKINS_URL")
        self.user = os.getenv("JENKINS_USER") or env_vars.get("JENKINS_USER")
        self.token = os.getenv("JENKINS_TOKEN") or env_vars.get("JENKINS_TOKEN")
        self.auth = os.getenv("JENKINS_AUTH") or env_vars.get("JENKINS_AUTH")

        if not self.url:
            print("Error: JENKINS_URL environment variable is required", file=sys.stderr)
            print("Use 'japi login' to set credentials", file=sys.stderr)
            sys.exit(1)

        # Determine authentication method
        auth_tuple = None
        if self.auth:
            # Use JENKINS_AUTH if provided (base64 encoded user:token)
            import base64
            try:
                decoded = base64.b64decode(self.auth).decode('utf-8')
                if ':' in decoded:
                    user, token = decoded.split(':', 1)
                    auth_tuple = (user, token)
            except Exception as e:
                print(f"Warning: Could not decode JENKINS_AUTH: {e}", file=sys.stderr)

        if not auth_tuple and self.user and self.token:
            auth_tuple = (self.user, self.token)

        if not auth_tuple:
            print("Error: Jenkins authentication required. Set JENKINS_USER and JENKINS_TOKEN, or JENKINS_AUTH", file=sys.stderr)
            print("Use 'japi login' to set credentials", file=sys.stderr)
            sys.exit(1)

        try:
            self.client = Jenkins(self.url, auth=auth_tuple)
        except Exception as e:
            print(f"Error connecting to Jenkins: {e}", file=sys.stderr)
            sys.exit(1)
    
    def list_jobs(self) -> list:
        """List all Jenkins jobs."""
        try:
            jobs = []
            # Use the correct API method for api4jenkins
            for job in self.client.iter():
                jobs.append({
                    'name': job.name,
                    'url': job.url
                })
            return jobs
        except Exception as e:
            print(f"Error listing jobs: {e}", file=sys.stderr)
            sys.exit(1)
    
    def get_job(self, job_name: str) -> Dict[str, Any]:
        """Get job details with recent build history."""
        try:
            job = self.client[job_name]
            if job is None:
                raise KeyError(f"Job '{job_name}' not found")

            # Get basic job info
            job_info = {
                'name': getattr(job, 'name', job_name),
                'url': getattr(job, 'url', f"{self.url}/job/{job_name}/"),
                'description': getattr(job, 'description', ''),
                'buildable': getattr(job, 'buildable', False),
            }

            # Get recent builds (up to 3, starting from most recent)
            recent_builds = []
            try:
                # Try to get builds using different methods
                builds = []
                if hasattr(job, 'builds'):
                    # Use builds attribute if available (usually most recent first)
                    builds = list(job.builds)[:3]
                elif hasattr(job, 'iter_builds'):
                    # Use iter_builds method if available
                    builds = list(job.iter_builds())[:3]
                else:
                    # Fallback: try to get recent builds by trying higher numbers first
                    # Jenkins typically numbers builds sequentially, so we'll try recent numbers
                    max_attempts = 500  # Try up to build number 500 to find recent builds
                    found_builds = []

                    for build_num in range(max_attempts, 0, -1):  # Start from highest number
                        try:
                            build = job[build_num]
                            if build:
                                found_builds.append(build)
                                if len(found_builds) >= 3:
                                    break
                        except (KeyError, IndexError):
                            continue  # Build number doesn't exist, try lower number

                    builds = found_builds

                # Sort builds by number (highest first) to ensure most recent are shown first
                builds.sort(key=lambda b: getattr(b, 'number', 0), reverse=True)

                for build in builds[:3]:  # Take only first 3 (most recent)
                    if build:
                        build_info = {
                            'number': getattr(build, 'number', 'N/A'),
                            'url': getattr(build, 'url', f"{job_info['url']}{getattr(build, 'number', '')}/"),
                            'status': self._get_build_status(build),
                            'start_time': self._get_build_start_time(build),
                            'duration': self._get_build_duration(build),
                        }
                        recent_builds.append(build_info)

            except Exception as e:
                # If we can't get build history, continue without it
                pass

            job_info['recent_builds'] = recent_builds
            return job_info

        except KeyError:
            print(f"Error: Job '{job_name}' not found", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error getting job: {e}", file=sys.stderr)
            sys.exit(1)

    def get_recent_jobs_by_status(self, status: str, limit: int = 10) -> list:
        """Get recent jobs filtered by last build status (SUCCESS or FAILURE)."""
        try:
            jobs_info = []
            # Use direct API call to get jobs with build information
            import httpx
            # Try to get jobs without tree specification first to avoid server errors
            api_url = f"{self.url}/api/json?tree=jobs[name,url,lastBuild[number,result,timestamp,duration],lastCompletedBuild[number,result,timestamp,duration]]"

            response = httpx.get(api_url, auth=self.client._auth)
            response.raise_for_status()
            data = response.json()

            all_jobs_data = data.get('jobs', [])


            for job_data in all_jobs_data:
                try:
                    # Get the last completed build info
                    last_build_data = job_data.get('lastCompletedBuild') or job_data.get('lastBuild')

                    if last_build_data and last_build_data.get('result') == status.upper():
                        try:
                            # Create a simple build object for helper methods
                            class SimpleBuild:
                                def __init__(self, data, job_name, jenkins_url):
                                    self.number = data.get('number')
                                    self.result = data.get('result')
                                    self.timestamp = data.get('timestamp')
                                    self.duration = data.get('duration')
                                    self.url = f"{jenkins_url}/job/{job_name}/{data.get('number', '')}/"

                            last_build = SimpleBuild(last_build_data, job_data['name'], self.url) if last_build_data else None

                            job_name = job_data['name']
                            job_info = {
                                'name': job_name,
                                'url': job_data.get('url', f"{self.url}/job/{job_name}/"),
                                'description': '',  # Not available in this API call
                                'buildable': True,  # Assume buildable
                                'last_build': {
                                    'number': getattr(last_build, 'number', 'N/A') if last_build else 'N/A',
                                    'status': status.upper(),
                                    'url': getattr(last_build, 'url', f"{self.url}/job/{job_name}/{getattr(last_build, 'number', 'N/A')}/") if last_build else '',
                                    'start_time': self._get_build_start_time(last_build) if last_build else 'N/A',
                                    'duration': self._get_build_duration(last_build) if last_build else 'N/A',
                                }
                            }
                            jobs_info.append(job_info)

                            if len(jobs_info) >= limit:
                                break
                        except Exception as e:
                            # Skip jobs that cause errors in processing
                            continue

                except Exception as e:
                    # Skip jobs that cause errors
                    continue

            # Sort by last build number (most recent first)
            jobs_info.sort(key=lambda j: j['last_build'].get('number', 0) if isinstance(j['last_build'], dict) else 0, reverse=True)
            return jobs_info[:limit]

        except Exception as e:
            print(f"Error getting recent jobs: {e}", file=sys.stderr)
            sys.exit(1)
            return jobs_info[:limit]

        except Exception as e:
            print(f"Error getting recent jobs: {e}", file=sys.stderr)
            sys.exit(1)

    def _get_build_status(self, build) -> str:
        """Get build status from build object."""
        try:
            # Try different ways to get build status
            if hasattr(build, 'result'):
                result = build.result
                if result is not None:
                    return str(result).upper()
            elif hasattr(build, 'status'):
                return str(build.status).upper()

            # Check if build is building
            if hasattr(build, 'building') and build.building:
                return "BUILDING"

            # Default to UNKNOWN
            return "UNKNOWN"
        except:
            return "UNKNOWN"

    def _get_build_start_time(self, build) -> str:
        """Get build start time from build object."""
        try:
            if hasattr(build, 'timestamp'):
                import datetime
                # Jenkins timestamp is in milliseconds
                timestamp_ms = build.timestamp
                dt = datetime.datetime.fromtimestamp(timestamp_ms / 1000)
                return dt.strftime('%Y-%m-%d %H:%M:%S')
            else:
                return "Unknown"
        except:
            return "Unknown"

    def _get_build_duration(self, build) -> str:
        """Get build duration from build object."""
        try:
            if hasattr(build, 'duration'):
                duration_ms = build.duration
                if duration_ms == 0:
                    # Build might still be running
                    return "Still running"
                else:
                    # Convert milliseconds to human readable format
                    total_seconds = duration_ms // 1000
                    hours, remainder = divmod(total_seconds, 3600)
                    minutes, seconds = divmod(remainder, 60)

                    if hours > 0:
                        return f"{hours}h {minutes}m {seconds}s"
                    elif minutes > 0:
                        return f"{minutes}m {seconds}s"
                    else:
                        return f"{seconds}s"
            else:
                return "Unknown"
        except:
            return "Unknown"
    
    def trigger_build(self, job_name: str, parameters: Optional[Dict[str, str]] = None) -> Dict[str, Any]:
        """Trigger a build for a job."""
        try:
            job = self.client[job_name]
            if parameters:
                queue_item = job.build(**parameters)
            else:
                queue_item = job.build()

            # api4jenkins returns a QueueItem, not a Build
            return {
                'queue_id': getattr(queue_item, 'id', 'unknown'),
                'url': getattr(queue_item, 'url', 'unknown'),
                'status': 'triggered'
            }
        except KeyError:
            print(f"Error: Job '{job_name}' not found", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error triggering build: {e}", file=sys.stderr)
            sys.exit(1)

    def get_job_xml(self, job_name: str) -> str:
        """Get job configuration in XML format."""
        try:
            job = self.client[job_name]
            # Try to get XML config using api4jenkins method if available
            if hasattr(job, 'config_xml'):
                return job.config_xml()
            elif hasattr(job, 'get_config_xml'):
                return job.get_config_xml()
            else:
                # Fallback: use direct HTTP request to config.xml endpoint
                config_url = f"{self.url}/job/{job_name}/config.xml"
                import httpx
                response = httpx.get(config_url, auth=self.client._auth)
                response.raise_for_status()
                return response.text
        except Exception as e:
            print(f"Error getting job XML: {e}", file=sys.stderr)
            sys.exit(1)

    def create_job_from_xml(self, job_name: str, xml_content: str, force: bool = False) -> dict:
        """Create or update job from XML configuration."""
        try:
            # Check if job already exists
            job_exists = False
            try:
                self.client[job_name]
                job_exists = True
                print(f"Job '{job_name}' already exists.")
            except KeyError:
                job_exists = False

            if job_exists and not force:
                # Ask for confirmation
                response = input(f"Do you want to update the existing job '{job_name}'? (y/N): ").strip().lower()
                if response not in ['y', 'yes']:
                    return {
                        'status': 'cancelled',
                        'message': 'Job creation cancelled by user'
                    }

            # Use direct HTTP requests for create/update operations
            import httpx

            if job_exists:
                # Update existing job
                url = f"{self.url}/job/{job_name}/config.xml"
                response = httpx.post(url, content=xml_content, auth=self.client._auth)
                response.raise_for_status()
                action = 'updated'
            else:
                # Create new job
                url = f"{self.url}/createItem"
                params = {'name': job_name}
                headers = {'Content-Type': 'application/xml'}
                response = httpx.post(url, params=params, content=xml_content,
                                    headers=headers, auth=self.client._auth)
                response.raise_for_status()
                action = 'created'

            return {
                'status': 'success',
                'action': action,
                'job_name': job_name,
                'url': f"{self.url}/job/{job_name}/"
            }

        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to create/update jobs.", file=sys.stderr)
                print("Required permissions: Job/Create, Job/Update, Job/Configure", file=sys.stderr)
            else:
                print(f"Error creating/updating job: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def get_build_logs(self, job_name: str, build_number: int) -> str:
        """Get console output/logs from a specific build."""
        try:
            job = self.client[job_name]
            build = job[build_number]

            # Try to get console output using different methods
            if hasattr(build, 'console'):
                return build.console()
            elif hasattr(build, 'get_console_output'):
                return build.get_console_output()
            else:
                # Fallback: use direct HTTP request to consoleText endpoint
                console_url = f"{self.url}/job/{job_name}/{build_number}/consoleText"
                import httpx
                response = httpx.get(console_url, auth=self.client._auth)
                response.raise_for_status()
                return response.text

        except KeyError:
            print(f"Error: Build {build_number} not found for job '{job_name}'", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error getting build logs: {e}", file=sys.stderr)
            sys.exit(1)

    def delete_job(self, job_name: str, force: bool = False) -> dict:
        """Delete a Jenkins job."""
        import httpx

        try:
            # Check if job exists first
            try:
                job = self.client[job_name]
                job_url = getattr(job, 'url', f"{self.url}/job/{job_name}/")
                print(f"ğŸ“‹ Job found: {job_url}", file=sys.stderr)
            except KeyError:
                print(f"âŒ Job '{job_name}' not found at {self.url}", file=sys.stderr)
                return {
                    'status': 'error',
                    'error': f"Job '{job_name}' not found"
                }

            if not force:
                # Ask for confirmation
                response = input(f"Are you sure you want to delete job '{job_name}'? This action cannot be undone. (y/N): ").strip().lower()
                if response not in ['y', 'yes']:
                    return {
                        'status': 'cancelled',
                        'message': 'Job deletion cancelled by user'
                    }

            # Test basic authentication and connectivity first
            print(f"ğŸ” Testing Jenkins connection and permissions...", file=sys.stderr)
            test_url = f"{self.url}/api/json?tree=jobs[name]"
            try:
                test_response = httpx.get(test_url, auth=self.client._auth)
                test_response.raise_for_status()
                print(f"âœ… Connection and basic authentication successful", file=sys.stderr)
            except Exception as e:
                print(f"âŒ Connection or authentication failed: {e}", file=sys.stderr)
                return {
                    'status': 'error',
                    'error': f"Connection or authentication failed: {e}"
                }

            # Try to get CSRF crumb if available (required by some Jenkins instances)
            crumb = None
            try:
                crumb_url = f"{self.url}/crumbIssuer/api/json"
                crumb_response = httpx.get(crumb_url, auth=self.client._auth)
                if crumb_response.status_code == 200:
                    crumb_data = crumb_response.json()
                    crumb = crumb_data.get('crumb')
                    print(f"ğŸ”’ CSRF protection detected, using crumb for authentication", file=sys.stderr)
            except:
                # CSRF crumb not required or not available, continue without it
                pass

            # Use direct HTTP request to delete job
            delete_url = f"{self.url}/job/{job_name}/doDelete"

            # Prepare headers and data
            headers = {}
            if crumb:
                headers[crumb_data.get('crumbRequestField', 'Jenkins-Crumb')] = crumb

            print(f"ğŸ—‘ï¸  Deleting job '{job_name}'...", file=sys.stderr)
            response = httpx.post(delete_url, auth=self.client._auth, headers=headers)
            response.raise_for_status()

            return {
                'status': 'success',
                'job_name': job_name,
                'message': f"Job '{job_name}' has been deleted successfully"
            }

        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"âŒ Permission denied. Cannot delete job '{job_name}'.", file=sys.stderr)
                print(f"\nğŸ”§ Troubleshooting steps:", file=sys.stderr)
                print(f"1. Check Jenkins user permissions: Go to Jenkins â†’ Manage Jenkins â†’ Manage Users", file=sys.stderr)
                print(f"2. Ensure your user has 'Job/Delete' permission", file=sys.stderr)
                print(f"3. For Matrix Authorization: Check 'Delete Jobs' permission", file=sys.stderr)
                print(f"4. For Role-Based Access: Ensure your role has 'Job' â†’ 'Delete' permission", file=sys.stderr)
                print(f"5. If using API token, ensure it's valid and has delete permissions", file=sys.stderr)
                print(f"\nğŸ’¡ Alternative solutions:", file=sys.stderr)
                print(f"â€¢ Use Jenkins Web UI: {self.url}/job/{job_name} â†’ Delete Job", file=sys.stderr)
                print(f"â€¢ Manual API call: curl -X POST '{self.url}/job/{job_name}/doDelete' -u 'username:token'", file=sys.stderr)
            elif '404' in error_msg or 'Not Found' in error_msg:
                print(f"âŒ Job '{job_name}' not found", file=sys.stderr)
            else:
                print(f"âŒ Error deleting job: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def list_plugins(self) -> list:
        """List all installed Jenkins plugins."""
        try:
            plugins = []
            for plugin in self.client.plugins:
                plugin_info = {
                    'name': getattr(plugin, 'short_name', getattr(plugin, 'name', 'Unknown')),
                    'version': getattr(plugin, 'version', 'Unknown'),
                    'enabled': getattr(plugin, 'enabled', True),
                    'display_name': getattr(plugin, 'display_name', getattr(plugin, 'name', 'Unknown')),
                    'url': getattr(plugin, 'url', ''),
                }
                # Try to get more details from API
                try:
                    plugin_json = plugin.api_json()
                    plugin_info['version'] = plugin_json.get('version', plugin_info['version'])
                    plugin_info['enabled'] = plugin_json.get('enabled', plugin_info['enabled'])
                    plugin_info['display_name'] = plugin_json.get('displayName', plugin_info['display_name'])
                    plugin_info['description'] = plugin_json.get('longName', plugin_json.get('displayName', ''))
                except:
                    pass
                plugins.append(plugin_info)
            return plugins
        except Exception as e:
            print(f"Error listing plugins: {e}", file=sys.stderr)
            sys.exit(1)

    def install_plugins(self, plugin_names: list, block: bool = False) -> dict:
        """Install one or more Jenkins plugins."""
        try:
            plugins_manager = self.client.plugins
            plugins_manager.install(*plugin_names, block=block)
            
            return {
                'status': 'success',
                'plugins': plugin_names,
                'message': f"Plugins installation initiated: {', '.join(plugin_names)}"
            }
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to install plugins.", file=sys.stderr)
                print("Required permissions: Overall/Administer or Plugin/Install", file=sys.stderr)
            else:
                print(f"Error installing plugins: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def uninstall_plugins(self, plugin_names: list) -> dict:
        """Uninstall one or more Jenkins plugins."""
        try:
            plugins_manager = self.client.plugins
            plugins_manager.uninstall(*plugin_names)
            
            return {
                'status': 'success',
                'plugins': plugin_names,
                'message': f"Plugins uninstallation initiated: {', '.join(plugin_names)}"
            }
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to uninstall plugins.", file=sys.stderr)
                print("Required permissions: Overall/Administer or Plugin/Uninstall", file=sys.stderr)
            else:
                print(f"Error uninstalling plugins: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def list_credentials(self) -> list:
        """List all credentials from Jenkins global credentials store."""
        try:
            import httpx
            import json
            
            # Jenkins Credentials API endpoint for global domain
            # Use depth=2 to get full credential details including typeName
            api_url = f"{self.url}/credentials/store/system/domain/_/api/json?depth=2"
            
            response = httpx.get(api_url, auth=self.client._auth)
            response.raise_for_status()
            data = response.json()
            
            credentials = []
            creds_list = data.get('credentials', [])
            
            for cred in creds_list:
                # Handle response structure based on actual Jenkins API response
                if isinstance(cred, dict):
                    # Get ID (required field)
                    cred_id = cred.get('id', 'N/A')
                    
                    # Get description (may be empty string)
                    description = cred.get('description', '')
                    
                    # Get type name
                    cred_type = cred.get('typeName', 'Unknown')
                    
                    # Get display name
                    display_name = cred.get('displayName', cred_id)
                    
                    # Scope is typically GLOBAL for system domain
                    scope = cred.get('scope', 'GLOBAL')
                    
                    # Normalize type name to readable format
                    if cred_type and cred_type != 'Unknown':
                        type_lower = cred_type.lower()
                        if 'username' in type_lower and 'password' in type_lower:
                            cred_type = 'Username/Password'
                        elif 'string' in type_lower or 'secret' in type_lower:
                            cred_type = 'Secret Text'
                        elif 'ssh' in type_lower or 'private' in type_lower:
                            cred_type = 'SSH Key'
                        elif 'certificate' in type_lower:
                            cred_type = 'Certificate'
                        elif 'file' in type_lower:
                            cred_type = 'Secret File'
                        # Keep original if no match
                    
                    cred_info = {
                        'id': cred_id,
                        'description': description,
                        'type': cred_type,
                        'scope': scope,
                        'display_name': display_name
                    }
                    credentials.append(cred_info)
            
            return credentials
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to view credentials.", file=sys.stderr)
                print("Required permissions: Credentials/View or Overall/Read", file=sys.stderr)
            elif '404' in error_msg:
                print(f"Error: Credentials API not found. Make sure Credentials Plugin is installed.", file=sys.stderr)
            else:
                print(f"Error listing credentials: {e}", file=sys.stderr)
            return []

    def create_credential(self, cred_type: str, cred_id: str, description: str = "", 
                         username: str = None, password: str = None, secret: str = None,
                         private_key: str = None, private_key_file: str = None, 
                         passphrase: str = None, force: bool = False) -> dict:
        """Create a new credential in Jenkins global credentials store."""
        try:
            import httpx
            import xml.etree.ElementTree as ET
            
            # Check if credential already exists
            existing_creds = self.list_credentials()
            cred_exists = any(c.get('id') == cred_id for c in existing_creds)
            
            if cred_exists and not force:
                return {
                    'status': 'exists',
                    'message': f"Credential with ID '{cred_id}' already exists. Use --force to overwrite."
                }
            
            # Get CSRF crumb
            crumb = None
            crumb_field = None
            try:
                crumb_url = f"{self.url}/crumbIssuer/api/json"
                crumb_response = httpx.get(crumb_url, auth=self.client._auth)
                if crumb_response.status_code == 200:
                    crumb_data = crumb_response.json()
                    crumb = crumb_data.get('crumb')
                    crumb_field = crumb_data.get('crumbRequestField', 'Jenkins-Crumb')
            except:
                pass
            
            # Build XML based on credential type
            if cred_type in ['username_password', 'username-password']:
                root = ET.Element('com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl')
                root.set('plugin', 'credentials')
                
                scope = ET.SubElement(root, 'scope')
                scope.text = 'GLOBAL'
                
                id_elem = ET.SubElement(root, 'id')
                id_elem.text = cred_id
                
                desc_elem = ET.SubElement(root, 'description')
                desc_elem.text = description
                
                username_elem = ET.SubElement(root, 'username')
                username_elem.text = username or ''
                
                password_elem = ET.SubElement(root, 'password')
                password_elem.text = password or ''
                
            elif cred_type in ['secret_text', 'secret-text']:
                root = ET.Element('org.jenkinsci.plugins.plaincredentials.impl.StringCredentialsImpl')
                root.set('plugin', 'plain-credentials')
                
                scope = ET.SubElement(root, 'scope')
                scope.text = 'GLOBAL'
                
                id_elem = ET.SubElement(root, 'id')
                id_elem.text = cred_id
                
                desc_elem = ET.SubElement(root, 'description')
                desc_elem.text = description
                
                secret_elem = ET.SubElement(root, 'secret')
                secret_elem.text = secret or ''
                
            elif cred_type in ['ssh_key', 'ssh-key']:
                root = ET.Element('com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey')
                root.set('plugin', 'ssh-credentials')
                
                scope = ET.SubElement(root, 'scope')
                scope.text = 'GLOBAL'
                
                id_elem = ET.SubElement(root, 'id')
                id_elem.text = cred_id
                
                desc_elem = ET.SubElement(root, 'description')
                desc_elem.text = description
                
                username_elem = ET.SubElement(root, 'username')
                username_elem.text = username or ''
                
                # Handle private key (from string or file)
                private_key_content = private_key
                if private_key_file:
                    try:
                        with open(private_key_file, 'r') as f:
                            private_key_content = f.read()
                    except Exception as e:
                        return {
                            'status': 'error',
                            'error': f"Could not read private key file: {e}"
                        }
                
                private_key_source = ET.SubElement(root, 'privateKeySource')
                direct_entry = ET.SubElement(private_key_source, 'class')
                direct_entry.text = 'com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey$DirectEntryPrivateKeySource'
                private_key_elem = ET.SubElement(private_key_source, 'privateKey')
                private_key_elem.text = private_key_content or ''
                
                if passphrase:
                    passphrase_elem = ET.SubElement(root, 'passphrase')
                    passphrase_elem.text = passphrase
                
            else:
                return {
                    'status': 'error',
                    'error': f"Unsupported credential type: {cred_type}. Supported types: username_password, secret_text, ssh_key"
                }
            
            # Convert to XML string
            xml_str = ET.tostring(root, encoding='unicode')
            
            # Create credential via API
            create_url = f"{self.url}/credentials/store/system/domain/_/createCredentials"
            
            headers = {'Content-Type': 'application/xml'}
            if crumb and crumb_field:
                headers[crumb_field] = crumb
            
            params = {}
            if cred_exists:
                # If credential exists and force is True, we need to delete first
                delete_result = self.delete_credential(cred_id, force=True)
                if delete_result.get('status') != 'success':
                    return {
                        'status': 'error',
                        'error': f"Could not delete existing credential: {delete_result.get('error', 'Unknown error')}"
                    }
            
            response = httpx.post(create_url, content=xml_str, headers=headers, 
                                auth=self.client._auth, params=params)
            response.raise_for_status()
            
            return {
                'status': 'success',
                'credential_id': cred_id,
                'message': f"Credential '{cred_id}' created successfully"
            }
            
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to create credentials.", file=sys.stderr)
                print("Required permissions: Credentials/Create or Overall/Administer", file=sys.stderr)
            elif '404' in error_msg:
                print(f"Error: Credentials API not found. Make sure Credentials Plugin is installed.", file=sys.stderr)
            else:
                print(f"Error creating credential: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }

    def delete_credential(self, cred_id: str, force: bool = False) -> dict:
        """Delete a credential from Jenkins global credentials store."""
        try:
            import httpx
            
            # Check if credential exists
            existing_creds = self.list_credentials()
            cred_exists = any(c.get('id') == cred_id for c in existing_creds)
            
            if not cred_exists:
                return {
                    'status': 'error',
                    'error': f"Credential with ID '{cred_id}' not found"
                }
            
            if not force:
                # Ask for confirmation (handled in CLI)
                pass
            
            # Get CSRF crumb
            crumb = None
            crumb_field = None
            try:
                crumb_url = f"{self.url}/crumbIssuer/api/json"
                crumb_response = httpx.get(crumb_url, auth=self.client._auth)
                if crumb_response.status_code == 200:
                    crumb_data = crumb_response.json()
                    crumb = crumb_data.get('crumb')
                    crumb_field = crumb_data.get('crumbRequestField', 'Jenkins-Crumb')
            except:
                pass
            
            # Delete credential via API
            delete_url = f"{self.url}/credentials/store/system/domain/_/credential/{cred_id}/doDelete"
            
            headers = {}
            if crumb and crumb_field:
                headers[crumb_field] = crumb
            
            response = httpx.post(delete_url, headers=headers, auth=self.client._auth)
            response.raise_for_status()
            
            return {
                'status': 'success',
                'credential_id': cred_id,
                'message': f"Credential '{cred_id}' deleted successfully"
            }
            
        except Exception as e:
            error_msg = str(e)
            if '403' in error_msg or 'Forbidden' in error_msg:
                print(f"Error: Permission denied. Make sure your Jenkins user has permission to delete credentials.", file=sys.stderr)
                print("Required permissions: Credentials/Delete or Overall/Administer", file=sys.stderr)
            elif '404' in error_msg:
                return {
                    'status': 'success',
                    'credential_id': cred_id,
                    'message': f"Credential '{cred_id}' not found (may have been already deleted)"
                }
            else:
                print(f"Error deleting credential: {e}", file=sys.stderr)
            return {
                'status': 'error',
                'error': str(e)
            }


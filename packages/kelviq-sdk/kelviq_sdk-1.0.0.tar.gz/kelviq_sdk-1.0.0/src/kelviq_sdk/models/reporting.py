# kelviq_sdk/models/reporting.py
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field, field_validator, ConfigDict
import datetime

# --- Common Base Model (can stay here or move to a more general models.base if you have many) ---

class BaseResponse(BaseModel):
    """Base model for common API response fields, if any."""
    # Example: request_id: Optional[str] = None
    # Example: success: bool = True
    pass

# --- Reporting Specific Models ---

class ReportUsagePayload(BaseModel):
    """
    Pydantic model for the payload of the report_usage operation.
    """
    value: int = Field(..., description="The usage value.")
    customerId: str = Field(..., min_length=1, description="The ID of the customer.")
    featureId: str = Field(..., min_length=1, description="The ID of the feature.")
    behaviour: str = Field(..., description="The behaviour of the usage report ('SET' or 'DELTA').")
    resourceId: Optional[str] = Field(None, description="Optional. The ID of the resource, if applicable.")

    model_config = ConfigDict(
        extra='forbid' # Disallow extra fields not defined in the model
    )

    @field_validator('behaviour')
    @classmethod
    def check_behaviour(cls, value: str) -> str:
        if value.upper() not in ("SET", "DELTA"): # Make comparison case-insensitive for input
            raise ValueError("Behaviour must be either 'SET' or 'DELTA'")
        return value.upper() # Store in a consistent case

class ReportUsageResponse(BaseResponse):
    """
    Pydantic model for the response of the report_usage operation.
    This model should reflect the actual structure of the API response.
    """
    value: int
    customerId: str
    featureId: str
    behaviour: str
    resourceId: Optional[str] = Field(None, description="The ID of the resource, if it was provided in the request and returned by the server.") # Updated description
    orgId: str = Field(..., description="Organization ID added by the server.")
    eventName: str = Field(..., description="Event name set by the server, e.g., '$usage.reported'.")
    idempotencyKey: str = Field(..., description="Idempotency key generated by the server.")
    timestamp: str = Field(..., description="Timestamp generated by the server (string format).")


class ReportEventPayload(BaseModel):
    """
    Pydantic model for the payload of the report_event operation.
    """
    customerId: str = Field(..., min_length=1, description="The ID of the customer.")
    eventName: str = Field(..., min_length=1, description="The name of the event.")
    idempotencyKey: str = Field(..., min_length=1, description="A unique key to prevent duplicate processing.")
    timestamp: str = Field(..., description="The UTC timestamp of when the event occurred (YYYY-MM-DD HH:MM:SS.ffffff).")
    resourceId: Optional[str] = Field(None, description="Optional. The ID of the resource associated with the event, if applicable.")
    properties: Optional[Dict[str, Any]] = Field(None, description="Additional properties for the event (JSON).")

    model_config = ConfigDict(
        extra='forbid'
    )

    @field_validator('timestamp')
    @classmethod
    def check_timestamp_format(cls, value: str) -> str:
        # This validator ensures the string timestamp is in the correct format.
        # The SDK user is responsible for providing it in this format.
        try:
            datetime.datetime.strptime(value, "%Y-%m-%d %H:%M:%S.%f")
        except ValueError:
            raise ValueError("Timestamp must be in 'YYYY-MM-DD HH:MM:SS.ffffff' format")
        return value

class ReportEventResponse(BaseResponse):
    """
    Pydantic model for the response of the report_event operation.
    This model should reflect the actual structure of the API response.
    """
    customerId: str
    eventName: str
    idempotencyKey: str
    timestamp: str # Server returns string timestamp
    resourceId: Optional[str] = Field(None, description="The ID of the resource, if it was provided in the request and returned by the server.") # Updated description
    properties: Optional[Dict[str, Any]] = None
    orgId: str = Field(..., description="Organization ID added by the server.")

# Example of how you might handle the timestamp as a datetime object in Pydantic models
# if you prefer to work with datetime objects directly after validation/parsing.
# This is an alternative way to structure payload if SDK methods accept datetime directly.
class _ReportEventPayloadWithInternalDatetime(BaseModel): # Underscore to indicate internal use if not exposed
    customerId: str
    eventName: str
    idempotencyKey: str
    timestamp_dt: datetime.datetime = Field(alias='timestamp') # For internal use with datetime object
    resourceId: Optional[str] = None
    properties: Optional[Dict[str, Any]] = None

    model_config = ConfigDict(
        extra='forbid',
        populate_by_name=True # Important for alias to work during model_dump
    )

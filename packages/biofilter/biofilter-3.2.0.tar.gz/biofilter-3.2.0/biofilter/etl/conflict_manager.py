import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Protection
from openpyxl.worksheet.datavalidation import DataValidation
from sqlalchemy import or_
from typing import Optional

from biofilter.utils.logger import Logger

# from biofilter.db.models.model_entities import Entity, EntityAlias
# from biofilter.db.models.model_genes import Gene, OmicStatus
# from biofilter.db.models.model_curation import (
#     CurationConflict,
#     ConflictStatus,
#     ConflictResolution,
# )  # noqa E501
from biofilter.db.models import (
    Entity,
    EntityAlias,
    GeneMaster,
    OmicStatus,
    CurationConflict,
    ConflictStatus,
    ConflictResolution,
)

# TODO: Create a strutucture to convert this class to generic and
# extend to mixin to each omic type


# class ConflictManager(ConflictResolutionMixin):
class ConflictManager:
    def __init__(self, session, logger):
        self.session = session
        self.logger = Logger()

    def export_conflicts_to_excel(
        self, output_path="curation_conflicts_template.xlsx"
    ):  # noqa E501

        # Step 1: Query all conflicts
        conflicts = self.session.query(CurationConflict).all()

        if not conflicts:
            self.logger.log("No conflicts found to export.", "WARNING")
            return False

        wb = Workbook()
        ws = wb.active
        ws.title = "Conflicts"

        # Headers
        headers = [
            "id",
            "data_source_id",
            "data_source_name",
            "entity_type",
            "entity_id",
            "identifier",
            "existing_identifier",
            "status",
            "resolution",
            "description",
            "notes",
        ]
        ws.append(headers)

        for col in ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"]:
            ws[f"{col}1"].protection = Protection(locked=True)

        # Dropdown options
        status_values = ["pending", "resolved"]
        resolution_values = ["keep_both", "merge", "delete", ""]

        # Dropdowns
        status_dv = DataValidation(
            type="list", formula1=f'"{",".join(status_values)}"', allow_blank=False
        )  # noqa E501

        resolution_dv = DataValidation(
            type="list", formula1=f'"{",".join(resolution_values)}"', allow_blank=True
        )  # noqa E501

        # Apply data validation to the specific columns
        ws.add_data_validation(status_dv)
        ws.add_data_validation(resolution_dv)

        for idx, conflict in enumerate(conflicts, start=2):
            ws.append(
                [
                    conflict.id,  # A
                    conflict.data_source_id,  # B
                    conflict.data_source.name if conflict.data_source else "",  # C
                    conflict.entity_type,  # D
                    conflict.entity_id or "",  # E
                    conflict.identifier,  # F
                    conflict.existing_identifier,  # G
                    conflict.status.value if conflict.status else "",  # H
                    conflict.resolution.value if conflict.resolution else "",  # I
                    conflict.description or "",  # J
                    conflict.notes or "",  # K
                ]
            )

            # Data validation applied on status (H) and resolution (I)
            status_dv.add(ws[f"H{idx}"])
            resolution_dv.add(ws[f"I{idx}"])

            # Editable columns
            for col in ["H", "I", "K"]:
                ws[f"{col}{idx}"].protection = Protection(locked=False)

            # Protect columns against editing
            for col in ["A", "B", "C", "D", "E", "F", "G", "J"]:
                ws[f"{col}{idx}"].protection = Protection(locked=True)

        # Protect the sheet
        ws.protection.sheet = True
        ws.protection.enable()
        ws.protection.allow_format_columns = True
        ws.protection.allow_format_rows = True
        ws.protection.password = "biofilter"

        wb.save(output_path)

        msg = f"Excel files exported successfully to {output_path}"
        self.logger.log(msg, "INFO")

        return True

    def import_conflicts_from_excel(
        self, input_path="curation_conflicts_template.xlsx"
    ):  # noqa E501
        """
        Loads conflict decisions (status/resolution/notes) from an Excel file
        previously generated by `export_conflicts_to_excel()`.

        Only rows with real changes are updated.

        TODO: Add in the ETLLog when the Conflict is updated.
        """
        try:
            df = pd.read_excel(input_path)

            updated = 0
            for _, row in df.iterrows():
                conflict_id = row.get("id")
                if pd.isna(conflict_id):
                    continue

                conflict = self.session.query(CurationConflict).get(
                    int(conflict_id)
                )  # noqa E501
                if not conflict:
                    self.logger.log(
                        f"‚ö†Ô∏è Conflict ID {conflict_id} not found", "WARNING"
                    )  # noqa E501
                    continue

                # Parse status and resolution safely
                new_status = row.get("status")
                new_resolution = row.get("resolution")
                new_notes = row.get("notes")

                has_changes = False

                # Status
                if new_status and new_status != conflict.status.value:
                    conflict.status = ConflictStatus(new_status)
                    has_changes = True

                # Resolution
                if pd.notna(new_resolution) and new_resolution != "":
                    if (
                        conflict.resolution is None
                        or new_resolution != conflict.resolution.value
                    ):  # noqa E501
                        conflict.resolution = ConflictResolution(
                            new_resolution
                        )  # noqa E501
                        has_changes = True

                # Notes
                if pd.notna(new_notes) and new_notes != (conflict.notes or ""):
                    conflict.notes = new_notes
                    has_changes = True

                if has_changes:
                    updated += 1
                    self.logger.log(
                        f"üîÑ Updated conflict ID {conflict_id}", "DEBUG"
                    )  # noqa E501

            self.session.commit()
            self.logger.log(
                f"‚úÖ {updated} conflict(s) updated from Excel", "INFO"
            )  # noqa E501
            return updated

        except Exception as e:
            self.logger.log(
                f"‚ùå Failed to import conflicts from Excel: {e}", "ERROR"
            )  # noqa E501
            return 0

    def is_conflict_resolved(
        self, identifier_type: str, identifier: str
    ) -> bool:  # noqa E501
        return (
            self.session.query(CurationConflict)
            .filter_by(
                entity_type="gene",
                identifier_type=identifier_type,
                identifier_value=identifier,
                status=ConflictStatus.resolved,
            )
            .first()
            is not None
        )

    def apply_resolution(self, row):
        """
        Applies a curation resolution rule to a gene with previously
        resolved conflict.

        Parameters:
        - row: the current row being processed (pandas Series)
        """
        hgnc_id = row.get("hgnc_id")

        # Search for the resolved conflict associated with this gene
        conflict = (
            self.session.query(CurationConflict)
            .filter_by(
                entity_type="gene", identifier=hgnc_id, status=ConflictStatus.resolved
            )  # noqa: E501
            .first()
        )

        if not conflict:
            msg = f"No resolved conflict found for {hgnc_id}"
            self.logger.log(msg, "ERROR")
            return False

        resolution = conflict.resolution

        # DELETE BLOCK
        if resolution == ConflictResolution.delete:
            msg = f"üóëÔ∏è Applying DELETE resolution for Gene {hgnc_id}"
            self.logger.log(msg, "INFO")

            # üîí Mark the Entity as deacticated and conflict
            entity = (
                self.session.query(Entity)
                .filter_by(id=conflict.entity_id)
                .first()  # noqa: E501
            )  # noqa: E501
            if entity:
                entity.has_conflict = True
                entity.is_deactive = True
                msg = f"üîí Entity {entity.id} marked as inactive (delete)"
                self.logger.log(msg, "DEBUG")
            else:
                msg = f"‚ö†Ô∏è Entity ID {conflict.entity_id} not found"
                self.logger.log(msg, "WARNING")

            # ‚ùå Remove the Gene associated with the hgnc_id
            gene = self.session.query(GeneMaster).filter_by(hgnc_id=hgnc_id).first()
            if gene:
                self.session.delete(gene)
                msg = f"üóëÔ∏è Gene {hgnc_id} deleted from database"
                self.logger.log(msg, "INFO")
            else:
                msg = f"‚ö†Ô∏è Gene {hgnc_id} not found during delete resolution"
                self.logger.log(msg, "WARNING")

            self.session.commit()

            # TODO: IMPORTANT DEVELOPMENT NOTE:
            # I desactivated the Entity and deleted the Gene if it exists,
            # but the aliases remained pointing to the deactivated entity!!!!!

            return False

        # MERGE BLOCK
        elif resolution == ConflictResolution.merge:
            # WHAT TO DO IN THIS STRATEGY:
            # 1. Deactivate the source entity
            # 2. Migrate the EntityAliass from the source entity to the target entity                # noqa: E501
            # 3. Mark the source gene as "merged" (or merged_into)

            msg = f"üîÄ Applying MERGE resolution: {hgnc_id} ‚Üí {conflict.existing_identifier}"  # noqa: E501
            self.logger.log(msg, "INFO")

            # Load the target gene (the one that will remain in the system)
            target_gene = (
                self.session.query(GeneMaster)
                .filter_by(hgnc_id=conflict.existing_identifier)
                .first()
            )
            if not target_gene:
                msg = f"‚ùå Target gene '{conflict.existing_identifier}' not found for merge"  # noqa: E501
                self.logger.log(msg, "ERROR")
                return False

            # üîí Mark the old Entity as inactive
            source_entity = (
                self.session.query(Entity)
                .filter_by(id=conflict.entity_id)
                .first()  # noqa: E501
            )
            if source_entity:
                source_entity.has_conflict = True
                source_entity.is_deactive = True
                msg = f"üîí Entity {source_entity.id} marked as inactive (merged)"  # noqa: E501
                self.logger.log(msg, "DEBUG")
            else:
                self.logger.log(
                    f"‚ö†Ô∏è Source entity ID {conflict.entity_id} not found",
                    "WARNING",  # noqa: E501
                )

            # Migration of EntityAliass from the source entity to the target gene                    # noqa: E501
            # TODO: We are keeping the old code as is_primary, resulting in two names               # noqa: E501
            migrated = 0
            for name_obj in (
                self.session.query(EntityAlias)
                .filter_by(entity_id=source_entity.id)
                .all()
            ):
                exists = (
                    self.session.query(EntityAlias)
                    .filter_by(
                        entity_id=target_gene.entity_id, name=name_obj.name
                    )  # noqa: E501
                    .first()
                )
                if exists:
                    self.session.delete(name_obj)
                else:
                    name_obj.entity_id = target_gene.entity_id
                    name_obj.is_primary = False
                    migrated += 1

            msg = f"üîÅ Migrated {migrated} aliases to Entity {target_gene.entity_id}"  # noqa: E501
            self.logger.log(msg, "DEBUG")

            # Alterar o status do Gene para "merged"
            source_gene = (
                self.session.query(GeneMaster).filter_by(hgnc_id=hgnc_id).first()
            )  # noqa: E501
            omic_status = (
                self.session.query(OmicStatus).filter_by(name="merged").first()
            )
            if source_gene:
                source_gene.omic_status_id = omic_status.id
                # source_gene.hgnc_status = "merged"  # TODO: Create a new Field to hosting the Target Gene ID              # noqa: E501
                # source_gene.merged_into = target_gene.id
                msg = f"üìé Gene '{hgnc_id}' marked as merged into {target_gene.hgnc_id}"  # noqa: E501
                self.logger.log(msg, "DEBUG")

            self.session.commit()
            return False

        # KEEP_BOTH BLOCk
        elif resolution == ConflictResolution.keep_both:
            # WHAT TO DO IN THIS STRATEGY:
            # 1. Keep both genes in the system
            # 2. The dominant entity (item_exist) will be used for relationships and annotations    # noqa: E501

            msg = f"‚öñÔ∏è KEEP_BOTH resolution: {hgnc_id} and {conflict.existing_identifier}"  # noqa: E501
            self.logger.log(msg, "INFO")

            # Mark the Entity as having a conflict (but do not deactivate it!)
            entity = (
                self.session.query(Entity).filter_by(id=conflict.entity_id).first()
            )  # noqa: E501
            if entity:
                entity.has_conflict = True
                msg = f"üîí Entity {entity.id} marked with conflict (keep_both)"
                self.logger.log(msg, "DEBUG")
            else:
                msg = f"‚ö†Ô∏è Entity ID {conflict.entity_id} not found"
                self.logger.log(msg, "WARNING")

            # Log the conflict resolution
            msg = f"‚úîÔ∏è Both genes '{hgnc_id}' and '{conflict.item_exist}' kept ‚Äî shared ID resolution will favor '{conflict.item_exist}'"  # noqa: E501
            self.logger.log(msg, "INFO")

            # TODO: We nedd create a new Gene Here!!!

            self.session.commit()

            return False

    def normalize_gene_identifiers(self, hgnc_id, entrez_id, ensembl_id):
        def clean_id(val):
            val = str(val).strip().upper() if val else None
            return val if val and val != "NAN" else None

        return (
            clean_id(hgnc_id),
            clean_id(entrez_id),
            clean_id(ensembl_id),
        )

    def detect_gene_conflict(
        self,
        hgnc_id: str,
        entrez_id: str,
        ensembl_id: str,
        entity_id: int,
        symbol: str,
        data_source_id,
    ) -> Optional[GeneMaster]:
        """
        Returns existing Gene if safe, or logs a conflict and returns None.
        """
        filters = []
        if hgnc_id:
            filters.append(GeneMaster.hgnc_id == hgnc_id)
        if entrez_id:
            filters.append(GeneMaster.entrez_id == entrez_id)
        if ensembl_id:
            filters.append(GeneMaster.ensembl_id == ensembl_id)
        if entity_id:
            filters.append(GeneMaster.entity_id == entity_id)

        candidates = self.session.query(GeneMaster).filter(or_(*filters)).all()

        if not candidates:
            return None

        # Check for identical gene
        for g in candidates:
            if (
                g.hgnc_id == hgnc_id
                and g.entrez_id == entrez_id
                and g.ensembl_id == ensembl_id
                and g.entity_id == entity_id
            ):
                msg = f"‚ôªÔ∏è Gene already exists (identical): {symbol}"
                self.logger.log(msg, "DEBUG")
                return g

        # Check for conflicts
        for g in candidates:

            conflicts = []
            if entrez_id and g.entrez_id == entrez_id and g.hgnc_id != hgnc_id:
                conflicts.append(f"entrez_id={entrez_id}")
            if ensembl_id and g.ensembl_id == ensembl_id and g.hgnc_id != hgnc_id:
                conflicts.append(f"ensembl_id={ensembl_id}")

            if not conflicts:
                msg = f"‚ôªÔ∏è System found record conflict, but couldn't analysis it: {symbol}"  # noqa: E501
                self.logger.log(msg, "INFO")
                return g

            # Log conflict
            description = (
                f"Gene {hgnc_id} conflicts with existing gene {g.hgnc_id}, "  # noqa: E501
                f"both share same identifier(s): {', '.join(conflicts)}"
            )

            already_logged = (
                self.session.query(CurationConflict)
                .filter_by(
                    entity_type="gene",
                    identifier=hgnc_id,
                    existing_identifier=g.hgnc_id,
                    status=ConflictStatus.pending,
                )
                .first()
            )

            if not already_logged:
                conflict = CurationConflict(
                    entity_type="gene",
                    identifier=hgnc_id,
                    existing_identifier=g.hgnc_id,
                    status=ConflictStatus.pending,
                    description=description,
                    entity_id=entity_id,
                    data_source_id=data_source_id,
                )
                self.session.add(conflict)

            entity = self.session.query(Entity).filter_by(id=entity_id).first()
            if entity:
                entity.has_conflict = 1

            self.session.commit()
            self.logger.log(
                f"üö´ Conflict detected for Gene '{symbol}' - submitted for curation",  # noqa E501
                "WARNING",
            )

            return "CONFLICT"

        # # Check for existing gene with same identifiers

        # existing_gene = self.session.query(Gene).filter(or_(*filters)).first()
        # if not existing_gene:
        #     return None

        # # Same Gene!
        # if (
        #     existing_gene.hgnc_id == hgnc_id
        #     and existing_gene.entrez_id == entrez_id
        #     and existing_gene.ensembl_id == ensembl_id
        #     and existing_gene.entity_id == entity_id
        # ):
        #     msg = f"‚ôªÔ∏è Gene already exists (identical): {symbol}"
        #     self.logger.log(msg, "DEBUG")
        #     return existing_gene

        # conflicts = []
        # if (
        #     entrez_id
        #     and existing_gene.entrez_id == entrez_id
        #     and existing_gene.hgnc_id != hgnc_id
        # ):
        #     conflicts.append(f"entrez_id={entrez_id}")
        # if (
        #     ensembl_id
        #     and existing_gene.ensembl_id == ensembl_id
        #     and existing_gene.hgnc_id != hgnc_id
        # ):
        #     conflicts.append(f"ensembl_id={ensembl_id}")

        # if not conflicts:
        #     self.logger.log(f"‚ôªÔ∏è Gene already exists: {symbol}", "INFO")
        #     return existing_gene

        # # Log conflict
        # description = (
        #     f"Gene {hgnc_id} conflicts with existing gene {existing_gene.hgnc_id}, "  # noqa: E501
        #     f"both share same identifier(s): {', '.join(conflicts)}"
        # )

        # already_logged = (
        #     self.session.query(CurationConflict)
        #     .filter_by(
        #         entity_type="gene",
        #         identifier=hgnc_id,
        #         existing_identifier=existing_gene.hgnc_id,
        #         status=ConflictStatus.pending,
        #     )
        #     .first()
        # )

        # if not already_logged:
        #     conflict = CurationConflict(
        #         entity_type="gene",
        #         identifier=hgnc_id,
        #         existing_identifier=existing_gene.hgnc_id,
        #         status=ConflictStatus.pending,
        #         description=description,
        #         entity_id=entity_id,
        #         data_source_id=data_source_id,
        #     )
        #     self.session.add(conflict)

        # entity = self.session.query(Entity).filter_by(id=entity_id).first()
        # if entity:
        #     entity.has_conflict = 1

        # self.session.commit()
        # self.logger.log(
        #     f"üö´ Conflict detected for Gene '{symbol}' - submitted for curation",  # noqa E501
        #     "WARNING",
        # )
        # return "CONFLICT"

from collections.abc import Iterator, Sequence
import enum
import types
from typing import Annotated, overload

import numpy
from numpy.typing import NDArray

from . import (
    _autograd as _autograd,
    _cuda as _cuda,
    _stax as _stax,
    ops as ops,
    parallel as parallel,
    profiler as profiler
)
from tensorplay._tensor import (
    cpu as cpu,
    cuda as cuda,
    double as double,
    flatten as flatten,
    float as float,
    int as int,
    is_float as is_float,
    long as long,
    ndimension as ndimension,
    t as t,
    type as type,
    unflatten as unflatten
)


class DType(enum.Enum):
    _new_member_ = __new__

    _use_args_: bool = False

    _member_names_: list = ...

    _member_map_: dict = ...

    _value2member_map_: dict = ...

    _hashable_values_: list = []

    _unhashable_values_: list = []

    _unhashable_values_map_: dict = {}

    _value_repr_: None = None

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    float32 = 8

    float64 = 9

    int32 = 3

    int64 = 4

    uint8 = 0

    int8 = 1

    int16 = 2

    uint16 = 5

    uint32 = 6

    uint64 = 7

    bool = 10

    undefined = 13

float32: DType = DType.float32

float64: DType = DType.float64

int32: DType = DType.int32

int64: DType = DType.int64

uint8: DType = DType.uint8

int8: DType = DType.int8

int16: DType = DType.int16

uint16: DType = DType.uint16

uint32: DType = DType.uint32

uint64: DType = DType.uint64

bool: DType = DType.bool

undefined: DType = DType.undefined

class DeviceType(enum.Enum):
    _new_member_ = __new__

    _use_args_: bool = False

    _member_names_: list = ['CPU', 'CUDA']

    _member_map_: dict = ...

    _value2member_map_: dict = {0 : DeviceType.CPU, 1 : DeviceType.CUDA}

    _hashable_values_: list = []

    _unhashable_values_: list = []

    _unhashable_values_map_: dict = {}

    _value_repr_: None = None

    CPU = 0

    CUDA = 1

CPU: DeviceType = DeviceType.CPU

CUDA: DeviceType = DeviceType.CUDA

class Device:
    @overload
    def __init__(self, type: DeviceType, index: int = -1) -> None: ...

    @overload
    def __init__(self, device: str) -> None: ...

    @overload
    def __init__(self, type: str, index: int) -> None: ...

    @property
    def type(self) -> str: ...

    @property
    def index(self) -> int: ...

    def is_cpu(self) -> bool: ...

    def is_cuda(self) -> bool: ...

    def __repr__(self) -> str: ...

    def __str__(self) -> str: ...

    def __eq__(self, arg: Device, /) -> bool: ...

    def __ne__(self, arg: Device, /) -> bool: ...

class Scalar:
    @overload
    def __init__(self, arg: float, /) -> None: ...

    @overload
    def __init__(self, arg: int, /) -> None: ...

    @overload
    def __init__(self, arg: bool, /) -> None: ...

    def __repr__(self) -> str: ...

    def __float__(self) -> float: ...

    def __int__(self) -> int: ...

    def __bool__(self) -> bool: ...

class Size:
    def __init__(self, arg: Sequence[int], /) -> None: ...

    def __len__(self) -> int: ...

    def __getitem__(self, arg: int, /) -> int: ...

    def __iter__(self) -> Iterator[int]: ...

    def __repr__(self) -> str: ...

    def __str__(self) -> str: ...

    @overload
    def __eq__(self, arg: Size, /) -> bool: ...

    @overload
    def __eq__(self, arg: tuple, /) -> bool: ...

    @overload
    def __eq__(self, arg: list, /) -> bool: ...

    def __ne__(self, arg: Size, /) -> bool: ...

class Generator:
    def __init__(self, seed: int = 0) -> None: ...

    def manual_seed(self, seed: int) -> int: ...

    def seed(self) -> int: ...

    def initial_seed(self) -> int: ...

    @property
    def device(self) -> Device: ...

def default_generator() -> Generator: ...

def manual_seed(seed: int) -> None: ...

def seed(seed: int) -> None: ...

def initial_seed() -> int: ...

def from_dlpack(obj: object) -> TensorBase: ...

def to_dlpack(obj: object, stream: int | None = None) -> types.CapsuleType: ...

def as_tensor(data: object, dtype: DType | None = None, device: Device | None = None) -> object:
    """
    Converts data into a tensor, sharing data and preserving autograd history if possible.
    """

def vision_to_tensor(image: Annotated[NDArray[numpy.uint8], dict(shape=(None, None, None), order='C', device='cpu')]) -> TensorBase:
    """
    Optimized conversion from HWC uint8 image to CHW float32 tensor (div 255)
    """

def audio_to_tensor(audio: object) -> TensorBase:
    """
    Optimized conversion for audio: (Time, Channels) -> (Channels, Time) with normalization
    """

class TensorBase:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, data: object, dtype: DType | None = None, device: Device | None = None, requires_grad: bool = False) -> None: ...

    @property
    def _impl_id(self) -> int: ...

    @property
    def shape(self) -> Size: ...

    @property
    def dtype(self) -> DType: ...

    @property
    def device(self) -> Device: ...

    @property
    def ndim(self) -> int: ...

    def dim(self) -> int: ...

    def numel(self) -> int: ...

    def itemsize(self) -> int: ...

    def is_contiguous(self) -> bool: ...

    def is_complex(self) -> bool: ...

    def is_floating_point(self) -> bool: ...

    @property
    def is_sparse(self) -> bool: ...

    @property
    def strides(self) -> tuple: ...

    @overload
    def stride(self) -> tuple: ...

    @overload
    def stride(self, arg: int, /) -> int: ...

    @property
    def requires_grad(self) -> bool: ...

    @requires_grad.setter
    def requires_grad(self, arg: bool, /) -> None: ...

    @property
    def is_leaf(self) -> bool: ...

    @property
    def grad_fn(self) -> Node: ...

    def _set_grad_fn(self, node: Node, output_nr: int = 0) -> None: ...

    @property
    def is_cuda(self) -> bool: ...

    def pin_memory(self) -> TensorBase: ...

    def is_pinned(self) -> bool: ...

    @property
    def grad(self) -> TensorBase | None: ...

    @grad.setter
    def grad(self, grad: TensorBase | None) -> None: ...

    def retain_grad(self) -> None: ...

    def backward(self, gradient: TensorBase | None = None, retain_graph: bool | None = None, create_graph: bool = False) -> None: ...

    @property
    def data(self) -> TensorBase: ...

    @data.setter
    def data(self, arg: TensorBase, /) -> None: ...

    def detach(self) -> TensorBase: ...

    def detach_(self) -> object: ...

    def clone(self) -> TensorBase: ...

    def requires_grad_(self, requires_grad: bool = True) -> object: ...

    @overload
    def size(self) -> Size: ...

    @overload
    def size(self, arg: int, /) -> int: ...

    @overload
    def view(self, *args) -> TensorBase: ...

    @overload
    def view(self, shape: Sequence[int]) -> TensorBase: ...

    @overload
    def reshape(self, *args) -> TensorBase: ...

    @overload
    def reshape(self, shape: Sequence[int]) -> TensorBase: ...

    def expand(self, size: Sequence[int], implicit: bool = False) -> TensorBase: ...

    def as_strided(self, size: Sequence[int], stride: Sequence[int], storage_offset: int | None = None) -> TensorBase: ...

    def select(self, dim: int, index: int) -> TensorBase: ...

    def slice(self, dim: int, start: int, end: int, step: int = 1) -> TensorBase: ...

    @overload
    def copy_(self, src: TensorBase) -> object: ...

    @overload
    def copy_(self, src: TensorBase) -> TensorBase: ...

    @overload
    def fill_(self, value: Scalar) -> object: ...

    @overload
    def fill_(self, value: Scalar) -> TensorBase: ...

    @overload
    def zero_(self) -> object: ...

    @overload
    def zero_(self) -> TensorBase: ...

    @overload
    def bernoulli_(self) -> object: ...

    @overload
    def bernoulli_(self) -> TensorBase: ...

    @overload
    def cauchy_(self, median: float = 0.0, sigma: float = 1.0) -> object: ...

    @overload
    def cauchy_(self, median: float = 0.0, sigma: float = 1.0) -> TensorBase: ...

    @overload
    def exponential_(self, lambd: float = 1.0) -> object: ...

    @overload
    def exponential_(self, lambd: float = 1.0) -> TensorBase: ...

    @overload
    def geometric_(self, p: float) -> object: ...

    @overload
    def geometric_(self, p: float) -> TensorBase: ...

    @overload
    def log_normal_(self, mean: float = 1.0, std: float = 2.0) -> object: ...

    @overload
    def log_normal_(self, mean: float = 1.0, std: float = 2.0) -> TensorBase: ...

    @overload
    def normal_(self, mean: float = 0.0, std: float = 1.0) -> object: ...

    @overload
    def normal_(self, mean: float = 0.0, std: float = 1.0) -> TensorBase: ...

    @overload
    def random_(self, low: int = 0, high: int = 0) -> object: ...

    @overload
    def random_(self, low: int = 0, high: int = 0) -> TensorBase: ...

    @overload
    def uniform_(self, from: float = 0.0, to: float = 1.0) -> object: ...

    @overload
    def uniform_(self, from_: float = 0.0, to: float = 1.0) -> TensorBase: ...

    @staticmethod
    def _load_file_segment(filename: str, offset: int, nbytes: int, shape: Sequence[int], dtype: DType, device: Device | None = None) -> TensorBase: ...

    @staticmethod
    def _load_file_segments(filename: str, segments: Sequence[tuple[TensorBase, int, int]]) -> None: ...

    @staticmethod
    def _save_file_segments(filename: str, tensors: Sequence[TensorBase]) -> None: ...

    @staticmethod
    def _from_bytes(data: bytes, shape: Sequence[int], dtype: DType) -> TensorBase: ...

    @overload
    def add(self, other: TensorBase, alpha: Scalar = 1) -> TensorBase: ...

    @overload
    def add(self, other: Scalar, alpha: Scalar = 1) -> TensorBase: ...

    @overload
    def add(self, other: TensorBase, alpha: Scalar | None = None) -> TensorBase: ...

    @overload
    def add(self, other: Scalar, alpha: Scalar | None = None) -> TensorBase: ...

    @overload
    def add_(self, other: TensorBase, alpha: Scalar = 1) -> TensorBase: ...

    @overload
    def add_(self, other: Scalar, alpha: Scalar = 1) -> TensorBase: ...

    @overload
    def add_(self, other: TensorBase, alpha: Scalar | None = None) -> object: ...

    @overload
    def add_(self, other: Scalar, alpha: Scalar | None = None) -> object: ...

    @overload
    def sub(self, other: TensorBase, alpha: Scalar = 1) -> TensorBase: ...

    @overload
    def sub(self, other: Scalar, alpha: Scalar = 1) -> TensorBase: ...

    @overload
    def sub(self, other: TensorBase, alpha: Scalar | None = None) -> TensorBase: ...

    @overload
    def sub(self, other: Scalar, alpha: Scalar | None = None) -> TensorBase: ...

    @overload
    def sub_(self, other: TensorBase, alpha: Scalar = 1) -> TensorBase: ...

    @overload
    def sub_(self, other: Scalar, alpha: Scalar = 1) -> TensorBase: ...

    @overload
    def sub_(self, other: TensorBase, alpha: Scalar | None = None) -> object: ...

    @overload
    def sub_(self, other: Scalar, alpha: Scalar | None = None) -> object: ...

    @overload
    def mul(self, other: TensorBase) -> TensorBase: ...

    @overload
    def mul(self, other: Scalar) -> TensorBase: ...

    @overload
    def mul(self, other: TensorBase) -> TensorBase: ...

    @overload
    def mul(self, other: Scalar) -> TensorBase: ...

    @overload
    def mul_(self, other: TensorBase) -> TensorBase: ...

    @overload
    def mul_(self, other: Scalar) -> TensorBase: ...

    @overload
    def mul_(self, other: TensorBase) -> object: ...

    @overload
    def mul_(self, other: Scalar) -> object: ...

    @overload
    def div(self, other: TensorBase) -> TensorBase: ...

    @overload
    def div(self, other: Scalar) -> TensorBase: ...

    @overload
    def div(self, other: TensorBase) -> TensorBase: ...

    @overload
    def div(self, other: Scalar) -> TensorBase: ...

    @overload
    def div_(self, other: TensorBase) -> TensorBase: ...

    @overload
    def div_(self, other: Scalar) -> TensorBase: ...

    @overload
    def div_(self, other: TensorBase) -> object: ...

    @overload
    def div_(self, other: Scalar) -> object: ...

    @overload
    def mm(self, other: TensorBase) -> TensorBase: ...

    @overload
    def mm(self, other: TensorBase) -> TensorBase: ...

    @overload
    def matmul(self, other: TensorBase) -> TensorBase: ...

    @overload
    def matmul(self, other: TensorBase) -> TensorBase: ...

    @overload
    def eq(self, other: TensorBase) -> TensorBase: ...

    @overload
    def eq(self, other: Scalar) -> TensorBase: ...

    @overload
    def ne(self, other: TensorBase) -> TensorBase: ...

    @overload
    def ne(self, other: Scalar) -> TensorBase: ...

    @overload
    def lt(self, other: TensorBase) -> TensorBase: ...

    @overload
    def lt(self, other: Scalar) -> TensorBase: ...

    @overload
    def le(self, other: TensorBase) -> TensorBase: ...

    @overload
    def le(self, other: Scalar) -> TensorBase: ...

    @overload
    def gt(self, other: TensorBase) -> TensorBase: ...

    @overload
    def gt(self, other: Scalar) -> TensorBase: ...

    @overload
    def ge(self, other: TensorBase) -> TensorBase: ...

    @overload
    def ge(self, other: Scalar) -> TensorBase: ...

    def transpose(self, dim0: int, dim1: int) -> TensorBase: ...

    def permute(self, dims: Sequence[int]) -> TensorBase: ...

    @overload
    def squeeze(self) -> TensorBase: ...

    @overload
    def squeeze(self, dim: int) -> TensorBase: ...

    def unsqueeze(self, dim: int) -> TensorBase: ...

    @overload
    def split(self, split_size: int, dim: int = 0) -> list[TensorBase]: ...

    @overload
    def split(self, split_sizes: Sequence[int], dim: int = 0) -> list[TensorBase]: ...

    def chunk(self, chunks: int, dim: int = 0) -> list[TensorBase]: ...

    def unbind(self, dim: int = 0) -> list[TensorBase]: ...

    @overload
    def bernoulli(self) -> TensorBase: ...

    @overload
    def bernoulli(self) -> TensorBase: ...

    @overload
    def abs(self) -> TensorBase: ...

    @overload
    def abs(self) -> TensorBase: ...

    @overload
    def abs(self) -> TensorBase: ...

    @overload
    def acos(self) -> TensorBase: ...

    @overload
    def acos(self) -> TensorBase: ...

    @overload
    def acosh(self) -> TensorBase: ...

    @overload
    def acosh(self) -> TensorBase: ...

    @overload
    def angle(self) -> TensorBase: ...

    @overload
    def angle(self) -> TensorBase: ...

    @overload
    def asin(self) -> TensorBase: ...

    @overload
    def asin(self) -> TensorBase: ...

    @overload
    def asinh(self) -> TensorBase: ...

    @overload
    def asinh(self) -> TensorBase: ...

    @overload
    def atan(self) -> TensorBase: ...

    @overload
    def atan(self) -> TensorBase: ...

    def atan2(self, other: TensorBase) -> TensorBase: ...

    @overload
    def poisson(self) -> TensorBase: ...

    @overload
    def poisson(self) -> TensorBase: ...

    @overload
    def atanh(self) -> TensorBase: ...

    @overload
    def atanh(self) -> TensorBase: ...

    @overload
    def ceil(self) -> TensorBase: ...

    @overload
    def ceil(self) -> TensorBase: ...

    @overload
    def clamp(self, min: Scalar | None = None, max: Scalar | None = None) -> TensorBase: ...

    @overload
    def clamp(self, min: Scalar | None = None, max: Scalar | None = None) -> TensorBase: ...

    @overload
    def cos(self) -> TensorBase: ...

    @overload
    def cos(self) -> TensorBase: ...

    @overload
    def cosh(self) -> TensorBase: ...

    @overload
    def cosh(self) -> TensorBase: ...

    @overload
    def exp(self) -> TensorBase: ...

    @overload
    def exp(self) -> TensorBase: ...

    @overload
    def floor(self) -> TensorBase: ...

    @overload
    def floor(self) -> TensorBase: ...

    @overload
    def lerp(self, end: TensorBase, weight: Scalar) -> TensorBase: ...

    @overload
    def lerp(self, end: TensorBase, weight: TensorBase) -> TensorBase: ...

    @overload
    def lerp(self, end: TensorBase, weight: Scalar) -> TensorBase: ...

    @overload
    def lerp(self, end: TensorBase, weight: TensorBase) -> TensorBase: ...

    @overload
    def log(self) -> TensorBase: ...

    @overload
    def log(self) -> TensorBase: ...

    @overload
    def neg(self) -> TensorBase: ...

    @overload
    def neg(self) -> TensorBase: ...

    @overload
    def pow(self, exponent: Scalar) -> TensorBase: ...

    @overload
    def pow(self, exponent: TensorBase) -> TensorBase: ...

    @overload
    def pow(self, exponent: Scalar) -> TensorBase: ...

    @overload
    def pow(self, exponent: Scalar) -> TensorBase: ...

    @overload
    def pow(self, exponent: TensorBase) -> TensorBase: ...

    @overload
    def round(self) -> TensorBase: ...

    @overload
    def round(self) -> TensorBase: ...

    @overload
    def rsqrt(self) -> TensorBase: ...

    @overload
    def rsqrt(self) -> TensorBase: ...

    @overload
    def sigmoid(self) -> TensorBase: ...

    @overload
    def sigmoid(self) -> TensorBase: ...

    @overload
    def sign(self) -> TensorBase: ...

    @overload
    def sign(self) -> TensorBase: ...

    @overload
    def sin(self) -> TensorBase: ...

    @overload
    def sin(self) -> TensorBase: ...

    @overload
    def sinh(self) -> TensorBase: ...

    @overload
    def sinh(self) -> TensorBase: ...

    @overload
    def softmax(self, dim: int, dtype: DType = DType.undefined) -> TensorBase: ...

    @overload
    def softmax(self, dim: int, dtype: DType = DType.undefined) -> TensorBase: ...

    def log_softmax(self, dim: int, dtype: DType = DType.undefined) -> TensorBase: ...

    @overload
    def sqrt(self) -> TensorBase: ...

    @overload
    def sqrt(self) -> TensorBase: ...

    @overload
    def sqrt(self) -> TensorBase: ...

    @overload
    def square(self) -> TensorBase: ...

    @overload
    def square(self) -> TensorBase: ...

    @overload
    def tan(self) -> TensorBase: ...

    @overload
    def tan(self) -> TensorBase: ...

    @overload
    def tanh(self) -> TensorBase: ...

    @overload
    def tanh(self) -> TensorBase: ...

    @overload
    def relu(self) -> TensorBase: ...

    @overload
    def relu(self) -> TensorBase: ...

    def relu_(self) -> TensorBase: ...

    @overload
    def gelu(self) -> TensorBase: ...

    @overload
    def gelu(self) -> TensorBase: ...

    @overload
    def silu(self) -> TensorBase: ...

    @overload
    def silu(self) -> TensorBase: ...

    @overload
    def sum(self, dtype: DType = DType.undefined) -> TensorBase: ...

    @overload
    def sum(self, dim: Sequence[int], keepdim: bool = False, dtype: DType = DType.undefined) -> TensorBase: ...

    @overload
    def sum(self, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def sum(self, dim: Sequence[int], keepdim: bool = False, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def sum(self, dim: int, keepdim: bool = False, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def mean(self, dtype: DType = DType.undefined) -> TensorBase: ...

    @overload
    def mean(self, dim: Sequence[int], keepdim: bool = False, dtype: DType = DType.undefined) -> TensorBase: ...

    @overload
    def mean(self, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def mean(self, dim: Sequence[int], keepdim: bool = False, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def mean(self, dim: int, keepdim: bool = False, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def max(self) -> TensorBase: ...

    @overload
    def max(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def max(self) -> TensorBase: ...

    @overload
    def max(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def max(self, dim: int, keepdim: bool = False) -> TensorBase: ...

    @overload
    def max(self) -> TensorBase: ...

    @overload
    def max(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def max(self, dim: int, keepdim: bool = False) -> TensorBase: ...

    @overload
    def min(self) -> TensorBase: ...

    @overload
    def min(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def min(self) -> TensorBase: ...

    @overload
    def min(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def min(self, dim: int, keepdim: bool = False) -> TensorBase: ...

    @overload
    def min(self) -> TensorBase: ...

    @overload
    def min(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def min(self, dim: int, keepdim: bool = False) -> TensorBase: ...

    @overload
    def prod(self, dtype: DType = DType.undefined) -> TensorBase: ...

    @overload
    def prod(self, dim: Sequence[int], keepdim: bool = False, dtype: DType = DType.undefined) -> TensorBase: ...

    @overload
    def prod(self, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def prod(self, dim: Sequence[int], keepdim: bool = False, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def prod(self, dim: int, keepdim: bool = False, *, dtype: DType | None = None) -> TensorBase: ...

    @overload
    def argmax(self, dim: int | None = None, keepdim: bool = False) -> TensorBase: ...

    @overload
    def argmax(self, dim: int | None = None, keepdim: bool = False) -> TensorBase: ...

    @overload
    def argmin(self, dim: int | None = None, keepdim: bool = False) -> TensorBase: ...

    @overload
    def argmin(self, dim: int | None = None, keepdim: bool = False) -> TensorBase: ...

    @overload
    def all(self) -> TensorBase: ...

    @overload
    def all(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def all(self) -> TensorBase: ...

    @overload
    def all(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def all(self, dim: int, keepdim: bool = False) -> TensorBase: ...

    @overload
    def any(self) -> TensorBase: ...

    @overload
    def any(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def any(self) -> TensorBase: ...

    @overload
    def any(self, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

    @overload
    def any(self, dim: int, keepdim: bool = False) -> TensorBase: ...

    @overload
    def var(self, correction: int = 1) -> TensorBase: ...

    @overload
    def var(self, dim: Sequence[int], correction: int = 1, keepdim: bool = False) -> TensorBase: ...

    @overload
    def var(self, correction: int = 1) -> TensorBase: ...

    @overload
    def var(self, dim: Sequence[int], correction: int = 1, keepdim: bool = False) -> TensorBase: ...

    @overload
    def var(self, dim: int, correction: int = 1, keepdim: bool = False) -> TensorBase: ...

    @overload
    def std(self, correction: int = 1) -> TensorBase: ...

    @overload
    def std(self, dim: Sequence[int], correction: int = 1, keepdim: bool = False) -> TensorBase: ...

    @overload
    def std(self, correction: int = 1) -> TensorBase: ...

    @overload
    def std(self, dim: Sequence[int], correction: int = 1, keepdim: bool = False) -> TensorBase: ...

    @overload
    def std(self, dim: int, correction: int = 1, keepdim: bool = False) -> TensorBase: ...

    def median(self) -> TensorBase: ...

    @overload
    def norm(self, p: float = 2.0) -> TensorBase: ...

    @overload
    def norm(self, dim: Sequence[int], p: float = 2.0, keepdim: bool = False) -> TensorBase: ...

    @overload
    def norm(self, p: float = 2.0) -> TensorBase: ...

    @overload
    def norm(self, dim: Sequence[int], p: float = 2.0, keepdim: bool = False) -> TensorBase: ...

    @overload
    def norm(self, dim: int, p: float = 2.0, keepdim: bool = False) -> TensorBase: ...

    def masked_select(self, mask: TensorBase) -> TensorBase: ...

    @overload
    def to(self, dtype: DType, non_blocking: bool = False, copy: bool = False) -> TensorBase: ...

    @overload
    def to(self, device: Device, non_blocking: bool = False, copy: bool = False) -> TensorBase: ...

    @overload
    def to(self, device: Device, dtype: DType, non_blocking: bool = False, copy: bool = False) -> TensorBase: ...

    def __array__(self, dtype: object | None = None) -> object: ...

    def numpy(self) -> NDArray: ...

    def data_ptr(self) -> int: ...

    def item(self) -> object: ...

    def tolist(self) -> object: ...

    def __getitem__(self, arg: object, /) -> TensorBase: ...

    def __setitem__(self, arg0: object, arg1: object, /) -> None: ...

    def __neg__(self) -> TensorBase: ...

    @overload
    def __add__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __add__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __add__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __sub__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __sub__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __sub__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __mul__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __mul__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __mul__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __truediv__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __truediv__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __truediv__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __iadd__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __iadd__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __isub__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __isub__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __imul__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __imul__(self, arg: float, /) -> TensorBase: ...

    @overload
    def __itruediv__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __itruediv__(self, arg: float, /) -> TensorBase: ...

    def __rtruediv__(self, arg: float, /) -> TensorBase: ...

    def __radd__(self, arg: float, /) -> TensorBase: ...

    def __rsub__(self, arg: float, /) -> TensorBase: ...

    def __rmul__(self, arg: float, /) -> TensorBase: ...

    def __matmul__(self, other: TensorBase) -> TensorBase: ...

    @overload
    def __eq__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __eq__(self, arg: Scalar, /) -> TensorBase: ...

    @overload
    def __ne__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __ne__(self, arg: Scalar, /) -> TensorBase: ...

    @overload
    def __lt__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __lt__(self, arg: Scalar, /) -> TensorBase: ...

    @overload
    def __le__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __le__(self, arg: Scalar, /) -> TensorBase: ...

    @overload
    def __gt__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __gt__(self, arg: Scalar, /) -> TensorBase: ...

    @overload
    def __ge__(self, arg: TensorBase, /) -> TensorBase: ...

    @overload
    def __ge__(self, arg: Scalar, /) -> TensorBase: ...

    @overload
    def __pow__(self, exponent: Scalar) -> TensorBase: ...

    @overload
    def __pow__(self, exponent: TensorBase) -> TensorBase: ...

    def __rpow__(self, arg: Scalar, /) -> TensorBase: ...

    def __dlpack__(self, stream: int | None = None) -> types.CapsuleType: ...

    def __dlpack_device__(self) -> tuple: ...

    def share_memory_(self) -> object: ...

    def is_shared(self) -> bool: ...

    def __getstate__(self) -> tuple: ...

    def __reduce__(self) -> tuple: ...

    def __setstate__(self, arg: tuple, /) -> None: ...

    def __repr__(self) -> str: ...

    def __str__(self) -> str: ...

class Node:
    @property
    def name(self) -> str: ...

    @property
    def next_functions(self) -> list[tuple[Node, int]]: ...

    @property
    def variable(self) -> TensorBase | None: ...

def tensor(data: object, *, dtype: DType | None = None, device: Device | None = None, requires_grad: bool = False) -> TensorBase:
    """
    tensor(data, *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def zeros(size: Sequence[int], *, dtype: DType | None = None, device: Device | None = None, requires_grad: bool = False) -> TensorBase:
    """
    zeros(size: Sequence[int], *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def zeros(*args, **kwargs) -> TensorBase:
    """
    zeros(*size: int, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def zeros(size: Sequence[int], dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def ones(size: Sequence[int], *, dtype: DType | None = None, device: Device | None = None, requires_grad: bool = False) -> TensorBase:
    """
    ones(size: Sequence[int], *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def ones(*args, **kwargs) -> TensorBase:
    """
    ones(*size: int, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def ones(size: Sequence[int], dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def eye(n: int, m: int = -1, *, dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase:
    """
    eye(n: int, m: int = -1, *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def eye(n: int, m: int = -1, dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def empty(size: Sequence[int], *, dtype: DType | None = None, device: Device | None = None, requires_grad: bool = False) -> TensorBase:
    """
    empty(size: Sequence[int], *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def empty(*args, **kwargs) -> TensorBase:
    """
    empty(*size: int, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def empty(size: Sequence[int], dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def rand(size: Sequence[int], *, dtype: DType | None = None, device: Device | None = None, requires_grad: bool = False) -> TensorBase:
    """
    rand(size: Sequence[int], *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def rand(*args, **kwargs) -> TensorBase:
    """
    rand(*size: int, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def rand(size: Sequence[int], dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def randint(low: int, high: int, size: Sequence[int], *, dtype: DType = DType.int64, device: Device = ..., requires_grad: bool = False) -> TensorBase:
    """
    randint(low: int, high: int, size: Sequence[int], *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def randint(low: int, high: int, size: Sequence[int], dtype: DType = DType.int64, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def randn(size: Sequence[int], *, dtype: DType | None = None, device: Device | None = None, requires_grad: bool = False) -> TensorBase:
    """
    randn(size: Sequence[int], *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def randn(*args, **kwargs) -> TensorBase:
    """
    randn(*size: int, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def randn(size: Sequence[int], dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def randperm(n: int, *, dtype: DType = DType.int64, device: Device = ..., requires_grad: bool = False) -> TensorBase:
    """
    randperm(n: int, *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def randperm(n: int, dtype: DType = DType.int64, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def full(shape: Sequence[int], fill_value: Scalar, *, dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase:
    """
    full(shape: Sequence[int], fill_value: Union[float, int], *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def full(size: Sequence[int], fill_value: Scalar, dtype: DType = DType.undefined, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

def embedding(weight: TensorBase, indices: TensorBase, padding_idx: int = -1, scale_grad_by_freq: bool = False, sparse: bool = False) -> TensorBase: ...

def embedding_dense_backward(grad_output: TensorBase, indices: TensorBase, num_weights: int, padding_idx: int, scale_grad_by_freq: bool) -> TensorBase: ...

def conv1d(input: TensorBase, weight: TensorBase, bias: TensorBase = ..., stride: Sequence[int] = [1], padding: Sequence[int] = [0], dilation: Sequence[int] = [1], groups: int = 1) -> TensorBase: ...

def conv1d_grad_input(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv1d_grad_weight(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv1d_grad_bias(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv2d(input: TensorBase, weight: TensorBase, bias: TensorBase = ..., stride: Sequence[int] = [1, 1], padding: Sequence[int] = [0, 0], dilation: Sequence[int] = [1, 1], groups: int = 1) -> TensorBase: ...

def conv2d_grad_input(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv2d_grad_weight(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv2d_grad_bias(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv3d(input: TensorBase, weight: TensorBase, bias: TensorBase = ..., stride: Sequence[int] = [1, 1, 1], padding: Sequence[int] = [0, 0, 0], dilation: Sequence[int] = [1, 1, 1], groups: int = 1) -> TensorBase: ...

def conv3d_grad_input(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv3d_grad_weight(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv3d_grad_bias(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], dilation: Sequence[int], groups: int) -> TensorBase: ...

def conv_transpose2d(input: TensorBase, weight: TensorBase, bias: TensorBase = ..., stride: Sequence[int] = [1, 1], padding: Sequence[int] = [0, 0], output_padding: Sequence[int] = [0, 0], groups: int = 1, dilation: Sequence[int] = [1, 1]) -> TensorBase: ...

def conv_transpose2d_grad_input(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], output_padding: Sequence[int], groups: int, dilation: Sequence[int]) -> TensorBase: ...

def conv_transpose2d_grad_weight(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], output_padding: Sequence[int], groups: int, dilation: Sequence[int]) -> TensorBase: ...

def conv_transpose2d_grad_bias(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], output_padding: Sequence[int], groups: int, dilation: Sequence[int]) -> TensorBase: ...

def conv_transpose3d(input: TensorBase, weight: TensorBase, bias: TensorBase = ..., stride: Sequence[int] = [1, 1, 1], padding: Sequence[int] = [0, 0, 0], output_padding: Sequence[int] = [0, 0, 0], groups: int = 1, dilation: Sequence[int] = [1, 1, 1]) -> TensorBase: ...

def conv_transpose3d_grad_input(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], output_padding: Sequence[int], groups: int, dilation: Sequence[int]) -> TensorBase: ...

def constant_pad_nd(self: TensorBase, pad: Sequence[int], value: Scalar) -> TensorBase: ...

def constant_pad_nd_backward(grad_output: TensorBase, pad: Sequence[int]) -> TensorBase: ...

def conv_transpose3d_grad_weight(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], output_padding: Sequence[int], groups: int, dilation: Sequence[int]) -> TensorBase: ...

def conv_transpose3d_grad_bias(grad_output: TensorBase, input: TensorBase, weight: TensorBase, stride: Sequence[int], padding: Sequence[int], output_padding: Sequence[int], groups: int, dilation: Sequence[int]) -> TensorBase: ...

def mm(self: TensorBase, other: TensorBase) -> TensorBase: ...

def matmul(self: TensorBase, other: TensorBase) -> TensorBase: ...

@overload
def eq(self: TensorBase, other: TensorBase) -> TensorBase: ...

@overload
def eq(self: TensorBase, other: Scalar) -> TensorBase: ...

@overload
def ne(self: TensorBase, other: TensorBase) -> TensorBase: ...

@overload
def ne(self: TensorBase, other: Scalar) -> TensorBase: ...

@overload
def lt(self: TensorBase, other: TensorBase) -> TensorBase: ...

@overload
def lt(self: TensorBase, other: Scalar) -> TensorBase: ...

@overload
def le(self: TensorBase, other: TensorBase) -> TensorBase: ...

@overload
def le(self: TensorBase, other: Scalar) -> TensorBase: ...

@overload
def gt(self: TensorBase, other: TensorBase) -> TensorBase: ...

@overload
def gt(self: TensorBase, other: Scalar) -> TensorBase: ...

@overload
def ge(self: TensorBase, other: TensorBase) -> TensorBase: ...

@overload
def ge(self: TensorBase, other: Scalar) -> TensorBase: ...

def transpose(self: TensorBase, dim0: int, dim1: int) -> TensorBase: ...

def t(self: TensorBase) -> TensorBase: ...

def permute(self: TensorBase, dims: Sequence[int]) -> TensorBase: ...

def permute_backward(grad_output: TensorBase, self: TensorBase, dims: Sequence[int]) -> TensorBase: ...

@overload
def squeeze(self: TensorBase) -> TensorBase: ...

@overload
def squeeze(self: TensorBase, dim: int) -> TensorBase: ...

def squeeze_backward(grad_output: TensorBase, self: TensorBase) -> TensorBase: ...

def unsqueeze(self: TensorBase, dim: int) -> TensorBase: ...

def cat(tensors: Sequence[TensorBase], dim: int = 0) -> TensorBase: ...

def stack(tensors: Sequence[TensorBase], dim: int = 0) -> TensorBase: ...

@overload
def split(self: TensorBase, split_size: int, dim: int = 0) -> list[TensorBase]: ...

@overload
def split(self: TensorBase, split_sizes: Sequence[int], dim: int = 0) -> list[TensorBase]: ...

def chunk(self: TensorBase, chunks: int, dim: int = 0) -> list[TensorBase]: ...

def reshape(self: TensorBase, shape: Sequence[int]) -> TensorBase: ...

def unbind(self: TensorBase, dim: int = 0) -> list[TensorBase]: ...

def rand_like(self: TensorBase, dtype: DType = DType.undefined, device: Device | None = None, requires_grad: bool = False) -> TensorBase: ...

def randint_like(self: TensorBase, low: int, high: int, dtype: DType = DType.undefined, device: Device | None = None, requires_grad: bool = False) -> TensorBase: ...

def randn_like(self: TensorBase, dtype: DType = DType.undefined, device: Device | None = None, requires_grad: bool = False) -> TensorBase: ...

def bernoulli(self: TensorBase) -> TensorBase: ...

def normal(mean: TensorBase, std: TensorBase) -> TensorBase: ...

def abs(self: TensorBase) -> TensorBase: ...

def acos(self: TensorBase) -> TensorBase: ...

def acosh(self: TensorBase) -> TensorBase: ...

def angle(self: TensorBase) -> TensorBase: ...

def asin(self: TensorBase) -> TensorBase: ...

def asinh(self: TensorBase) -> TensorBase: ...

def atan(self: TensorBase) -> TensorBase: ...

def atan2(self: TensorBase, other: TensorBase) -> TensorBase: ...

def poisson(self: TensorBase) -> TensorBase: ...

def atanh(self: TensorBase) -> TensorBase: ...

def ceil(self: TensorBase) -> TensorBase: ...

def clamp(self: TensorBase, min: Scalar | None = None, max: Scalar | None = None) -> TensorBase: ...

def clamp_backward(grad_output: TensorBase, self: TensorBase, min: Scalar | None = None, max: Scalar | None = None) -> TensorBase: ...

def cos(self: TensorBase) -> TensorBase: ...

def cosh(self: TensorBase) -> TensorBase: ...

def exp(self: TensorBase) -> TensorBase: ...

def floor(self: TensorBase) -> TensorBase: ...

@overload
def lerp(self: TensorBase, end: TensorBase, weight: Scalar) -> TensorBase: ...

@overload
def lerp(self: TensorBase, end: TensorBase, weight: TensorBase) -> TensorBase: ...

def log(self: TensorBase) -> TensorBase: ...

def neg(self: TensorBase) -> TensorBase: ...

@overload
def pow(self: TensorBase, exponent: Scalar) -> TensorBase: ...

@overload
def pow(self: TensorBase, exponent: TensorBase) -> TensorBase: ...

def round(self: TensorBase) -> TensorBase: ...

def rsqrt(self: TensorBase) -> TensorBase: ...

def sigmoid(self: TensorBase) -> TensorBase: ...

def sign(self: TensorBase) -> TensorBase: ...

def sin(self: TensorBase) -> TensorBase: ...

def sinh(self: TensorBase) -> TensorBase: ...

def softmax(self: TensorBase, dim: int, dtype: DType = DType.undefined) -> TensorBase: ...

def log_softmax(self: TensorBase, dim: int, dtype: DType = DType.undefined) -> TensorBase: ...

def sqrt(self: TensorBase) -> TensorBase: ...

def square(self: TensorBase) -> TensorBase: ...

def tan(self: TensorBase) -> TensorBase: ...

def tanh(self: TensorBase) -> TensorBase: ...

def relu(self: TensorBase) -> TensorBase: ...

def relu_(self: TensorBase) -> TensorBase: ...

def threshold_backward(grad_output: TensorBase, output: TensorBase, threshold: Scalar) -> TensorBase: ...

def gelu(self: TensorBase) -> TensorBase: ...

def silu(self: TensorBase) -> TensorBase: ...

@overload
def arange(start: Scalar, end: Scalar, step: Scalar = 1, dtype: DType = DType.undefined, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def arange(end: Scalar, dtype: DType = DType.undefined, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def linspace(start: Scalar, end: Scalar, steps: int, dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def linspace(start: Scalar, end: Scalar, steps: int, *, dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase:
    """
    linspace(start: float, end: float, steps: int, *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def logspace(start: Scalar, end: Scalar, steps: int, base: float = 10.0, dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase: ...

@overload
def logspace(start: Scalar, end: Scalar, steps: int, base: float = 10.0, *, dtype: DType = DType.float32, device: Device = ..., requires_grad: bool = False) -> TensorBase:
    """
    logspace(start: float, end: float, steps: int, base: float = 10.0, *, dtype: Optional[DType] = None, device: Optional[Device] = None, requires_grad: bool = False) -> Tensor
    """

@overload
def sum(self: TensorBase, dtype: DType = DType.undefined) -> TensorBase: ...

@overload
def sum(self: TensorBase, dim: Sequence[int], keepdim: bool = False, dtype: DType = DType.undefined) -> TensorBase: ...

@overload
def mean(self: TensorBase, dtype: DType = DType.undefined) -> TensorBase: ...

@overload
def mean(self: TensorBase, dim: Sequence[int], keepdim: bool = False, dtype: DType = DType.undefined) -> TensorBase: ...

@overload
def max(self: TensorBase) -> TensorBase: ...

@overload
def max(self: TensorBase, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

@overload
def min(self: TensorBase) -> TensorBase: ...

@overload
def min(self: TensorBase, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

@overload
def prod(self: TensorBase, dtype: DType = DType.undefined) -> TensorBase: ...

@overload
def prod(self: TensorBase, dim: Sequence[int], keepdim: bool = False, dtype: DType = DType.undefined) -> TensorBase: ...

def argmax(self: TensorBase, dim: int | None = None, keepdim: bool = False) -> TensorBase: ...

def argmin(self: TensorBase, dim: int | None = None, keepdim: bool = False) -> TensorBase: ...

@overload
def all(self: TensorBase) -> TensorBase: ...

@overload
def all(self: TensorBase, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

@overload
def any(self: TensorBase) -> TensorBase: ...

@overload
def any(self: TensorBase, dim: Sequence[int], keepdim: bool = False) -> TensorBase: ...

@overload
def var(self: TensorBase, correction: int = 1) -> TensorBase: ...

@overload
def var(self: TensorBase, dim: Sequence[int], correction: int = 1, keepdim: bool = False) -> TensorBase: ...

@overload
def std(self: TensorBase, correction: int = 1) -> TensorBase: ...

@overload
def std(self: TensorBase, dim: Sequence[int], correction: int = 1, keepdim: bool = False) -> TensorBase: ...

def median(self: TensorBase) -> TensorBase: ...

@overload
def norm(self: TensorBase, p: float = 2.0) -> TensorBase: ...

@overload
def norm(self: TensorBase, dim: Sequence[int], p: float = 2.0, keepdim: bool = False) -> TensorBase: ...

def empty_like(self: TensorBase, dtype: DType = DType.undefined, device: Device | None = None, requires_grad: bool = False) -> TensorBase: ...

def zeros_like(self: TensorBase, dtype: DType = DType.undefined, device: Device | None = None, requires_grad: bool = False) -> TensorBase: ...

def ones_like(self: TensorBase, dtype: DType = DType.undefined, device: Device | None = None, requires_grad: bool = False) -> TensorBase: ...

def full_like(self: TensorBase, fill_value: Scalar, dtype: DType = DType.undefined, device: Device | None = None, requires_grad: bool = False) -> TensorBase: ...

def masked_select(self: TensorBase, mask: TensorBase) -> TensorBase: ...

def max_pool2d(input: TensorBase, kernel_size: Sequence[int], stride: Sequence[int] = [], padding: Sequence[int] = [0, 0], dilation: Sequence[int] = [1, 1], ceil_mode: bool = False) -> TensorBase: ...

def avg_pool2d(input: TensorBase, kernel_size: Sequence[int], stride: Sequence[int] = [], padding: Sequence[int] = [0, 0], ceil_mode: bool = False, count_include_pad: bool = True, divisor_override: int | None = None) -> TensorBase: ...

def adaptive_avg_pool2d(input: TensorBase, output_size: Sequence[int]) -> TensorBase: ...

def adaptive_max_pool2d(input: TensorBase, output_size: Sequence[int]) -> TensorBase: ...

def nll_loss(self: TensorBase, target: TensorBase, weight: TensorBase | None = None, reduction: int = 1, ignore_index: int = -100) -> tuple[TensorBase, TensorBase]: ...

def nll_loss_backward(grad_output: TensorBase, self: TensorBase, target: TensorBase, weight: TensorBase | None = None, reduction: int = 1, ignore_index: int = -100, total_weight: TensorBase = ...) -> TensorBase: ...

def mse_loss(self: TensorBase, target: TensorBase, reduction: int = 1) -> TensorBase: ...

def mse_loss_backward(grad_output: TensorBase, self: TensorBase, target: TensorBase, reduction: int = 1) -> TensorBase: ...

def max_pool2d_backward(grad_output: TensorBase, input: TensorBase, kernel_size: Sequence[int], stride: Sequence[int] = [], padding: Sequence[int] = [0, 0], dilation: Sequence[int] = [1, 1], ceil_mode: bool = False) -> TensorBase: ...

def avg_pool2d_backward(grad_output: TensorBase, input: TensorBase, kernel_size: Sequence[int], stride: Sequence[int] = [], padding: Sequence[int] = [0, 0], ceil_mode: bool = False, count_include_pad: bool = True, divisor_override: int | None = None) -> TensorBase: ...

def adaptive_avg_pool2d_backward(grad_output: TensorBase, input: TensorBase) -> TensorBase: ...

def adaptive_max_pool2d_backward(grad_output: TensorBase, input: TensorBase) -> TensorBase: ...

def batch_norm(input: TensorBase, weight: TensorBase, bias: TensorBase, running_mean: TensorBase, running_var: TensorBase, training: bool, momentum: float, eps: float) -> TensorBase: ...

def layer_norm(input: TensorBase, normalized_shape: Sequence[int], weight: TensorBase | None = None, bias: TensorBase | None = None, eps: float = 1e-05) -> TensorBase: ...

def group_norm(input: TensorBase, num_groups: int, weight: TensorBase | None = None, bias: TensorBase | None = None, eps: float = 1e-05) -> TensorBase: ...

def instance_norm(input: TensorBase, weight: TensorBase | None = None, bias: TensorBase | None = None, running_mean: TensorBase | None = None, running_var: TensorBase | None = None, use_input_stats: bool = True, momentum: float = 0.1, eps: float = 1e-05) -> TensorBase: ...

def batch_norm_backward(grad_output: TensorBase, input: TensorBase, weight: TensorBase | None = None, running_mean: TensorBase | None = None, running_var: TensorBase | None = None, training: bool = True, eps: float = 1e-05) -> tuple[TensorBase, TensorBase, TensorBase]: ...

def layer_norm_backward(grad_output: TensorBase, input: TensorBase, normalized_shape: Sequence[int], weight: TensorBase | None = None, bias: TensorBase | None = None, eps: float = 1e-05) -> tuple[TensorBase, TensorBase, TensorBase]: ...

def group_norm_backward(grad_output: TensorBase, input: TensorBase, num_groups: int, weight: TensorBase | None = None, bias: TensorBase | None = None, eps: float = 1e-05) -> tuple[TensorBase, TensorBase, TensorBase]: ...

def instance_norm_backward(grad_output: TensorBase, input: TensorBase, weight: TensorBase | None = None, bias: TensorBase | None = None, running_mean: TensorBase | None = None, running_var: TensorBase | None = None, use_input_stats: bool = True, eps: float = 1e-05) -> tuple[TensorBase, TensorBase, TensorBase]: ...

@overload
def _show_config() -> str: ...

@overload
def _show_config() -> str: ...

def is_cuda_available() -> bool: ...

def _cxx_flags() -> str: ...

def _parallel_info() -> str: ...

def _get_build_info() -> dict[str, str]: ...

def set_printoptions(edge_items: int = -1, threshold: int = -1, precision: int = -1, linewidth: int = -1) -> None:
    """Set print options"""

def has_mkldnn() -> bool: ...

def is_mkldnn_enabled() -> bool: ...

def set_mkldnn_enabled(arg: bool, /) -> None: ...

def has_mkl() -> bool: ...

def has_openmp() -> bool: ...

def _add_docstr(obj: object | None, doc: str) -> object:
    """Adds or replaces the docstring of a Python object."""

def _set_module_name(arg0: object, arg1: str, /) -> None: ...

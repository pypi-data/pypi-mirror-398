#!/usr/bin/env python3
"""
Malware Analyzer - An√°lise est√°tica de malware e arquivos suspeitos
Parte do toolkit Olho de Deus

NOTA: Este m√≥dulo analisa arquivos potencialmente maliciosos.
Execute em ambiente isolado (sandbox/VM).
"""

import os
import sys
import re
import json
import hashlib
import struct
from typing import List, Dict, Optional, Set, Tuple
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
import string
import binascii

try:
    import requests
except ImportError:
    requests = None


@dataclass
class FileAnalysis:
    """Resultado de an√°lise de arquivo."""
    filename: str
    size: int
    md5: str
    sha1: str
    sha256: str
    file_type: str
    magic_bytes: str
    entropy: float
    strings: List[str]
    suspicious_strings: List[str]
    imports: List[str]
    urls: List[str]
    ips: List[str]
    emails: List[str]
    registry_keys: List[str]
    yara_matches: List[str]
    risk_score: int
    
    def to_dict(self) -> Dict:
        return {
            "filename": self.filename,
            "size": self.size,
            "hashes": {
                "md5": self.md5,
                "sha1": self.sha1,
                "sha256": self.sha256
            },
            "file_type": self.file_type,
            "magic_bytes": self.magic_bytes,
            "entropy": self.entropy,
            "strings_count": len(self.strings),
            "suspicious_strings": self.suspicious_strings,
            "imports": self.imports,
            "urls": self.urls,
            "ips": self.ips,
            "emails": self.emails,
            "registry_keys": self.registry_keys,
            "yara_matches": self.yara_matches,
            "risk_score": self.risk_score
        }


class FileTypeDetector:
    """Detector de tipos de arquivo por magic bytes."""
    
    MAGIC_SIGNATURES = {
        b'\x4D\x5A': 'PE/EXE',
        b'\x7F\x45\x4C\x46': 'ELF',
        b'\x50\x4B\x03\x04': 'ZIP/Office/APK',
        b'\x50\x4B\x05\x06': 'ZIP (empty)',
        b'\x25\x50\x44\x46': 'PDF',
        b'\xD0\xCF\x11\xE0': 'OLE/DOC/XLS',
        b'\x7B\x5C\x72\x74': 'RTF',
        b'\xFF\xD8\xFF': 'JPEG',
        b'\x89\x50\x4E\x47': 'PNG',
        b'\x47\x49\x46\x38': 'GIF',
        b'\x52\x61\x72\x21': 'RAR',
        b'\x1F\x8B': 'GZIP',
        b'\x42\x5A\x68': 'BZIP2',
        b'\xFD\x37\x7A\x58\x5A': 'XZ',
        b'\x4D\x53\x43\x46': 'CAB',
        b'\x21\x3C\x61\x72\x63\x68\x3E': 'DEB',
        b'\xED\xAB\xEE\xDB': 'RPM',
        b'\xCA\xFE\xBA\xBE': 'Java Class/Mach-O',
        b'\x00\x00\x00\x20\x66\x74\x79\x70': 'MP4',
        b'\x00\x00\x01\xBA': 'MPEG',
        b'\x49\x44\x33': 'MP3',
        b'\x52\x49\x46\x46': 'RIFF/AVI/WAV',
    }
    
    @classmethod
    def detect(cls, data: bytes) -> str:
        """Detecta tipo de arquivo pelos magic bytes."""
        for magic, file_type in cls.MAGIC_SIGNATURES.items():
            if data.startswith(magic):
                return file_type
        return "Unknown"


class StringExtractor:
    """Extrator de strings de bin√°rios."""
    
    # Padr√µes suspeitos
    SUSPICIOUS_PATTERNS = [
        # Comandos de sistema
        r'cmd\.exe', r'powershell', r'wscript', r'cscript',
        r'/bin/sh', r'/bin/bash', r'wget', r'curl',
        
        # Registro Windows
        r'HKEY_LOCAL_MACHINE', r'HKEY_CURRENT_USER', r'HKLM', r'HKCU',
        r'Run\\', r'RunOnce\\', r'CurrentVersion\\Run',
        
        # Malware keywords
        r'keylog', r'screenshot', r'webcam', r'microphone',
        r'password', r'credential', r'bitcoin', r'wallet',
        r'ransom', r'encrypt', r'decrypt', r'victim',
        
        # C2/Network
        r'socket', r'connect', r'recv', r'send',
        r'download', r'upload', r'exfil',
        
        # Anti-analysis
        r'vmware', r'virtualbox', r'sandbox', r'debugger',
        r'IsDebuggerPresent', r'CheckRemoteDebugger',
        r'GetTickCount', r'QueryPerformanceCounter',
        
        # Crypto
        r'AES', r'RSA', r'CryptEncrypt', r'CryptDecrypt',
        r'base64', r'xor',
    ]
    
    # Regex para URLs
    URL_PATTERN = re.compile(
        r'https?://[a-zA-Z0-9\-._~:/?#\[\]@!$&\'()*+,;=%]+',
        re.IGNORECASE
    )
    
    # Regex para IPs
    IP_PATTERN = re.compile(
        r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}'
        r'(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b'
    )
    
    # Regex para emails
    EMAIL_PATTERN = re.compile(
        r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
    )
    
    # Regex para registry
    REGISTRY_PATTERN = re.compile(
        r'HKEY_[A-Z_]+\\[^\s"\'<>|]+',
        re.IGNORECASE
    )
    
    @classmethod
    def extract_strings(cls, data: bytes, min_length: int = 4) -> List[str]:
        """Extrai strings ASCII e Unicode."""
        strings = set()
        
        # ASCII strings
        ascii_pattern = re.compile(
            b'[' + bytes(string.printable, 'ascii') + b']{' + 
            str(min_length).encode() + b',}'
        )
        for match in ascii_pattern.finditer(data):
            try:
                s = match.group().decode('ascii', errors='ignore').strip()
                if s:
                    strings.add(s)
            except Exception:
                pass
        
        # Unicode strings (UTF-16LE common in Windows)
        try:
            unicode_data = data.decode('utf-16le', errors='ignore')
            for s in re.findall(r'[\x20-\x7e]{' + str(min_length) + r',}', unicode_data):
                strings.add(s)
        except Exception:
            pass
        
        return list(strings)
    
    @classmethod
    def find_suspicious(cls, strings: List[str]) -> List[str]:
        """Encontra strings suspeitas."""
        suspicious = []
        
        for s in strings:
            for pattern in cls.SUSPICIOUS_PATTERNS:
                if re.search(pattern, s, re.IGNORECASE):
                    suspicious.append(s)
                    break
        
        return list(set(suspicious))
    
    @classmethod
    def extract_urls(cls, text: str) -> List[str]:
        """Extrai URLs."""
        return list(set(cls.URL_PATTERN.findall(text)))
    
    @classmethod
    def extract_ips(cls, text: str) -> List[str]:
        """Extrai endere√ßos IP."""
        ips = cls.IP_PATTERN.findall(text)
        # Filtrar IPs privados e localhost
        return [ip for ip in set(ips) if not ip.startswith(('127.', '0.', '192.168.', '10.'))]
    
    @classmethod
    def extract_emails(cls, text: str) -> List[str]:
        """Extrai emails."""
        return list(set(cls.EMAIL_PATTERN.findall(text)))
    
    @classmethod
    def extract_registry(cls, text: str) -> List[str]:
        """Extrai chaves de registro."""
        return list(set(cls.REGISTRY_PATTERN.findall(text)))


class EntropyCalculator:
    """Calculador de entropia de Shannon."""
    
    @staticmethod
    def calculate(data: bytes) -> float:
        """Calcula entropia do arquivo."""
        from collections import Counter
        import math
        
        if not data:
            return 0.0
        
        counter = Counter(data)
        length = len(data)
        
        entropy = 0.0
        for count in counter.values():
            prob = count / length
            if prob > 0:
                entropy -= prob * math.log2(prob)
        
        return round(entropy, 4)
    
    @staticmethod
    def is_packed(entropy: float) -> bool:
        """Verifica se arquivo parece estar compactado/criptografado."""
        # Entropia > 7.0 sugere packing/encryption
        return entropy > 7.0


class PEAnalyzer:
    """Analisador de arquivos PE (Windows executables)."""
    
    SUSPICIOUS_IMPORTS = [
        'VirtualAlloc', 'VirtualProtect', 'WriteProcessMemory',
        'CreateRemoteThread', 'NtCreateThreadEx', 'RtlCreateUserThread',
        'LoadLibraryA', 'LoadLibraryW', 'GetProcAddress',
        'URLDownloadToFile', 'WinExec', 'ShellExecute',
        'RegOpenKeyEx', 'RegSetValueEx', 'RegCreateKeyEx',
        'CryptEncrypt', 'CryptDecrypt', 'CryptGenKey',
        'WSAStartup', 'socket', 'connect', 'send', 'recv',
        'InternetOpen', 'InternetConnect', 'HttpSendRequest',
        'IsDebuggerPresent', 'CheckRemoteDebuggerPresent',
        'NtQueryInformationProcess', 'GetTickCount',
        'CreateService', 'StartService',
        'AdjustTokenPrivileges', 'OpenProcessToken',
    ]
    
    @classmethod
    def parse_pe(cls, data: bytes) -> Dict:
        """Parse b√°sico de PE header."""
        result = {
            "is_pe": False,
            "machine": None,
            "sections": [],
            "imports": [],
            "exports": [],
            "suspicious_imports": []
        }
        
        if not data.startswith(b'MZ'):
            return result
        
        try:
            # Offset do PE header
            pe_offset = struct.unpack('<I', data[0x3C:0x40])[0]
            
            # Verificar assinatura PE
            if data[pe_offset:pe_offset+4] != b'PE\x00\x00':
                return result
            
            result["is_pe"] = True
            
            # Machine type
            machine = struct.unpack('<H', data[pe_offset+4:pe_offset+6])[0]
            machines = {0x14c: 'i386', 0x8664: 'AMD64', 0x1c0: 'ARM'}
            result["machine"] = machines.get(machine, f'0x{machine:04x}')
            
            # Number of sections
            num_sections = struct.unpack('<H', data[pe_offset+6:pe_offset+8])[0]
            result["num_sections"] = num_sections
            
        except Exception:
            pass
        
        return result


class VirusTotalChecker:
    """Verificador VirusTotal."""
    
    API_URL = "https://www.virustotal.com/api/v3"
    
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        self.session = requests.Session() if requests else None
        
        if self.session and api_key:
            self.session.headers.update({
                'x-apikey': api_key
            })
    
    def check_hash(self, file_hash: str) -> Optional[Dict]:
        """Verifica hash no VirusTotal."""
        if not self.session or not self.api_key:
            return None
        
        try:
            url = f"{self.API_URL}/files/{file_hash}"
            response = self.session.get(url, timeout=30)
            
            if response.status_code == 200:
                return response.json()
        except Exception:
            pass
        
        return None


class MalwareAnalyzer:
    """Analisador de malware principal."""
    
    def __init__(self, vt_api_key: Optional[str] = None):
        self.vt_checker = VirusTotalChecker(vt_api_key)
    
    def analyze_file(self, file_path: str) -> FileAnalysis:
        """Analisa um arquivo."""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Arquivo n√£o encontrado: {file_path}")
        
        with open(file_path, 'rb') as f:
            data = f.read()
        
        # Hashes
        md5 = hashlib.md5(data).hexdigest()
        sha1 = hashlib.sha1(data).hexdigest()
        sha256 = hashlib.sha256(data).hexdigest()
        
        # Tipo de arquivo
        file_type = FileTypeDetector.detect(data)
        magic_bytes = binascii.hexlify(data[:16]).decode()
        
        # Entropia
        entropy = EntropyCalculator.calculate(data)
        
        # Strings
        strings = StringExtractor.extract_strings(data)
        all_text = ' '.join(strings)
        
        suspicious_strings = StringExtractor.find_suspicious(strings)
        urls = StringExtractor.extract_urls(all_text)
        ips = StringExtractor.extract_ips(all_text)
        emails = StringExtractor.extract_emails(all_text)
        registry_keys = StringExtractor.extract_registry(all_text)
        
        # An√°lise PE
        imports = []
        if file_type == 'PE/EXE':
            pe_info = PEAnalyzer.parse_pe(data)
            # Extrair imports das strings
            for s in strings:
                if s in PEAnalyzer.SUSPICIOUS_IMPORTS:
                    imports.append(s)
        
        # Calcular score de risco
        risk_score = self._calculate_risk_score(
            entropy=entropy,
            suspicious_count=len(suspicious_strings),
            urls_count=len(urls),
            ips_count=len(ips),
            imports_count=len(imports),
            file_type=file_type
        )
        
        return FileAnalysis(
            filename=os.path.basename(file_path),
            size=len(data),
            md5=md5,
            sha1=sha1,
            sha256=sha256,
            file_type=file_type,
            magic_bytes=magic_bytes,
            entropy=entropy,
            strings=strings[:100],  # Limitar
            suspicious_strings=suspicious_strings,
            imports=imports,
            urls=urls,
            ips=ips,
            emails=emails,
            registry_keys=registry_keys,
            yara_matches=[],  # Requer YARA
            risk_score=risk_score
        )
    
    def _calculate_risk_score(self, **kwargs) -> int:
        """Calcula score de risco."""
        score = 0
        
        # Entropia alta (packed/encrypted)
        if kwargs.get('entropy', 0) > 7.0:
            score += 30
        elif kwargs.get('entropy', 0) > 6.5:
            score += 15
        
        # Strings suspeitas
        score += min(kwargs.get('suspicious_count', 0) * 5, 30)
        
        # URLs
        score += min(kwargs.get('urls_count', 0) * 2, 10)
        
        # IPs
        score += min(kwargs.get('ips_count', 0) * 3, 15)
        
        # Imports suspeitos
        score += min(kwargs.get('imports_count', 0) * 3, 15)
        
        return min(score, 100)


def interactive_menu():
    """Menu interativo do Malware Analyzer."""
    analyzer = MalwareAnalyzer()
    
    while True:
        os.system('cls' if os.name == 'nt' else 'clear')
        print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë          ü¶† MALWARE ANALYZER - Olho de Deus                  ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                              ‚ïë
‚ïë  [1] üìÅ Analisar Arquivo                                     ‚ïë
‚ïë  [2] üî¢ Calcular Hashes                                      ‚ïë
‚ïë  [3] üìä Calcular Entropia                                    ‚ïë
‚ïë  [4] üìù Extrair Strings                                      ‚ïë
‚ïë  [5] üîç Verificar VirusTotal (hash)                          ‚ïë
‚ïë  [6] üìã An√°lise em Lote                                      ‚ïë
‚ïë                                                              ‚ïë
‚ïë  ‚ö†Ô∏è  Execute em ambiente isolado (sandbox/VM)                 ‚ïë
‚ïë                                                              ‚ïë
‚ïë  [0] Voltar                                                  ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)
        
        escolha = input("Op√ß√£o: ").strip()
        
        if escolha == '0':
            break
        
        elif escolha == '1':
            print("\n=== Analisar Arquivo ===")
            file_path = input("Caminho do arquivo: ").strip()
            
            if not file_path or not os.path.exists(file_path):
                print("‚ùå Arquivo n√£o encontrado")
                input("Enter para continuar...")
                continue
            
            print(f"\nAnalisando {file_path}...")
            
            try:
                result = analyzer.analyze_file(file_path)
                
                # Risk score color
                if result.risk_score >= 70:
                    risk_icon = "üî¥"
                    risk_text = "ALTO RISCO"
                elif result.risk_score >= 40:
                    risk_icon = "üü†"
                    risk_text = "M√âDIO RISCO"
                elif result.risk_score >= 20:
                    risk_icon = "üü°"
                    risk_text = "BAIXO RISCO"
                else:
                    risk_icon = "üü¢"
                    risk_text = "PROVAVELMENTE SEGURO"
                
                print(f"\n{risk_icon} SCORE: {result.risk_score}/100 - {risk_text}")
                
                print(f"\nüìÑ INFORMA√á√ïES B√ÅSICAS:")
                print(f"   Arquivo: {result.filename}")
                print(f"   Tamanho: {result.size:,} bytes")
                print(f"   Tipo: {result.file_type}")
                print(f"   Magic: {result.magic_bytes[:32]}")
                print(f"   Entropia: {result.entropy} {'(PACKED?)' if result.entropy > 7 else ''}")
                
                print(f"\nüî¢ HASHES:")
                print(f"   MD5: {result.md5}")
                print(f"   SHA1: {result.sha1}")
                print(f"   SHA256: {result.sha256}")
                
                if result.suspicious_strings:
                    print(f"\n‚ö†Ô∏è STRINGS SUSPEITAS ({len(result.suspicious_strings)}):")
                    for s in result.suspicious_strings[:10]:
                        print(f"   ‚Ä¢ {s[:60]}")
                
                if result.urls:
                    print(f"\nüåê URLs ({len(result.urls)}):")
                    for url in result.urls[:5]:
                        print(f"   ‚Ä¢ {url[:60]}")
                
                if result.ips:
                    print(f"\nüîó IPs ({len(result.ips)}):")
                    for ip in result.ips[:5]:
                        print(f"   ‚Ä¢ {ip}")
                
                if result.imports:
                    print(f"\nüì¶ IMPORTS SUSPEITOS ({len(result.imports)}):")
                    for imp in result.imports[:10]:
                        print(f"   ‚Ä¢ {imp}")
                
                if result.registry_keys:
                    print(f"\nüîë REGISTRY ({len(result.registry_keys)}):")
                    for key in result.registry_keys[:5]:
                        print(f"   ‚Ä¢ {key[:60]}")
                
                save = input("\nSalvar relat√≥rio? (s/n): ").lower()
                if save == 's':
                    report_file = f"analysis_{result.sha256[:16]}.json"
                    with open(report_file, 'w') as f:
                        json.dump(result.to_dict(), f, indent=2)
                    print(f"‚úÖ Salvo em {report_file}")
                    
            except Exception as e:
                print(f"‚ùå Erro: {e}")
        
        elif escolha == '2':
            print("\n=== Calcular Hashes ===")
            file_path = input("Caminho do arquivo: ").strip()
            
            if not file_path or not os.path.exists(file_path):
                print("‚ùå Arquivo n√£o encontrado")
                input("Enter para continuar...")
                continue
            
            with open(file_path, 'rb') as f:
                data = f.read()
            
            print(f"\nüî¢ HASHES de {os.path.basename(file_path)}:")
            print(f"   MD5:    {hashlib.md5(data).hexdigest()}")
            print(f"   SHA1:   {hashlib.sha1(data).hexdigest()}")
            print(f"   SHA256: {hashlib.sha256(data).hexdigest()}")
            print(f"   SHA512: {hashlib.sha512(data).hexdigest()}")
        
        elif escolha == '3':
            print("\n=== Calcular Entropia ===")
            file_path = input("Caminho do arquivo: ").strip()
            
            if not file_path or not os.path.exists(file_path):
                print("‚ùå Arquivo n√£o encontrado")
                input("Enter para continuar...")
                continue
            
            with open(file_path, 'rb') as f:
                data = f.read()
            
            entropy = EntropyCalculator.calculate(data)
            is_packed = EntropyCalculator.is_packed(entropy)
            
            print(f"\nüìä ENTROPIA: {entropy}")
            
            if entropy < 5.0:
                print("   Baixa - Arquivo de texto ou dados simples")
            elif entropy < 6.0:
                print("   M√©dia - Arquivo bin√°rio normal")
            elif entropy < 7.0:
                print("   Alta - Pode conter dados comprimidos")
            else:
                print("   üî¥ MUITO ALTA - Provavelmente packed/criptografado")
        
        elif escolha == '4':
            print("\n=== Extrair Strings ===")
            file_path = input("Caminho do arquivo: ").strip()
            min_len = input("Tamanho m√≠nimo (default: 4): ").strip()
            min_len = int(min_len) if min_len.isdigit() else 4
            
            if not file_path or not os.path.exists(file_path):
                print("‚ùå Arquivo n√£o encontrado")
                input("Enter para continuar...")
                continue
            
            with open(file_path, 'rb') as f:
                data = f.read()
            
            strings = StringExtractor.extract_strings(data, min_len)
            
            print(f"\nüìù {len(strings)} strings encontradas:")
            for s in strings[:50]:
                print(f"   {s[:80]}")
            
            if len(strings) > 50:
                print(f"\n   ... e mais {len(strings) - 50} strings")
            
            save = input("\nSalvar strings? (s/n): ").lower()
            if save == 's':
                with open("extracted_strings.txt", 'w', encoding='utf-8') as f:
                    for s in strings:
                        f.write(s + '\n')
                print("‚úÖ Salvo em extracted_strings.txt")
        
        elif escolha == '5':
            print("\n=== Verificar VirusTotal ===")
            file_hash = input("Hash (MD5/SHA1/SHA256): ").strip()
            
            if not file_hash:
                continue
            
            print("\n‚ö†Ô∏è Requer API key do VirusTotal")
            print("   Obtenha em: https://www.virustotal.com/gui/join-us")
            print("\n   Use a URL manual:")
            print(f"   https://www.virustotal.com/gui/file/{file_hash}")
        
        elif escolha == '6':
            print("\n=== An√°lise em Lote ===")
            dir_path = input("Diret√≥rio: ").strip()
            
            if not dir_path or not os.path.isdir(dir_path):
                print("‚ùå Diret√≥rio n√£o encontrado")
                input("Enter para continuar...")
                continue
            
            files = [f for f in os.listdir(dir_path) if os.path.isfile(os.path.join(dir_path, f))]
            
            print(f"\nAnalisando {len(files)} arquivos...\n")
            
            results = []
            for f in files[:20]:  # Limitar
                file_path = os.path.join(dir_path, f)
                try:
                    result = analyzer.analyze_file(file_path)
                    risk = result.risk_score
                    icon = "üî¥" if risk >= 70 else "üü†" if risk >= 40 else "üü°" if risk >= 20 else "üü¢"
                    print(f"   {icon} [{risk:3d}] {f}")
                    results.append(result.to_dict())
                except Exception as e:
                    print(f"   ‚ùå {f}: {e}")
            
            if results:
                save = input("\nSalvar resultados? (s/n): ").lower()
                if save == 's':
                    with open("batch_analysis.json", 'w') as f:
                        json.dump(results, f, indent=2)
                    print("‚úÖ Salvo em batch_analysis.json")
        
        input("\nPressione Enter para continuar...")


if __name__ == "__main__":
    interactive_menu()

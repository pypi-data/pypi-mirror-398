#!/usr/bin/env python3
"""
Exploit Database Search - Busca em ExploitDB, CVE, NVD
Parte do toolkit Olho de Deus
"""

import os
import sys
import json
import re
import sqlite3
import requests
from typing import List, Dict, Optional
from datetime import datetime
from dataclasses import dataclass


@dataclass
class Exploit:
    """Estrutura de um exploit."""
    id: str
    title: str
    platform: str
    type: str
    date: str
    author: str
    url: str
    cve: Optional[str] = None
    description: Optional[str] = None
    verified: bool = False
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "title": self.title,
            "platform": self.platform,
            "type": self.type,
            "date": self.date,
            "author": self.author,
            "url": self.url,
            "cve": self.cve,
            "description": self.description,
            "verified": self.verified
        }


@dataclass
class CVE:
    """Estrutura de um CVE."""
    id: str
    description: str
    severity: str
    cvss_score: float
    published: str
    modified: str
    references: List[str]
    cwe: Optional[str] = None
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "description": self.description,
            "severity": self.severity,
            "cvss_score": self.cvss_score,
            "published": self.published,
            "modified": self.modified,
            "references": self.references,
            "cwe": self.cwe
        }


class ExploitDBClient:
    """Cliente para busca no ExploitDB."""
    
    BASE_URL = "https://www.exploit-db.com"
    SEARCH_URL = "https://www.exploit-db.com/search"
    GITHUB_RAW = "https://raw.githubusercontent.com/offensive-security/exploitdb/master"
    
    def __init__(self, db_path: str = "data/exploits.db"):
        self.db_path = db_path
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "X-Requested-With": "XMLHttpRequest"
        })
        self._init_db()
    
    def _init_db(self):
        """Inicializa banco de dados local."""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS exploits (
                    id TEXT PRIMARY KEY,
                    title TEXT,
                    platform TEXT,
                    type TEXT,
                    date TEXT,
                    author TEXT,
                    url TEXT,
                    cve TEXT,
                    description TEXT,
                    verified INTEGER,
                    cached_at TEXT
                )
            """)
            conn.execute("""
                CREATE TABLE IF NOT EXISTS cves (
                    id TEXT PRIMARY KEY,
                    description TEXT,
                    severity TEXT,
                    cvss_score REAL,
                    published TEXT,
                    modified TEXT,
                    references_json TEXT,
                    cwe TEXT,
                    cached_at TEXT
                )
            """)
            conn.execute("CREATE INDEX IF NOT EXISTS idx_exploits_cve ON exploits(cve)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_exploits_platform ON exploits(platform)")
    
    def search(self, query: str, platform: str = None, type_filter: str = None) -> List[Exploit]:
        """Busca exploits no ExploitDB."""
        params = {
            "draw": 1,
            "columns[0][data]": "date_published",
            "columns[0][name]": "date_published",
            "columns[0][searchable]": "true",
            "columns[0][orderable]": "true",
            "order[0][column]": 0,
            "order[0][dir]": "desc",
            "start": 0,
            "length": 50,
            "search[value]": query,
            "search[regex]": "false"
        }
        
        if platform:
            params["platform"] = platform
        if type_filter:
            params["type"] = type_filter
        
        try:
            response = self.session.get(self.SEARCH_URL, params=params, timeout=30)
            response.raise_for_status()
            data = response.json()
            
            exploits = []
            for item in data.get("data", []):
                # Parse HTML response
                id_match = re.search(r'/exploits/(\d+)', str(item.get("id", "")))
                exploit_id = id_match.group(1) if id_match else ""
                
                title_match = re.search(r'>([^<]+)</a>', str(item.get("description", [{}])[0].get("title", "")))
                title = title_match.group(1) if title_match else item.get("description", [{}])[0].get("title", "")
                
                exploit = Exploit(
                    id=exploit_id,
                    title=title,
                    platform=item.get("platform", {}).get("platform", ""),
                    type=item.get("type", {}).get("type", ""),
                    date=item.get("date_published", ""),
                    author=item.get("author", {}).get("name", ""),
                    url=f"{self.BASE_URL}/exploits/{exploit_id}",
                    verified="verified" in str(item.get("verified", "")).lower()
                )
                exploits.append(exploit)
                
                # Cache
                self._cache_exploit(exploit)
            
            return exploits
            
        except Exception as e:
            print(f"Erro na busca ExploitDB: {e}")
            return self._search_cached(query)
    
    def _cache_exploit(self, exploit: Exploit):
        """Salva exploit no cache."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    INSERT OR REPLACE INTO exploits 
                    (id, title, platform, type, date, author, url, cve, description, verified, cached_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    exploit.id, exploit.title, exploit.platform, exploit.type,
                    exploit.date, exploit.author, exploit.url, exploit.cve,
                    exploit.description, 1 if exploit.verified else 0,
                    datetime.now().isoformat()
                ))
        except Exception:
            pass
    
    def _search_cached(self, query: str) -> List[Exploit]:
        """Busca no cache local."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute("""
                    SELECT id, title, platform, type, date, author, url, cve, description, verified
                    FROM exploits
                    WHERE title LIKE ? OR description LIKE ? OR cve LIKE ?
                    ORDER BY date DESC
                    LIMIT 50
                """, (f"%{query}%", f"%{query}%", f"%{query}%"))
                
                exploits = []
                for row in cursor.fetchall():
                    exploits.append(Exploit(
                        id=row[0], title=row[1], platform=row[2], type=row[3],
                        date=row[4], author=row[5], url=row[6], cve=row[7],
                        description=row[8], verified=bool(row[9])
                    ))
                return exploits
        except Exception:
            return []
    
    def get_exploit(self, exploit_id: str) -> Optional[Dict]:
        """ObtÃ©m detalhes de um exploit especÃ­fico."""
        try:
            url = f"{self.BASE_URL}/exploits/{exploit_id}"
            response = self.session.get(url, timeout=30)
            response.raise_for_status()
            
            # Parse bÃ¡sico do HTML
            html = response.text
            
            # Extrair cÃ³digo do exploit
            code_match = re.search(r'<code[^>]*>(.*?)</code>', html, re.DOTALL)
            code = code_match.group(1) if code_match else None
            
            # Extrair CVE
            cve_match = re.search(r'CVE-\d{4}-\d+', html)
            cve = cve_match.group(0) if cve_match else None
            
            return {
                "id": exploit_id,
                "url": url,
                "cve": cve,
                "code_preview": code[:500] if code else None,
                "raw_url": f"{self.GITHUB_RAW}/exploits/{exploit_id[:2]}/{exploit_id}.txt"
            }
            
        except Exception as e:
            print(f"Erro ao obter exploit: {e}")
            return None
    
    def download_exploit(self, exploit_id: str, output_dir: str = "exploits") -> Optional[str]:
        """Baixa cÃ³digo do exploit."""
        os.makedirs(output_dir, exist_ok=True)
        
        try:
            # Tentar do GitHub primeiro
            url = f"{self.GITHUB_RAW}/exploits/{exploit_id[:2]}/{exploit_id}.txt"
            response = requests.get(url, timeout=30)
            
            if response.status_code == 200:
                filepath = os.path.join(output_dir, f"exploit_{exploit_id}.txt")
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(response.text)
                return filepath
            
            return None
            
        except Exception as e:
            print(f"Erro no download: {e}")
            return None


class NVDClient:
    """Cliente para National Vulnerability Database."""
    
    BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    
    def __init__(self, api_key: str = None):
        self.api_key = api_key
        self.session = requests.Session()
        if api_key:
            self.session.headers["apiKey"] = api_key
    
    def search_cve(self, keyword: str = None, cve_id: str = None) -> List[CVE]:
        """Busca CVEs no NVD."""
        params = {}
        
        if cve_id:
            params["cveId"] = cve_id
        elif keyword:
            params["keywordSearch"] = keyword
        
        params["resultsPerPage"] = 50
        
        try:
            response = self.session.get(self.BASE_URL, params=params, timeout=60)
            response.raise_for_status()
            data = response.json()
            
            cves = []
            for vuln in data.get("vulnerabilities", []):
                cve_data = vuln.get("cve", {})
                
                # Extrair descriÃ§Ã£o
                descriptions = cve_data.get("descriptions", [])
                description = next(
                    (d.get("value") for d in descriptions if d.get("lang") == "en"),
                    descriptions[0].get("value") if descriptions else ""
                )
                
                # Extrair CVSS
                metrics = cve_data.get("metrics", {})
                cvss_v3 = metrics.get("cvssMetricV31", [{}])[0] if metrics.get("cvssMetricV31") else {}
                cvss_v2 = metrics.get("cvssMetricV2", [{}])[0] if metrics.get("cvssMetricV2") else {}
                
                cvss_data = cvss_v3.get("cvssData", cvss_v2.get("cvssData", {}))
                
                # Extrair referÃªncias
                references = [ref.get("url") for ref in cve_data.get("references", [])]
                
                # Extrair CWE
                weaknesses = cve_data.get("weaknesses", [])
                cwe = None
                if weaknesses:
                    for w in weaknesses:
                        for desc in w.get("description", []):
                            if desc.get("value", "").startswith("CWE-"):
                                cwe = desc.get("value")
                                break
                
                cve = CVE(
                    id=cve_data.get("id", ""),
                    description=description,
                    severity=cvss_data.get("baseSeverity", "UNKNOWN"),
                    cvss_score=cvss_data.get("baseScore", 0.0),
                    published=cve_data.get("published", ""),
                    modified=cve_data.get("lastModified", ""),
                    references=references[:10],  # Limitar
                    cwe=cwe
                )
                cves.append(cve)
            
            return cves
            
        except Exception as e:
            print(f"Erro na busca NVD: {e}")
            return []
    
    def get_cve(self, cve_id: str) -> Optional[CVE]:
        """ObtÃ©m detalhes de um CVE especÃ­fico."""
        cves = self.search_cve(cve_id=cve_id)
        return cves[0] if cves else None
    
    def search_by_product(self, vendor: str, product: str, version: str = None) -> List[CVE]:
        """Busca CVEs por produto."""
        params = {
            "cpeName": f"cpe:2.3:*:{vendor}:{product}:*:*:*:*:*:*:*:*",
            "resultsPerPage": 50
        }
        
        try:
            response = self.session.get(self.BASE_URL, params=params, timeout=60)
            response.raise_for_status()
            # Processar similar ao search_cve
            return self.search_cve(keyword=f"{vendor} {product}")
        except Exception:
            return []


class CVESearchClient:
    """Cliente alternativo para cve.circl.lu."""
    
    BASE_URL = "https://cve.circl.lu/api"
    
    def search(self, vendor: str = None, product: str = None) -> List[Dict]:
        """Busca CVEs por vendor/product."""
        try:
            if vendor and product:
                url = f"{self.BASE_URL}/search/{vendor}/{product}"
            else:
                return []
            
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            print(f"Erro CVE Search: {e}")
            return []
    
    def get_cve(self, cve_id: str) -> Optional[Dict]:
        """ObtÃ©m CVE por ID."""
        try:
            url = f"{self.BASE_URL}/cve/{cve_id}"
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            return response.json()
        except Exception:
            return None
    
    def get_last_cves(self, limit: int = 30) -> List[Dict]:
        """ObtÃ©m Ãºltimos CVEs."""
        try:
            url = f"{self.BASE_URL}/last/{limit}"
            response = requests.get(url, timeout=30)
            response.raise_for_status()
            return response.json()
        except Exception:
            return []


class VulnerabilityScanner:
    """Scanner de vulnerabilidades integrado."""
    
    def __init__(self, nvd_api_key: str = None):
        self.exploitdb = ExploitDBClient()
        self.nvd = NVDClient(nvd_api_key)
        self.cve_search = CVESearchClient()
    
    def full_search(self, query: str) -> Dict:
        """Busca completa em todas as fontes."""
        results = {
            "query": query,
            "timestamp": datetime.now().isoformat(),
            "exploitdb": [],
            "nvd_cves": [],
            "cve_search": []
        }
        
        # ExploitDB
        print("  [*] Buscando no ExploitDB...")
        exploits = self.exploitdb.search(query)
        results["exploitdb"] = [e.to_dict() for e in exploits]
        
        # NVD
        print("  [*] Buscando no NVD...")
        cves = self.nvd.search_cve(keyword=query)
        results["nvd_cves"] = [c.to_dict() for c in cves]
        
        # CVE Search
        print("  [*] Buscando em cve.circl.lu...")
        if "-" in query and query.upper().startswith("CVE"):
            cve_data = self.cve_search.get_cve(query.upper())
            if cve_data:
                results["cve_search"] = [cve_data]
        
        return results
    
    def search_by_software(self, software: str, version: str = None) -> Dict:
        """Busca vulnerabilidades de um software especÃ­fico."""
        results = {
            "software": software,
            "version": version,
            "timestamp": datetime.now().isoformat(),
            "vulnerabilities": []
        }
        
        # Buscar em todas as fontes
        search_term = f"{software} {version}" if version else software
        
        exploits = self.exploitdb.search(search_term)
        cves = self.nvd.search_cve(keyword=search_term)
        
        for cve in cves:
            vuln = {
                "cve_id": cve.id,
                "description": cve.description[:200] + "..." if len(cve.description) > 200 else cve.description,
                "severity": cve.severity,
                "cvss_score": cve.cvss_score,
                "published": cve.published,
                "exploits_available": []
            }
            
            # Associar exploits
            for exp in exploits:
                if cve.id in str(exp.cve):
                    vuln["exploits_available"].append({
                        "id": exp.id,
                        "title": exp.title,
                        "url": exp.url
                    })
            
            results["vulnerabilities"].append(vuln)
        
        # Adicionar exploits sem CVE associado
        for exp in exploits:
            if not any(exp.id in str(v.get("exploits_available", [])) for v in results["vulnerabilities"]):
                results["vulnerabilities"].append({
                    "cve_id": exp.cve or "N/A",
                    "description": exp.title,
                    "severity": "UNKNOWN",
                    "cvss_score": 0.0,
                    "published": exp.date,
                    "exploits_available": [{
                        "id": exp.id,
                        "title": exp.title,
                        "url": exp.url
                    }]
                })
        
        return results


def interactive_menu():
    """Menu interativo do Exploit Database Search."""
    scanner = VulnerabilityScanner()
    
    while True:
        os.system('cls' if os.name == 'nt' else 'clear')
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       ğŸ” EXPLOIT DATABASE SEARCH - Olho de Deus              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                              â•‘
â•‘  [1] ğŸ” Busca Geral (ExploitDB + NVD + CVE)                  â•‘
â•‘  [2] ğŸ’» Buscar por Software/Produto                          â•‘
â•‘  [3] ğŸ“‹ Buscar CVE especÃ­fico                                â•‘
â•‘  [4] ğŸ“¥ Download de Exploit                                  â•‘
â•‘  [5] ğŸ“° Ãšltimos CVEs publicados                              â•‘
â•‘  [6] ğŸ¯ Buscar por Plataforma (Windows/Linux/Web)            â•‘
â•‘                                                              â•‘
â•‘  [0] Voltar                                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
        
        escolha = input("OpÃ§Ã£o: ").strip()
        
        if escolha == '0':
            break
        
        elif escolha == '1':
            print("\n=== Busca Geral de Vulnerabilidades ===")
            query = input("Termo de busca: ").strip()
            if not query:
                continue
            
            print(f"\nBuscando '{query}'...\n")
            results = scanner.full_search(query)
            
            # Mostrar resultados ExploitDB
            if results["exploitdb"]:
                print(f"\nğŸ“ ExploitDB ({len(results['exploitdb'])} resultados):")
                print("-" * 60)
                for exp in results["exploitdb"][:10]:
                    verified = "âœ“" if exp.get("verified") else " "
                    print(f"  [{verified}] EDB-{exp['id']}: {exp['title'][:50]}...")
                    print(f"      Platform: {exp['platform']} | Type: {exp['type']} | Date: {exp['date']}")
            
            # Mostrar CVEs
            if results["nvd_cves"]:
                print(f"\nğŸ”’ CVEs ({len(results['nvd_cves'])} resultados):")
                print("-" * 60)
                for cve in results["nvd_cves"][:10]:
                    severity_icon = {"CRITICAL": "ğŸ”´", "HIGH": "ğŸŸ ", "MEDIUM": "ğŸŸ¡", "LOW": "ğŸŸ¢"}.get(cve['severity'], "âšª")
                    print(f"  {severity_icon} {cve['id']} (CVSS: {cve['cvss_score']})")
                    print(f"      {cve['description'][:70]}...")
            
            if not results["exploitdb"] and not results["nvd_cves"]:
                print("Nenhum resultado encontrado.")
        
        elif escolha == '2':
            print("\n=== Buscar por Software ===")
            software = input("Nome do software (ex: apache, wordpress): ").strip()
            version = input("VersÃ£o (opcional): ").strip() or None
            
            if not software:
                continue
            
            print(f"\nBuscando vulnerabilidades de {software}...\n")
            results = scanner.search_by_software(software, version)
            
            print(f"ğŸ“Š {len(results['vulnerabilities'])} vulnerabilidades encontradas:\n")
            
            for vuln in results["vulnerabilities"][:15]:
                severity_icon = {"CRITICAL": "ğŸ”´", "HIGH": "ğŸŸ ", "MEDIUM": "ğŸŸ¡", "LOW": "ğŸŸ¢"}.get(vuln['severity'], "âšª")
                print(f"{severity_icon} {vuln['cve_id']} (CVSS: {vuln['cvss_score']})")
                print(f"   {vuln['description'][:60]}...")
                if vuln.get("exploits_available"):
                    print(f"   ğŸ¯ Exploits: {len(vuln['exploits_available'])} disponÃ­veis")
                print()
        
        elif escolha == '3':
            print("\n=== Buscar CVE EspecÃ­fico ===")
            cve_id = input("CVE ID (ex: CVE-2021-44228): ").strip().upper()
            
            if not cve_id.startswith("CVE-"):
                print("Formato invÃ¡lido. Use: CVE-YYYY-NNNNN")
                input("Enter para continuar...")
                continue
            
            print(f"\nBuscando {cve_id}...\n")
            
            # NVD
            cve = scanner.nvd.get_cve(cve_id)
            if cve:
                print(f"ğŸ“‹ {cve.id}")
                print(f"   Severity: {cve.severity} (CVSS: {cve.cvss_score})")
                print(f"   Published: {cve.published}")
                print(f"   CWE: {cve.cwe or 'N/A'}")
                print(f"\n   Description:")
                print(f"   {cve.description}")
                print(f"\n   References:")
                for ref in cve.references[:5]:
                    print(f"   - {ref}")
            else:
                print("CVE nÃ£o encontrado no NVD.")
            
            # Buscar exploits relacionados
            exploits = scanner.exploitdb.search(cve_id)
            if exploits:
                print(f"\nğŸ¯ Exploits disponÃ­veis:")
                for exp in exploits[:5]:
                    print(f"   - EDB-{exp.id}: {exp.title}")
                    print(f"     {exp.url}")
        
        elif escolha == '4':
            print("\n=== Download de Exploit ===")
            exploit_id = input("Exploit ID (nÃºmero): ").strip()
            
            if not exploit_id.isdigit():
                print("ID invÃ¡lido!")
                input("Enter para continuar...")
                continue
            
            print(f"\nBaixando exploit {exploit_id}...")
            filepath = scanner.exploitdb.download_exploit(exploit_id)
            
            if filepath:
                print(f"âœ… Exploit salvo em: {filepath}")
            else:
                print("âŒ NÃ£o foi possÃ­vel baixar o exploit.")
        
        elif escolha == '5':
            print("\n=== Ãšltimos CVEs Publicados ===\n")
            
            cves = scanner.cve_search.get_last_cves(30)
            
            for cve in cves[:20]:
                cve_id = cve.get("id", "N/A")
                summary = cve.get("summary", "No description")[:60]
                cvss = cve.get("cvss", 0)
                
                print(f"  {cve_id} (CVSS: {cvss})")
                print(f"    {summary}...")
                print()
        
        elif escolha == '6':
            print("\n=== Buscar por Plataforma ===")
            print("  [1] Windows")
            print("  [2] Linux")
            print("  [3] Web Application")
            print("  [4] Android")
            print("  [5] iOS")
            
            plat_choice = input("\nPlataforma: ").strip()
            platforms = {"1": "windows", "2": "linux", "3": "webapps", "4": "android", "5": "ios"}
            platform = platforms.get(plat_choice, "windows")
            
            keyword = input("Palavra-chave (opcional): ").strip() or ""
            
            print(f"\nBuscando exploits para {platform}...\n")
            exploits = scanner.exploitdb.search(keyword, platform=platform)
            
            print(f"ğŸ“ {len(exploits)} exploits encontrados:\n")
            for exp in exploits[:20]:
                verified = "âœ“" if exp.verified else " "
                print(f"  [{verified}] EDB-{exp.id}: {exp.title[:50]}...")
                print(f"      Type: {exp.type} | Date: {exp.date}")
        
        input("\nPressione Enter para continuar...")


if __name__ == "__main__":
    interactive_menu()

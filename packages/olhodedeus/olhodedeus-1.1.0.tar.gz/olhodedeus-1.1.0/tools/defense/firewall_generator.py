#!/usr/bin/env python3
"""
Firewall Generator - Gerador de regras de firewall
Parte do toolkit Olho de Deus
"""

import os
import sys
import re
import json
import ipaddress
from typing import List, Dict, Optional, Set, Tuple, Union
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum


class Action(Enum):
    ALLOW = "allow"
    DENY = "deny"
    DROP = "drop"
    REJECT = "reject"
    LOG = "log"


class Protocol(Enum):
    TCP = "tcp"
    UDP = "udp"
    ICMP = "icmp"
    ANY = "any"


class Direction(Enum):
    IN = "in"
    OUT = "out"
    BOTH = "both"


@dataclass
class FirewallRule:
    """Regra de firewall."""
    name: str
    action: Action
    protocol: Protocol
    src_ip: str
    dst_ip: str
    src_port: Optional[str]
    dst_port: Optional[str]
    direction: Direction
    enabled: bool = True
    comment: str = ""
    priority: int = 100
    
    def to_dict(self) -> Dict:
        return {
            "name": self.name,
            "action": self.action.value,
            "protocol": self.protocol.value,
            "src_ip": self.src_ip,
            "dst_ip": self.dst_ip,
            "src_port": self.src_port,
            "dst_port": self.dst_port,
            "direction": self.direction.value,
            "enabled": self.enabled,
            "comment": self.comment,
            "priority": self.priority
        }


class IPTablesGenerator:
    """Gerador de regras iptables (Linux)."""
    
    @staticmethod
    def generate_rule(rule: FirewallRule) -> str:
        """Gera comando iptables."""
        parts = ["iptables"]
        
        # Chain
        chain = "INPUT" if rule.direction == Direction.IN else "OUTPUT"
        if rule.direction == Direction.BOTH:
            chain = "FORWARD"
        
        parts.append(f"-A {chain}")
        
        # Protocol
        if rule.protocol != Protocol.ANY:
            parts.append(f"-p {rule.protocol.value}")
        
        # Source
        if rule.src_ip and rule.src_ip != "any":
            parts.append(f"-s {rule.src_ip}")
        
        # Destination
        if rule.dst_ip and rule.dst_ip != "any":
            parts.append(f"-d {rule.dst_ip}")
        
        # Ports
        if rule.src_port and rule.protocol in [Protocol.TCP, Protocol.UDP]:
            parts.append(f"--sport {rule.src_port}")
        
        if rule.dst_port and rule.protocol in [Protocol.TCP, Protocol.UDP]:
            parts.append(f"--dport {rule.dst_port}")
        
        # Action
        action_map = {
            Action.ALLOW: "ACCEPT",
            Action.DENY: "DROP",
            Action.DROP: "DROP",
            Action.REJECT: "REJECT",
            Action.LOG: "LOG"
        }
        parts.append(f"-j {action_map[rule.action]}")
        
        # Comment
        if rule.comment:
            parts.append(f'-m comment --comment "{rule.comment}"')
        
        return " ".join(parts)
    
    @staticmethod
    def generate_script(rules: List[FirewallRule], flush: bool = True) -> str:
        """Gera script iptables completo."""
        lines = [
            "#!/bin/bash",
            "# Firewall rules generated by Olho de Deus",
            f"# Generated at: {datetime.now().isoformat()}",
            "",
        ]
        
        if flush:
            lines.extend([
                "# Flush existing rules",
                "iptables -F",
                "iptables -X",
                "iptables -Z",
                "",
                "# Set default policies",
                "iptables -P INPUT DROP",
                "iptables -P FORWARD DROP", 
                "iptables -P OUTPUT ACCEPT",
                "",
                "# Allow loopback",
                "iptables -A INPUT -i lo -j ACCEPT",
                "iptables -A OUTPUT -o lo -j ACCEPT",
                "",
                "# Allow established connections",
                "iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT",
                "",
            ])
        
        lines.append("# Custom rules")
        
        for rule in sorted(rules, key=lambda r: r.priority):
            if rule.enabled:
                lines.append(f"# {rule.name}")
                lines.append(IPTablesGenerator.generate_rule(rule))
        
        lines.extend([
            "",
            "# Save rules",
            "# iptables-save > /etc/iptables/rules.v4",
            "",
            "echo 'Firewall rules applied.'"
        ])
        
        return "\n".join(lines)


class WindowsFirewallGenerator:
    """Gerador de regras para Windows Firewall."""
    
    @staticmethod
    def generate_rule(rule: FirewallRule) -> str:
        """Gera comando netsh."""
        parts = ["netsh advfirewall firewall add rule"]
        
        # Name
        parts.append(f'name="{rule.name}"')
        
        # Direction
        dir_map = {"in": "in", "out": "out", "both": "in"}
        parts.append(f"dir={dir_map[rule.direction.value]}")
        
        # Action
        action_map = {
            Action.ALLOW: "allow",
            Action.DENY: "block",
            Action.DROP: "block",
            Action.REJECT: "block",
            Action.LOG: "allow"
        }
        parts.append(f"action={action_map[rule.action]}")
        
        # Protocol
        if rule.protocol != Protocol.ANY:
            parts.append(f"protocol={rule.protocol.value}")
        
        # Remote IP
        if rule.src_ip and rule.src_ip != "any":
            parts.append(f"remoteip={rule.src_ip}")
        
        # Local port
        if rule.dst_port and rule.protocol in [Protocol.TCP, Protocol.UDP]:
            parts.append(f"localport={rule.dst_port}")
        
        # Remote port
        if rule.src_port and rule.protocol in [Protocol.TCP, Protocol.UDP]:
            parts.append(f"remoteport={rule.src_port}")
        
        # Enable/Disable
        parts.append(f"enable={'yes' if rule.enabled else 'no'}")
        
        # Description
        if rule.comment:
            parts.append(f'description="{rule.comment}"')
        
        return " ".join(parts)
    
    @staticmethod
    def generate_script(rules: List[FirewallRule], reset: bool = False) -> str:
        """Gera script batch/PowerShell."""
        lines = [
            "@echo off",
            "REM Firewall rules generated by Olho de Deus",
            f"REM Generated at: {datetime.now().isoformat()}",
            "",
            "REM Requires Administrator privileges",
            "",
        ]
        
        if reset:
            lines.extend([
                "REM Reset firewall",
                "netsh advfirewall reset",
                "",
            ])
        
        lines.append("REM Custom rules")
        
        for rule in sorted(rules, key=lambda r: r.priority):
            lines.append(f"REM {rule.name}")
            lines.append(WindowsFirewallGenerator.generate_rule(rule))
        
        lines.extend([
            "",
            "echo Firewall rules applied.",
            "pause"
        ])
        
        return "\n".join(lines)


class PfGenerator:
    """Gerador de regras pf (BSD/macOS)."""
    
    @staticmethod
    def generate_rule(rule: FirewallRule) -> str:
        """Gera regra pf."""
        parts = []
        
        # Action
        action_map = {
            Action.ALLOW: "pass",
            Action.DENY: "block",
            Action.DROP: "block drop",
            Action.REJECT: "block return",
            Action.LOG: "pass log"
        }
        parts.append(action_map[rule.action])
        
        # Direction
        if rule.direction != Direction.BOTH:
            parts.append(rule.direction.value)
        
        # Quick
        parts.append("quick")
        
        # Protocol
        if rule.protocol != Protocol.ANY:
            parts.append(f"proto {rule.protocol.value}")
        
        # Source
        if rule.src_ip and rule.src_ip != "any":
            src = f"from {rule.src_ip}"
            if rule.src_port:
                src += f" port {rule.src_port}"
            parts.append(src)
        else:
            parts.append("from any")
        
        # Destination
        if rule.dst_ip and rule.dst_ip != "any":
            dst = f"to {rule.dst_ip}"
            if rule.dst_port:
                dst += f" port {rule.dst_port}"
            parts.append(dst)
        else:
            if rule.dst_port:
                parts.append(f"to any port {rule.dst_port}")
        
        return " ".join(parts)
    
    @staticmethod
    def generate_config(rules: List[FirewallRule]) -> str:
        """Gera arquivo pf.conf."""
        lines = [
            "# pf.conf generated by Olho de Deus",
            f"# Generated at: {datetime.now().isoformat()}",
            "",
            "# Macros",
            'tcp_services = "{ 22, 80, 443 }"',
            'udp_services = "{ 53, 123 }"',
            "",
            "# Options",
            "set skip on lo0",
            "set block-policy drop",
            "",
            "# Scrub",
            "scrub in all",
            "",
            "# Default deny",
            "block all",
            "",
            "# Allow established",
            "pass out quick proto { tcp udp } all keep state",
            "",
            "# Custom rules",
        ]
        
        for rule in sorted(rules, key=lambda r: r.priority):
            if rule.enabled:
                lines.append(f"# {rule.name}")
                lines.append(PfGenerator.generate_rule(rule))
        
        return "\n".join(lines)


class UFWGenerator:
    """Gerador de regras UFW (Ubuntu/Debian)."""
    
    @staticmethod
    def generate_rule(rule: FirewallRule) -> str:
        """Gera comando ufw."""
        parts = ["ufw"]
        
        # Action
        action_map = {
            Action.ALLOW: "allow",
            Action.DENY: "deny",
            Action.DROP: "deny",
            Action.REJECT: "reject",
            Action.LOG: "allow"
        }
        parts.append(action_map[rule.action])
        
        # Direction
        if rule.direction == Direction.IN:
            parts.append("in")
        elif rule.direction == Direction.OUT:
            parts.append("out")
        
        # Source
        if rule.src_ip and rule.src_ip != "any":
            parts.append(f"from {rule.src_ip}")
        
        # Destination
        if rule.dst_ip and rule.dst_ip != "any":
            parts.append(f"to {rule.dst_ip}")
        
        # Port
        if rule.dst_port:
            proto = rule.protocol.value if rule.protocol != Protocol.ANY else "tcp"
            parts.append(f"port {rule.dst_port}")
            parts.append(f"proto {proto}")
        
        # Comment
        if rule.comment:
            parts.append(f"comment '{rule.comment}'")
        
        return " ".join(parts)
    
    @staticmethod
    def generate_script(rules: List[FirewallRule], reset: bool = False) -> str:
        """Gera script UFW."""
        lines = [
            "#!/bin/bash",
            "# UFW rules generated by Olho de Deus",
            f"# Generated at: {datetime.now().isoformat()}",
            "",
        ]
        
        if reset:
            lines.extend([
                "# Reset UFW",
                "ufw --force reset",
                "",
                "# Set defaults",
                "ufw default deny incoming",
                "ufw default allow outgoing",
                "",
            ])
        
        lines.append("# Custom rules")
        
        for rule in sorted(rules, key=lambda r: r.priority):
            if rule.enabled:
                lines.append(f"# {rule.name}")
                lines.append(UFWGenerator.generate_rule(rule))
        
        lines.extend([
            "",
            "# Enable UFW",
            "ufw --force enable",
            "",
            "echo 'UFW rules applied.'",
            "ufw status verbose"
        ])
        
        return "\n".join(lines)


class FirewallGenerator:
    """Gerador principal de regras de firewall."""
    
    COMMON_RULES = {
        "ssh": FirewallRule(
            name="Allow SSH",
            action=Action.ALLOW,
            protocol=Protocol.TCP,
            src_ip="any",
            dst_ip="any",
            src_port=None,
            dst_port="22",
            direction=Direction.IN,
            comment="SSH access"
        ),
        "http": FirewallRule(
            name="Allow HTTP",
            action=Action.ALLOW,
            protocol=Protocol.TCP,
            src_ip="any",
            dst_ip="any",
            src_port=None,
            dst_port="80",
            direction=Direction.IN,
            comment="Web HTTP"
        ),
        "https": FirewallRule(
            name="Allow HTTPS",
            action=Action.ALLOW,
            protocol=Protocol.TCP,
            src_ip="any",
            dst_ip="any",
            src_port=None,
            dst_port="443",
            direction=Direction.IN,
            comment="Web HTTPS"
        ),
        "dns": FirewallRule(
            name="Allow DNS",
            action=Action.ALLOW,
            protocol=Protocol.UDP,
            src_ip="any",
            dst_ip="any",
            src_port=None,
            dst_port="53",
            direction=Direction.BOTH,
            comment="DNS queries"
        ),
        "ping": FirewallRule(
            name="Allow ICMP",
            action=Action.ALLOW,
            protocol=Protocol.ICMP,
            src_ip="any",
            dst_ip="any",
            src_port=None,
            dst_port=None,
            direction=Direction.BOTH,
            comment="ICMP/Ping"
        ),
    }
    
    def __init__(self):
        self.rules: List[FirewallRule] = []
    
    def add_rule(self, rule: FirewallRule):
        """Adiciona regra."""
        self.rules.append(rule)
    
    def add_preset(self, preset_name: str) -> bool:
        """Adiciona regra prÃ©-definida."""
        if preset_name in self.COMMON_RULES:
            self.rules.append(self.COMMON_RULES[preset_name])
            return True
        return False
    
    def block_ip(self, ip: str, comment: str = ""):
        """Bloqueia um IP."""
        rule = FirewallRule(
            name=f"Block {ip}",
            action=Action.DROP,
            protocol=Protocol.ANY,
            src_ip=ip,
            dst_ip="any",
            src_port=None,
            dst_port=None,
            direction=Direction.IN,
            comment=comment or f"Blocked IP: {ip}",
            priority=10
        )
        self.rules.append(rule)
    
    def block_port(self, port: int, protocol: Protocol = Protocol.TCP, comment: str = ""):
        """Bloqueia uma porta."""
        rule = FirewallRule(
            name=f"Block port {port}",
            action=Action.DROP,
            protocol=protocol,
            src_ip="any",
            dst_ip="any",
            src_port=None,
            dst_port=str(port),
            direction=Direction.IN,
            comment=comment or f"Blocked port: {port}"
        )
        self.rules.append(rule)
    
    def allow_from_ip(self, ip: str, port: Optional[int] = None, 
                      protocol: Protocol = Protocol.TCP, comment: str = ""):
        """Permite acesso de um IP."""
        rule = FirewallRule(
            name=f"Allow from {ip}",
            action=Action.ALLOW,
            protocol=protocol,
            src_ip=ip,
            dst_ip="any",
            src_port=None,
            dst_port=str(port) if port else None,
            direction=Direction.IN,
            comment=comment or f"Allowed from: {ip}"
        )
        self.rules.append(rule)
    
    def generate_iptables(self, flush: bool = True) -> str:
        """Gera script iptables."""
        return IPTablesGenerator.generate_script(self.rules, flush)
    
    def generate_windows(self, reset: bool = False) -> str:
        """Gera script Windows Firewall."""
        return WindowsFirewallGenerator.generate_script(self.rules, reset)
    
    def generate_ufw(self, reset: bool = False) -> str:
        """Gera script UFW."""
        return UFWGenerator.generate_script(self.rules, reset)
    
    def generate_pf(self) -> str:
        """Gera config pf."""
        return PfGenerator.generate_config(self.rules)
    
    def import_ips_from_file(self, file_path: str, action: Action = Action.DROP):
        """Importa lista de IPs de arquivo."""
        if not os.path.exists(file_path):
            return 0
        
        count = 0
        with open(file_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    try:
                        ipaddress.ip_address(line)
                        self.block_ip(line, f"Imported from {os.path.basename(file_path)}")
                        count += 1
                    except ValueError:
                        pass
        
        return count


def interactive_menu():
    """Menu interativo do Firewall Generator."""
    generator = FirewallGenerator()
    
    while True:
        os.system('cls' if os.name == 'nt' else 'clear')
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          ðŸ”¥ FIREWALL GENERATOR - Olho de Deus                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                              â•‘
â•‘  [1] âž• Adicionar Regra Manual                               â•‘
â•‘  [2] ðŸ“‹ Adicionar Regra PrÃ©-definida                         â•‘
â•‘  [3] ðŸš« Bloquear IP                                          â•‘
â•‘  [4] ðŸ”’ Bloquear Porta                                       â•‘
â•‘  [5] âœ… Permitir IP                                          â•‘
â•‘  [6] ðŸ“ Importar Lista de IPs                                â•‘
â•‘  [7] ðŸ“œ Visualizar Regras ({len(generator.rules)} regras)                          â•‘
â•‘  [8] ðŸ’¾ Gerar Script                                         â•‘
â•‘  [9] ðŸ—‘ï¸  Limpar Regras                                        â•‘
â•‘                                                              â•‘
â•‘  [0] Voltar                                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
        
        escolha = input("OpÃ§Ã£o: ").strip()
        
        if escolha == '0':
            break
        
        elif escolha == '1':
            print("\n=== Adicionar Regra Manual ===")
            
            name = input("Nome da regra: ").strip()
            
            print("\nAÃ§Ãµes: allow, deny, drop, reject, log")
            action_str = input("AÃ§Ã£o: ").strip().lower()
            action = Action(action_str) if action_str in [a.value for a in Action] else Action.ALLOW
            
            print("\nProtocolos: tcp, udp, icmp, any")
            proto_str = input("Protocolo: ").strip().lower()
            protocol = Protocol(proto_str) if proto_str in [p.value for p in Protocol] else Protocol.TCP
            
            src_ip = input("IP origem (ou 'any'): ").strip() or "any"
            dst_ip = input("IP destino (ou 'any'): ").strip() or "any"
            src_port = input("Porta origem (ou Enter para nenhuma): ").strip() or None
            dst_port = input("Porta destino (ou Enter para nenhuma): ").strip() or None
            
            print("\nDireÃ§Ã£o: in, out, both")
            dir_str = input("DireÃ§Ã£o: ").strip().lower()
            direction = Direction(dir_str) if dir_str in [d.value for d in Direction] else Direction.IN
            
            comment = input("ComentÃ¡rio: ").strip()
            
            rule = FirewallRule(
                name=name or "Custom Rule",
                action=action,
                protocol=protocol,
                src_ip=src_ip,
                dst_ip=dst_ip,
                src_port=src_port,
                dst_port=dst_port,
                direction=direction,
                comment=comment
            )
            
            generator.add_rule(rule)
            print("âœ… Regra adicionada!")
        
        elif escolha == '2':
            print("\n=== Regras PrÃ©-definidas ===")
            print("\nDisponÃ­veis:")
            for name in generator.COMMON_RULES:
                rule = generator.COMMON_RULES[name]
                print(f"   {name}: {rule.comment}")
            
            preset = input("\nNome do preset: ").strip().lower()
            
            if generator.add_preset(preset):
                print(f"âœ… Preset '{preset}' adicionado!")
            else:
                print(f"âŒ Preset '{preset}' nÃ£o encontrado")
        
        elif escolha == '3':
            print("\n=== Bloquear IP ===")
            ip = input("IP para bloquear: ").strip()
            comment = input("ComentÃ¡rio (opcional): ").strip()
            
            if ip:
                generator.block_ip(ip, comment)
                print(f"âœ… IP {ip} serÃ¡ bloqueado!")
        
        elif escolha == '4':
            print("\n=== Bloquear Porta ===")
            try:
                port = int(input("Porta: ").strip())
                proto = input("Protocolo (tcp/udp): ").strip().lower()
                protocol = Protocol.TCP if proto != "udp" else Protocol.UDP
                comment = input("ComentÃ¡rio (opcional): ").strip()
                
                generator.block_port(port, protocol, comment)
                print(f"âœ… Porta {port}/{protocol.value} serÃ¡ bloqueada!")
            except ValueError:
                print("âŒ Porta invÃ¡lida")
        
        elif escolha == '5':
            print("\n=== Permitir IP ===")
            ip = input("IP para permitir: ").strip()
            port_str = input("Porta (Enter para todas): ").strip()
            port = int(port_str) if port_str else None
            comment = input("ComentÃ¡rio (opcional): ").strip()
            
            if ip:
                generator.allow_from_ip(ip, port, comment=comment)
                print(f"âœ… IP {ip} serÃ¡ permitido!")
        
        elif escolha == '6':
            print("\n=== Importar Lista de IPs ===")
            file_path = input("Caminho do arquivo: ").strip()
            
            if file_path and os.path.exists(file_path):
                count = generator.import_ips_from_file(file_path)
                print(f"âœ… {count} IPs importados para bloqueio!")
            else:
                print("âŒ Arquivo nÃ£o encontrado")
        
        elif escolha == '7':
            print("\n=== Regras Atuais ===\n")
            
            if not generator.rules:
                print("Nenhuma regra definida.")
            else:
                for i, rule in enumerate(generator.rules, 1):
                    action_icon = "âœ…" if rule.action == Action.ALLOW else "ðŸš«"
                    print(f"{i}. {action_icon} {rule.name}")
                    print(f"   {rule.action.value.upper()} {rule.protocol.value.upper()}")
                    print(f"   {rule.src_ip}:{rule.src_port or '*'} -> {rule.dst_ip}:{rule.dst_port or '*'}")
                    if rule.comment:
                        print(f"   ComentÃ¡rio: {rule.comment}")
                    print()
        
        elif escolha == '8':
            print("\n=== Gerar Script ===")
            print("\nFormatos disponÃ­veis:")
            print("   1. iptables (Linux)")
            print("   2. Windows Firewall (netsh)")
            print("   3. UFW (Ubuntu/Debian)")
            print("   4. pf (BSD/macOS)")
            
            fmt = input("\nFormato: ").strip()
            
            script = ""
            ext = ".sh"
            
            if fmt == '1':
                script = generator.generate_iptables()
                ext = ".sh"
            elif fmt == '2':
                script = generator.generate_windows()
                ext = ".bat"
            elif fmt == '3':
                script = generator.generate_ufw()
                ext = ".sh"
            elif fmt == '4':
                script = generator.generate_pf()
                ext = ".conf"
            
            if script:
                print(f"\n{'='*50}")
                print(script[:1000])
                if len(script) > 1000:
                    print(f"\n... ({len(script)} caracteres total)")
                print(f"{'='*50}")
                
                save = input("\nSalvar arquivo? (s/n): ").lower()
                if save == 's':
                    filename = f"firewall_rules_{datetime.now().strftime('%Y%m%d_%H%M%S')}{ext}"
                    with open(filename, 'w') as f:
                        f.write(script)
                    print(f"âœ… Salvo em {filename}")
        
        elif escolha == '9':
            confirm = input("Limpar todas as regras? (s/n): ").lower()
            if confirm == 's':
                generator.rules = []
                print("âœ… Regras limpas!")
        
        input("\nPressione Enter para continuar...")


if __name__ == "__main__":
    interactive_menu()

"""
Module for the filter class

Some notation conventions:

- $x_m$ Predicted state from the previous k-1 state
- $y_m$ indicates the observations resulted from the predicted
state ($x_m$)
- $H$ is the design (Jacobian) matrix, that translates from state to observation
(i.e. $y = H \\cdot x$)
- $\\Phi$ is the state transition matrix, that translates from the
state k-1 to the predicted state ($x_m$)
"""
from abc import ABC, abstractmethod
from collections import namedtuple
from typing import List

import numpy as np

State = List[float]  # e.g. np.array

ModelObs = namedtuple('ModelObs', ('y_m', 'H'))  # y_m must be an array of arrays (2D shaped)


class Model(ABC):
    """
    Abstract class that declares the interface for entities that model
    an entity to be used by an estimation filter
    """

    @abstractmethod
    def propagate_state(self, state: np.array) -> np.array:
        """
        Propagate a state from time k-1 to k
        """

    @abstractmethod
    def to_observations(self, state: np.array, compute_jacobian: bool = False, **kwargs) -> ModelObs:
        """
        Propagate a state to its corresponding modelled observations (i.e.
        compute expected observations/measurements for the input state)

        :return: a tuple where the first element are the observations and the second
        is the Jacobian matrix (if compute_jacobian is True, otherwise the second
        element will be None)
        """

    def Phi(self):
        """
        Provide with the state transition matrix (also noted F in certain
        Kalman notation)
        """


class StateHandler(ABC):
    """
    Abstract class that handles the state generated by UKF
    """

    @abstractmethod
    def process_state(self, state: np.array, covariance_matrix: np.array, **kwargs):
        """
        Process the state and associated covariance_matrix
        """


class FilterInterface(ABC):
    """Interface for the Filter class"""

    @abstractmethod
    def process(self, y_k: np.array, R: np.array, **kwargs):
        """
        Process an observation batch

        :param y_k: object that contains the observations
        :param R: matrix with the covariance of the measurement (i.e. measurement noise)
        """

#!/usr/bin/env python3
"""WebQA Agent CLI - Command line interface for web quality assurance testing."""

import argparse
import asyncio
import os
import subprocess
import sys
import traceback
import threading

import yaml
from playwright.async_api import Error as PlaywrightError
from playwright.async_api import async_playwright

from webqa_agent.executor import ParallelMode


# ============================================================================
# Configuration Template
# ============================================================================

CONFIG_TEMPLATE = """# WebQA Agent Configuration File
# Generated by: webqa-agent init
# Documentation: https://github.com/MigoXLab/webqa-agent

target:
  url: https://example.com  # Target URL to test
  description: Website quality assurance testing
  max_concurrent_tests: 2  # Optional, default parallel 2

test_config:
  function_test:
    enabled: True
    type: ai  # default or ai
    business_objectives: Generate 3 functional test cases for the website
    dynamic_step_generation:
      enabled: True
      max_dynamic_steps: 10
      min_elements_threshold: 1
  ux_test:
    enabled: True
  performance_test:
    enabled: False  # Requires Lighthouse: npm install lighthouse chrome-launcher
  security_test:
    enabled: False  # Requires Nuclei: https://github.com/projectdiscovery/nuclei

llm_config:
  model: gpt-4.1-2025-04-14  # Vision-capable model recommended for UX tests
  filter_model: gpt-4o-mini  # Lightweight model for element filtering
  api_key: your_api_key_here  # Or set OPENAI_API_KEY environment variable
  base_url: https://api.openai.com/v1  # Or set OPENAI_BASE_URL environment variable
  temperature: 0.1

browser_config:
  viewport: {"width": 1280, "height": 720}
  headless: False  # Docker environment will automatically override to True
  language: en-US
  cookies: []
  save_screenshots: False

report:
  language: en-US  # zh-CN or en-US

log:
  level: info  # debug, info
"""


# ============================================================================
# Utility Functions
# ============================================================================

def get_version():
    """Get the package version."""
    from webqa_agent import __version__
    return __version__


def find_config_file(config_path=None):
    """Find configuration file with priority search."""
    # 1. Explicit path has highest priority
    if config_path:
        if os.path.isfile(config_path):
            return config_path
        else:
            raise FileNotFoundError(f"Specified config file not found: {config_path}")

    # 2. Search default locations
    current_dir = os.getcwd()
    default_paths = [
        os.path.join(current_dir, "config.yaml"),
        os.path.join(current_dir, "config", "config.yaml"),
        "/app/config/config.yaml",  # Docker container
    ]

    for path in default_paths:
        if os.path.isfile(path):
            return path

    return None


def load_yaml(path):
    """Load and parse YAML configuration file."""
    if not os.path.isfile(path):
        print(f"[ERROR] Config file not found: {path}", file=sys.stderr)
        sys.exit(1)
    try:
        with open(path, "r", encoding="utf-8") as f:
            return yaml.safe_load(f)
    except Exception as e:
        print(f"[ERROR] Failed to parse YAML: {e}", file=sys.stderr)
        sys.exit(1)


# ============================================================================
# Environment Check Functions
# ============================================================================

async def check_playwright_browsers_async():
    """Check if Playwright browsers are installed."""
    try:
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            await browser.close()
        print("‚úÖ Playwright browsers available")
        return True
    except PlaywrightError as e:
        print(f"‚ö†Ô∏è Playwright browsers unavailable: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Playwright check failed: {e}")
        return False


def check_lighthouse_installation():
    """Check if Lighthouse is properly installed."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    current_dir = os.getcwd()
    is_windows = os.name == "nt"
    lighthouse_exe = "lighthouse.cmd" if is_windows else "lighthouse"

    # Possible lighthouse paths (local installation priority)
    lighthouse_paths = [
        os.path.join(current_dir, "node_modules", ".bin", lighthouse_exe),  # local installation in current directory
        os.path.join(script_dir, "node_modules", ".bin", lighthouse_exe),  # local installation in script directory
        "lighthouse",  # global installation path (fallback)
    ]

    if not is_windows:
        lighthouse_paths.insert(-1, os.path.join("/app", "node_modules", ".bin", "lighthouse"))

    for path in lighthouse_paths:
        try:
            result = subprocess.run([path, "--version"], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                version = result.stdout.strip()
                print(f"‚úÖ Lighthouse available: {version}")
                return True
        except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
            continue

    print("‚ùå Lighthouse not found")
    return False


def check_nuclei_installation():
    """Check if Nuclei is properly installed."""
    try:
        result = subprocess.run(["nuclei", "-version"], capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            version = result.stdout.strip()
            print(f"‚úÖ Nuclei available: {version}")
            return True
    except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
        pass
    print("‚ùå Nuclei not found")
    return False


# ============================================================================
# LLM Configuration
# ============================================================================

def validate_and_build_llm_config(cfg):
    """Validate and build LLM configuration."""
    llm_cfg_raw = cfg.get("llm_config", {})

    # Environment variables take priority
    api_key = os.getenv("OPENAI_API_KEY") or llm_cfg_raw.get("api_key", "")
    base_url = os.getenv("OPENAI_BASE_URL") or llm_cfg_raw.get("base_url", "")
    model = llm_cfg_raw.get("model", "gpt-4o-mini")
    filter_model = llm_cfg_raw.get("filter_model", model)
    temperature = llm_cfg_raw.get("temperature", 0.1)
    top_p = llm_cfg_raw.get("top_p")
    max_tokens = llm_cfg_raw.get("max_tokens")
    reasoning = llm_cfg_raw.get("reasoning")
    text_cfg = llm_cfg_raw.get("text")

    # Validate required fields
    if not api_key or api_key == "your_api_key_here":
        raise ValueError(
            "‚ùå LLM API Key not configured!\n"
            "   Please set one of the following:\n"
            "   - Environment variable: OPENAI_API_KEY\n"
            "   - Config file: llm_config.api_key"
        )

    if not base_url:
        print("‚ö†Ô∏è  base_url not set, using OpenAI default")
        base_url = "https://api.openai.com/v1"

    llm_config = {
        "api": "openai",
        "model": model,
        "filter_model": filter_model,
        "api_key": api_key,
        "base_url": base_url,
        "temperature": temperature,
    }

    if top_p is not None:
        llm_config["top_p"] = top_p
    if max_tokens is not None:
        llm_config["max_tokens"] = max_tokens
    if reasoning is not None:
        llm_config["reasoning"] = reasoning
    if text_cfg is not None:
        llm_config["text"] = text_cfg

    # Display configuration (masked)
    api_key_masked = f"{api_key[:8]}...{api_key[-4:]}" if len(api_key) > 12 else "***"
    print("‚úÖ LLM configuration validated:")
    print(f"   Model: {model}")
    if filter_model != model:
        print(f"   Filter Model: {filter_model}")
    print(f"   API Key: {api_key_masked}")
    print(f"   Base URL: {base_url}")

    return llm_config


# ============================================================================
# Test Configuration Builder
# ============================================================================

def build_test_configurations(cfg, cookies=None):
    """Build test configurations from config file."""
    tests = []
    tconf = cfg.get("test_config", {})

    is_docker = os.getenv("DOCKER_ENV") == "true"
    config_headless = cfg.get("browser_config", {}).get("headless", True)
    headless = True if is_docker else config_headless

    base_browser = {
        "viewport": cfg.get("browser_config", {}).get("viewport", {"width": 1280, "height": 720}),
        "headless": headless,
    }

    # Function test
    if tconf.get("function_test", {}).get("enabled"):
        if tconf["function_test"].get("type") == "ai":
            tests.append({
                "test_type": "ui_agent_langgraph",
                "enabled": True,
                "browser_config": base_browser,
                "test_specific_config": {
                    "cookies": cookies,
                    "business_objectives": tconf["function_test"].get("business_objectives", ""),
                    "dynamic_step_generation": tconf["function_test"].get("dynamic_step_generation", {}),
                },
            })
        else:
            tests.append({
                "test_type": "basic_test",
                "enabled": True,
                "browser_config": base_browser,
                "test_specific_config": {},
            })

    # UX test
    if tconf.get("ux_test", {}).get("enabled"):
        tests.append({
            "test_type": "ux_test",
            "enabled": True,
            "browser_config": base_browser,
            "test_specific_config": {},
        })

    # Performance test
    if tconf.get("performance_test", {}).get("enabled"):
        tests.append({
            "test_type": "performance",
            "enabled": True,
            "browser_config": base_browser,
            "test_specific_config": {},
        })

    # Security test
    if tconf.get("security_test", {}).get("enabled"):
        tests.append({
            "test_type": "security",
            "enabled": True,
            "browser_config": base_browser,
            "test_specific_config": {},
        })

    return tests


# ============================================================================
# Command: init
# ============================================================================

def cmd_init(args):
    """Initialize a new configuration file."""
    output_path = args.output or "config.yaml"
    
    # Check if file already exists
    if os.path.exists(output_path) and not args.force:
        print(f"‚ùå Config file already exists: {output_path}")
        print(f"   Use --force to overwrite, or specify a different path with --output")
        sys.exit(1)
    
    # Create directory if needed
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir, exist_ok=True)
        print(f"üìÅ Created directory: {output_dir}")
    
    # Write config file
    try:
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(CONFIG_TEMPLATE)
        
        print(f"‚úÖ Configuration file created: {output_path}")
        print()
        print("üìù Next steps:")
        print(f"   1. Edit {output_path} to configure:")
        print("      - target.url: The website URL to test")
        print("      - llm_config.api_key: Your OpenAI API key")
        print("      - test_config: Enable/disable test types")
        print()
        print("   2. Run tests:")
        print(f"      webqa-agent run -c {output_path}")
        
    except Exception as e:
        print(f"‚ùå Failed to create config file: {e}", file=sys.stderr)
        sys.exit(1)


# ============================================================================
# Command: run
# ============================================================================

async def run_tests(cfg):
    """Execute the test suite."""
    # Display runtime info
    is_docker = os.getenv("DOCKER_ENV") == "true"
    print(f"üèÉ Runtime: {'Docker container' if is_docker else 'Local environment'}")

    # Configure screenshot saving
    from webqa_agent.actions.action_handler import ActionHandler
    save_screenshots = cfg.get("browser_config", {}).get("save_screenshots", False)
    ActionHandler.set_screenshot_config(save_screenshots=save_screenshots)
    if not save_screenshots:
        print("üì∏ Screenshot saving: disabled (screenshots will be captured but not saved to disk)")
    else:
        print("üì∏ Screenshot saving: enabled")

    # Check enabled tests
    tconf = cfg.get("test_config", {})
    enabled_tests = []
    if tconf.get("function_test", {}).get("enabled"):
        test_type = tconf.get("function_test", {}).get("type", "default")
        enabled_tests.append(f"Function Test ({test_type})")
    if tconf.get("ux_test", {}).get("enabled"):
        enabled_tests.append("User Experience Test")
    if tconf.get("performance_test", {}).get("enabled"):
        enabled_tests.append("Performance Test")
    if tconf.get("security_test", {}).get("enabled"):
        enabled_tests.append("Security Test")

    if not enabled_tests:
        print("‚ö†Ô∏è No test types enabled in configuration")
        sys.exit(1)

    print(f"üìã Tests enabled: {', '.join(enabled_tests)}")

    # Check dependencies
    needs_browser = any([
        tconf.get("function_test", {}).get("enabled"),
        tconf.get("ux_test", {}).get("enabled"),
        tconf.get("performance_test", {}).get("enabled"),
        tconf.get("security_test", {}).get("enabled"),
    ])

    if needs_browser:
        ok = await check_playwright_browsers_async()
        if not ok:
            print("\nüí° Install browsers with: playwright install chromium", file=sys.stderr)
            sys.exit(1)

    if tconf.get("performance_test", {}).get("enabled"):
        if not check_lighthouse_installation():
            print("\nüí° Install Lighthouse: npm install lighthouse chrome-launcher", file=sys.stderr)
            sys.exit(1)

    if tconf.get("security_test", {}).get("enabled"):
        if not check_nuclei_installation():
            print("\nüí° Install Nuclei: https://github.com/projectdiscovery/nuclei", file=sys.stderr)
            sys.exit(1)

    # Validate LLM config
    try:
        llm_config = validate_and_build_llm_config(cfg)
    except ValueError as e:
        print(f"\n{e}", file=sys.stderr)
        sys.exit(1)

    # Build test configurations
    cookies = cfg.get("browser_config", {}).get("cookies", [])
    test_configurations = build_test_configurations(cfg, cookies=cookies)
    target_url = cfg.get("target", {}).get("url", "")

    if not target_url:
        print("‚ùå No target URL specified in configuration", file=sys.stderr)
        sys.exit(1)

    print(f"üéØ Target URL: {target_url}")

    # Execute tests
    try:
        raw_concurrency = cfg.get("target", {}).get("max_concurrent_tests", 2)
        try:
            max_concurrent_tests = max(1, int(raw_concurrency))
        except (ValueError, TypeError):
            max_concurrent_tests = 2

        print(f"‚öôÔ∏è Concurrency: {max_concurrent_tests}")

        parallel_mode = ParallelMode([], max_concurrent_tests=max_concurrent_tests)
        results, report_path, html_report_path, result_count = await parallel_mode.run(
            url=target_url,
            llm_config=llm_config,
            test_configurations=test_configurations,
            log_cfg=cfg.get("log", {"level": "info"}),
            report_cfg=cfg.get("report", {"language": "en-US"})
        )

        if result_count:
            print(f"üìä Results Summary:")
            print(f"   Total: {result_count.get('total', 0)}")
            print(f"   ‚úÖ Passed: {result_count.get('passed', 0)}")
            print(f"   ‚ö†Ô∏è Warning: {result_count.get('warning', 0)}")
            print(f"   ‚ùå Failed: {result_count.get('failed', 0)}")

        if html_report_path:
            print(f"\nüìÑ Report: {html_report_path}")

    except Exception:
        print("\n‚ùå Test execution failed:", file=sys.stderr)
        traceback.print_exc()
        sys.exit(1)


def cmd_run(args):
    """Run command handler."""
    # Find config file
    config_path = find_config_file(args.config)
    
    if config_path is None:
        print("‚ùå No configuration file found!")
        print()
        print("üìç Searched locations:")
        print("   - ./config.yaml")
        print("   - ./config/config.yaml")
        print()
        print("üí° Create a new configuration file:")
        print("   webqa-agent init")
        print()
        print("   Or specify a config file:")
        print("   webqa-agent run -c /path/to/config.yaml")
        sys.exit(1)
    
    print(f"üìÇ Using config: {config_path}")
    cfg = load_yaml(config_path)
    
    # Run tests
    asyncio.run(run_tests(cfg))


def cmd_ui(args):
    """Launch Gradio web UI."""
    # Set language if provided
    if args.lang:
        os.environ["GRADIO_LANGUAGE"] = args.lang

    # Check gradio
    try:
        import gradio
    except ImportError:
        print("‚ùå Gradio is not installed. Install with: uv add \"gradio>5.44.0\"")
        sys.exit(1)

    # Optional version check
    try:
        from packaging import version
        required = "5.44.0"
        if version.parse(gradio.__version__) <= version.parse(required):
            print(f"‚ùå Gradio version {gradio.__version__} detected, need >= {required}")
            print(f"Install/upgrade: uv add \"gradio>={required}\"")
            sys.exit(1)
    except ImportError:
        pass

    # Import UI factory
    try:
        from app_gradio.demo_gradio import create_gradio_interface, process_queue
    except ImportError as e:
        print(f"‚ùå Failed to import Gradio app: {e}")
        sys.exit(1)

    # Ensure Playwright browsers
    ok = asyncio.run(check_playwright_browsers_async())
    if not ok:
        print("üîç Playwright browsers missing, installing chromium ...")
        try:
            subprocess.run([sys.executable, "-m", "playwright", "install", "chromium"], check=True)
            ok = asyncio.run(check_playwright_browsers_async())
        except Exception as e:
            print(f"‚ùå Failed to install Playwright browsers: {e}")
            print("Please run manually: playwright install chromium")
            sys.exit(1)

    if not ok:
        print("‚ùå Playwright browsers still unavailable. Please run: playwright install chromium")
        sys.exit(1)

    # Start queue processor thread
    def _run_queue():
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(process_queue())

    queue_thread = threading.Thread(target=_run_queue, daemon=True)
    queue_thread.start()

    language = os.getenv("GRADIO_LANGUAGE", "en-US")
    print("üöÄ Starting WebQA Agent Gradio UI ...")
    print(f"üåê Language: {language}")
    print(f"üîó http://{args.host}:{args.port}")
    print("üí° Set GRADIO_LANGUAGE=en-US or zh-CN to switch interface language.")

    app = create_gradio_interface(language=language)
    try:
        app.launch(
            server_name=args.host,
            server_port=args.port,
            share=False,
            show_error=True,
            inbrowser=not args.no_browser,
        )
    except Exception as e:
        print(f"‚ùå Failed to launch Gradio UI: {e}")
        sys.exit(1)


# ============================================================================
# Main Entry Point
# ============================================================================

def create_parser():
    """Create argument parser with subcommands."""
    parser = argparse.ArgumentParser(
        prog="webqa-agent",
        description="WebQA Agent - AI-powered web quality assurance testing",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  webqa-agent init                    Create config.yaml in current directory
  webqa-agent init -o myconfig.yaml   Create config at specified path
  webqa-agent run                     Run tests with auto-discovered config
  webqa-agent run -c config.yaml      Run tests with specified config

Documentation: https://github.com/MigoXLab/webqa-agent
"""
    )
    
    parser.add_argument(
        "--version", "-v",
        action="version",
        version=f"%(prog)s {get_version()}"
    )
    
    subparsers = parser.add_subparsers(
        title="Commands",
        dest="command",
        metavar="<command>"
    )
    
    # init command
    init_parser = subparsers.add_parser(
        "init",
        help="Create a new configuration file",
        description="Initialize a new WebQA Agent configuration file with default settings."
    )
    init_parser.add_argument(
        "--output", "-o",
        metavar="PATH",
        default="config.yaml",
        help="Output path for config file (default: config.yaml)"
    )
    init_parser.add_argument(
        "--force", "-f",
        action="store_true",
        help="Overwrite existing config file"
    )
    
    # run command
    run_parser = subparsers.add_parser(
        "run",
        help="Run quality assurance tests",
        description="Execute web quality assurance tests based on configuration."
    )
    run_parser.add_argument(
        "--config", "-c",
        metavar="PATH",
        help="Path to configuration file (default: auto-discover)"
    )
    # ui command
    ui_parser = subparsers.add_parser(
        "ui",
        help="Launch Gradio web UI",
        description="Start the Gradio interface for WebQA Agent."
    )
    ui_parser.add_argument(
        "--lang", "-l",
        default=os.getenv("GRADIO_LANGUAGE", "en-US"),
        help="Interface language (en-US or zh-CN). Defaults to GRADIO_LANGUAGE env or en-US."
    )
    ui_parser.add_argument(
        "--host",
        default="0.0.0.0",
        help="Host to bind (default: 0.0.0.0)"
    )
    ui_parser.add_argument(
        "--port",
        type=int,
        default=7860,
        help="Port to serve (default: 7860)"
    )
    ui_parser.add_argument(
        "--no-browser",
        action="store_true",
        help="Do not auto-open browser"
    )
    
    return parser


def main():
    """Main entry point for the CLI."""
    parser = create_parser()
    args = parser.parse_args()
    
    # Show help if no command provided
    if args.command is None:
        parser.print_help()
        print()
        print("üí° Quick start:")
        print("   webqa-agent init      # Create configuration file")
        print("   webqa-agent run       # Run tests")
        sys.exit(0)
    
    # Dispatch to command handler
    if args.command == "init":
        cmd_init(args)
    elif args.command == "run":
        cmd_run(args)
    elif args.command == "ui":
        cmd_ui(args)


if __name__ == "__main__":
    main()

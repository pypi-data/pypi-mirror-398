{"version":3,"file":"mathUtil-CL7lMSDB.js","sources":["../../src/utils/mathUtil.ts"],"sourcesContent":["import type { ReadOnlyRect } from '@/lib/litegraph/src/interfaces'\nimport type { Bounds } from '@/renderer/core/layout/types'\n\n/**\n * Finds the greatest common divisor (GCD) for two numbers using iterative\n * Euclidean algorithm. Uses iteration instead of recursion to avoid stack\n * overflow with large inputs or small floating-point step values.\n *\n * For floating-point numbers, uses a tolerance-based approach to handle\n * precision issues and limits iterations to prevent hangs.\n *\n * @param a - The first number.\n * @param b - The second number.\n * @returns The GCD of the two numbers.\n */\nexport const gcd = (a: number, b: number): number => {\n  // Use absolute values to handle negative numbers\n  let x = Math.abs(a)\n  let y = Math.abs(b)\n\n  // Handle edge cases\n  if (x === 0) return y\n  if (y === 0) return x\n\n  // For floating-point numbers, use tolerance-based comparison\n  // This prevents infinite loops due to floating-point precision issues\n  const epsilon = 1e-10\n  const maxIterations = 100\n\n  let iterations = 0\n  while (y > epsilon && iterations < maxIterations) {\n    ;[x, y] = [y, x % y]\n    iterations++\n  }\n\n  return x\n}\n\n/**\n * Finds the least common multiple (LCM) for two numbers.\n *\n * @param a - The first number.\n * @param b - The second number.\n * @returns The LCM of the two numbers.\n */\nexport const lcm = (a: number, b: number): number => {\n  return Math.abs(a * b) / gcd(a, b)\n}\n\n/**\n * Computes the union (bounding box) of multiple rectangles using a single-pass algorithm.\n *\n * Finds the minimum and maximum x/y coordinates across all rectangles to create\n * a single bounding rectangle that contains all input rectangles. Optimized for\n * performance with V8-friendly tuple access patterns.\n *\n * @param rectangles - Array of rectangle tuples in [x, y, width, height] format\n * @returns Bounds object with union rectangle, or null if no rectangles provided\n */\nexport function computeUnionBounds(\n  rectangles: readonly ReadOnlyRect[]\n): Bounds | null {\n  const n = rectangles.length\n  if (n === 0) {\n    return null\n  }\n\n  const r0 = rectangles[0]\n  let minX = r0[0]\n  let minY = r0[1]\n  let maxX = minX + r0[2]\n  let maxY = minY + r0[3]\n\n  for (let i = 1; i < n; i++) {\n    const r = rectangles[i]\n    const x1 = r[0]\n    const y1 = r[1]\n    const x2 = x1 + r[2]\n    const y2 = y1 + r[3]\n\n    if (x1 < minX) minX = x1\n    if (y1 < minY) minY = y1\n    if (x2 > maxX) maxX = x2\n    if (y2 > maxY) maxY = y2\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  }\n}\n"],"names":["gcd","__name","a","b","x","y","epsilon","maxIterations","iterations","lcm","computeUnionBounds","rectangles","n","r0","minX","minY","maxX","maxY","i","r","x1","y1","x2","y2"],"mappings":"+EAea,MAAAA,EAAMC,EAAA,CAACC,EAAWC,IAAsB,CAE/C,IAAAC,EAAI,KAAK,IAAIF,CAAC,EACdG,EAAI,KAAK,IAAIF,CAAC,EAGd,GAAAC,IAAM,EAAU,OAAAC,EAChB,GAAAA,IAAM,EAAU,OAAAD,EAIpB,MAAME,EAAU,MACVC,EAAgB,IAEtB,IAAIC,EAAa,EACV,KAAAH,EAAIC,GAAWE,EAAaD,GAChC,CAACH,EAAGC,CAAC,EAAI,CAACA,EAAGD,EAAIC,CAAC,EACnBG,IAGK,OAAAJ,CACT,EArBmB,OA8BNK,EAAMR,EAAA,CAACC,EAAWC,IACtB,KAAK,IAAID,EAAIC,CAAC,EAAIH,EAAIE,EAAGC,CAAC,EADhB,OAcZ,SAASO,EACdC,EACe,CACf,MAAMC,EAAID,EAAW,OACrB,GAAIC,IAAM,EACD,OAAA,KAGH,MAAAC,EAAKF,EAAW,CAAC,EACnB,IAAAG,EAAOD,EAAG,CAAC,EACXE,EAAOF,EAAG,CAAC,EACXG,EAAOF,EAAOD,EAAG,CAAC,EAClBI,EAAOF,EAAOF,EAAG,CAAC,EAEtB,QAASK,EAAI,EAAGA,EAAIN,EAAGM,IAAK,CACpB,MAAAC,EAAIR,EAAWO,CAAC,EAChBE,EAAKD,EAAE,CAAC,EACRE,EAAKF,EAAE,CAAC,EACRG,EAAKF,EAAKD,EAAE,CAAC,EACbI,EAAKF,EAAKF,EAAE,CAAC,EAEfC,EAAKN,IAAaA,EAAAM,GAClBC,EAAKN,IAAaA,EAAAM,GAClBC,EAAKN,IAAaA,EAAAM,GAClBC,EAAKN,IAAaA,EAAAM,EACxB,CAEO,MAAA,CACL,EAAGT,EACH,EAAGC,EACH,MAAOC,EAAOF,EACd,OAAQG,EAAOF,CAAA,CAEnB,CAjCgBd,EAAAS,EAAA"}
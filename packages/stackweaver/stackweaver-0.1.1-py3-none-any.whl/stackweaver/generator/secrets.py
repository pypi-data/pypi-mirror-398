"""
Secret Generation for StackWeaver.

Generates cryptographically secure secrets for services using CSPRNG.
"""

import secrets
import string
from dataclasses import dataclass
from pathlib import Path
from typing import Any


@dataclass
class SecretDefinition:
    """Represents a secret that needs to be generated."""

    key: str  # Environment variable name (e.g., "POSTGRES_PASSWORD")
    value: str = ""  # Generated secret value
    description: str = ""  # Optional description
    length: int = 32  # Secret length (default 192-bit entropy)

    def generate(self) -> None:
        """Generate a cryptographically secure secret."""
        if not self.value:  # Only generate if not already set
            self.value = SecretGenerator.generate_secret(self.length)


class SecretGenerator:
    """Manages secret generation for a stack."""

    # Character set for secrets: a-z, A-Z, 0-9
    CHARSET = string.ascii_letters + string.digits

    # Default secret length (32 chars = 192-bit entropy with 62-char alphabet)
    DEFAULT_LENGTH = 32

    # Warning header for .env files
    ENV_FILE_HEADER = """# Generated by StackWeaver - DO NOT COMMIT TO GIT
#
# This file contains sensitive secrets for your Docker stack.
# Add this file to .gitignore to prevent accidental commits.
#
# Generated secrets use cryptographically secure random generation (CSPRNG)
# with 192-bit entropy for maximum security.
"""

    def __init__(self) -> None:
        """Initialize secret generator."""
        self._secrets: dict[str, SecretDefinition] = {}

    def add_secret(
        self,
        key: str,
        description: str = "",
        length: int = DEFAULT_LENGTH,
    ) -> SecretDefinition:
        """
        Add a secret to be generated.

        Args:
            key: Environment variable name
            description: Optional description of what this secret is for
            length: Secret length (default 32)

        Returns:
            SecretDefinition instance
        """
        if key in self._secrets:
            return self._secrets[key]

        secret = SecretDefinition(key=key, description=description, length=length)
        secret.generate()
        self._secrets[key] = secret
        return secret

    def get_secret(self, key: str) -> SecretDefinition | None:
        """
        Get a secret by key.

        Args:
            key: Environment variable name

        Returns:
            SecretDefinition or None if not found
        """
        return self._secrets.get(key)

    def get_all_secrets(self) -> dict[str, SecretDefinition]:
        """
        Get all registered secrets.

        Returns:
            Dictionary of key to SecretDefinition
        """
        return self._secrets.copy()

    def generate_env_file(self, output_path: Path | str) -> None:
        """
        Generate a .env file with all secrets.

        Args:
            output_path: Path to write .env file
        """
        output_path = Path(output_path)

        lines = [self.ENV_FILE_HEADER]

        # Group secrets by prefix for better organization
        grouped_secrets = self._group_secrets_by_prefix()

        for prefix, secrets_group in grouped_secrets.items():
            if prefix:
                lines.append(f"\n# {prefix.upper()} Configuration")

            for secret in secrets_group:
                if secret.description:
                    lines.append(f"# {secret.description}")
                lines.append(f"{secret.key}={secret.value}")

        content = "\n".join(lines) + "\n"
        output_path.write_text(content, encoding="utf-8")

    def _group_secrets_by_prefix(self) -> dict[str, list[SecretDefinition]]:
        """Group secrets by their prefix for organized .env output."""
        groups: dict[str, list[SecretDefinition]] = {}

        for secret in self._secrets.values():
            # Extract prefix (e.g., "POSTGRES" from "POSTGRES_PASSWORD")
            parts = secret.key.split("_")
            prefix = parts[0] if len(parts) > 1 else ""

            if prefix not in groups:
                groups[prefix] = []
            groups[prefix].append(secret)

        return groups

    @staticmethod
    def generate_secret(length: int = DEFAULT_LENGTH) -> str:
        """
        Generate a cryptographically secure random secret.

        Uses Python's secrets module (CSPRNG) for secure random generation.

        Args:
            length: Length of the secret (default 32 characters)

        Returns:
            Cryptographically secure random string

        Raises:
            ValueError: If length is less than 8
        """
        if length < 8:
            raise ValueError("Secret length must be at least 8 characters")

        return "".join(secrets.choice(SecretGenerator.CHARSET) for _ in range(length))

    @staticmethod
    def validate_secret_strength(secret: str) -> dict[str, Any]:
        """
        Validate the strength of a secret.

        Args:
            secret: Secret to validate

        Returns:
            Dictionary with validation results
        """
        has_upper = any(c.isupper() for c in secret)
        has_lower = any(c.islower() for c in secret)
        has_digit = any(c.isdigit() for c in secret)
        length_ok = len(secret) >= 8

        is_strong = all([has_upper, has_lower, has_digit, length_ok])

        return {
            "is_strong": is_strong,
            "has_uppercase": has_upper,
            "has_lowercase": has_lower,
            "has_digit": has_digit,
            "length_ok": length_ok,
            "length": len(secret),
        }

    @staticmethod
    def ensure_gitignore_entry(project_root: Path | str) -> None:
        """
        Ensure .env is in .gitignore to prevent accidental commits.

        Args:
            project_root: Root directory of the project
        """
        project_root = Path(project_root)
        gitignore_path = project_root / ".gitignore"

        # Read existing .gitignore
        if gitignore_path.exists():
            content = gitignore_path.read_text(encoding="utf-8")
            lines = content.splitlines()
        else:
            lines = []

        # Check if .env is already ignored
        if ".env" not in lines and "*.env" not in lines:
            # Add .env entry with comment
            lines.append("")
            lines.append("# Environment files with secrets")
            lines.append(".env")
            lines.append(".env.local")
            lines.append(".env.*.local")

            content = "\n".join(lines) + "\n"
            gitignore_path.write_text(content, encoding="utf-8")

    def clear(self) -> None:
        """Clear all registered secrets."""
        self._secrets.clear()

    def __len__(self) -> int:
        """Get number of registered secrets."""
        return len(self._secrets)


def generate_database_secrets(tool_name: str, db_type: str) -> dict[str, str]:
    """
    Generate secrets for a database service.

    Args:
        tool_name: Name of the tool
        db_type: Database type (postgres, mysql, etc.)

    Returns:
        Dictionary of environment variable names to secret values
    """
    generator = SecretGenerator()
    db_type = db_type.lower()
    tool_name = tool_name.upper().replace("-", "_")

    if db_type == "postgres":
        generator.add_secret(
            f"{tool_name}_POSTGRES_PASSWORD",
            description=f"PostgreSQL password for {tool_name}",
        )
        return {secret.key: secret.value for secret in generator.get_all_secrets().values()}

    elif db_type in ("mysql", "mariadb"):
        generator.add_secret(
            f"{tool_name}_MYSQL_ROOT_PASSWORD",
            description=f"MySQL root password for {tool_name}",
        )
        generator.add_secret(
            f"{tool_name}_MYSQL_PASSWORD",
            description=f"MySQL user password for {tool_name}",
        )
        return {secret.key: secret.value for secret in generator.get_all_secrets().values()}

    elif db_type == "mongodb":
        generator.add_secret(
            f"{tool_name}_MONGO_ROOT_PASSWORD",
            description=f"MongoDB root password for {tool_name}",
        )
        return {secret.key: secret.value for secret in generator.get_all_secrets().values()}

    elif db_type == "redis":
        generator.add_secret(
            f"{tool_name}_REDIS_PASSWORD",
            description=f"Redis password for {tool_name}",
        )
        return {secret.key: secret.value for secret in generator.get_all_secrets().values()}

    return {}

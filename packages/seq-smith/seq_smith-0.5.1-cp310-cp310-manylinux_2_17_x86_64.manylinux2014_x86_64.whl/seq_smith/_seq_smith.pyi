# This file is automatically generated by pyo3_stub_gen

import enum
from collections.abc import Sequence
from typing import final

import np.typing as npt
import numpy as np

@final
class Alignment:
    @property
    def fragments(self) -> list[AlignmentFragment]: ...
    @property
    def score(self) -> int: ...
    @property
    def stats(self) -> AlignmentStats: ...

@final
class AlignmentFragment:
    def __init__(
        self,
        fragment_type: FragmentType,
        sa_start: int,
        sb_start: int,
        length: int,
    ) -> None: ...
    @property
    def fragment_type(self) -> FragmentType: ...
    @fragment_type.setter
    def fragment_type(self, value: FragmentType) -> None: ...
    @property
    def sa_start(self) -> int: ...
    @property
    def sb_start(self) -> int: ...
    @property
    def len(self) -> int: ...

@final
class AlignmentStats:
    @property
    def num_exact_matches(self) -> int: ...
    @property
    def num_positive_mismatches(self) -> int: ...
    @property
    def num_negative_mismatches(self) -> int: ...
    @property
    def num_a_gaps(self) -> int: ...
    @property
    def num_b_gaps(self) -> int: ...
    @property
    def len(self) -> int: ...

@final
class FragmentType(enum.Enum):
    AGap = ...
    BGap = ...
    Match = ...

def global_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: np.typing.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
) -> Alignment: ...
def global_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
    num_threads: int | None = None,
) -> list[Alignment]: ...
def local_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: np.typing.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
) -> Alignment: ...
def local_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
    num_threads: int | None = None,
) -> list[Alignment]: ...
def local_global_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
) -> Alignment: ...
def local_global_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
    num_threads: int | None = None,
) -> list[Alignment]: ...
def overlap_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
) -> Alignment: ...
def overlap_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
    num_threads: int | None = None,
) -> list[Alignment]: ...
def top_k_ungapped_local_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: npt.NDArray[np.int32],
    k: int,
    filter_overlap_a: bool = True,
    filter_overlap_b: bool = True,
) -> list[Alignment]: ...
def top_k_ungapped_local_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    k: int,
    num_threads: int | None = None,
    filter_overlap_a: bool = True,
    filter_overlap_b: bool = True,
) -> list[list[Alignment]]: ...

from collections.abc import Sequence
import enum


class BufferKind(enum.Enum):
    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    WORKSPACE = 0

    CONSTANT = 1

    INPUT = 2

    OUTPUT = 3

    @property
    def is_io(self) -> bool: ...

    def __hash__(self) -> int: ...

class Allocation:
    def __init__(self, id: int | str, size: int, start: int, end: int, offset: int | None = None, kind: BufferKind | None = None) -> None: ...

    @property
    def id(self) -> int | str: ...

    @property
    def size(self) -> int: ...

    @property
    def start(self) -> int: ...

    @property
    def end(self) -> int: ...

    @property
    def offset(self) -> int | None: ...

    @property
    def kind(self) -> BufferKind | None: ...

    @property
    def is_allocated(self) -> bool: ...

    @property
    def duration(self) -> int: ...

    @property
    def height(self) -> int | None: ...

    @property
    def area(self) -> int: ...

    def overlaps_temporally(self, other: Allocation) -> bool: ...

    def overlaps_spatially(self, other: Allocation) -> bool: ...

    def overlaps(self, other: Allocation) -> bool: ...

    def with_offset(self, offset: int) -> Allocation: ...

    def with_kind(self, kind: BufferKind) -> Allocation: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, arg: Allocation, /) -> bool: ...

    def __hash__(self) -> int: ...

class GreedyAllocatorCpp:
    def __init__(self) -> None: ...

    def allocate(self, allocations: Sequence[Allocation]) -> list[Allocation]: ...

    def __str__(self) -> str: ...

    def __repr__(self) -> str: ...

    def __eq__(self, arg: GreedyAllocatorCpp, /) -> bool: ...

    def __hash__(self) -> int: ...

# Product Intake Workflow

**Project**: {{ project.name }}
**Workflow**: Product Intake
**Purpose**: Triage incoming work requests, bugs, and ideas into the backlog

## Output Formatting Requirements

**IMPORTANT**: Use actual Unicode emojis in reports, NOT GitHub-style shortcodes:
- :bug: Bug | :bulb: Idea | :memo: Feature Request | :question: Question
- :fire: Urgent | :exclamation: High | :arrow_up: Medium | :arrow_down: Low

---

## Where This Fits

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  WORK INTAKE FLOW                                                           │
│                                                                             │
│  External Sources                                                           │
│  ├── Customer feedback                                                      │
│  ├── Bug reports                                                            │
│  ├── Feature requests                                                       │
│  ├── Technical debt items                                                   │
│  ├── Stakeholder ideas                                                      │
│  └── Support tickets                                                        │
│      │                                                                      │
│      ▼                                                                      │
│  ══════════════════                                                         │
│  YOU ARE HERE: /product-intake                                              │
│  ══════════════════                                                         │
│      │                                                                      │
│      ├──► Bugs ──────────────► Backlog (prioritized for fix)               │
│      ├──► Small Tasks ──────► Backlog (ready for sprint)                   │
│      ├──► Medium Features ──► Backlog (ready for sprint planning)          │
│      ├──► Large Epics ──────► /backlog-grooming (decompose to Features)    │
│      └──► Strategic Ideas ──► /architecture-planning (architectural design)│
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Prerequisites

1. **Work tracking configured** in {{ work_tracking.platform }}
2. **Intake item** (bug report, feature request, customer feedback, etc.)
3. **Agents enabled** for triage analysis

---

## Workflow Initialization

```python
import sys
sys.path.insert(0, ".claude/skills")

from workflow_state import WorkflowState
from workflow_profiler import WorkflowProfiler
from work_tracking import get_adapter
from pathlib import Path
from datetime import datetime

# Initialize and validate platform
try:
    adapter = get_adapter()
    print(f":clipboard: Work Tracking: {adapter.platform}")
except ValueError as e:
    print(f":x: ERROR: {e}")
    print("\n:arrow_right: Fix: Configure work tracking platform in .claude/config.yaml")
    print("   Example:")
    print("   work_tracking:")
    print("     platform: 'azure-devops'  # or 'file-based'")
    sys.exit(1)

# Validate platform matches configuration
configured_platform = "{{ work_tracking.platform }}"
if adapter.platform != configured_platform:
    print(f":warning: WARNING: Adapter platform mismatch!")
    print(f"   Configured: {configured_platform}")
    print(f"   Actual: {adapter.platform}")
    print("\n:x: This indicates a configuration error. Aborting.")
    sys.exit(1)

# Initialize state
intake_id = datetime.now().strftime("%Y%m%d-%H%M%S")
state = WorkflowState("product-intake", f"intake-{intake_id}")
profiler = WorkflowProfiler(f"product-intake-{intake_id}")
```

---

## Phase 1: Capture Intake Item

### Step 1.1: Classify Intake Type

```python
print("\n:inbox_tray: PRODUCT INTAKE")
print("=" * 60)
print("\nWhat type of item is this?")
print("  1. :bug: Bug Report (something is broken)")
print("  2. :bulb: Feature Request (new capability needed)")
print("  3. :wrench: Technical Debt (code/architecture improvement)")
print("  4. :shield: Security Issue (vulnerability or concern)")
print("  5. :zap: Performance Issue (slowness or resource problem)")
print("  6. :question: Question/Clarification (needs investigation)")
print("  7. :memo: Customer Feedback (general input)")

intake_type_map = {
    '1': ('Bug', '{{ work_tracking.work_item_types.bug }}'),
    '2': ('Feature', '{{ work_tracking.work_item_types.feature }}'),
    '3': ('Technical Debt', '{{ work_tracking.work_item_types.task }}'),
    '4': ('Security', '{{ work_tracking.work_item_types.bug }}'),
    '5': ('Performance', '{{ work_tracking.work_item_types.bug }}'),
    '6': ('Investigation', '{{ work_tracking.work_item_types.task }}'),
    '7': ('Feedback', '{{ work_tracking.work_item_types.story }}'),
}

type_choice = input("\nSelect type (1-7): ")
intake_type, work_item_type = intake_type_map.get(type_choice, ('Feature', '{{ work_tracking.work_item_types.feature }}'))

state.set_metadata("intake_type", intake_type)
state.set_metadata("work_item_type", work_item_type)
```

### Step 1.2: Capture Details

```python
print(f"\n:pencil: Describe the {intake_type}")
print("-" * 40)

# Title
title = input("Title (brief summary): ")

# Description
print("\nDescription (detailed explanation, end with blank line):")
desc_lines = []
while True:
    line = input()
    if line == "":
        break
    desc_lines.append(line)
description = "\n".join(desc_lines)

# Source
print("\nSource of this item:")
print("  1. Customer report")
print("  2. Internal team")
print("  3. Support ticket")
print("  4. Monitoring/alerts")
print("  5. Code review")
print("  6. Other")
source_choice = input("Select source (1-6): ")
source_map = {
    '1': 'Customer',
    '2': 'Internal',
    '3': 'Support',
    '4': 'Monitoring',
    '5': 'Code Review',
    '6': 'Other'
}
source = source_map.get(source_choice, 'Other')

# For bugs: reproduction steps
if intake_type in ['Bug', 'Security', 'Performance']:
    print("\nReproduction steps (if applicable, end with blank line):")
    repro_lines = []
    while True:
        line = input()
        if line == "":
            break
        repro_lines.append(line)
    repro_steps = "\n".join(repro_lines)

    print("\nExpected vs Actual behavior:")
    expected = input("Expected: ")
    actual = input("Actual: ")
else:
    repro_steps = ""
    expected = ""
    actual = ""

# Urgency
print("\nUrgency level:")
print("  1. :fire: Critical (production down, data loss, security breach)")
print("  2. :exclamation: High (major feature broken, significant impact)")
print("  3. :arrow_up: Medium (important but workaround exists)")
print("  4. :arrow_down: Low (nice to have, minor inconvenience)")
urgency_choice = input("Select urgency (1-4): ")
urgency_map = {'1': 'Critical', '2': 'High', '3': 'Medium', '4': 'Low'}
urgency = urgency_map.get(urgency_choice, 'Medium')

state.set_metadata("title", title)
state.set_metadata("description", description)
state.set_metadata("source", source)
state.set_metadata("urgency", urgency)
```

---

## Phase 2: Triage Analysis

### Step 2.1: AI-Assisted Triage

{% if 'business-analyst' in agent_config.enabled_agents %}
**Agent**: Business Analyst
**Model**: {{ agent_config.models.analyst | default('claude-sonnet-4.5') }}

1. **Read agent definition:** `.claude/agents/business-analyst.md`

2. **Task:** "Triage this incoming work item:

   **Type**: {intake_type}
   **Title**: {title}
   **Description**: {description}
   **Source**: {source}
   **Reported Urgency**: {urgency}

   {% if repro_steps %}
   **Reproduction Steps**: {repro_steps}
   **Expected**: {expected}
   **Actual**: {actual}
   {% endif %}

   **Project Context**:
   - Project: {{ project.name }}
   - Type: {{ project.type }}

   **Triage Analysis Required:**

   1. **Validate Urgency**: Is the reported urgency appropriate?
      - Critical: Production outage, data loss, active security breach
      - High: Major feature broken, significant user impact
      - Medium: Important but has workaround
      - Low: Minor issue, cosmetic, nice-to-have

   2. **Classify Size**:
      - Small: Can be done in 1-2 days, single component → Create as Task
      - Medium: 3-5 days, multiple components → Create as Feature
      - Large: 1-2 weeks, needs breakdown into Features → Create as Epic
      - Epic: Multiple weeks, needs decomposition → Create as Epic, run /backlog-grooming

   3. **Identify Related Work**:
      - Is this a duplicate of existing work item?
      - Does this relate to an existing Epic or Feature?
      - Are there similar items that should be grouped?

   4. **Assess Impact**:
      - Users affected (all, segment, single)
      - Revenue impact (direct, indirect, none)
      - Reputation risk (high, medium, low)

   5. **Recommend Action**:
      - Create as Bug/Task/Feature and add to backlog
      - Escalate to on-call (if critical)
      - Defer to roadmap planning (if strategic)
      - Request more information (if unclear)
      - Reject (if out of scope or duplicate)

   **Output Format**:
   ```json
   {
     'validated_urgency': 'Critical|High|Medium|Low',
     'urgency_rationale': 'Why this urgency level',
     'size': 'Small|Medium|Large|Epic',
     'size_rationale': 'Why this size',
     'potential_duplicates': ['WI-123', 'WI-456'],
     'related_epics': ['EPIC-001'],
     'impact': {
       'users_affected': 'All|Segment|Single',
       'revenue_impact': 'Direct|Indirect|None',
       'reputation_risk': 'High|Medium|Low'
     },
     'recommended_action': 'Create|Escalate|Defer|Request Info|Reject',
     'action_rationale': 'Why this action',
     'suggested_title': 'Improved title if needed',
     'suggested_tags': ['tag1', 'tag2'],
     'questions': ['Clarifying question if needed']
   }
   ```"

3. **Spawn agent** using Task tool with model `{{ agent_config.models.analyst | default('sonnet') }}`

4. **Checkpoint:** Save triage analysis to state
{% endif %}

### Step 2.2: Technical Assessment (For Bugs/Technical Items)

{% if 'senior-engineer' in agent_config.enabled_agents and intake_type in ['Bug', 'Security', 'Performance', 'Technical Debt'] %}
**Agent**: Senior Engineer
**Model**: {{ agent_config.models.engineer | default('claude-sonnet-4.5') }}

1. **Read agent definition:** `.claude/agents/senior-engineer.md`

2. **Task:** "Provide technical assessment for this {intake_type}:

   **Title**: {title}
   **Description**: {description}

   {% if repro_steps %}
   **Reproduction Steps**: {repro_steps}
   **Expected**: {expected}
   **Actual**: {actual}
   {% endif %}

   **Tech Stack**: {{ tech_stack_context }}

   **Technical Assessment Required:**
   1. Likely root cause hypothesis
   2. Affected components/modules
   3. Potential fix approach
   4. Regression risk of fix
   5. Testing requirements
   6. Story point estimate

   **Output Format**:
   ```json
   {
     'root_cause_hypothesis': 'What might be causing this',
     'affected_components': ['Component 1', 'Component 2'],
     'fix_approach': 'How to fix',
     'regression_risk': 'High|Medium|Low',
     'testing_requirements': ['Unit test', 'Integration test'],
     'story_points': 3,
     'technical_notes': 'Additional context'
   }
   ```"

3. **Spawn agent** using Task tool with model `{{ agent_config.models.engineer | default('sonnet') }}`

4. **Checkpoint:** Save technical assessment to state
{% endif %}

---

## Phase 3: Human Review & Decision

### Step 3.1: Present Triage Results

```python
print("\n" + "=" * 80)
print(":mag: TRIAGE RESULTS")
print("=" * 80)

print(f"\n:label: Title: {suggested_title or title}")
print(f":inbox_tray: Type: {intake_type}")
print(f":exclamation: Urgency: {validated_urgency} (reported: {urgency})")
print(f":straight_ruler: Size: {size}")
print(f":busts_in_silhouette: Impact: {impact['users_affected']} users | "
      f"Revenue: {impact['revenue_impact']} | Risk: {impact['reputation_risk']}")

print(f"\n:arrow_right: Recommended Action: {recommended_action}")
print(f"   Rationale: {action_rationale}")

if potential_duplicates:
    print(f"\n:warning: Potential Duplicates: {', '.join(potential_duplicates)}")

if related_epics:
    print(f":link: Related Epics: {', '.join(related_epics)}")

if questions:
    print(f"\n:question: Questions Needing Answers:")
    for q in questions:
        print(f"   - {q}")

{% if intake_type in ['Bug', 'Security', 'Performance', 'Technical Debt'] %}
if technical_assessment:
    print(f"\n:wrench: Technical Assessment:")
    print(f"   Root Cause: {technical_assessment['root_cause_hypothesis']}")
    print(f"   Components: {', '.join(technical_assessment['affected_components'])}")
    print(f"   Story Points: {technical_assessment['story_points']}")
{% endif %}

print("\n" + "=" * 80)
```

### Step 3.2: Confirm Action

```python
print("\nConfirm action:")
print(f"  [c] Create work item as recommended ({recommended_action})")
print("  [m] Modify (change type, urgency, etc.)")
print("  [e] Escalate to on-call")
print("  [d] Defer to roadmap planning")
print("  [r] Reject (out of scope/duplicate)")
print("  [q] Request more information")

action = input("\nSelect action: ").lower()

if action == 'm':
    # Allow modifications
    new_urgency = input(f"New urgency [{validated_urgency}]: ") or validated_urgency
    new_type = input(f"New type [{work_item_type}]: ") or work_item_type
    validated_urgency = new_urgency
    work_item_type = new_type
    action = 'c'  # Then create

if action == 'r':
    rejection_reason = input("Rejection reason: ")
    state.set_metadata("rejection_reason", rejection_reason)
    print(f":x: Item rejected: {rejection_reason}")
    state.complete_workflow()
    exit()

if action == 'q':
    info_needed = input("What information is needed? ")
    # Create investigation task
    work_item_type = "{{ work_tracking.work_item_types.task }}"
    title = f"[Investigation] {title}"
    description += f"\n\n## Information Needed\n{info_needed}"
```

---

## Phase 4: Work Item Creation

### Step 4.0: Duplicate Detection

```python
if action in ['c', 'e']:
    # Check for recent duplicates before creating work item
    print(f"\n:mag: Checking for duplicate work items...")

    # Import duplicate detection from Azure DevOps CLI wrapper
    import sys
    sys.path.insert(0, ".claude/skills/azure_devops")
    from cli_wrapper import check_recent_duplicates

    # Check for duplicates in last 1 hour with 95% similarity threshold
    duplicate = check_recent_duplicates(
        title=suggested_title or title,
        work_item_type=work_item_type,
        hours=1,
        similarity_threshold=0.95
    )

    if duplicate:
        print(f"\n:warning: DUPLICATE DETECTED!")
        print(f"   Found similar work item: #{duplicate['id']}")
        print(f"   Title: {duplicate['title']}")
        print(f"   Similarity: {duplicate['similarity']:.1%}")
        print(f"   Created: {duplicate['created_date']}")
        print(f"   State: {duplicate['state']}")
        print(f"   URL: {duplicate['url']}")

        print(f"\n:question: This work item appears to be a duplicate. What would you like to do?")
        print(f"   [u] Use existing work item #{duplicate['id']}")
        print(f"   [c] Create new work item anyway")
        print(f"   [x] Cancel and exit")

        dup_action = input("\nSelect action: ").lower()

        if dup_action == 'u':
            # Use existing work item
            work_item_id = duplicate['id']
            print(f"\n:white_check_mark: Using existing work item #{work_item_id}")

            # Skip to completion phase
            state.set_metadata("duplicate_handled", True)
            state.set_metadata("used_existing_item", work_item_id)
            action = 'skip_creation'

        elif dup_action == 'x':
            # Cancel workflow
            print(f"\n:x: Workflow cancelled by user (duplicate detected)")
            state.complete_workflow()
            exit()

        elif dup_action == 'c':
            # Continue with creation
            print(f"\n:arrow_forward: Continuing with work item creation...")
            # action remains 'c' or 'e', proceed to creation

    else:
        print(f":white_check_mark: No duplicates found")
```

### Step 4.1: Create Work Item

```python
if action in ['c', 'e']:
    # Determine work item type based on size classification from triage
    # This overrides the initial type from intake classification
    size_to_type = {
        'Small': '{{ work_tracking.work_item_types.task }}',      # 1-2 days → Task
        'Medium': '{{ work_tracking.work_item_types.feature }}',  # 3-5 days → Feature
        'Large': '{{ work_tracking.work_item_types.epic }}',      # 1-2 weeks → Epic (needs Features)
        'Epic': '{{ work_tracking.work_item_types.epic }}'        # Multiple weeks → Epic (needs breakdown)
    }

    # Use size-based type unless it's a Bug (bugs stay as bugs regardless of size)
    if intake_type not in ['Bug', 'Security', 'Performance']:
        work_item_type = size_to_type.get(size, work_item_type)
        print(f"\n:label: Size classification: {size} → Creating as {work_item_type}")

    print(f"\n:rocket: Creating {work_item_type}...")

    # Build description
    full_description = f"""## Summary
{description}

{% if repro_steps %}
## Reproduction Steps
{repro_steps}

## Expected Behavior
{expected}

## Actual Behavior
{actual}
{% endif %}

## Triage Information
- **Source**: {source}
- **Urgency**: {validated_urgency}
- **Size**: {size}
- **Impact**: {impact['users_affected']} users affected

{% if technical_assessment %}
## Technical Assessment
- **Likely Cause**: {technical_assessment['root_cause_hypothesis']}
- **Affected Components**: {', '.join(technical_assessment['affected_components'])}
- **Fix Approach**: {technical_assessment['fix_approach']}
- **Regression Risk**: {technical_assessment['regression_risk']}
{% endif %}

{% if related_epics %}
## Related Work
- Related Epics: {', '.join(related_epics)}
{% endif %}

---
*Created via /product-intake workflow on {datetime.now().strftime('%Y-%m-%d %H:%M')}*
"""

    # Map urgency to priority
    priority_map = {'Critical': 1, 'High': 2, 'Medium': 3, 'Low': 4}
    priority = priority_map.get(validated_urgency, 3)

    # Map urgency to severity (for Bugs)
    severity_map = {'Critical': '1 - Critical', 'High': '2 - High', 'Medium': '3 - Medium', 'Low': '4 - Low'}
    severity = severity_map.get(validated_urgency, '3 - Medium')

    # Build fields dict
    fields = {
        'Microsoft.VSTS.Common.Priority': priority,
        {% if work_tracking.custom_fields.story_points %}
        '{{ work_tracking.custom_fields.story_points }}': technical_assessment.get('story_points', 0) if technical_assessment else 0,
        {% endif %}
        'System.Tags': '; '.join(suggested_tags + [
            f'intake-{intake_type.lower().replace(" ", "-")}',
            f'urgency-{validated_urgency.lower()}',
            f'source-{source.lower()}'
        ])
    }

    # Add Bug-specific fields if this is a Bug
    if work_item_type == '{{ work_tracking.work_item_types.bug }}':
        fields['Microsoft.VSTS.Common.Severity'] = severity

        # Reproduction steps (structured field, not just in description)
        if repro_steps:
            fields['Microsoft.VSTS.TCM.ReproSteps'] = f"<div>{repro_steps}</div>"

        # System information (environment, version, etc.)
        system_info_parts = []
        if technical_assessment and 'affected_components' in technical_assessment:
            system_info_parts.append(f"<b>Affected Components:</b> {', '.join(technical_assessment['affected_components'])}")
        system_info_parts.append(f"<b>Source:</b> {source}")
        system_info_parts.append(f"<b>Urgency:</b> {validated_urgency}")
        if expected and actual:
            system_info_parts.append(f"<b>Expected:</b> {expected}<br><b>Actual:</b> {actual}")
        fields['Microsoft.VSTS.TCM.SystemInfo'] = '<br>'.join(system_info_parts)

        # Acceptance criteria for bug fix
        acceptance_parts = []
        if repro_steps:
            acceptance_parts.append("- Bug no longer reproduces following the reproduction steps")
        if expected:
            acceptance_parts.append(f"- System behaves as expected: {expected}")
        acceptance_parts.append("- No regression in related functionality")
        acceptance_parts.append("- Unit tests added to prevent regression")
        fields['Microsoft.VSTS.Common.AcceptanceCriteria'] = '<br>'.join(acceptance_parts)

    # Create work item
    try:
        result = adapter.create_work_item(
            work_item_type=work_item_type,
            title=suggested_title or title,
            description=full_description,
            fields=fields,
            verify=True
        )

        work_item_id = result['id']
        state.record_work_item_created(work_item_id, {'title': title, 'type': intake_type})

        print(f":white_check_mark: Created {work_item_type} {work_item_id}: {suggested_title or title}")

        # Link to related Epic if identified
        if related_epics:
            for epic_ref in related_epics:
                try:
                    epic_id = epic_ref.replace('EPIC-', '')
                    adapter.link_work_items(work_item_id, epic_id, "Related")
                    print(f"  :link: Linked to {epic_ref}")
                except:
                    pass

    except Exception as e:
        print(f":red_circle: Failed to create work item: {e}")
        state.record_error(str(e), {'title': title})
```

### Step 4.2: Handle Escalation

```python
if action == 'e':
    print("\n:rotating_light: ESCALATION")
    print("-" * 40)
    print("This item has been marked for escalation.")
    print(f"Work Item: {work_item_id}")
    print(f"Urgency: {validated_urgency}")

    # Add escalation tag
    try:
        adapter.update_work_item(
            work_item_id=work_item_id,
            fields={
                'System.Tags': f"{'; '.join(suggested_tags)}; escalated; on-call"
            }
        )
    except:
        pass

    print("\n:arrow_right: Next steps:")
    print("  1. Notify on-call engineer")
    print("  2. Create incident channel (if applicable)")
    print("  3. Begin investigation immediately")
```

### Step 4.3: Handle Deferral to Roadmap

```python
if action == 'd':
    print("\n:calendar: DEFERRED TO ROADMAP")
    print("-" * 40)
    print("This item will be considered in the next roadmap planning cycle.")

    # Create as an idea/proposal
    work_item_type = "{{ work_tracking.work_item_types.feature }}"
    result = adapter.create_work_item(
        work_item_type=work_item_type,
        title=f"[Proposal] {suggested_title or title}",
        description=full_description + "\n\n## Status\nDeferred to roadmap planning",
        fields={
            'System.State': 'Proposed',
            'System.Tags': '; '.join(['roadmap-candidate', 'deferred'] + suggested_tags)
        },
        verify=True
    )

    work_item_id = result['id']
    print(f":white_check_mark: Created proposal {work_item_id} for roadmap consideration")
```

---

## Phase 5: Completion

### Step 5.1: Route to Next Workflow

```python
print("\n" + "=" * 80)
print(":white_check_mark: INTAKE COMPLETE")
print("=" * 80)

# Check if this was a duplicate that was handled
if action == 'skip_creation':
    print(f"\n:recycle: Used existing work item #{work_item_id}")
    print(f"   No new work item created (duplicate avoided)")
    print(f"\n:white_check_mark: Workflow completed successfully")
else:
    # Route based on work item type created
    if work_item_type == '{{ work_tracking.work_item_types.epic }}':
        print(f"\n:arrow_right: Epic {work_item_id} created: {suggested_title or title}")
        print(f"   Size: {size} | Urgency: {validated_urgency}")
        print(f"\n:arrow_right: Next step: Run /backlog-grooming to decompose into Features and Tasks")
    elif work_item_type == '{{ work_tracking.work_item_types.feature }}':
        print(f"\n:arrow_right: Feature {work_item_id} created: {suggested_title or title}")
        print(f"   Size: {size} ({technical_assessment.get('story_points', 'N/A')} pts) | Urgency: {validated_urgency}")
        if validated_urgency == 'Critical':
            print(f"\n:fire: CRITICAL Feature - add to sprint immediately")
        else:
            print(f"\n:arrow_right: Ready for /sprint-planning (Feature will be broken into Tasks)")
    elif work_item_type == '{{ work_tracking.work_item_types.task }}':
        print(f"\n:arrow_right: Task {work_item_id} created: {suggested_title or title}")
        print(f"   Size: Small | Urgency: {validated_urgency}")
        if validated_urgency == 'Critical':
            print(f"\n:fire: CRITICAL Task - add to current sprint")
        else:
            print(f"\n:arrow_right: Ready for /sprint-planning")
    elif work_item_type == '{{ work_tracking.work_item_types.bug }}':
        print(f"\n:bug: Bug {work_item_id} created: {suggested_title or title}")
        print(f"   Urgency: {validated_urgency}")
        if validated_urgency == 'Critical':
            print(f"\n:fire: CRITICAL Bug - immediate action required!")
            print("   1. Notify on-call engineer")
            print("   2. Add to current sprint")
            print("   3. Begin investigation")
        else:
            print(f"\n:arrow_right: Added to bug backlog for triage and prioritization")

state.complete_workflow()
profiler.save_report()
```

---

## Batch Intake Mode

For processing multiple items at once:

```python
# Optional: Batch mode for processing multiple items
def batch_intake(items_file):
    """Process multiple intake items from a file."""
    import json

    with open(items_file) as f:
        items = json.load(f)

    results = []
    for item in items:
        # Process each item through triage
        result = process_single_intake(item)
        results.append(result)

    print(f"\n:package: Batch processing complete")
    print(f"   Total items: {len(items)}")
    print(f"   Created: {sum(1 for r in results if r.get('created'))}")
    print(f"   Rejected: {sum(1 for r in results if r.get('rejected'))}")
```

---

## Configuration

**Agents Used:**
{% if 'business-analyst' in agent_config.enabled_agents %}- Business Analyst (triage analysis){% endif %}
{% if 'senior-engineer' in agent_config.enabled_agents %}- Senior Engineer (technical assessment){% endif %}

**Work Item Types Created:**
- Bug: {{ work_tracking.work_item_types.bug }}
- Feature: {{ work_tracking.work_item_types.feature }}
- Task: {{ work_tracking.work_item_types.task }}
- Story: {{ work_tracking.work_item_types.story }}

---

## Success Criteria

- :white_check_mark: Item properly classified and triaged
- :white_check_mark: Urgency validated and appropriate
- :white_check_mark: Size estimated for planning
- :white_check_mark: Duplicates/related work identified
- :white_check_mark: Work item created in {{ work_tracking.platform }}
- :white_check_mark: Routed to appropriate next workflow

---

*Generated by Trustable AI Workbench for {{ project.name }}*

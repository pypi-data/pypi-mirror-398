
# python wrapper for package github.com/linksocks/linksocks/linksocks_go within overall package linksockslib
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy.EXE build -vm=C:\Users\RUNNER~1\AppData\Local\Temp\linksocks_pyvenv_ea5seas9\venv\Scripts\python.exe -output=D:\a\linksocks\linksocks\_bindings\python\linksockslib -name=linksockslib -no-make=true ./linksocks_go

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _linksockslib
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from linksockslib import linksocks
# and then refer to everything using linksocks. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [16]byte
class Array_16_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Array_16_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Array_16_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Array_16_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _linksockslib.Array_16_byte_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Array_16_byte_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _linksockslib.Array_16_byte_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [4]byte
class Array_4_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Array_4_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Array_4_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Array_4_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _linksockslib.Array_4_byte_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Array_4_byte_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _linksockslib.Array_4_byte_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice []*x509.Certificate
class Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_Ptr_x509_Certificate_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Ptr_x509_Certificate(handle=_linksockslib.Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_x509_Certificate(handle=_linksockslib.Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_x509_Certificate(handle=_linksockslib.Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*multipart.FileHeader
class Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_Ptr_multipart_FileHeader_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_multipart_FileHeader.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_Ptr_multipart_FileHeader([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_Ptr_multipart_FileHeader_len(self.handle)
				return Slice_Ptr_multipart_FileHeader(handle=_linksockslib.Slice_Ptr_multipart_FileHeader_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_multipart_FileHeader(handle=_linksockslib.Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_Ptr_multipart_FileHeader_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_multipart_FileHeader.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_multipart_FileHeader(handle=_linksockslib.Slice_Ptr_multipart_FileHeader_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_Ptr_multipart_FileHeader_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*net.IPNet
class Slice_Ptr_net_IPNet(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_Ptr_net_IPNet_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_net_IPNet.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_Ptr_net_IPNet len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_Ptr_net_IPNet([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_Ptr_net_IPNet_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_Ptr_net_IPNet_len(self.handle)
				return Slice_Ptr_net_IPNet(handle=_linksockslib.Slice_Ptr_net_IPNet_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_net_IPNet(handle=_linksockslib.Slice_Ptr_net_IPNet_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_Ptr_net_IPNet_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_net_IPNet.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_net_IPNet(handle=_linksockslib.Slice_Ptr_net_IPNet_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_Ptr_net_IPNet_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*http.Cookie
class Slice_Ptr_http_Cookie(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_Ptr_http_Cookie_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_http_Cookie.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_Ptr_http_Cookie len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_Ptr_http_Cookie([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_Ptr_http_Cookie_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_Ptr_http_Cookie_len(self.handle)
				return Slice_Ptr_http_Cookie(handle=_linksockslib.Slice_Ptr_http_Cookie_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_http_Cookie(handle=_linksockslib.Slice_Ptr_http_Cookie_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_Ptr_http_Cookie_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_http_Cookie.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_http_Cookie(handle=_linksockslib.Slice_Ptr_http_Cookie_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_Ptr_http_Cookie_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*url.URL
class Slice_Ptr_url_URL(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_Ptr_url_URL_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_url_URL.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_Ptr_url_URL len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_Ptr_url_URL([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_Ptr_url_URL_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_Ptr_url_URL_len(self.handle)
				return Slice_Ptr_url_URL(handle=_linksockslib.Slice_Ptr_url_URL_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_url_URL(handle=_linksockslib.Slice_Ptr_url_URL_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_Ptr_url_URL_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_url_URL.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_url_URL(handle=_linksockslib.Slice_Ptr_url_URL_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_Ptr_url_URL_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]*x509.Certificate
class Slice_Slice_Ptr_x509_Certificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_Slice_Ptr_x509_Certificate_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_Ptr_x509_Certificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_Slice_Ptr_x509_Certificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_Slice_Ptr_x509_Certificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_Slice_Ptr_x509_Certificate_len(self.handle)
				return Slice_Slice_Ptr_x509_Certificate(handle=_linksockslib.Slice_Slice_Ptr_x509_Certificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Slice_Ptr_x509_Certificate(handle=_linksockslib.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_Slice_Ptr_x509_Certificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_Ptr_x509_Certificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Slice_Ptr_x509_Certificate(handle=_linksockslib.Slice_Slice_Ptr_x509_Certificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_Slice_Ptr_x509_Certificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice [][]byte
class Slice_Slice_byte(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_Slice_byte_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Slice_byte.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_Slice_byte len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_Slice_byte([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_Slice_byte_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_Slice_byte_len(self.handle)
				return Slice_Slice_byte(handle=_linksockslib.Slice_Slice_byte_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_byte(handle=_linksockslib.Slice_Slice_byte_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_Slice_byte_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Slice_byte.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_byte(handle=_linksockslib.Slice_Slice_byte_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_Slice_byte_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.ExtKeyUsage
class Slice_x509_ExtKeyUsage(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_x509_ExtKeyUsage_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_ExtKeyUsage.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_x509_ExtKeyUsage len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_x509_ExtKeyUsage([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_x509_ExtKeyUsage_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_x509_ExtKeyUsage_len(self.handle)
				return Slice_x509_ExtKeyUsage(handle=_linksockslib.Slice_x509_ExtKeyUsage_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _linksockslib.Slice_x509_ExtKeyUsage_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_x509_ExtKeyUsage_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_ExtKeyUsage.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _linksockslib.Slice_x509_ExtKeyUsage_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_x509_ExtKeyUsage_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.OID
class Slice_x509_OID(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_x509_OID_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_OID.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_x509_OID len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_x509_OID([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_x509_OID_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_x509_OID_len(self.handle)
				return Slice_x509_OID(handle=_linksockslib.Slice_x509_OID_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.x509_OID(handle=_linksockslib.Slice_x509_OID_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_x509_OID_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_OID.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.x509_OID(handle=_linksockslib.Slice_x509_OID_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_x509_OID_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []x509.PolicyMapping
class Slice_x509_PolicyMapping(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_x509_PolicyMapping_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_x509_PolicyMapping.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_x509_PolicyMapping len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_x509_PolicyMapping([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_x509_PolicyMapping_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_x509_PolicyMapping_len(self.handle)
				return Slice_x509_PolicyMapping(handle=_linksockslib.Slice_x509_PolicyMapping_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.x509_PolicyMapping(handle=_linksockslib.Slice_x509_PolicyMapping_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_x509_PolicyMapping_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_x509_PolicyMapping.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.x509_PolicyMapping(handle=_linksockslib.Slice_x509_PolicyMapping_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_x509_PolicyMapping_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.AttributeTypeAndValue
class Slice_pkix_AttributeTypeAndValue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_pkix_AttributeTypeAndValue_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_AttributeTypeAndValue.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_pkix_AttributeTypeAndValue len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_pkix_AttributeTypeAndValue([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_pkix_AttributeTypeAndValue_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_pkix_AttributeTypeAndValue_len(self.handle)
				return Slice_pkix_AttributeTypeAndValue(handle=_linksockslib.Slice_pkix_AttributeTypeAndValue_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_AttributeTypeAndValue(handle=_linksockslib.Slice_pkix_AttributeTypeAndValue_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_pkix_AttributeTypeAndValue_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_AttributeTypeAndValue.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_AttributeTypeAndValue(handle=_linksockslib.Slice_pkix_AttributeTypeAndValue_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_pkix_AttributeTypeAndValue_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.Extension
class Slice_pkix_Extension(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_pkix_Extension_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_Extension.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_pkix_Extension len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_pkix_Extension([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_pkix_Extension_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_pkix_Extension_len(self.handle)
				return Slice_pkix_Extension(handle=_linksockslib.Slice_pkix_Extension_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_Extension(handle=_linksockslib.Slice_pkix_Extension_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_pkix_Extension_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_Extension.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_Extension(handle=_linksockslib.Slice_pkix_Extension_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_pkix_Extension_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []pkix.RevokedCertificate
class Slice_pkix_RevokedCertificate(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_pkix_RevokedCertificate_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_pkix_RevokedCertificate.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_pkix_RevokedCertificate len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_pkix_RevokedCertificate([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_pkix_RevokedCertificate_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_pkix_RevokedCertificate_len(self.handle)
				return Slice_pkix_RevokedCertificate(handle=_linksockslib.Slice_pkix_RevokedCertificate_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.pkix_RevokedCertificate(handle=_linksockslib.Slice_pkix_RevokedCertificate_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_pkix_RevokedCertificate_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_pkix_RevokedCertificate.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.pkix_RevokedCertificate(handle=_linksockslib.Slice_pkix_RevokedCertificate_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_pkix_RevokedCertificate_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []asn1.ObjectIdentifier
class Slice_asn1_ObjectIdentifier(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_asn1_ObjectIdentifier_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_asn1_ObjectIdentifier.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_asn1_ObjectIdentifier len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_asn1_ObjectIdentifier([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_asn1_ObjectIdentifier_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_asn1_ObjectIdentifier_len(self.handle)
				return Slice_asn1_ObjectIdentifier(handle=_linksockslib.Slice_asn1_ObjectIdentifier_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.asn1_ObjectIdentifier(handle=_linksockslib.Slice_asn1_ObjectIdentifier_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_asn1_ObjectIdentifier_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_asn1_ObjectIdentifier.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.asn1_ObjectIdentifier(handle=_linksockslib.Slice_asn1_ObjectIdentifier_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_asn1_ObjectIdentifier_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []fmt.Stringer
class Slice_fmt_Stringer(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_fmt_Stringer_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_fmt_Stringer.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_fmt_Stringer len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_fmt_Stringer([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_fmt_Stringer_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_fmt_Stringer_len(self.handle)
				return Slice_fmt_Stringer(handle=_linksockslib.Slice_fmt_Stringer_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.fmt_Stringer(handle=_linksockslib.Slice_fmt_Stringer_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_fmt_Stringer_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_fmt_Stringer.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.fmt_Stringer(handle=_linksockslib.Slice_fmt_Stringer_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_fmt_Stringer_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []linksocks.LogEntry
class Slice_linksocks_LogEntry(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_linksocks_LogEntry_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_linksocks_LogEntry.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_linksocks_LogEntry len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_linksocks_LogEntry([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_linksocks_LogEntry_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_linksocks_LogEntry_len(self.handle)
				return Slice_linksocks_LogEntry(handle=_linksockslib.Slice_linksocks_LogEntry_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return LogEntry(handle=_linksockslib.Slice_linksocks_LogEntry_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_linksocks_LogEntry_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_linksocks_LogEntry.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = LogEntry(handle=_linksockslib.Slice_linksocks_LogEntry_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_linksocks_LogEntry_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []zerolog.Hook
class Slice_zerolog_Hook(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_zerolog_Hook_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_zerolog_Hook.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_zerolog_Hook len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_zerolog_Hook([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_zerolog_Hook_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_zerolog_Hook_len(self.handle)
				return Slice_zerolog_Hook(handle=_linksockslib.Slice_zerolog_Hook_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.zerolog_Hook(handle=_linksockslib.Slice_zerolog_Hook_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_zerolog_Hook_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_zerolog_Hook.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.zerolog_Hook(handle=_linksockslib.Slice_zerolog_Hook_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_zerolog_Hook_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []interface{}
class Slice_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_interface__CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_interface_.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_interface_([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_interface__len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_interface__len(self.handle)
				return Slice_interface_(handle=_linksockslib.Slice_interface__subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _linksockslib.Slice_interface__elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_interface__set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_interface_.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _linksockslib.Slice_interface__elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_interface__append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []big.Word
class Slice_big_Word(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_big_Word_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_big_Word.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_big_Word len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_big_Word([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_big_Word_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_big_Word_len(self.handle)
				return Slice_big_Word(handle=_linksockslib.Slice_big_Word_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _linksockslib.Slice_big_Word_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_big_Word_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_big_Word.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _linksockslib.Slice_big_Word_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_big_Word_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []net.IP
class Slice_net_IP(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_net_IP_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_net_IP.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_net_IP len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_net_IP([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_net_IP_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_net_IP_len(self.handle)
				return Slice_net_IP(handle=_linksockslib.Slice_net_IP_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.net_IP(handle=_linksockslib.Slice_net_IP_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_net_IP_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_net_IP.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.net_IP(handle=_linksockslib.Slice_net_IP_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_net_IP_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []time.Duration
class Slice_time_Duration(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_time_Duration_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_time_Duration.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_time_Duration len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_time_Duration([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_time_Duration_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_time_Duration_len(self.handle)
				return Slice_time_Duration(handle=_linksockslib.Slice_time_Duration_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _linksockslib.Slice_time_Duration_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_time_Duration_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_time_Duration.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _linksockslib.Slice_time_Duration_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_time_Duration_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []time.Time
class Slice_time_Time(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Slice_time_Time_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_time_Time.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksocks.Slice_time_Time len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'linksocks.Slice_time_Time([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _linksockslib.Slice_time_Time_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _linksockslib.Slice_time_Time_len(self.handle)
				return Slice_time_Time(handle=_linksockslib.Slice_time_Time_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.time_Time(handle=_linksockslib.Slice_time_Time_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_linksockslib.Slice_time_Time_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_time_Time.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.time_Time(handle=_linksockslib.Slice_time_Time_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_linksockslib.Slice_time_Time_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string][]*multipart.FileHeader
class Map_string_Slice_Ptr_multipart_FileHeader(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Map_string_Slice_Ptr_multipart_FileHeader_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_Ptr_multipart_FileHeader.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_linksockslib.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, k, v)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksockslib.Map_string_Slice_Ptr_multipart_FileHeader len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'linksockslib.Map_string_Slice_Ptr_multipart_FileHeader({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _linksockslib.Map_string_Slice_Ptr_multipart_FileHeader_len(self.handle)
	def __getitem__(self, key):
		return Slice_Ptr_multipart_FileHeader(handle=_linksockslib.Map_string_Slice_Ptr_multipart_FileHeader_elem(self.handle, key))
	def __setitem__(self, key, value):
		_linksockslib.Map_string_Slice_Ptr_multipart_FileHeader_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _linksockslib.Map_string_Slice_Ptr_multipart_FileHeader_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_linksockslib.Map_string_Slice_Ptr_multipart_FileHeader_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _linksockslib.Map_string_Slice_Ptr_multipart_FileHeader_contains(self.handle, key)

# Python type for map map[string][]string
class Map_string_Slice_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Map_string_Slice_string_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Slice_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_linksockslib.Map_string_Slice_string_set(self.handle, k, v)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksockslib.Map_string_Slice_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'linksockslib.Map_string_Slice_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _linksockslib.Map_string_Slice_string_len(self.handle)
	def __getitem__(self, key):
		return go.Slice_string(handle=_linksockslib.Map_string_Slice_string_elem(self.handle, key))
	def __setitem__(self, key, value):
		_linksockslib.Map_string_Slice_string_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _linksockslib.Map_string_Slice_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_linksockslib.Map_string_Slice_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _linksockslib.Map_string_Slice_string_contains(self.handle, key)

# Python type for map map[string]bool
class Map_string_bool(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.Map_string_bool_CTor()
			_linksockslib.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_bool.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_linksockslib.Map_string_bool_set(self.handle, k, v)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		s = 'linksockslib.Map_string_bool len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'linksockslib.Map_string_bool({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _linksockslib.Map_string_bool_len(self.handle)
	def __getitem__(self, key):
		return _linksockslib.Map_string_bool_elem(self.handle, key)
	def __setitem__(self, key, value):
		_linksockslib.Map_string_bool_set(self.handle, key, value)
	def __delitem__(self, key):
		return _linksockslib.Map_string_bool_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_linksockslib.Map_string_bool_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _linksockslib.Map_string_bool_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---
from enum import Enum

class Duration(Enum):
	DefaultMinBatchWaitTime = 20000000
	DefaultMaxBatchWaitTime = 500000000
	DefaultConnectTimeout = 10000000000
	SocketCleanupDelay = 30000000000
	DefaultChannelTimeout = 43200000000000

DefaultMinBatchWaitTime = 20000000
DefaultMaxBatchWaitTime = 500000000
DefaultConnectTimeout = 10000000000
SocketCleanupDelay = 30000000000
DefaultChannelTimeout = 43200000000000



#---- Constants from Go: Python can only ask that you please don't change these! ---
BinaryConnectorOperationAdd = 1
BinaryConnectorOperationRemove = 2
BinaryProtocolTCP = 1
BinaryProtocolUDP = 2
BinaryTypeAuth = 1
BinaryTypeAuthResponse = 2
BinaryTypeConnect = 3
BinaryTypeConnectResponse = 5
BinaryTypeConnector = 7
BinaryTypeConnectorResponse = 8
BinaryTypeData = 4
BinaryTypeDisconnect = 6
BinaryTypeLog = 9
BinaryTypePartners = 10
DataCompressionGzip = 1
DataCompressionNone = 0
DefaultBufferSize = 1048576
DefaultCompressionThreshold = 524288
DefaultHighSpeedThreshold = 262144
DefaultLowSpeedThreshold = 131072
LogLevelDebug = "debug"
"""
LogLevel constants for ServerMessage

"""
LogLevelError = "error"
"""
LogLevel constants for ServerMessage

"""
LogLevelInfo = "info"
"""
LogLevel constants for ServerMessage

"""
LogLevelTrace = "trace"
"""
LogLevel constants for ServerMessage

"""
LogLevelWarn = "warn"
"""
LogLevel constants for ServerMessage

"""
MaxRedirects = 5
MaxWebSocketMessageSize = 33554432
ProtocolVersion = 1
TypeAuth = "auth"
TypeAuthResponse = "auth_response"
TypeConnect = "connect"
TypeConnectResponse = "connect_response"
TypeConnector = "connector"
TypeConnectorResponse = "connector_response"
TypeData = "data"
TypeDisconnect = "disconnect"
TypeLog = "log"
TypePartners = "partners"


# ---- Global Variables: can only use functions to access ---
def Hour():
	"""
	Hour Gets Go Variable: linksocks.Hour
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	return _linksockslib.linksocks_Hour()

def Set_Hour(value):
	"""
	Set_Hour Sets Go Variable: linksocks.Hour
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_Hour(value.handle)
	else:
		_linksockslib.linksocks_Set_Hour(value)

def LevelDebug():
	"""
	LevelDebug Gets Go Variable: linksocks.LevelDebug
	Zerolog level constants for Python bindings
	
	"""
	return _linksockslib.linksocks_LevelDebug()

def Set_LevelDebug(value):
	"""
	Set_LevelDebug Sets Go Variable: linksocks.LevelDebug
	Zerolog level constants for Python bindings
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_LevelDebug(value.handle)
	else:
		_linksockslib.linksocks_Set_LevelDebug(value)

def LevelError():
	"""
	LevelError Gets Go Variable: linksocks.LevelError
	Zerolog level constants for Python bindings
	
	"""
	return _linksockslib.linksocks_LevelError()

def Set_LevelError(value):
	"""
	Set_LevelError Sets Go Variable: linksocks.LevelError
	Zerolog level constants for Python bindings
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_LevelError(value.handle)
	else:
		_linksockslib.linksocks_Set_LevelError(value)

def LevelFatal():
	"""
	LevelFatal Gets Go Variable: linksocks.LevelFatal
	Zerolog level constants for Python bindings
	
	"""
	return _linksockslib.linksocks_LevelFatal()

def Set_LevelFatal(value):
	"""
	Set_LevelFatal Sets Go Variable: linksocks.LevelFatal
	Zerolog level constants for Python bindings
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_LevelFatal(value.handle)
	else:
		_linksockslib.linksocks_Set_LevelFatal(value)

def LevelInfo():
	"""
	LevelInfo Gets Go Variable: linksocks.LevelInfo
	Zerolog level constants for Python bindings
	
	"""
	return _linksockslib.linksocks_LevelInfo()

def Set_LevelInfo(value):
	"""
	Set_LevelInfo Sets Go Variable: linksocks.LevelInfo
	Zerolog level constants for Python bindings
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_LevelInfo(value.handle)
	else:
		_linksockslib.linksocks_Set_LevelInfo(value)

def LevelPanic():
	"""
	LevelPanic Gets Go Variable: linksocks.LevelPanic
	Zerolog level constants for Python bindings
	
	"""
	return _linksockslib.linksocks_LevelPanic()

def Set_LevelPanic(value):
	"""
	Set_LevelPanic Sets Go Variable: linksocks.LevelPanic
	Zerolog level constants for Python bindings
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_LevelPanic(value.handle)
	else:
		_linksockslib.linksocks_Set_LevelPanic(value)

def LevelTrace():
	"""
	LevelTrace Gets Go Variable: linksocks.LevelTrace
	Zerolog level constants for Python bindings
	
	"""
	return _linksockslib.linksocks_LevelTrace()

def Set_LevelTrace(value):
	"""
	Set_LevelTrace Sets Go Variable: linksocks.LevelTrace
	Zerolog level constants for Python bindings
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_LevelTrace(value.handle)
	else:
		_linksockslib.linksocks_Set_LevelTrace(value)

def LevelWarn():
	"""
	LevelWarn Gets Go Variable: linksocks.LevelWarn
	Zerolog level constants for Python bindings
	
	"""
	return _linksockslib.linksocks_LevelWarn()

def Set_LevelWarn(value):
	"""
	Set_LevelWarn Sets Go Variable: linksocks.LevelWarn
	Zerolog level constants for Python bindings
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_LevelWarn(value.handle)
	else:
		_linksockslib.linksocks_Set_LevelWarn(value)

def Microsecond():
	"""
	Microsecond Gets Go Variable: linksocks.Microsecond
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	return _linksockslib.linksocks_Microsecond()

def Set_Microsecond(value):
	"""
	Set_Microsecond Sets Go Variable: linksocks.Microsecond
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_Microsecond(value.handle)
	else:
		_linksockslib.linksocks_Set_Microsecond(value)

def Millisecond():
	"""
	Millisecond Gets Go Variable: linksocks.Millisecond
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	return _linksockslib.linksocks_Millisecond()

def Set_Millisecond(value):
	"""
	Set_Millisecond Sets Go Variable: linksocks.Millisecond
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_Millisecond(value.handle)
	else:
		_linksockslib.linksocks_Set_Millisecond(value)

def Minute():
	"""
	Minute Gets Go Variable: linksocks.Minute
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	return _linksockslib.linksocks_Minute()

def Set_Minute(value):
	"""
	Set_Minute Sets Go Variable: linksocks.Minute
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_Minute(value.handle)
	else:
		_linksockslib.linksocks_Set_Minute(value)

def Nanosecond():
	"""
	Nanosecond Gets Go Variable: linksocks.Nanosecond
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	return _linksockslib.linksocks_Nanosecond()

def Set_Nanosecond(value):
	"""
	Set_Nanosecond Sets Go Variable: linksocks.Nanosecond
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_Nanosecond(value.handle)
	else:
		_linksockslib.linksocks_Set_Nanosecond(value)

def Platform():
	"""
	Platform Gets Go Variable: linksocks.Platform
	
	"""
	return _linksockslib.linksocks_Platform()

def Set_Platform(value):
	"""
	Set_Platform Sets Go Variable: linksocks.Platform
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_Platform(value.handle)
	else:
		_linksockslib.linksocks_Set_Platform(value)

def Second():
	"""
	Second Gets Go Variable: linksocks.Second
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	return _linksockslib.linksocks_Second()

def Set_Second(value):
	"""
	Set_Second Sets Go Variable: linksocks.Second
	Time constants for Python bindings
	These provide access to Go's time.Duration constants in Python
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_Second(value.handle)
	else:
		_linksockslib.linksocks_Set_Second(value)

def Version():
	"""
	Version Gets Go Variable: linksocks.Version
	
	"""
	return _linksockslib.linksocks_Version()

def Set_Version(value):
	"""
	Set_Version Sets Go Variable: linksocks.Version
	
	"""
	if isinstance(value, go.GoClass):
		_linksockslib.linksocks_Set_Version(value.handle)
	else:
		_linksockslib.linksocks_Set_Version(value)



# ---- Interfaces ---

# Python type for interface linksocks.BaseMessage
class BaseMessage(go.GoClass):
	"""BaseMessage defines the common interface for all message types\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = 0
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_BaseMessage_GetType(self.handle)


# ---- Structs ---

# Python type for struct linksocks.ConnectMessage
class ConnectMessage(go.GoClass):
	"""ConnectMessage represents a TCP connection request\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ConnectMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Protocol = args[0]
			if "Protocol" in kwargs:
				self.Protocol = kwargs["Protocol"]
			if  1 < len(args):
				self.Address = args[1]
			if "Address" in kwargs:
				self.Address = kwargs["Address"]
			if  2 < len(args):
				self.Port = args[2]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  3 < len(args):
				self.ChannelID = args[3]
			if "ChannelID" in kwargs:
				self.ChannelID = kwargs["ChannelID"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ConnectMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ConnectMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Protocol(self):
		return _linksockslib.linksocks_ConnectMessage_Protocol_Get(self.handle)
	@Protocol.setter
	def Protocol(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectMessage_Protocol_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectMessage_Protocol_Set(self.handle, value)
	@property
	def Address(self):
		return _linksockslib.linksocks_ConnectMessage_Address_Get(self.handle)
	@Address.setter
	def Address(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectMessage_Address_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectMessage_Address_Set(self.handle, value)
	@property
	def Port(self):
		return _linksockslib.linksocks_ConnectMessage_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectMessage_Port_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectMessage_Port_Set(self.handle, value)
	@property
	def ChannelID(self):
		return go.uuid_UUID(handle=_linksockslib.linksocks_ConnectMessage_ChannelID_Get(self.handle))
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_ConnectMessage_GetType(self.handle)

# Python type for struct linksocks.DataMessage
class DataMessage(go.GoClass):
	"""DataMessage represents a data transfer message\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_DataMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Protocol = args[0]
			if "Protocol" in kwargs:
				self.Protocol = kwargs["Protocol"]
			if  1 < len(args):
				self.ChannelID = args[1]
			if "ChannelID" in kwargs:
				self.ChannelID = kwargs["ChannelID"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  3 < len(args):
				self.Compression = args[3]
			if "Compression" in kwargs:
				self.Compression = kwargs["Compression"]
			if  4 < len(args):
				self.Address = args[4]
			if "Address" in kwargs:
				self.Address = kwargs["Address"]
			if  5 < len(args):
				self.Port = args[5]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  6 < len(args):
				self.TargetAddr = args[6]
			if "TargetAddr" in kwargs:
				self.TargetAddr = kwargs["TargetAddr"]
			if  7 < len(args):
				self.TargetPort = args[7]
			if "TargetPort" in kwargs:
				self.TargetPort = kwargs["TargetPort"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.DataMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.DataMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Protocol(self):
		return _linksockslib.linksocks_DataMessage_Protocol_Get(self.handle)
	@Protocol.setter
	def Protocol(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_DataMessage_Protocol_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_DataMessage_Protocol_Set(self.handle, value)
	@property
	def ChannelID(self):
		return go.uuid_UUID(handle=_linksockslib.linksocks_DataMessage_ChannelID_Get(self.handle))
	@property
	def Data(self):
		return go.Slice_byte(handle=_linksockslib.linksocks_DataMessage_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_DataMessage_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Compression(self):
		return _linksockslib.linksocks_DataMessage_Compression_Get(self.handle)
	@Compression.setter
	def Compression(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_DataMessage_Compression_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_DataMessage_Compression_Set(self.handle, value)
	@property
	def Address(self):
		return _linksockslib.linksocks_DataMessage_Address_Get(self.handle)
	@Address.setter
	def Address(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_DataMessage_Address_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_DataMessage_Address_Set(self.handle, value)
	@property
	def Port(self):
		return _linksockslib.linksocks_DataMessage_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_DataMessage_Port_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_DataMessage_Port_Set(self.handle, value)
	@property
	def TargetAddr(self):
		return _linksockslib.linksocks_DataMessage_TargetAddr_Get(self.handle)
	@TargetAddr.setter
	def TargetAddr(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_DataMessage_TargetAddr_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_DataMessage_TargetAddr_Set(self.handle, value)
	@property
	def TargetPort(self):
		return _linksockslib.linksocks_DataMessage_TargetPort_Get(self.handle)
	@TargetPort.setter
	def TargetPort(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_DataMessage_TargetPort_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_DataMessage_TargetPort_Set(self.handle, value)
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_DataMessage_GetType(self.handle)

# Python type for struct linksocks.TokenRequest
class TokenRequest(go.GoClass):
	"""TokenRequest represents a request to create a new token\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_TokenRequest_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  1 < len(args):
				self.Token = args[1]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  2 < len(args):
				self.Port = args[2]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  3 < len(args):
				self.Username = args[3]
			if "Username" in kwargs:
				self.Username = kwargs["Username"]
			if  4 < len(args):
				self.Password = args[4]
			if "Password" in kwargs:
				self.Password = kwargs["Password"]
			if  5 < len(args):
				self.ReverseToken = args[5]
			if "ReverseToken" in kwargs:
				self.ReverseToken = kwargs["ReverseToken"]
			if  6 < len(args):
				self.AllowManageConnector = args[6]
			if "AllowManageConnector" in kwargs:
				self.AllowManageConnector = kwargs["AllowManageConnector"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.TokenRequest{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.TokenRequest ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return _linksockslib.linksocks_TokenRequest_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenRequest_Type_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenRequest_Type_Set(self.handle, value)
	@property
	def Token(self):
		return _linksockslib.linksocks_TokenRequest_Token_Get(self.handle)
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenRequest_Token_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenRequest_Token_Set(self.handle, value)
	@property
	def Port(self):
		return _linksockslib.linksocks_TokenRequest_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenRequest_Port_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenRequest_Port_Set(self.handle, value)
	@property
	def Username(self):
		return _linksockslib.linksocks_TokenRequest_Username_Get(self.handle)
	@Username.setter
	def Username(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenRequest_Username_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenRequest_Username_Set(self.handle, value)
	@property
	def Password(self):
		return _linksockslib.linksocks_TokenRequest_Password_Get(self.handle)
	@Password.setter
	def Password(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenRequest_Password_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenRequest_Password_Set(self.handle, value)
	@property
	def ReverseToken(self):
		return _linksockslib.linksocks_TokenRequest_ReverseToken_Get(self.handle)
	@ReverseToken.setter
	def ReverseToken(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenRequest_ReverseToken_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenRequest_ReverseToken_Set(self.handle, value)
	@property
	def AllowManageConnector(self):
		return _linksockslib.linksocks_TokenRequest_AllowManageConnector_Get(self.handle)
	@AllowManageConnector.setter
	def AllowManageConnector(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenRequest_AllowManageConnector_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenRequest_AllowManageConnector_Set(self.handle, value)

# Python type for struct linksocks.StatusResponse
class StatusResponse(go.GoClass):
	"""StatusResponse represents the server status\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_StatusResponse_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Version = args[0]
			if "Version" in kwargs:
				self.Version = kwargs["Version"]
			if  1 < len(args):
				self.Tokens = args[1]
			if "Tokens" in kwargs:
				self.Tokens = kwargs["Tokens"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.StatusResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.StatusResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Version(self):
		return _linksockslib.linksocks_StatusResponse_Version_Get(self.handle)
	@Version.setter
	def Version(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_StatusResponse_Version_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_StatusResponse_Version_Set(self.handle, value)
	@property
	def Tokens(self):
		return Slice_interface_(handle=_linksockslib.linksocks_StatusResponse_Tokens_Get(self.handle))
	@Tokens.setter
	def Tokens(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_StatusResponse_Tokens_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct linksocks.ConnectorMessage
class ConnectorMessage(go.GoClass):
	"""ConnectorMessage represents a connector management command from reverse client\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ConnectorMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.ChannelID = args[0]
			if "ChannelID" in kwargs:
				self.ChannelID = kwargs["ChannelID"]
			if  1 < len(args):
				self.ConnectorToken = args[1]
			if "ConnectorToken" in kwargs:
				self.ConnectorToken = kwargs["ConnectorToken"]
			if  2 < len(args):
				self.Operation = args[2]
			if "Operation" in kwargs:
				self.Operation = kwargs["Operation"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ConnectorMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ConnectorMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ChannelID(self):
		return go.uuid_UUID(handle=_linksockslib.linksocks_ConnectorMessage_ChannelID_Get(self.handle))
	@property
	def ConnectorToken(self):
		return _linksockslib.linksocks_ConnectorMessage_ConnectorToken_Get(self.handle)
	@ConnectorToken.setter
	def ConnectorToken(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectorMessage_ConnectorToken_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectorMessage_ConnectorToken_Set(self.handle, value)
	@property
	def Operation(self):
		return _linksockslib.linksocks_ConnectorMessage_Operation_Get(self.handle)
	@Operation.setter
	def Operation(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectorMessage_Operation_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectorMessage_Operation_Set(self.handle, value)
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_ConnectorMessage_GetType(self.handle)

# Python type for struct linksocks.DynamicForwarder
class DynamicForwarder(go.GoClass):
	"""DynamicForwarder handles dynamic batching and sending of network data\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_DynamicForwarder_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.DynamicForwarder{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.DynamicForwarder ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ProcessReads(self, conn, goRun=False):
		"""ProcessReads(object conn) 
		
		ProcessReads handles reading from a network connection and forwarding to WebSocket with dynamic batching
		"""
		_linksockslib.linksocks_DynamicForwarder_ProcessReads(self.handle, conn.handle, goRun)
	def ProcessReadsImmediate(self, conn, goRun=False):
		"""ProcessReadsImmediate(object conn) 
		
		processReadsImmediate handles reading directly without batching
		"""
		_linksockslib.linksocks_DynamicForwarder_ProcessReadsImmediate(self.handle, conn.handle, goRun)
	def ProcessUDPReads(self, conn, goRun=False):
		"""ProcessUDPReads(object conn) 
		
		ProcessUDPReads handles reading from a UDP connection with appropriate metadata
		"""
		_linksockslib.linksocks_DynamicForwarder_ProcessUDPReads(self.handle, conn.handle, goRun)

# Python type for struct linksocks.Relay
class Relay(go.GoClass):
	"""Relay handles stream transport between SOCKS5 and WebSocket\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_Relay_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.Relay{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.Relay ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def RefuseSocksRequest(self, conn, reason):
		"""RefuseSocksRequest(object conn, int reason) str
		
		RefuseSocksRequest refuses a SOCKS5 client request with the specified reason
		"""
		return _linksockslib.linksocks_Relay_RefuseSocksRequest(self.handle, conn.handle, reason)
	def HandleNetworkConnection(self, ctx, ws, request):
		"""HandleNetworkConnection(object ctx, object ws, object request) str
		
		HandleNetworkConnection handles network connection based on protocol type
		"""
		return _linksockslib.linksocks_Relay_HandleNetworkConnection(self.handle, ctx.handle, ws.handle, request.handle)
	def HandleTCPConnection(self, ctx, ws, request):
		"""HandleTCPConnection(object ctx, object ws, object request) str
		
		HandleTCPConnection handles TCP network connection
		"""
		return _linksockslib.linksocks_Relay_HandleTCPConnection(self.handle, ctx.handle, ws.handle, request.handle)
	def HandleUDPConnection(self, ctx, ws, request):
		"""HandleUDPConnection(object ctx, object ws, object request) str
		
		HandleUDPConnection handles UDP network connection
		"""
		return _linksockslib.linksocks_Relay_HandleUDPConnection(self.handle, ctx.handle, ws.handle, request.handle)
	def HandleSocksRequest(self, ctx, ws, socksConn, socksUsername, socksPassword):
		"""HandleSocksRequest(object ctx, object ws, object socksConn, str socksUsername, str socksPassword) str
		
		HandleSocksRequest handles incoming SOCKS5 client request
		"""
		return _linksockslib.linksocks_Relay_HandleSocksRequest(self.handle, ctx.handle, ws.handle, socksConn.handle, socksUsername, socksPassword)
	def HandleRemoteTCPForward(self, ctx, ws, remoteConn, channelID):
		"""HandleRemoteTCPForward(object ctx, object ws, object remoteConn, []int channelID) str
		
		HandleRemoteTCPForward handles remote TCP forwarding
		"""
		return _linksockslib.linksocks_Relay_HandleRemoteTCPForward(self.handle, ctx.handle, ws.handle, remoteConn.handle, channelID.handle)
	def HandleRemoteUDPForward(self, ctx, ws, udpConn, channelID):
		"""HandleRemoteUDPForward(object ctx, object ws, object udpConn, []int channelID) str
		
		HandleRemoteUDPForward handles remote UDP forwarding
		"""
		return _linksockslib.linksocks_Relay_HandleRemoteUDPForward(self.handle, ctx.handle, ws.handle, udpConn.handle, channelID.handle)
	def HandleSocksTCPForward(self, ctx, ws, socksConn, channelID):
		"""HandleSocksTCPForward(object ctx, object ws, object socksConn, []int channelID) str
		
		HandleSocksTCPForward handles TCP forwarding between SOCKS client and WebSocket
		"""
		return _linksockslib.linksocks_Relay_HandleSocksTCPForward(self.handle, ctx.handle, ws.handle, socksConn.handle, channelID.handle)
	def HandleSocksUDPForward(self, ctx, ws, udpConn, socksConn, channelID):
		"""HandleSocksUDPForward(object ctx, object ws, object udpConn, object socksConn, []int channelID) str
		
		HandleSocksUDPForward handles SOCKS5 UDP forwarding
		"""
		return _linksockslib.linksocks_Relay_HandleSocksUDPForward(self.handle, ctx.handle, ws.handle, udpConn.handle, socksConn.handle, channelID.handle)
	def Close(self, goRun=False):
		"""Close() 
		
		Close gracefully shuts down the Relay
		"""
		_linksockslib.linksocks_Relay_Close(self.handle, goRun)
	def SetConnectionSuccess(self, channelID, goRun=False):
		"""SetConnectionSuccess([]int channelID) 
		
		SetConnectionSuccess sets the connection success status for a channel
		"""
		_linksockslib.linksocks_Relay_SetConnectionSuccess(self.handle, channelID.handle, goRun)

# Python type for struct linksocks.RelayOption
class RelayOption(go.GoClass):
	"""RelayOption contains configuration options for Relay\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_RelayOption_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.BufferSize = args[0]
			if "BufferSize" in kwargs:
				self.BufferSize = kwargs["BufferSize"]
			if  1 < len(args):
				self.ChannelTimeout = args[1]
			if "ChannelTimeout" in kwargs:
				self.ChannelTimeout = kwargs["ChannelTimeout"]
			if  2 < len(args):
				self.ConnectTimeout = args[2]
			if "ConnectTimeout" in kwargs:
				self.ConnectTimeout = kwargs["ConnectTimeout"]
			if  3 < len(args):
				self.FastOpen = args[3]
			if "FastOpen" in kwargs:
				self.FastOpen = kwargs["FastOpen"]
			if  4 < len(args):
				self.UpstreamProxy = args[4]
			if "UpstreamProxy" in kwargs:
				self.UpstreamProxy = kwargs["UpstreamProxy"]
			if  5 < len(args):
				self.UpstreamUsername = args[5]
			if "UpstreamUsername" in kwargs:
				self.UpstreamUsername = kwargs["UpstreamUsername"]
			if  6 < len(args):
				self.UpstreamPassword = args[6]
			if "UpstreamPassword" in kwargs:
				self.UpstreamPassword = kwargs["UpstreamPassword"]
			if  7 < len(args):
				self.EnableDynamicBatching = args[7]
			if "EnableDynamicBatching" in kwargs:
				self.EnableDynamicBatching = kwargs["EnableDynamicBatching"]
			if  8 < len(args):
				self.MaxBatchWaitTime = args[8]
			if "MaxBatchWaitTime" in kwargs:
				self.MaxBatchWaitTime = kwargs["MaxBatchWaitTime"]
			if  9 < len(args):
				self.MinBatchWaitTime = args[9]
			if "MinBatchWaitTime" in kwargs:
				self.MinBatchWaitTime = kwargs["MinBatchWaitTime"]
			if  10 < len(args):
				self.HighSpeedThreshold = args[10]
			if "HighSpeedThreshold" in kwargs:
				self.HighSpeedThreshold = kwargs["HighSpeedThreshold"]
			if  11 < len(args):
				self.LowSpeedThreshold = args[11]
			if "LowSpeedThreshold" in kwargs:
				self.LowSpeedThreshold = kwargs["LowSpeedThreshold"]
			if  12 < len(args):
				self.CompressionThreshold = args[12]
			if "CompressionThreshold" in kwargs:
				self.CompressionThreshold = kwargs["CompressionThreshold"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.RelayOption{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.RelayOption ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def BufferSize(self):
		"""BufferSize controls the size of reusable buffers
		Larger values may improve performance but increase memory usage
		"""
		return _linksockslib.linksocks_RelayOption_BufferSize_Get(self.handle)
	@BufferSize.setter
	def BufferSize(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_BufferSize_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_BufferSize_Set(self.handle, value)
	@property
	def ChannelTimeout(self):
		return _linksockslib.linksocks_RelayOption_ChannelTimeout_Get(self.handle)
	@ChannelTimeout.setter
	def ChannelTimeout(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_ChannelTimeout_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_ChannelTimeout_Set(self.handle, value)
	@property
	def ConnectTimeout(self):
		return _linksockslib.linksocks_RelayOption_ConnectTimeout_Get(self.handle)
	@ConnectTimeout.setter
	def ConnectTimeout(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_ConnectTimeout_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_ConnectTimeout_Set(self.handle, value)
	@property
	def FastOpen(self):
		"""FastOpen controls whether to wait for connect success response
		When false, assumes connection success immediately
		"""
		return _linksockslib.linksocks_RelayOption_FastOpen_Get(self.handle)
	@FastOpen.setter
	def FastOpen(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_FastOpen_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_FastOpen_Set(self.handle, value)
	@property
	def UpstreamProxy(self):
		"""Upstream SOCKS5 proxy configuration
		"""
		return _linksockslib.linksocks_RelayOption_UpstreamProxy_Get(self.handle)
	@UpstreamProxy.setter
	def UpstreamProxy(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_UpstreamProxy_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_UpstreamProxy_Set(self.handle, value)
	@property
	def UpstreamUsername(self):
		return _linksockslib.linksocks_RelayOption_UpstreamUsername_Get(self.handle)
	@UpstreamUsername.setter
	def UpstreamUsername(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_UpstreamUsername_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_UpstreamUsername_Set(self.handle, value)
	@property
	def UpstreamPassword(self):
		return _linksockslib.linksocks_RelayOption_UpstreamPassword_Get(self.handle)
	@UpstreamPassword.setter
	def UpstreamPassword(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_UpstreamPassword_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_UpstreamPassword_Set(self.handle, value)
	@property
	def EnableDynamicBatching(self):
		"""Adaptive batching configuration
		"""
		return _linksockslib.linksocks_RelayOption_EnableDynamicBatching_Get(self.handle)
	@EnableDynamicBatching.setter
	def EnableDynamicBatching(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_EnableDynamicBatching_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_EnableDynamicBatching_Set(self.handle, value)
	@property
	def MaxBatchWaitTime(self):
		return _linksockslib.linksocks_RelayOption_MaxBatchWaitTime_Get(self.handle)
	@MaxBatchWaitTime.setter
	def MaxBatchWaitTime(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_MaxBatchWaitTime_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_MaxBatchWaitTime_Set(self.handle, value)
	@property
	def MinBatchWaitTime(self):
		return _linksockslib.linksocks_RelayOption_MinBatchWaitTime_Get(self.handle)
	@MinBatchWaitTime.setter
	def MinBatchWaitTime(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_MinBatchWaitTime_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_MinBatchWaitTime_Set(self.handle, value)
	@property
	def HighSpeedThreshold(self):
		"""HighSpeedThreshold defines the bytes/sec rate above which batch delay increases
		"""
		return _linksockslib.linksocks_RelayOption_HighSpeedThreshold_Get(self.handle)
	@HighSpeedThreshold.setter
	def HighSpeedThreshold(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_HighSpeedThreshold_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_HighSpeedThreshold_Set(self.handle, value)
	@property
	def LowSpeedThreshold(self):
		"""LowSpeedThreshold defines the bytes/sec rate below which batch delay resets to zero
		"""
		return _linksockslib.linksocks_RelayOption_LowSpeedThreshold_Get(self.handle)
	@LowSpeedThreshold.setter
	def LowSpeedThreshold(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_LowSpeedThreshold_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_LowSpeedThreshold_Set(self.handle, value)
	@property
	def CompressionThreshold(self):
		"""CompressionThreshold defines the data size in bytes above which compression is applied
		"""
		return _linksockslib.linksocks_RelayOption_CompressionThreshold_Get(self.handle)
	@CompressionThreshold.setter
	def CompressionThreshold(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_RelayOption_CompressionThreshold_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_RelayOption_CompressionThreshold_Set(self.handle, value)
	def WithBufferSize(self, size):
		"""WithBufferSize(int size) object
		
		WithBufferSize sets the buffer size for the relay
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithBufferSize(self.handle, size))
	def WithChannelTimeout(self, timeout):
		"""WithChannelTimeout(long timeout) object
		
		WithChannelTimeout sets the channel timeout for the relay
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithChannelTimeout(self.handle, timeout))
	def WithConnectTimeout(self, timeout):
		"""WithConnectTimeout(long timeout) object
		
		WithConnectTimeout sets the connect timeout for the relay
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithConnectTimeout(self.handle, timeout))
	def WithFastOpen(self, fastOpen):
		"""WithFastOpen(bool fastOpen) object
		
		WithFastOpen sets the fast open mode for the relay
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithFastOpen(self.handle, fastOpen))
	def WithUpstreamProxy(self, proxy):
		"""WithUpstreamProxy(str proxy) object
		
		WithUpstreamProxy sets the upstream SOCKS5 proxy
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithUpstreamProxy(self.handle, proxy))
	def WithUpstreamAuth(self, username, password):
		"""WithUpstreamAuth(str username, str password) object
		
		WithUpstreamAuth sets the upstream SOCKS5 proxy authentication
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithUpstreamAuth(self.handle, username, password))
	def WithDynamicBatching(self, enabled):
		"""WithDynamicBatching(bool enabled) object
		
		WithDynamicBatching enables or disables adaptive batching for SOCKS TCP
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithDynamicBatching(self.handle, enabled))
	def WithBatchingTimeLimits(self, min, max):
		"""WithBatchingTimeLimits(long min, long max) object
		
		WithBatchingTimeLimits sets the min/max wait times for SOCKS TCP batching
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithBatchingTimeLimits(self.handle, min, max))
	def WithHighSpeedThreshold(self, threshold):
		"""WithHighSpeedThreshold(float threshold) object
		
		WithHighSpeedThreshold sets the threshold for increasing batch delay
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithHighSpeedThreshold(self.handle, threshold))
	def WithLowSpeedThreshold(self, threshold):
		"""WithLowSpeedThreshold(float threshold) object
		
		WithLowSpeedThreshold sets the threshold for reverting to immediate send
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithLowSpeedThreshold(self.handle, threshold))
	def WithCompressionThreshold(self, threshold):
		"""WithCompressionThreshold(int threshold) object
		
		WithCompressionThreshold sets the threshold for enabling data compression
		"""
		return RelayOption(handle=_linksockslib.linksocks_RelayOption_WithCompressionThreshold(self.handle, threshold))

# Python type for struct linksocks.ServerOption
class ServerOption(go.GoClass):
	"""ServerOption represents configuration options for LinkSocksServer\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ServerOption_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.WSHost = args[0]
			if "WSHost" in kwargs:
				self.WSHost = kwargs["WSHost"]
			if  1 < len(args):
				self.WSPort = args[1]
			if "WSPort" in kwargs:
				self.WSPort = kwargs["WSPort"]
			if  2 < len(args):
				self.SocksHost = args[2]
			if "SocksHost" in kwargs:
				self.SocksHost = kwargs["SocksHost"]
			if  3 < len(args):
				self.PortPool = args[3]
			if "PortPool" in kwargs:
				self.PortPool = kwargs["PortPool"]
			if  4 < len(args):
				self.SocksWaitClient = args[4]
			if "SocksWaitClient" in kwargs:
				self.SocksWaitClient = kwargs["SocksWaitClient"]
			if  5 < len(args):
				self.Logger = args[5]
			if "Logger" in kwargs:
				self.Logger = kwargs["Logger"]
			if  6 < len(args):
				self.BufferSize = args[6]
			if "BufferSize" in kwargs:
				self.BufferSize = kwargs["BufferSize"]
			if  7 < len(args):
				self.APIKey = args[7]
			if "APIKey" in kwargs:
				self.APIKey = kwargs["APIKey"]
			if  8 < len(args):
				self.ChannelTimeout = args[8]
			if "ChannelTimeout" in kwargs:
				self.ChannelTimeout = kwargs["ChannelTimeout"]
			if  9 < len(args):
				self.ConnectTimeout = args[9]
			if "ConnectTimeout" in kwargs:
				self.ConnectTimeout = kwargs["ConnectTimeout"]
			if  10 < len(args):
				self.FastOpen = args[10]
			if "FastOpen" in kwargs:
				self.FastOpen = kwargs["FastOpen"]
			if  11 < len(args):
				self.UpstreamProxy = args[11]
			if "UpstreamProxy" in kwargs:
				self.UpstreamProxy = kwargs["UpstreamProxy"]
			if  12 < len(args):
				self.UpstreamUsername = args[12]
			if "UpstreamUsername" in kwargs:
				self.UpstreamUsername = kwargs["UpstreamUsername"]
			if  13 < len(args):
				self.UpstreamPassword = args[13]
			if "UpstreamPassword" in kwargs:
				self.UpstreamPassword = kwargs["UpstreamPassword"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ServerOption{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ServerOption ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def WSHost(self):
		return _linksockslib.linksocks_ServerOption_WSHost_Get(self.handle)
	@WSHost.setter
	def WSHost(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_WSHost_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_WSHost_Set(self.handle, value)
	@property
	def WSPort(self):
		return _linksockslib.linksocks_ServerOption_WSPort_Get(self.handle)
	@WSPort.setter
	def WSPort(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_WSPort_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_WSPort_Set(self.handle, value)
	@property
	def SocksHost(self):
		return _linksockslib.linksocks_ServerOption_SocksHost_Get(self.handle)
	@SocksHost.setter
	def SocksHost(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_SocksHost_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_SocksHost_Set(self.handle, value)
	@property
	def PortPool(self):
		return PortPool(handle=_linksockslib.linksocks_ServerOption_PortPool_Get(self.handle))
	@PortPool.setter
	def PortPool(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_PortPool_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SocksWaitClient(self):
		return _linksockslib.linksocks_ServerOption_SocksWaitClient_Get(self.handle)
	@SocksWaitClient.setter
	def SocksWaitClient(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_SocksWaitClient_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_SocksWaitClient_Set(self.handle, value)
	@property
	def Logger(self):
		return go.zerolog_Logger(handle=_linksockslib.linksocks_ServerOption_Logger_Get(self.handle))
	@Logger.setter
	def Logger(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_Logger_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def BufferSize(self):
		return _linksockslib.linksocks_ServerOption_BufferSize_Get(self.handle)
	@BufferSize.setter
	def BufferSize(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_BufferSize_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_BufferSize_Set(self.handle, value)
	@property
	def APIKey(self):
		return _linksockslib.linksocks_ServerOption_APIKey_Get(self.handle)
	@APIKey.setter
	def APIKey(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_APIKey_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_APIKey_Set(self.handle, value)
	@property
	def ChannelTimeout(self):
		return _linksockslib.linksocks_ServerOption_ChannelTimeout_Get(self.handle)
	@ChannelTimeout.setter
	def ChannelTimeout(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_ChannelTimeout_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_ChannelTimeout_Set(self.handle, value)
	@property
	def ConnectTimeout(self):
		return _linksockslib.linksocks_ServerOption_ConnectTimeout_Get(self.handle)
	@ConnectTimeout.setter
	def ConnectTimeout(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_ConnectTimeout_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_ConnectTimeout_Set(self.handle, value)
	@property
	def FastOpen(self):
		return _linksockslib.linksocks_ServerOption_FastOpen_Get(self.handle)
	@FastOpen.setter
	def FastOpen(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_FastOpen_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_FastOpen_Set(self.handle, value)
	@property
	def UpstreamProxy(self):
		return _linksockslib.linksocks_ServerOption_UpstreamProxy_Get(self.handle)
	@UpstreamProxy.setter
	def UpstreamProxy(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_UpstreamProxy_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_UpstreamProxy_Set(self.handle, value)
	@property
	def UpstreamUsername(self):
		return _linksockslib.linksocks_ServerOption_UpstreamUsername_Get(self.handle)
	@UpstreamUsername.setter
	def UpstreamUsername(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_UpstreamUsername_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_UpstreamUsername_Set(self.handle, value)
	@property
	def UpstreamPassword(self):
		return _linksockslib.linksocks_ServerOption_UpstreamPassword_Get(self.handle)
	@UpstreamPassword.setter
	def UpstreamPassword(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ServerOption_UpstreamPassword_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ServerOption_UpstreamPassword_Set(self.handle, value)
	def WithWSHost(self, host):
		"""WithWSHost(str host) object
		
		WithWSHost sets the WebSocket host
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithWSHost(self.handle, host))
	def WithWSPort(self, port):
		"""WithWSPort(int port) object
		
		WithWSPort sets the WebSocket port
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithWSPort(self.handle, port))
	def WithSocksHost(self, host):
		"""WithSocksHost(str host) object
		
		WithSocksHost sets the SOCKS host
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithSocksHost(self.handle, host))
	def WithPortPool(self, pool):
		"""WithPortPool(object pool) object
		
		WithPortPool sets the port pool
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithPortPool(self.handle, pool.handle))
	def WithSocksWaitClient(self, wait):
		"""WithSocksWaitClient(bool wait) object
		
		WithSocksWaitClient sets whether to wait for client before starting SOCKS server
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithSocksWaitClient(self.handle, wait))
	def WithLogger(self, logger):
		"""WithLogger(object logger) object
		
		WithLogger sets the logger
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithLogger(self.handle, logger.handle))
	def WithBufferSize(self, size):
		"""WithBufferSize(int size) object
		
		WithBufferSize sets the buffer size for data transfer
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithBufferSize(self.handle, size))
	def WithAPI(self, apiKey):
		"""WithAPI(str apiKey) object
		
		WithAPI sets apiKey to enable the HTTP API
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithAPI(self.handle, apiKey))
	def WithChannelTimeout(self, timeout):
		"""WithChannelTimeout(long timeout) object
		
		WithChannelTimeout sets the channel timeout duration
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithChannelTimeout(self.handle, timeout))
	def WithConnectTimeout(self, timeout):
		"""WithConnectTimeout(long timeout) object
		
		WithConnectTimeout sets the connect timeout duration
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithConnectTimeout(self.handle, timeout))
	def WithFastOpen(self, fastOpen):
		"""WithFastOpen(bool fastOpen) object
		
		WithFastOpen controls whether to wait for connect success response
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithFastOpen(self.handle, fastOpen))
	def WithUpstreamProxy(self, proxy):
		"""WithUpstreamProxy(str proxy) object
		
		WithUpstreamProxy sets the upstream SOCKS5 proxy
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithUpstreamProxy(self.handle, proxy))
	def WithUpstreamAuth(self, username, password):
		"""WithUpstreamAuth(str username, str password) object
		
		WithUpstreamAuth sets the upstream SOCKS5 proxy authentication
		"""
		return ServerOption(handle=_linksockslib.linksocks_ServerOption_WithUpstreamAuth(self.handle, username, password))

# Python type for struct linksocks.AuthResponseMessage
class AuthResponseMessage(go.GoClass):
	"""AuthResponseMessage represents an authentication response\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_AuthResponseMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Success = args[0]
			if "Success" in kwargs:
				self.Success = kwargs["Success"]
			if  1 < len(args):
				self.Error = args[1]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.AuthResponseMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.AuthResponseMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Success(self):
		return _linksockslib.linksocks_AuthResponseMessage_Success_Get(self.handle)
	@Success.setter
	def Success(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_AuthResponseMessage_Success_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_AuthResponseMessage_Success_Set(self.handle, value)
	@property
	def Error(self):
		return _linksockslib.linksocks_AuthResponseMessage_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_AuthResponseMessage_Error_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_AuthResponseMessage_Error_Set(self.handle, value)
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_AuthResponseMessage_GetType(self.handle)

# Python type for struct linksocks.TokenResponse
class TokenResponse(go.GoClass):
	"""TokenResponse represents the response for token operations\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_TokenResponse_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Success = args[0]
			if "Success" in kwargs:
				self.Success = kwargs["Success"]
			if  1 < len(args):
				self.Token = args[1]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  2 < len(args):
				self.Port = args[2]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  3 < len(args):
				self.Error = args[3]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.TokenResponse{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.TokenResponse ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Success(self):
		return _linksockslib.linksocks_TokenResponse_Success_Get(self.handle)
	@Success.setter
	def Success(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenResponse_Success_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenResponse_Success_Set(self.handle, value)
	@property
	def Token(self):
		return _linksockslib.linksocks_TokenResponse_Token_Get(self.handle)
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenResponse_Token_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenResponse_Token_Set(self.handle, value)
	@property
	def Port(self):
		return _linksockslib.linksocks_TokenResponse_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenResponse_Port_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenResponse_Port_Set(self.handle, value)
	@property
	def Error(self):
		return _linksockslib.linksocks_TokenResponse_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenResponse_Error_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenResponse_Error_Set(self.handle, value)

# Python type for struct linksocks.APIHandler
class APIHandler(go.GoClass):
	"""APIHandler handles HTTP API requests for LinkSocksServer\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_APIHandler_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.APIHandler{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.APIHandler ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def RegisterHandlers(self, mux, goRun=False):
		"""RegisterHandlers(object mux) 
		
		RegisterHandlers registers API endpoints with the provided mux
		"""
		_linksockslib.linksocks_APIHandler_RegisterHandlers(self.handle, mux.handle, goRun)

# Python type for struct linksocks.AuthMessage
class AuthMessage(go.GoClass):
	"""AuthMessage represents an authentication request\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_AuthMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Token = args[0]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  1 < len(args):
				self.Reverse = args[1]
			if "Reverse" in kwargs:
				self.Reverse = kwargs["Reverse"]
			if  2 < len(args):
				self.Instance = args[2]
			if "Instance" in kwargs:
				self.Instance = kwargs["Instance"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.AuthMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.AuthMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Token(self):
		return _linksockslib.linksocks_AuthMessage_Token_Get(self.handle)
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_AuthMessage_Token_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_AuthMessage_Token_Set(self.handle, value)
	@property
	def Reverse(self):
		return _linksockslib.linksocks_AuthMessage_Reverse_Get(self.handle)
	@Reverse.setter
	def Reverse(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_AuthMessage_Reverse_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_AuthMessage_Reverse_Set(self.handle, value)
	@property
	def Instance(self):
		return go.uuid_UUID(handle=_linksockslib.linksocks_AuthMessage_Instance_Get(self.handle))
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_AuthMessage_GetType(self.handle)

# Python type for struct linksocks.CLI
class CLI(go.GoClass):
	"""CLI represents the command-line interface for LinkSocks\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_CLI_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.CLI{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.CLI ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Execute(self):
		"""Execute() str
		
		Execute runs the CLI application
		"""
		return _linksockslib.linksocks_CLI_Execute(self.handle)

# Python type for struct linksocks.ContextWithCancel
class ContextWithCancel(go.GoClass):
	"""ContextWithCancel wraps context and cancel function for Python bindings\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ContextWithCancel_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ContextWithCancel{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ContextWithCancel ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Cancel(self, goRun=False):
		"""Cancel() 
		
		Cancel calls the cancel function to cancel the context
		"""
		_linksockslib.linksocks_ContextWithCancel_Cancel(self.handle, goRun)
	def Context(self):
		"""Context() object
		
		Context returns the underlying context.Context
		"""
		return go.context_Context(handle=_linksockslib.linksocks_ContextWithCancel_Context(self.handle))

# Python type for struct linksocks.DisconnectMessage
class DisconnectMessage(go.GoClass):
	"""DisconnectMessage represents a connection termination message\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_DisconnectMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.ChannelID = args[0]
			if "ChannelID" in kwargs:
				self.ChannelID = kwargs["ChannelID"]
			if  1 < len(args):
				self.Error = args[1]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.DisconnectMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.DisconnectMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ChannelID(self):
		return go.uuid_UUID(handle=_linksockslib.linksocks_DisconnectMessage_ChannelID_Get(self.handle))
	@property
	def Error(self):
		return _linksockslib.linksocks_DisconnectMessage_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_DisconnectMessage_Error_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_DisconnectMessage_Error_Set(self.handle, value)
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_DisconnectMessage_GetType(self.handle)

# Python type for struct linksocks.LogEntry
class LogEntry(go.GoClass):
	"""LogEntry represents a single log entry with metadata\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_LogEntry_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.LoggerID = args[0]
			if "LoggerID" in kwargs:
				self.LoggerID = kwargs["LoggerID"]
			if  1 < len(args):
				self.Message = args[1]
			if "Message" in kwargs:
				self.Message = kwargs["Message"]
			if  2 < len(args):
				self.Time = args[2]
			if "Time" in kwargs:
				self.Time = kwargs["Time"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.LogEntry{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.LogEntry ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def LoggerID(self):
		return _linksockslib.linksocks_LogEntry_LoggerID_Get(self.handle)
	@LoggerID.setter
	def LoggerID(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_LogEntry_LoggerID_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_LogEntry_LoggerID_Set(self.handle, value)
	@property
	def Message(self):
		return _linksockslib.linksocks_LogEntry_Message_Get(self.handle)
	@Message.setter
	def Message(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_LogEntry_Message_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_LogEntry_Message_Set(self.handle, value)
	@property
	def Time(self):
		return _linksockslib.linksocks_LogEntry_Time_Get(self.handle)
	@Time.setter
	def Time(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_LogEntry_Time_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_LogEntry_Time_Set(self.handle, value)

# Python type for struct linksocks.ReverseTokenResult
class ReverseTokenResult(go.GoClass):
	"""ReverseTokenResult represents the result of adding a reverse token\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ReverseTokenResult_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Token = args[0]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  1 < len(args):
				self.Port = args[1]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ReverseTokenResult{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ReverseTokenResult ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Token(self):
		return _linksockslib.linksocks_ReverseTokenResult_Token_Get(self.handle)
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenResult_Token_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ReverseTokenResult_Token_Set(self.handle, value)
	@property
	def Port(self):
		return _linksockslib.linksocks_ReverseTokenResult_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenResult_Port_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ReverseTokenResult_Port_Set(self.handle, value)

# Python type for struct linksocks.ConnectResponseMessage
class ConnectResponseMessage(go.GoClass):
	"""ConnectResponseMessage represents a connection response\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ConnectResponseMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Success = args[0]
			if "Success" in kwargs:
				self.Success = kwargs["Success"]
			if  1 < len(args):
				self.Error = args[1]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
			if  2 < len(args):
				self.ChannelID = args[2]
			if "ChannelID" in kwargs:
				self.ChannelID = kwargs["ChannelID"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ConnectResponseMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ConnectResponseMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Success(self):
		return _linksockslib.linksocks_ConnectResponseMessage_Success_Get(self.handle)
	@Success.setter
	def Success(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectResponseMessage_Success_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectResponseMessage_Success_Set(self.handle, value)
	@property
	def Error(self):
		return _linksockslib.linksocks_ConnectResponseMessage_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectResponseMessage_Error_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectResponseMessage_Error_Set(self.handle, value)
	@property
	def ChannelID(self):
		return go.uuid_UUID(handle=_linksockslib.linksocks_ConnectResponseMessage_ChannelID_Get(self.handle))
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_ConnectResponseMessage_GetType(self.handle)

# Python type for struct linksocks.ConnectorResponseMessage
class ConnectorResponseMessage(go.GoClass):
	"""ConnectorResponseMessage represents a connector management response\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ConnectorResponseMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Success = args[0]
			if "Success" in kwargs:
				self.Success = kwargs["Success"]
			if  1 < len(args):
				self.Error = args[1]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
			if  2 < len(args):
				self.ChannelID = args[2]
			if "ChannelID" in kwargs:
				self.ChannelID = kwargs["ChannelID"]
			if  3 < len(args):
				self.ConnectorToken = args[3]
			if "ConnectorToken" in kwargs:
				self.ConnectorToken = kwargs["ConnectorToken"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ConnectorResponseMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ConnectorResponseMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Success(self):
		return _linksockslib.linksocks_ConnectorResponseMessage_Success_Get(self.handle)
	@Success.setter
	def Success(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectorResponseMessage_Success_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectorResponseMessage_Success_Set(self.handle, value)
	@property
	def Error(self):
		return _linksockslib.linksocks_ConnectorResponseMessage_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectorResponseMessage_Error_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectorResponseMessage_Error_Set(self.handle, value)
	@property
	def ChannelID(self):
		return go.uuid_UUID(handle=_linksockslib.linksocks_ConnectorResponseMessage_ChannelID_Get(self.handle))
	@property
	def ConnectorToken(self):
		return _linksockslib.linksocks_ConnectorResponseMessage_ConnectorToken_Get(self.handle)
	@ConnectorToken.setter
	def ConnectorToken(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ConnectorResponseMessage_ConnectorToken_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ConnectorResponseMessage_ConnectorToken_Set(self.handle, value)
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_ConnectorResponseMessage_GetType(self.handle)

# Python type for struct linksocks.LinkSocksServer
class LinkSocksServer(go.GoClass):
	"""LinkSocksServer represents a SOCKS5 over WebSocket protocol server\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_LinkSocksServer_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.LinkSocksServer{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.LinkSocksServer ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def AddReverseToken(self, opts):
		"""AddReverseToken(object opts) object, str
		
		AddReverseToken adds a new token for reverse socks and assigns a port
		"""
		return ReverseTokenResult(handle=_linksockslib.linksocks_LinkSocksServer_AddReverseToken(self.handle, opts.handle))
	def AddForwardToken(self, token):
		"""AddForwardToken(str token) str, str
		
		AddForwardToken adds a new token for forward socks proxy
		"""
		return _linksockslib.linksocks_LinkSocksServer_AddForwardToken(self.handle, token)
	def AddConnectorToken(self, connectorToken, reverseToken):
		"""AddConnectorToken(str connectorToken, str reverseToken) str, str
		
		AddConnectorToken adds a new connector token that forwards requests to a reverse token
		"""
		return _linksockslib.linksocks_LinkSocksServer_AddConnectorToken(self.handle, connectorToken, reverseToken)
	def RemoveToken(self, token):
		"""RemoveToken(str token) bool
		
		RemoveToken removes a token and disconnects all its clients
		"""
		return _linksockslib.linksocks_LinkSocksServer_RemoveToken(self.handle, token)
	def Serve(self, ctx):
		"""Serve(object ctx) str
		
		Serve starts the WebSocket server and waits for clients
		"""
		return _linksockslib.linksocks_LinkSocksServer_Serve(self.handle, ctx.handle)
	def WaitReady(self, ctx, timeout):
		"""WaitReady(object ctx, long timeout) str
		
		WaitReady starts the server and waits for the server to be ready with optional timeout
		"""
		return _linksockslib.linksocks_LinkSocksServer_WaitReady(self.handle, ctx.handle, timeout)
	def Close(self, goRun=False):
		"""Close() 
		
		Close gracefully shuts down the LinkSocksServer
		"""
		_linksockslib.linksocks_LinkSocksServer_Close(self.handle, goRun)
	def GetClientCount(self):
		"""GetClientCount() int
		
		GetClientCount returns the total number of connected clients
		"""
		return _linksockslib.linksocks_LinkSocksServer_GetClientCount(self.handle)
	def HasClients(self):
		"""HasClients() bool
		
		HasClients returns true if there are any connected clients
		"""
		return _linksockslib.linksocks_LinkSocksServer_HasClients(self.handle)
	def GetTokenClientCount(self, token):
		"""GetTokenClientCount(str token) int
		
		GetTokenClientCount counts clients connected for a given token
		"""
		return _linksockslib.linksocks_LinkSocksServer_GetTokenClientCount(self.handle, token)

# Python type for struct linksocks.LogMessage
class LogMessage(go.GoClass):
	"""LogMessage represents a log message from server to client\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_LogMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Level = args[0]
			if "Level" in kwargs:
				self.Level = kwargs["Level"]
			if  1 < len(args):
				self.Msg = args[1]
			if "Msg" in kwargs:
				self.Msg = kwargs["Msg"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.LogMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.LogMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Level(self):
		return _linksockslib.linksocks_LogMessage_Level_Get(self.handle)
	@Level.setter
	def Level(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_LogMessage_Level_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_LogMessage_Level_Set(self.handle, value)
	@property
	def Msg(self):
		return _linksockslib.linksocks_LogMessage_Msg_Get(self.handle)
	@Msg.setter
	def Msg(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_LogMessage_Msg_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_LogMessage_Msg_Set(self.handle, value)
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_LogMessage_GetType(self.handle)

# Python type for struct linksocks.PortPool
class PortPool(go.GoClass):
	"""PortPool is a thread-safe port pool for managing available network ports\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_PortPool_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.PortPool{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.PortPool ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Get(self, requestedPort):
		"""Get(int requestedPort) int
		
		Get retrieves an available port from the pool
		If a specific port is requested, it will try to allocate that port
		"""
		return _linksockslib.linksocks_PortPool_Get(self.handle, requestedPort)
	def Put(self, port, goRun=False):
		"""Put(int port) 
		
		Put returns a port back to the pool
		"""
		_linksockslib.linksocks_PortPool_Put(self.handle, port, goRun)

# Python type for struct linksocks.TokenStatus
class TokenStatus(go.GoClass):
	"""TokenStatus represents the status of a token\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_TokenStatus_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Token = args[0]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  2 < len(args):
				self.ClientsCount = args[2]
			if "ClientsCount" in kwargs:
				self.ClientsCount = kwargs["ClientsCount"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.TokenStatus{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.TokenStatus ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Token(self):
		return _linksockslib.linksocks_TokenStatus_Token_Get(self.handle)
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenStatus_Token_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenStatus_Token_Set(self.handle, value)
	@property
	def Type(self):
		return _linksockslib.linksocks_TokenStatus_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenStatus_Type_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenStatus_Type_Set(self.handle, value)
	@property
	def ClientsCount(self):
		return _linksockslib.linksocks_TokenStatus_ClientsCount_Get(self.handle)
	@ClientsCount.setter
	def ClientsCount(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_TokenStatus_ClientsCount_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_TokenStatus_ClientsCount_Set(self.handle, value)

# Python type for struct linksocks.ReverseTokenStatus
class ReverseTokenStatus(TokenStatus):
	"""ReverseTokenStatus represents the status of a reverse token\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ReverseTokenStatus_CTor()
			_linksockslib.IncRef(self.handle)
			if  1 < len(args):
				self.Port = args[1]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  2 < len(args):
				self.ConnectorTokens = args[2]
			if "ConnectorTokens" in kwargs:
				self.ConnectorTokens = kwargs["ConnectorTokens"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ReverseTokenStatus{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ReverseTokenStatus ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Port(self):
		return _linksockslib.linksocks_ReverseTokenStatus_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenStatus_Port_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ReverseTokenStatus_Port_Set(self.handle, value)
	@property
	def ConnectorTokens(self):
		return go.Slice_string(handle=_linksockslib.linksocks_ReverseTokenStatus_ConnectorTokens_Get(self.handle))
	@ConnectorTokens.setter
	def ConnectorTokens(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenStatus_ConnectorTokens_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct linksocks.LinkSocksClient
class LinkSocksClient(go.GoClass):
	"""LinkSocksClient represents a SOCKS5 over WebSocket protocol client\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_LinkSocksClient_CTor()
			_linksockslib.IncRef(self.handle)
			if  2 < len(args):
				self.IsConnected = args[2]
			if "IsConnected" in kwargs:
				self.IsConnected = kwargs["IsConnected"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.LinkSocksClient{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.LinkSocksClient ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def IsConnected(self):
		return _linksockslib.linksocks_LinkSocksClient_IsConnected_Get(self.handle)
	@IsConnected.setter
	def IsConnected(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_LinkSocksClient_IsConnected_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_LinkSocksClient_IsConnected_Set(self.handle, value)
	def WaitReady(self, ctx, timeout):
		"""WaitReady(object ctx, long timeout) str
		
		WaitReady start the client and waits for the client to be ready with optional timeout
		"""
		return _linksockslib.linksocks_LinkSocksClient_WaitReady(self.handle, ctx.handle, timeout)
	def Connect(self, ctx):
		"""Connect(object ctx) str
		
		Connect starts the client operation
		"""
		return _linksockslib.linksocks_LinkSocksClient_Connect(self.handle, ctx.handle)
	def Close(self, goRun=False):
		"""Close() 
		
		Close gracefully shuts down the LinkSocksClient
		"""
		_linksockslib.linksocks_LinkSocksClient_Close(self.handle, goRun)
	def AddConnector(self, connectorToken):
		"""AddConnector(str connectorToken) str, str
		
		AddConnector sends a request to add a new connector token and waits for response.
		This function is only available in reverse proxy mode.
		"""
		return _linksockslib.linksocks_LinkSocksClient_AddConnector(self.handle, connectorToken)
	def RemoveConnector(self, connectorToken):
		"""RemoveConnector(str connectorToken) str
		
		RemoveConnector sends a request to remove a connector token and waits for response.
		This function is only available in reverse proxy mode.
		"""
		return _linksockslib.linksocks_LinkSocksClient_RemoveConnector(self.handle, connectorToken)
	def GetPartnersCount(self):
		"""GetPartnersCount() int
		
		GetPartnersCount returns the current number of partners
		"""
		return _linksockslib.linksocks_LinkSocksClient_GetPartnersCount(self.handle)

# Python type for struct linksocks.ClientOption
class ClientOption(go.GoClass):
	"""ClientOption represents configuration options for LinkSocksClient\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ClientOption_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.WSURL = args[0]
			if "WSURL" in kwargs:
				self.WSURL = kwargs["WSURL"]
			if  1 < len(args):
				self.Reverse = args[1]
			if "Reverse" in kwargs:
				self.Reverse = kwargs["Reverse"]
			if  2 < len(args):
				self.SocksHost = args[2]
			if "SocksHost" in kwargs:
				self.SocksHost = kwargs["SocksHost"]
			if  3 < len(args):
				self.SocksPort = args[3]
			if "SocksPort" in kwargs:
				self.SocksPort = kwargs["SocksPort"]
			if  4 < len(args):
				self.SocksUsername = args[4]
			if "SocksUsername" in kwargs:
				self.SocksUsername = kwargs["SocksUsername"]
			if  5 < len(args):
				self.SocksPassword = args[5]
			if "SocksPassword" in kwargs:
				self.SocksPassword = kwargs["SocksPassword"]
			if  6 < len(args):
				self.SocksWaitServer = args[6]
			if "SocksWaitServer" in kwargs:
				self.SocksWaitServer = kwargs["SocksWaitServer"]
			if  7 < len(args):
				self.Reconnect = args[7]
			if "Reconnect" in kwargs:
				self.Reconnect = kwargs["Reconnect"]
			if  8 < len(args):
				self.ReconnectDelay = args[8]
			if "ReconnectDelay" in kwargs:
				self.ReconnectDelay = kwargs["ReconnectDelay"]
			if  9 < len(args):
				self.Logger = args[9]
			if "Logger" in kwargs:
				self.Logger = kwargs["Logger"]
			if  10 < len(args):
				self.BufferSize = args[10]
			if "BufferSize" in kwargs:
				self.BufferSize = kwargs["BufferSize"]
			if  11 < len(args):
				self.ChannelTimeout = args[11]
			if "ChannelTimeout" in kwargs:
				self.ChannelTimeout = kwargs["ChannelTimeout"]
			if  12 < len(args):
				self.ConnectTimeout = args[12]
			if "ConnectTimeout" in kwargs:
				self.ConnectTimeout = kwargs["ConnectTimeout"]
			if  13 < len(args):
				self.Threads = args[13]
			if "Threads" in kwargs:
				self.Threads = kwargs["Threads"]
			if  14 < len(args):
				self.FastOpen = args[14]
			if "FastOpen" in kwargs:
				self.FastOpen = kwargs["FastOpen"]
			if  15 < len(args):
				self.UpstreamProxy = args[15]
			if "UpstreamProxy" in kwargs:
				self.UpstreamProxy = kwargs["UpstreamProxy"]
			if  16 < len(args):
				self.UpstreamUsername = args[16]
			if "UpstreamUsername" in kwargs:
				self.UpstreamUsername = kwargs["UpstreamUsername"]
			if  17 < len(args):
				self.UpstreamPassword = args[17]
			if "UpstreamPassword" in kwargs:
				self.UpstreamPassword = kwargs["UpstreamPassword"]
			if  18 < len(args):
				self.NoEnvProxy = args[18]
			if "NoEnvProxy" in kwargs:
				self.NoEnvProxy = kwargs["NoEnvProxy"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ClientOption{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ClientOption ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def WSURL(self):
		return _linksockslib.linksocks_ClientOption_WSURL_Get(self.handle)
	@WSURL.setter
	def WSURL(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_WSURL_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_WSURL_Set(self.handle, value)
	@property
	def Reverse(self):
		return _linksockslib.linksocks_ClientOption_Reverse_Get(self.handle)
	@Reverse.setter
	def Reverse(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_Reverse_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_Reverse_Set(self.handle, value)
	@property
	def SocksHost(self):
		return _linksockslib.linksocks_ClientOption_SocksHost_Get(self.handle)
	@SocksHost.setter
	def SocksHost(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_SocksHost_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_SocksHost_Set(self.handle, value)
	@property
	def SocksPort(self):
		return _linksockslib.linksocks_ClientOption_SocksPort_Get(self.handle)
	@SocksPort.setter
	def SocksPort(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_SocksPort_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_SocksPort_Set(self.handle, value)
	@property
	def SocksUsername(self):
		return _linksockslib.linksocks_ClientOption_SocksUsername_Get(self.handle)
	@SocksUsername.setter
	def SocksUsername(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_SocksUsername_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_SocksUsername_Set(self.handle, value)
	@property
	def SocksPassword(self):
		return _linksockslib.linksocks_ClientOption_SocksPassword_Get(self.handle)
	@SocksPassword.setter
	def SocksPassword(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_SocksPassword_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_SocksPassword_Set(self.handle, value)
	@property
	def SocksWaitServer(self):
		return _linksockslib.linksocks_ClientOption_SocksWaitServer_Get(self.handle)
	@SocksWaitServer.setter
	def SocksWaitServer(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_SocksWaitServer_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_SocksWaitServer_Set(self.handle, value)
	@property
	def Reconnect(self):
		return _linksockslib.linksocks_ClientOption_Reconnect_Get(self.handle)
	@Reconnect.setter
	def Reconnect(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_Reconnect_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_Reconnect_Set(self.handle, value)
	@property
	def ReconnectDelay(self):
		return _linksockslib.linksocks_ClientOption_ReconnectDelay_Get(self.handle)
	@ReconnectDelay.setter
	def ReconnectDelay(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_ReconnectDelay_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_ReconnectDelay_Set(self.handle, value)
	@property
	def Logger(self):
		return go.zerolog_Logger(handle=_linksockslib.linksocks_ClientOption_Logger_Get(self.handle))
	@Logger.setter
	def Logger(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_Logger_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def BufferSize(self):
		return _linksockslib.linksocks_ClientOption_BufferSize_Get(self.handle)
	@BufferSize.setter
	def BufferSize(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_BufferSize_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_BufferSize_Set(self.handle, value)
	@property
	def ChannelTimeout(self):
		return _linksockslib.linksocks_ClientOption_ChannelTimeout_Get(self.handle)
	@ChannelTimeout.setter
	def ChannelTimeout(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_ChannelTimeout_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_ChannelTimeout_Set(self.handle, value)
	@property
	def ConnectTimeout(self):
		return _linksockslib.linksocks_ClientOption_ConnectTimeout_Get(self.handle)
	@ConnectTimeout.setter
	def ConnectTimeout(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_ConnectTimeout_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_ConnectTimeout_Set(self.handle, value)
	@property
	def Threads(self):
		return _linksockslib.linksocks_ClientOption_Threads_Get(self.handle)
	@Threads.setter
	def Threads(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_Threads_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_Threads_Set(self.handle, value)
	@property
	def FastOpen(self):
		return _linksockslib.linksocks_ClientOption_FastOpen_Get(self.handle)
	@FastOpen.setter
	def FastOpen(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_FastOpen_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_FastOpen_Set(self.handle, value)
	@property
	def UpstreamProxy(self):
		return _linksockslib.linksocks_ClientOption_UpstreamProxy_Get(self.handle)
	@UpstreamProxy.setter
	def UpstreamProxy(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_UpstreamProxy_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_UpstreamProxy_Set(self.handle, value)
	@property
	def UpstreamUsername(self):
		return _linksockslib.linksocks_ClientOption_UpstreamUsername_Get(self.handle)
	@UpstreamUsername.setter
	def UpstreamUsername(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_UpstreamUsername_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_UpstreamUsername_Set(self.handle, value)
	@property
	def UpstreamPassword(self):
		return _linksockslib.linksocks_ClientOption_UpstreamPassword_Get(self.handle)
	@UpstreamPassword.setter
	def UpstreamPassword(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_UpstreamPassword_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_UpstreamPassword_Set(self.handle, value)
	@property
	def NoEnvProxy(self):
		return _linksockslib.linksocks_ClientOption_NoEnvProxy_Get(self.handle)
	@NoEnvProxy.setter
	def NoEnvProxy(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ClientOption_NoEnvProxy_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ClientOption_NoEnvProxy_Set(self.handle, value)
	def WithWSURL(self, url):
		"""WithWSURL(str url) object
		
		WithWSURL sets the WebSocket server URL
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithWSURL(self.handle, url))
	def WithReverse(self, reverse):
		"""WithReverse(bool reverse) object
		
		WithReverse sets the reverse proxy mode
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithReverse(self.handle, reverse))
	def WithSocksHost(self, host):
		"""WithSocksHost(str host) object
		
		WithSocksHost sets the SOCKS5 server host
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithSocksHost(self.handle, host))
	def WithSocksPort(self, port):
		"""WithSocksPort(int port) object
		
		WithSocksPort sets the SOCKS5 server port
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithSocksPort(self.handle, port))
	def WithSocksUsername(self, username):
		"""WithSocksUsername(str username) object
		
		WithSocksUsername sets the SOCKS5 authentication username
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithSocksUsername(self.handle, username))
	def WithSocksPassword(self, password):
		"""WithSocksPassword(str password) object
		
		WithSocksPassword sets the SOCKS5 authentication password
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithSocksPassword(self.handle, password))
	def WithSocksWaitServer(self, wait):
		"""WithSocksWaitServer(bool wait) object
		
		WithSocksWaitServer sets whether to wait for server connection before starting SOCKS server
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithSocksWaitServer(self.handle, wait))
	def WithReconnect(self, reconnect):
		"""WithReconnect(bool reconnect) object
		
		WithReconnect sets the reconnect behavior
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithReconnect(self.handle, reconnect))
	def WithReconnectDelay(self, delay):
		"""WithReconnectDelay(long delay) object
		
		WithReconnectDelay sets the reconnect delay duration
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithReconnectDelay(self.handle, delay))
	def WithLogger(self, logger):
		"""WithLogger(object logger) object
		
		WithLogger sets the logger instance
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithLogger(self.handle, logger.handle))
	def WithBufferSize(self, size):
		"""WithBufferSize(int size) object
		
		WithBufferSize sets the buffer size for data transfer
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithBufferSize(self.handle, size))
	def WithChannelTimeout(self, timeout):
		"""WithChannelTimeout(long timeout) object
		
		WithChannelTimeout sets the channel timeout duration
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithChannelTimeout(self.handle, timeout))
	def WithConnectTimeout(self, timeout):
		"""WithConnectTimeout(long timeout) object
		
		WithConnectTimeout sets the connect timeout duration
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithConnectTimeout(self.handle, timeout))
	def WithThreads(self, threads):
		"""WithThreads(int threads) object
		
		WithThreads sets the number of concurrent WebSocket connections
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithThreads(self.handle, threads))
	def WithFastOpen(self, fastOpen):
		"""WithFastOpen(bool fastOpen) object
		
		WithFastOpen controls whether to wait for connect success response
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithFastOpen(self.handle, fastOpen))
	def WithUpstreamProxy(self, proxy):
		"""WithUpstreamProxy(str proxy) object
		
		WithUpstreamProxy sets the upstream SOCKS5 proxy
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithUpstreamProxy(self.handle, proxy))
	def WithUpstreamAuth(self, username, password):
		"""WithUpstreamAuth(str username, str password) object
		
		WithUpstreamAuth sets the upstream SOCKS5 proxy authentication
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithUpstreamAuth(self.handle, username, password))
	def WithNoEnvProxy(self, noEnvProxy):
		"""WithNoEnvProxy(bool noEnvProxy) object
		
		WithNoEnvProxy sets whether to ignore environment proxy settings
		"""
		return ClientOption(handle=_linksockslib.linksocks_ClientOption_WithNoEnvProxy(self.handle, noEnvProxy))

# Python type for struct linksocks.PartnersMessage
class PartnersMessage(go.GoClass):
	"""PartnersMessage represents a partners count update message\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_PartnersMessage_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Count = args[0]
			if "Count" in kwargs:
				self.Count = kwargs["Count"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.PartnersMessage{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.PartnersMessage ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Count(self):
		return _linksockslib.linksocks_PartnersMessage_Count_Get(self.handle)
	@Count.setter
	def Count(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_PartnersMessage_Count_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_PartnersMessage_Count_Set(self.handle, value)
	def GetType(self):
		"""GetType() str"""
		return _linksockslib.linksocks_PartnersMessage_GetType(self.handle)

# Python type for struct linksocks.ReverseTokenOptions
class ReverseTokenOptions(go.GoClass):
	"""ReverseTokenOptions represents configuration options for reverse token\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_ReverseTokenOptions_CTor()
			_linksockslib.IncRef(self.handle)
			if  0 < len(args):
				self.Token = args[0]
			if "Token" in kwargs:
				self.Token = kwargs["Token"]
			if  1 < len(args):
				self.Port = args[1]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  2 < len(args):
				self.Username = args[2]
			if "Username" in kwargs:
				self.Username = kwargs["Username"]
			if  3 < len(args):
				self.Password = args[3]
			if "Password" in kwargs:
				self.Password = kwargs["Password"]
			if  4 < len(args):
				self.AllowManageConnector = args[4]
			if "AllowManageConnector" in kwargs:
				self.AllowManageConnector = kwargs["AllowManageConnector"]
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ReverseTokenOptions{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.ReverseTokenOptions ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Token(self):
		return _linksockslib.linksocks_ReverseTokenOptions_Token_Get(self.handle)
	@Token.setter
	def Token(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenOptions_Token_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ReverseTokenOptions_Token_Set(self.handle, value)
	@property
	def Port(self):
		return _linksockslib.linksocks_ReverseTokenOptions_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenOptions_Port_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ReverseTokenOptions_Port_Set(self.handle, value)
	@property
	def Username(self):
		return _linksockslib.linksocks_ReverseTokenOptions_Username_Get(self.handle)
	@Username.setter
	def Username(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenOptions_Username_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ReverseTokenOptions_Username_Set(self.handle, value)
	@property
	def Password(self):
		return _linksockslib.linksocks_ReverseTokenOptions_Password_Get(self.handle)
	@Password.setter
	def Password(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenOptions_Password_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ReverseTokenOptions_Password_Set(self.handle, value)
	@property
	def AllowManageConnector(self):
		return _linksockslib.linksocks_ReverseTokenOptions_AllowManageConnector_Get(self.handle)
	@AllowManageConnector.setter
	def AllowManageConnector(self, value):
		if isinstance(value, go.GoClass):
			_linksockslib.linksocks_ReverseTokenOptions_AllowManageConnector_Set(self.handle, value.handle)
		else:
			_linksockslib.linksocks_ReverseTokenOptions_AllowManageConnector_Set(self.handle, value)

# Python type for struct linksocks.WSConn
class WSConn(go.GoClass):
	"""WSConn wraps a websocket.Conn with mutex protection\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_WSConn_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.WSConn{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.WSConn ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Label(self):
		"""Label() str"""
		return _linksockslib.linksocks_WSConn_Label(self.handle)
	def GetClientIP(self):
		"""GetClientIP() str
		
		GetClientIP returns the client IP address
		"""
		return _linksockslib.linksocks_WSConn_GetClientIP(self.handle)
	def SetClientIPFromRequest(self, r, goRun=False):
		"""SetClientIPFromRequest(object r) 
		
		SetClientIPFromRequest extracts and sets the client IP from HTTP request
		"""
		_linksockslib.linksocks_WSConn_SetClientIPFromRequest(self.handle, r.handle, goRun)
	def SyncWriteBinary(self, data):
		"""SyncWriteBinary([]int data) str
		
		SyncWriteBinary performs thread-safe binary writes to the websocket connection
		"""
		return _linksockslib.linksocks_WSConn_SyncWriteBinary(self.handle, data.handle)
	def ReadMessage(self):
		"""ReadMessage() object, str
		
		ReadMessage reads a BaseMessage from the websocket connection
		"""
		return BaseMessage(handle=_linksockslib.linksocks_WSConn_ReadMessage(self.handle))
	def WriteMessage(self, msg):
		"""WriteMessage(object msg) str
		
		WriteMessage writes a BaseMessage to the websocket connection
		"""
		return _linksockslib.linksocks_WSConn_WriteMessage(self.handle, msg.handle)
	def SyncWriteControl(self, messageType, data, deadline):
		"""SyncWriteControl(int messageType, []int data, object deadline) str
		
		SyncWriteControl performs thread-safe control message writes and tracks ping time
		"""
		return _linksockslib.linksocks_WSConn_SyncWriteControl(self.handle, messageType, data.handle, deadline.handle)
	def Close(self):
		"""Close() str
		
		Close closes the underlying websocket connection
		"""
		return _linksockslib.linksocks_WSConn_Close(self.handle)

# Python type for struct linksocks.SocketManager
class SocketManager(go.GoClass):
	"""SocketManager manages socket lifecycle and reuse\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_linksockslib.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_linksockslib.IncRef(self.handle)
		else:
			self.handle = _linksockslib.linksocks_SocketManager_CTor()
			_linksockslib.IncRef(self.handle)
	def __del__(self):
		_linksockslib.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.SocketManager{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'linksocks.SocketManager ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def GetListener(self, port):
		"""GetListener(int port) object, str"""
		return go.net_Listener(handle=_linksockslib.linksocks_SocketManager_GetListener(self.handle, port))
	def ReleaseListener(self, port, goRun=False):
		"""ReleaseListener(int port) """
		_linksockslib.linksocks_SocketManager_ReleaseListener(self.handle, port, goRun)
	def Close(self, goRun=False):
		"""Close() 
		
		Close closes all managed sockets immediately
		"""
		_linksockslib.linksocks_SocketManager_Close(self.handle, goRun)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewRelay(logger, option):
	"""NewRelay(object logger, object option) object
	
	NewRelay creates a new Relay instance
	"""
	return Relay(handle=_linksockslib.linksocks_NewRelay(logger.handle, option.handle))
def NewDefaultRelayOption():
	"""NewDefaultRelayOption() object
	
	NewDefaultRelayOption creates a RelayOption with default values
	"""
	return RelayOption(handle=_linksockslib.linksocks_NewDefaultRelayOption())
def DefaultServerOption():
	"""DefaultServerOption() object
	
	DefaultServerOption returns default server options
	"""
	return ServerOption(handle=_linksockslib.linksocks_DefaultServerOption())
def NewAPIHandler(server, apiKey):
	"""NewAPIHandler(object server, str apiKey) object
	
	NewAPIHandler creates a new API handler for the given server
	"""
	return APIHandler(handle=_linksockslib.linksocks_NewAPIHandler(server.handle, apiKey))
def NewCLI():
	"""NewCLI() object
	
	NewCLI creates a new CLI instance
	"""
	return CLI(handle=_linksockslib.linksocks_NewCLI())
def NewContextWithCancel():
	"""NewContextWithCancel() object
	
	NewContextWithCancel creates a new context from the global context
	"""
	return ContextWithCancel(handle=_linksockslib.linksocks_NewContextWithCancel())
def NewLinkSocksServer(opt):
	"""NewLinkSocksServer(object opt) object
	
	NewLinkSocksServer creates a new LinkSocksServer instance
	"""
	return LinkSocksServer(handle=_linksockslib.linksocks_NewLinkSocksServer(opt.handle))
def NewPortPoolFromRange(start, end):
	"""NewPortPoolFromRange(int start, int end) object
	
	NewPortPoolFromRange creates a new port pool from a range of ports
	"""
	return PortPool(handle=_linksockslib.linksocks_NewPortPoolFromRange(start, end))
def NewPortPool(ports):
	"""NewPortPool([]int ports) object
	
	NewPortPool creates a new port pool from a slice of ports
	"""
	return PortPool(handle=_linksockslib.linksocks_NewPortPool(ports.handle))
def NewLinkSocksClient(token, opt):
	"""NewLinkSocksClient(str token, object opt) object
	
	NewLinkSocksClient creates a new LinkSocksClient instance
	"""
	return LinkSocksClient(handle=_linksockslib.linksocks_NewLinkSocksClient(token, opt.handle))
def DefaultClientOption():
	"""DefaultClientOption() object
	
	DefaultClientOption returns default client options
	"""
	return ClientOption(handle=_linksockslib.linksocks_DefaultClientOption())
def DefaultReverseTokenOptions():
	"""DefaultReverseTokenOptions() object
	
	DefaultReverseTokenOptions returns default options for reverse token
	"""
	return ReverseTokenOptions(handle=_linksockslib.linksocks_DefaultReverseTokenOptions())
def NewWSConn(conn, label, logger):
	"""NewWSConn(object conn, str label, object logger) object
	
	NewWSConn creates a new mutex-protected websocket connection
	"""
	return WSConn(handle=_linksockslib.linksocks_NewWSConn(conn.handle, label, logger.handle))
def NewSocketManager(host, log):
	"""NewSocketManager(str host, object log) object"""
	return SocketManager(handle=_linksockslib.linksocks_NewSocketManager(host, log.handle))


# ---- Functions ---
def NewContext():
	"""NewContext() object
	
	NewContext creates a new context from the global context
	"""
	return go.context_Context(handle=_linksockslib.linksocks_NewContext())
def NewLogger(cb):
	"""NewLogger(callable cb) object
	
	NewLogger creates a new zerolog.Logger with auto-generated ID
	"""
	return go.zerolog_Logger(handle=_linksockslib.linksocks_NewLogger(cb))
def NewLoggerWithID(id):
	"""NewLoggerWithID(str id) object
	
	NewLoggerWithID creates a new zerolog.Logger that tags output with the given ID
	"""
	return go.zerolog_Logger(handle=_linksockslib.linksocks_NewLoggerWithID(id))
def PackMessage(msg):
	"""PackMessage(object msg) []int, str
	
	PackMessage converts a message to binary format
	"""
	return go.Slice_byte(handle=_linksockslib.linksocks_PackMessage(msg.handle))
def NewLoggerWithLevel(level, cb):
	"""NewLoggerWithLevel(int level, callable cb) object
	
	NewLoggerWithLevel creates a new zerolog.Logger with auto-generated ID and specified level
	"""
	return go.zerolog_Logger(handle=_linksockslib.linksocks_NewLoggerWithLevel(level, cb))
def SetLoggerGlobalLevel(level, goRun=False):
	"""SetLoggerGlobalLevel(int level) 
	
	SetLoggerGlobalLevel sets the global log level for all loggers
	"""
	_linksockslib.linksocks_SetLoggerGlobalLevel(level, goRun)
def CancelLogWaiters(goRun=False):
	"""CancelLogWaiters() 
	
	CancelLogWaiters cancels all waiting log listeners
	"""
	_linksockslib.linksocks_CancelLogWaiters(goRun)
def ParseMessage(data):
	"""ParseMessage([]int data) object, str"""
	return BaseMessage(handle=_linksockslib.linksocks_ParseMessage(data.handle))
def Background():
	"""Background() object
	
	Background returns a global context
	"""
	return go.context_Context(handle=_linksockslib.linksocks_Background())
def CancelGlobalContext(goRun=False):
	"""CancelGlobalContext() 
	
	CancelGlobalContext cancels the global context
	"""
	_linksockslib.linksocks_CancelGlobalContext(goRun)
def GetLogEntries():
	"""GetLogEntries() []object"""
	return Slice_linksocks_LogEntry(handle=_linksockslib.linksocks_GetLogEntries())
def NewLoggerWithIDAndLevel(id, level):
	"""NewLoggerWithIDAndLevel(str id, int level) object
	
	NewLoggerWithIDAndLevel creates a new zerolog.Logger with specified level that tags output with the given ID
	"""
	return go.zerolog_Logger(handle=_linksockslib.linksocks_NewLoggerWithIDAndLevel(id, level))
def WaitForLogEntries(timeoutMs):
	"""WaitForLogEntries(long timeoutMs) []object"""
	return Slice_linksocks_LogEntry(handle=_linksockslib.linksocks_WaitForLogEntries(timeoutMs))
def DebugLog(logger, msg, goRun=False):
	"""DebugLog(object logger, str msg) 
	
	DebugLog logs a debug message
	"""
	_linksockslib.linksocks_DebugLog(logger.handle, msg, goRun)
def ParseDuration(s):
	"""ParseDuration(str s) long, str
	
	ParseDuration parses a duration string.
	A duration string is a possibly signed sequence of decimal numbers,
	each with optional fraction and a unit suffix, such as "300ms", "-1.5h" or "2h45m".
	Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h".
	"""
	return _linksockslib.linksocks_ParseDuration(s)



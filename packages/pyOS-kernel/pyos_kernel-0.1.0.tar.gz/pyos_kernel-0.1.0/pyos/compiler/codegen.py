"""
pyOS Code Generator - Generates Assembly from Python
"""

from typing import TYPE_CHECKING, List, Dict, Any
from ..drivers.screen import Screen
from ..drivers.keyboard import Keyboard
from ..memory.manager import Memory
from ..memory.gdt import GDT

if TYPE_CHECKING:
    from ..kernel import Kernel


class CodeGenerator:
    """
    Generates x86/x86_64 Assembly code from Python kernel code.
    """
    
    def __init__(self, kernel: 'Kernel'):
        self.kernel = kernel
        self.arch = kernel.config.arch.value
        self.asm_lines: List[str] = []
        self.string_counter = 0
        self.label_counter = 0
        self._strings_to_emit = []
        self._func_operations = {}  # Operations per function
    
    def generate(self) -> str:
        """Generate complete Assembly code."""
        self.asm_lines = []
        self.string_counter = 0
        self._strings_to_emit = []
        self._func_operations = {}
        
        # Execute each boot function separately and capture its operations
        for boot_func in self.kernel._boot_functions:
            Screen._reset()
            boot_func.func()
            ops = Screen._get_operations().copy()
            self._func_operations[boot_func.name] = ops
            
            # Collect strings from this function
            for op in ops:
                if op["type"] == "print" and "text" in op:
                    label = f"str_{self.string_counter}"
                    self.string_counter += 1
                    text = op["text"]
                    self._strings_to_emit.append((label, text))
                    op["_string_label"] = label
        
        # Header
        self._emit_header()
        
        # Text section
        self._emit_text_section()
        
        return '\n'.join(self.asm_lines)
    
    def _emit(self, line: str) -> None:
        """Emit a line of assembly."""
        self.asm_lines.append(line)
    
    def _emit_header(self) -> None:
        """Emit assembly header."""
        self._emit("; pyOS Generated Kernel")
        self._emit(f"; Architecture: {self.arch}")
        self._emit("; Generated by pyOS Compiler")
        self._emit("")
        
        if self.arch == "x86":
            self._emit("[BITS 32]")
        else:
            self._emit("[BITS 64]")
        
        self._emit("[ORG 0x1000]")
        self._emit("")
    
    def _emit_text_section(self) -> None:
        """Emit text section with code."""
        self._emit("; ==================")
        self._emit("; Kernel Entry Point")
        self._emit("; ==================")
        self._emit("")
        self._emit("_start:")
        self._emit("    mov esp, 0x90000")
        
        # Call boot functions in correct order (sorted by priority, lower first)
        sorted_funcs = sorted(self.kernel._boot_functions, key=lambda x: x.priority)
        
        self._emit("")
        self._emit("    ; Call boot functions")
        for boot_func in sorted_funcs:
            self._emit(f"    call {boot_func.name}")
        
        # Main loop
        self._emit("")
        self._emit("    ; Main loop - halt CPU")
        self._emit(".main_loop:")
        self._emit("    hlt")
        self._emit("    jmp .main_loop")
        
        # Generate boot functions
        self._emit("")
        self._generate_boot_functions()
        
        # Generate helper functions
        self._emit("")
        self._generate_screen_functions()
        self._generate_keyboard_functions()
    
    def _generate_boot_functions(self) -> None:
        """Generate code for boot functions."""
        for boot_func in self.kernel._boot_functions:
            self._emit(f"; Function: {boot_func.name}")
            self._emit(f"{boot_func.name}:")
            self._emit("    push ebp")
            self._emit("    mov ebp, esp")
            
            # Get operations for THIS function only
            ops = self._func_operations.get(boot_func.name, [])
            
            # Generate code for screen operations
            for op in ops:
                if op["type"] == "clear":
                    self._emit("    call screen_clear")
                elif op["type"] == "print":
                    label = op.get("_string_label", "str_0")
                    row = op.get("row", 0)
                    col = op.get("col", 0)
                    fg = op.get("foreground", 15)
                    bg = op.get("background", 0)
                    color = (bg << 4) | fg
                    self._emit(f"    push dword {color}")
                    self._emit(f"    push dword {col}")
                    self._emit(f"    push dword {row}")
                    self._emit(f"    push dword {label}")
                    self._emit("    call screen_print")
                    self._emit("    add esp, 16")
            
            self._emit("    pop ebp")
            self._emit("    ret")
            self._emit("")
    
    def _generate_screen_functions(self) -> None:
        """Generate VGA screen functions."""
        self._emit("; ==================")
        self._emit("; Screen Functions")
        self._emit("; ==================")
        self._emit("VGA_MEMORY equ 0xB8000")
        self._emit("VGA_WIDTH equ 80")
        self._emit("VGA_HEIGHT equ 25")
        self._emit("")
        
        # screen_clear
        self._emit("screen_clear:")
        self._emit("    push ebp")
        self._emit("    mov ebp, esp")
        self._emit("    push edi")
        self._emit("    push eax")
        self._emit("    push ecx")
        self._emit("")
        self._emit("    mov edi, VGA_MEMORY")
        self._emit("    mov ecx, VGA_WIDTH * VGA_HEIGHT")
        self._emit("    mov ax, 0x0720")
        self._emit("    rep stosw")
        self._emit("")
        self._emit("    pop ecx")
        self._emit("    pop eax")
        self._emit("    pop edi")
        self._emit("    pop ebp")
        self._emit("    ret")
        self._emit("")
        
        # screen_print (string, row, col, color)
        self._emit("screen_print:")
        self._emit("    push ebp")
        self._emit("    mov ebp, esp")
        self._emit("    push esi")
        self._emit("    push edi")
        self._emit("    push eax")
        self._emit("    push ebx")
        self._emit("")
        self._emit("    mov esi, [ebp+8]")
        self._emit("    mov eax, [ebp+12]")
        self._emit("    mov ebx, VGA_WIDTH * 2")
        self._emit("    mul ebx")
        self._emit("    mov edi, [ebp+16]")
        self._emit("    shl edi, 1")
        self._emit("    add edi, eax")
        self._emit("    add edi, VGA_MEMORY")
        self._emit("    mov ah, [ebp+20]")
        self._emit("")
        self._emit(".sp_loop:")
        self._emit("    lodsb")
        self._emit("    test al, al")
        self._emit("    jz .sp_done")
        self._emit("    stosw")
        self._emit("    jmp .sp_loop")
        self._emit("")
        self._emit(".sp_done:")
        self._emit("    pop ebx")
        self._emit("    pop eax")
        self._emit("    pop edi")
        self._emit("    pop esi")
        self._emit("    pop ebp")
        self._emit("    ret")
        self._emit("")
    
    def _generate_keyboard_functions(self) -> None:
        """Generate keyboard functions."""
        self._emit("; ==================")
        self._emit("; Keyboard Functions")
        self._emit("; ==================")
        self._emit("KEYBOARD_DATA_PORT equ 0x60")
        self._emit("KEYBOARD_STATUS_PORT equ 0x64")
        self._emit("")
        
        self._emit("keyboard_read_scancode:")
        self._emit("    push ebp")
        self._emit("    mov ebp, esp")
        self._emit(".kb_wait:")
        self._emit("    in al, KEYBOARD_STATUS_PORT")
        self._emit("    test al, 1")
        self._emit("    jz .kb_wait")
        self._emit("    in al, KEYBOARD_DATA_PORT")
        self._emit("    movzx eax, al")
        self._emit("    pop ebp")
        self._emit("    ret")
        self._emit("")
        
        # Emit strings at the end
        self._emit("; ==================")
        self._emit("; Data Section")
        self._emit("; ==================")
        for label, text in self._strings_to_emit:
            escaped = text.replace('\\', '\\\\').replace('"', '\\"')
            self._emit(f'{label}: db "{escaped}", 0')

#!/usr/bin/env python3
# Automatically generated file by swagger_to. DO NOT EDIT OR APPEND ANYTHING!
"""Implements the client for Homechart."""

# pylint: skip-file
# pydocstyle: add-ignore=D105,D107,D401

import contextlib
import json
from typing import Any, BinaryIO, Dict, List, MutableMapping, Optional, cast

import requests
import requests.auth


def from_obj(obj: Any, expected: List[type], path: str = '') -> Any:
    """
    Checks and converts the given obj along the expected types.

    :param obj: to be converted
    :param expected: list of types representing the (nested) structure
    :param path: to the object used for debugging
    :return: the converted object
    """
    if not expected:
        raise ValueError("`expected` is empty, but at least one type needs to be specified.")

    exp = expected[0]

    if exp == float:
        if isinstance(obj, int):
            return float(obj)

        if isinstance(obj, float):
            return obj

        raise ValueError(
            'Expected object of type int or float at {!r}, but got {}.'.format(path, type(obj)))

    if exp in [bool, int, str, list, dict]:
        if not isinstance(obj, exp):
            raise ValueError(
                'Expected object of type {} at {!r}, but got {}.'.format(exp, path, type(obj)))

    if exp in [bool, int, float, str]:
        return obj

    if exp == list:
        lst = []  # type: List[Any]
        for i, value in enumerate(obj):
            lst.append(
                from_obj(value, expected=expected[1:], path='{}[{}]'.format(path, i)))

        return lst

    if exp == dict:
        adict = dict()  # type: Dict[str, Any]
        for key, value in obj.items():
            if not isinstance(key, str):
                raise ValueError(
                    'Expected a key of type str at path {!r}, got: {}'.format(path, type(key)))

            adict[key] = from_obj(value, expected=expected[1:], path='{}[{!r}]'.format(path, key))

        return adict

    if exp == AppCLI:
        return app_c_l_i_from_obj(obj, path=path)

    if exp == AppMacro:
        return app_macro_from_obj(obj, path=path)

    if exp == AppMacroFlag:
        return app_macro_flag_from_obj(obj, path=path)

    if exp == CachesProvider:
        return caches_provider_from_obj(obj, path=path)

    if exp == ConfigApp:
        return config_app_from_obj(obj, path=path)

    if exp == ConfigCloud:
        return config_cloud_from_obj(obj, path=path)

    if exp == ConfigCloudPayments:
        return config_cloud_payments_from_obj(obj, path=path)

    if exp == ConfigConfig:
        return config_config_from_obj(obj, path=path)

    if exp == ConfigWellKnownResponse:
        return config_well_known_response_from_obj(obj, path=path)

    if exp == ControllersResponse:
        return controllers_response_from_obj(obj, path=path)

    if exp == CryptolibEncryptedValue:
        return cryptolib_encrypted_value_from_obj(obj, path=path)

    if exp == CryptolibKeyCryptolibKeyProviderPrivate:
        return cryptolib_key_cryptolib_key_provider_private_from_obj(obj, path=path)

    if exp == CryptolibKeyCryptolibKeyProviderPublic:
        return cryptolib_key_cryptolib_key_provider_public_from_obj(obj, path=path)

    if exp == CryptolibKeyCryptolibRSA2048PublicKey:
        return cryptolib_key_cryptolib_r_s_a2048_public_key_from_obj(obj, path=path)

    if exp == DatabasesProvider:
        return databases_provider_from_obj(obj, path=path)

    if exp == HttplibClient:
        return httplib_client_from_obj(obj, path=path)

    if exp == HttplibJsonResponseConfigConfig:
        return httplib_json_response_config_config_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthAccountDelegations:
        return httplib_json_response_models_auth_account_delegations_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthAccounts:
        return httplib_json_response_models_auth_accounts_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthHouseholds:
        return httplib_json_response_models_auth_households_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthOIDCClients:
        return httplib_json_response_models_auth_o_id_c_clients_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthOIDCCodes:
        return httplib_json_response_models_auth_o_id_c_codes_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthSessions:
        return httplib_json_response_models_auth_sessions_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsBookmarks:
        return httplib_json_response_models_bookmarks_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetAccounts:
        return httplib_json_response_models_budget_accounts_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetCategories:
        return httplib_json_response_models_budget_categories_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetMonthCategories:
        return httplib_json_response_models_budget_month_categories_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetMonths:
        return httplib_json_response_models_budget_months_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetPayees:
        return httplib_json_response_models_budget_payees_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetRecurrences:
        return httplib_json_response_models_budget_recurrences_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetTransactions:
        return httplib_json_response_models_budget_transactions_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsCalendarEvents:
        return httplib_json_response_models_calendar_events_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsCalendarICalendars:
        return httplib_json_response_models_calendar_i_calendars_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsChanges:
        return httplib_json_response_models_changes_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsConfigKeys:
        return httplib_json_response_models_config_keys_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsCookMealPlans:
        return httplib_json_response_models_cook_meal_plans_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsCookMealTimes:
        return httplib_json_response_models_cook_meal_times_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsCookRecipes:
        return httplib_json_response_models_cook_recipes_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsFeatureCandidates:
        return httplib_json_response_models_feature_candidates_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsFeatureVotes:
        return httplib_json_response_models_feature_votes_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsHealthItems:
        return httplib_json_response_models_health_items_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsHealthLogItems:
        return httplib_json_response_models_health_log_items_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsInventoryCollections:
        return httplib_json_response_models_inventory_collections_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsInventoryItems:
        return httplib_json_response_models_inventory_items_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsLabelsValues:
        return httplib_json_response_models_labels_values_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsNotesPageVersions:
        return httplib_json_response_models_notes_page_versions_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsNotesPages:
        return httplib_json_response_models_notes_pages_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsPlanProjects:
        return httplib_json_response_models_plan_projects_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsPlanTasks:
        return httplib_json_response_models_plan_tasks_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsRewardCards:
        return httplib_json_response_models_reward_cards_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsSecretsValues:
        return httplib_json_response_models_secrets_values_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsSecretsVaults:
        return httplib_json_response_models_secrets_vaults_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsShopCategories:
        return httplib_json_response_models_shop_categories_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsShopItems:
        return httplib_json_response_models_shop_items_from_obj(obj, path=path)

    if exp == HttplibJsonResponseModelsShopLists:
        return httplib_json_response_models_shop_lists_from_obj(obj, path=path)

    if exp == HttplibJsonResponseWebauthnCredentialCreationOpts:
        return httplib_json_response_webauthn_credential_creation_opts_from_obj(obj, path=path)

    if exp == HttplibJsonResponseCacheID:
        return httplib_json_response_cache_id_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataConfigConfig:
        return httplib_json_response_data_config_config_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthAccountDelegations:
        return httplib_json_response_data_models_auth_account_delegations_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthAccounts:
        return httplib_json_response_data_models_auth_accounts_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthHouseholds:
        return httplib_json_response_data_models_auth_households_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthOIDCClients:
        return httplib_json_response_data_models_auth_o_id_c_clients_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthOIDCCodes:
        return httplib_json_response_data_models_auth_o_id_c_codes_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthSessions:
        return httplib_json_response_data_models_auth_sessions_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBookmarks:
        return httplib_json_response_data_models_bookmarks_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetAccounts:
        return httplib_json_response_data_models_budget_accounts_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetCategories:
        return httplib_json_response_data_models_budget_categories_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetMonthCategories:
        return httplib_json_response_data_models_budget_month_categories_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetMonths:
        return httplib_json_response_data_models_budget_months_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetPayees:
        return httplib_json_response_data_models_budget_payees_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetRecurrences:
        return httplib_json_response_data_models_budget_recurrences_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetTransactions:
        return httplib_json_response_data_models_budget_transactions_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCalendarEvents:
        return httplib_json_response_data_models_calendar_events_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCalendarICalendars:
        return httplib_json_response_data_models_calendar_i_calendars_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsChanges:
        return httplib_json_response_data_models_changes_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsConfigKeys:
        return httplib_json_response_data_models_config_keys_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCookMealPlans:
        return httplib_json_response_data_models_cook_meal_plans_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCookMealTimes:
        return httplib_json_response_data_models_cook_meal_times_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCookRecipes:
        return httplib_json_response_data_models_cook_recipes_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsFeatureCandidates:
        return httplib_json_response_data_models_feature_candidates_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsFeatureVotes:
        return httplib_json_response_data_models_feature_votes_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsHealthItems:
        return httplib_json_response_data_models_health_items_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsHealthLogItems:
        return httplib_json_response_data_models_health_log_items_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsInventoryCollections:
        return httplib_json_response_data_models_inventory_collections_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsInventoryItems:
        return httplib_json_response_data_models_inventory_items_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsLabelsValues:
        return httplib_json_response_data_models_labels_values_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsNotesPageVersions:
        return httplib_json_response_data_models_notes_page_versions_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsNotesPages:
        return httplib_json_response_data_models_notes_pages_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsPlanProjects:
        return httplib_json_response_data_models_plan_projects_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsPlanTasks:
        return httplib_json_response_data_models_plan_tasks_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsRewardCards:
        return httplib_json_response_data_models_reward_cards_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsSecretsValues:
        return httplib_json_response_data_models_secrets_values_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsSecretsVaults:
        return httplib_json_response_data_models_secrets_vaults_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsShopCategories:
        return httplib_json_response_data_models_shop_categories_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsShopItems:
        return httplib_json_response_data_models_shop_items_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataModelsShopLists:
        return httplib_json_response_data_models_shop_lists_from_obj(obj, path=path)

    if exp == HttplibJsonResponseDataWebauthnCredentialCreationOpts:
        return httplib_json_response_data_webauthn_credential_creation_opts_from_obj(obj, path=path)

    if exp == HttplibJsonResponseError:
        return httplib_json_response_error_from_obj(obj, path=path)

    if exp == HttplibServer:
        return httplib_server_from_obj(obj, path=path)

    if exp == JsonnetJsonnet:
        return jsonnet_jsonnet_from_obj(obj, path=path)

    if exp == JwtRegisteredClaims:
        return jwt_registered_claims_from_obj(obj, path=path)

    if exp == ModelsAuthAccount:
        return models_auth_account_from_obj(obj, path=path)

    if exp == ModelsAuthAccountDelegation:
        return models_auth_account_delegation_from_obj(obj, path=path)

    if exp == ModelsAuthAccountDelegationAccess:
        return models_auth_account_delegation_access_from_obj(obj, path=path)

    if exp == ModelsAuthAccountPreferences:
        return models_auth_account_preferences_from_obj(obj, path=path)

    if exp == ModelsAuthAccountPreferencesNotificationsHousehold:
        return models_auth_account_preferences_notifications_household_from_obj(obj, path=path)

    if exp == ModelsAuthAccountPrivateKey:
        return models_auth_account_private_key_from_obj(obj, path=path)

    if exp == ModelsAuthHousehold:
        return models_auth_household_from_obj(obj, path=path)

    if exp == ModelsAuthHouseholdMember:
        return models_auth_household_member_from_obj(obj, path=path)

    if exp == ModelsAuthHouseholdPreferences:
        return models_auth_household_preferences_from_obj(obj, path=path)

    if exp == ModelsAuthOIDCClient:
        return models_auth_o_id_c_client_from_obj(obj, path=path)

    if exp == ModelsAuthOIDCCode:
        return models_auth_o_id_c_code_from_obj(obj, path=path)

    if exp == ModelsAuthSession:
        return models_auth_session_from_obj(obj, path=path)

    if exp == ModelsBookmark:
        return models_bookmark_from_obj(obj, path=path)

    if exp == ModelsBudgetAccount:
        return models_budget_account_from_obj(obj, path=path)

    if exp == ModelsBudgetCategory:
        return models_budget_category_from_obj(obj, path=path)

    if exp == ModelsBudgetMonth:
        return models_budget_month_from_obj(obj, path=path)

    if exp == ModelsBudgetMonthCategory:
        return models_budget_month_category_from_obj(obj, path=path)

    if exp == ModelsBudgetPayee:
        return models_budget_payee_from_obj(obj, path=path)

    if exp == ModelsBudgetRecurrence:
        return models_budget_recurrence_from_obj(obj, path=path)

    if exp == ModelsBudgetRecurrenceTemplate:
        return models_budget_recurrence_template_from_obj(obj, path=path)

    if exp == ModelsBudgetTransaction:
        return models_budget_transaction_from_obj(obj, path=path)

    if exp == ModelsBudgetTransactionAccount:
        return models_budget_transaction_account_from_obj(obj, path=path)

    if exp == ModelsBudgetTransactionCategory:
        return models_budget_transaction_category_from_obj(obj, path=path)

    if exp == ModelsCalendarEvent:
        return models_calendar_event_from_obj(obj, path=path)

    if exp == ModelsCalendarICalendar:
        return models_calendar_i_calendar_from_obj(obj, path=path)

    if exp == ModelsChange:
        return models_change_from_obj(obj, path=path)

    if exp == ModelsColor:
        return models_color_from_obj(obj, path=path)

    if exp == ModelsConfigKey:
        return models_config_key_from_obj(obj, path=path)

    if exp == ModelsCookMealPlan:
        return models_cook_meal_plan_from_obj(obj, path=path)

    if exp == ModelsCookMealTime:
        return models_cook_meal_time_from_obj(obj, path=path)

    if exp == ModelsCookRecipe:
        return models_cook_recipe_from_obj(obj, path=path)

    if exp == ModelsCookRecipeNote:
        return models_cook_recipe_note_from_obj(obj, path=path)

    if exp == ModelsEvent:
        return models_event_from_obj(obj, path=path)

    if exp == ModelsFeatureCandidate:
        return models_feature_candidate_from_obj(obj, path=path)

    if exp == ModelsFeatureVote:
        return models_feature_vote_from_obj(obj, path=path)

    if exp == ModelsHealthItem:
        return models_health_item_from_obj(obj, path=path)

    if exp == ModelsHealthLogItem:
        return models_health_log_item_from_obj(obj, path=path)

    if exp == ModelsInventoryCollection:
        return models_inventory_collection_from_obj(obj, path=path)

    if exp == ModelsInventoryCollectionSort:
        return models_inventory_collection_sort_from_obj(obj, path=path)

    if exp == ModelsInventoryItem:
        return models_inventory_item_from_obj(obj, path=path)

    if exp == ModelsLabelsValue:
        return models_labels_value_from_obj(obj, path=path)

    if exp == ModelsNotesPage:
        return models_notes_page_from_obj(obj, path=path)

    if exp == ModelsNotesPageVersion:
        return models_notes_page_version_from_obj(obj, path=path)

    if exp == ModelsPermissions:
        return models_permissions_from_obj(obj, path=path)

    if exp == ModelsPlanProject:
        return models_plan_project_from_obj(obj, path=path)

    if exp == ModelsPlanTask:
        return models_plan_task_from_obj(obj, path=path)

    if exp == ModelsRewardCard:
        return models_reward_card_from_obj(obj, path=path)

    if exp == ModelsSecretsValue:
        return models_secrets_value_from_obj(obj, path=path)

    if exp == ModelsSecretsVault:
        return models_secrets_vault_from_obj(obj, path=path)

    if exp == ModelsSecretsVaultKey:
        return models_secrets_vault_key_from_obj(obj, path=path)

    if exp == ModelsShopCategory:
        return models_shop_category_from_obj(obj, path=path)

    if exp == ModelsShopItem:
        return models_shop_item_from_obj(obj, path=path)

    if exp == ModelsShopList:
        return models_shop_list_from_obj(obj, path=path)

    if exp == NotifyAPN:
        return notify_a_p_n_from_obj(obj, path=path)

    if exp == NotifySMTP:
        return notify_s_m_t_p_from_obj(obj, path=path)

    if exp == NotifyWebPush:
        return notify_web_push_from_obj(obj, path=path)

    if exp == NotifyWebPushClient:
        return notify_web_push_client_from_obj(obj, path=path)

    if exp == OidcClientIssuer:
        return oidc_client_issuer_from_obj(obj, path=path)

    if exp == PaymentsApple:
        return payments_apple_from_obj(obj, path=path)

    if exp == PaymentsGoogle:
        return payments_google_from_obj(obj, path=path)

    if exp == PaymentsPaddle:
        return payments_paddle_from_obj(obj, path=path)

    if exp == RegexpRegexp:
        return regexp_regexp_from_obj(obj, path=path)

    if exp == TypesCivilDate:
        return types_civil_date_from_obj(obj, path=path)

    if exp == TypesFilter:
        return types_filter_from_obj(obj, path=path)

    if exp == TypesRecurrence:
        return types_recurrence_from_obj(obj, path=path)

    if exp == WebauthnCredential:
        return webauthn_credential_from_obj(obj, path=path)

    if exp == WebauthnCredentialCreation:
        return webauthn_credential_creation_from_obj(obj, path=path)

    if exp == WebauthnCredentialCreationOpts:
        return webauthn_credential_creation_opts_from_obj(obj, path=path)

    if exp == WebauthnCredentialCreationOptsParameter:
        return webauthn_credential_creation_opts_parameter_from_obj(obj, path=path)

    if exp == WebauthnCredentialCreationOptsRelyingParty:
        return webauthn_credential_creation_opts_relying_party_from_obj(obj, path=path)

    if exp == WebauthnCredentialCreationOptsUser:
        return webauthn_credential_creation_opts_user_from_obj(obj, path=path)

    if exp == WebauthnCredentialRequest:
        return webauthn_credential_request_from_obj(obj, path=path)

    raise ValueError("Unexpected `expected` type: {}".format(exp))


def to_jsonable(obj: Any, expected: List[type], path: str = "") -> Any:
    """
    Checks and converts the given object along the expected types to a JSON-able representation.

    :param obj: to be converted
    :param expected: list of types representing the (nested) structure
    :param path: path to the object used for debugging
    :return: JSON-able representation of the object
    """
    if not expected:
        raise ValueError("`expected` is empty, but at least one type needs to be specified.")

    exp = expected[0]
    if not isinstance(obj, exp):
        raise ValueError('Expected object of type {} at path {!r}, but got {}.'.format(
            exp, path, type(obj)))

    # Assert on primitive types to help type-hinting.
    if exp == bool:
        assert isinstance(obj, bool)
        return obj

    if exp == int:
        assert isinstance(obj, int)
        return obj

    if exp == float:
        assert isinstance(obj, float)
        return obj

    if exp == str:
        assert isinstance(obj, str)
        return obj

    if exp == list:
        assert isinstance(obj, list)

        lst = []  # type: List[Any]
        for i, value in enumerate(obj):
            lst.append(
                to_jsonable(value, expected=expected[1:], path='{}[{}]'.format(path, i)))

        return lst

    if exp == dict:
        assert isinstance(obj, dict)

        adict = dict()  # type: Dict[str, Any]
        for key, value in obj.items():
            if not isinstance(key, str):
                raise ValueError(
                    'Expected a key of type str at path {!r}, got: {}'.format(path, type(key)))

            adict[key] = to_jsonable(
                value,
                expected=expected[1:],
                path='{}[{!r}]'.format(path, key))

        return adict

    if exp == AppCLI:
        assert isinstance(obj, AppCLI)
        return app_c_l_i_to_jsonable(obj, path=path)

    if exp == AppMacro:
        assert isinstance(obj, AppMacro)
        return app_macro_to_jsonable(obj, path=path)

    if exp == AppMacroFlag:
        assert isinstance(obj, AppMacroFlag)
        return app_macro_flag_to_jsonable(obj, path=path)

    if exp == CachesProvider:
        assert isinstance(obj, CachesProvider)
        return caches_provider_to_jsonable(obj, path=path)

    if exp == ConfigApp:
        assert isinstance(obj, ConfigApp)
        return config_app_to_jsonable(obj, path=path)

    if exp == ConfigCloud:
        assert isinstance(obj, ConfigCloud)
        return config_cloud_to_jsonable(obj, path=path)

    if exp == ConfigCloudPayments:
        assert isinstance(obj, ConfigCloudPayments)
        return config_cloud_payments_to_jsonable(obj, path=path)

    if exp == ConfigConfig:
        assert isinstance(obj, ConfigConfig)
        return config_config_to_jsonable(obj, path=path)

    if exp == ConfigWellKnownResponse:
        assert isinstance(obj, ConfigWellKnownResponse)
        return config_well_known_response_to_jsonable(obj, path=path)

    if exp == ControllersResponse:
        assert isinstance(obj, ControllersResponse)
        return controllers_response_to_jsonable(obj, path=path)

    if exp == CryptolibEncryptedValue:
        assert isinstance(obj, CryptolibEncryptedValue)
        return cryptolib_encrypted_value_to_jsonable(obj, path=path)

    if exp == CryptolibKeyCryptolibKeyProviderPrivate:
        assert isinstance(obj, CryptolibKeyCryptolibKeyProviderPrivate)
        return cryptolib_key_cryptolib_key_provider_private_to_jsonable(obj, path=path)

    if exp == CryptolibKeyCryptolibKeyProviderPublic:
        assert isinstance(obj, CryptolibKeyCryptolibKeyProviderPublic)
        return cryptolib_key_cryptolib_key_provider_public_to_jsonable(obj, path=path)

    if exp == CryptolibKeyCryptolibRSA2048PublicKey:
        assert isinstance(obj, CryptolibKeyCryptolibRSA2048PublicKey)
        return cryptolib_key_cryptolib_r_s_a2048_public_key_to_jsonable(obj, path=path)

    if exp == DatabasesProvider:
        assert isinstance(obj, DatabasesProvider)
        return databases_provider_to_jsonable(obj, path=path)

    if exp == HttplibClient:
        assert isinstance(obj, HttplibClient)
        return httplib_client_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseConfigConfig:
        assert isinstance(obj, HttplibJsonResponseConfigConfig)
        return httplib_json_response_config_config_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthAccountDelegations:
        assert isinstance(obj, HttplibJsonResponseModelsAuthAccountDelegations)
        return httplib_json_response_models_auth_account_delegations_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthAccounts:
        assert isinstance(obj, HttplibJsonResponseModelsAuthAccounts)
        return httplib_json_response_models_auth_accounts_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthHouseholds:
        assert isinstance(obj, HttplibJsonResponseModelsAuthHouseholds)
        return httplib_json_response_models_auth_households_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthOIDCClients:
        assert isinstance(obj, HttplibJsonResponseModelsAuthOIDCClients)
        return httplib_json_response_models_auth_o_id_c_clients_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthOIDCCodes:
        assert isinstance(obj, HttplibJsonResponseModelsAuthOIDCCodes)
        return httplib_json_response_models_auth_o_id_c_codes_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsAuthSessions:
        assert isinstance(obj, HttplibJsonResponseModelsAuthSessions)
        return httplib_json_response_models_auth_sessions_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsBookmarks:
        assert isinstance(obj, HttplibJsonResponseModelsBookmarks)
        return httplib_json_response_models_bookmarks_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetAccounts:
        assert isinstance(obj, HttplibJsonResponseModelsBudgetAccounts)
        return httplib_json_response_models_budget_accounts_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetCategories:
        assert isinstance(obj, HttplibJsonResponseModelsBudgetCategories)
        return httplib_json_response_models_budget_categories_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetMonthCategories:
        assert isinstance(obj, HttplibJsonResponseModelsBudgetMonthCategories)
        return httplib_json_response_models_budget_month_categories_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetMonths:
        assert isinstance(obj, HttplibJsonResponseModelsBudgetMonths)
        return httplib_json_response_models_budget_months_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetPayees:
        assert isinstance(obj, HttplibJsonResponseModelsBudgetPayees)
        return httplib_json_response_models_budget_payees_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetRecurrences:
        assert isinstance(obj, HttplibJsonResponseModelsBudgetRecurrences)
        return httplib_json_response_models_budget_recurrences_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsBudgetTransactions:
        assert isinstance(obj, HttplibJsonResponseModelsBudgetTransactions)
        return httplib_json_response_models_budget_transactions_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsCalendarEvents:
        assert isinstance(obj, HttplibJsonResponseModelsCalendarEvents)
        return httplib_json_response_models_calendar_events_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsCalendarICalendars:
        assert isinstance(obj, HttplibJsonResponseModelsCalendarICalendars)
        return httplib_json_response_models_calendar_i_calendars_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsChanges:
        assert isinstance(obj, HttplibJsonResponseModelsChanges)
        return httplib_json_response_models_changes_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsConfigKeys:
        assert isinstance(obj, HttplibJsonResponseModelsConfigKeys)
        return httplib_json_response_models_config_keys_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsCookMealPlans:
        assert isinstance(obj, HttplibJsonResponseModelsCookMealPlans)
        return httplib_json_response_models_cook_meal_plans_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsCookMealTimes:
        assert isinstance(obj, HttplibJsonResponseModelsCookMealTimes)
        return httplib_json_response_models_cook_meal_times_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsCookRecipes:
        assert isinstance(obj, HttplibJsonResponseModelsCookRecipes)
        return httplib_json_response_models_cook_recipes_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsFeatureCandidates:
        assert isinstance(obj, HttplibJsonResponseModelsFeatureCandidates)
        return httplib_json_response_models_feature_candidates_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsFeatureVotes:
        assert isinstance(obj, HttplibJsonResponseModelsFeatureVotes)
        return httplib_json_response_models_feature_votes_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsHealthItems:
        assert isinstance(obj, HttplibJsonResponseModelsHealthItems)
        return httplib_json_response_models_health_items_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsHealthLogItems:
        assert isinstance(obj, HttplibJsonResponseModelsHealthLogItems)
        return httplib_json_response_models_health_log_items_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsInventoryCollections:
        assert isinstance(obj, HttplibJsonResponseModelsInventoryCollections)
        return httplib_json_response_models_inventory_collections_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsInventoryItems:
        assert isinstance(obj, HttplibJsonResponseModelsInventoryItems)
        return httplib_json_response_models_inventory_items_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsLabelsValues:
        assert isinstance(obj, HttplibJsonResponseModelsLabelsValues)
        return httplib_json_response_models_labels_values_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsNotesPageVersions:
        assert isinstance(obj, HttplibJsonResponseModelsNotesPageVersions)
        return httplib_json_response_models_notes_page_versions_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsNotesPages:
        assert isinstance(obj, HttplibJsonResponseModelsNotesPages)
        return httplib_json_response_models_notes_pages_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsPlanProjects:
        assert isinstance(obj, HttplibJsonResponseModelsPlanProjects)
        return httplib_json_response_models_plan_projects_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsPlanTasks:
        assert isinstance(obj, HttplibJsonResponseModelsPlanTasks)
        return httplib_json_response_models_plan_tasks_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsRewardCards:
        assert isinstance(obj, HttplibJsonResponseModelsRewardCards)
        return httplib_json_response_models_reward_cards_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsSecretsValues:
        assert isinstance(obj, HttplibJsonResponseModelsSecretsValues)
        return httplib_json_response_models_secrets_values_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsSecretsVaults:
        assert isinstance(obj, HttplibJsonResponseModelsSecretsVaults)
        return httplib_json_response_models_secrets_vaults_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsShopCategories:
        assert isinstance(obj, HttplibJsonResponseModelsShopCategories)
        return httplib_json_response_models_shop_categories_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsShopItems:
        assert isinstance(obj, HttplibJsonResponseModelsShopItems)
        return httplib_json_response_models_shop_items_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseModelsShopLists:
        assert isinstance(obj, HttplibJsonResponseModelsShopLists)
        return httplib_json_response_models_shop_lists_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseWebauthnCredentialCreationOpts:
        assert isinstance(obj, HttplibJsonResponseWebauthnCredentialCreationOpts)
        return httplib_json_response_webauthn_credential_creation_opts_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseCacheID:
        assert isinstance(obj, HttplibJsonResponseCacheID)
        return httplib_json_response_cache_id_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataConfigConfig:
        assert isinstance(obj, HttplibJsonResponseDataConfigConfig)
        return httplib_json_response_data_config_config_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthAccountDelegations:
        assert isinstance(obj, HttplibJsonResponseDataModelsAuthAccountDelegations)
        return httplib_json_response_data_models_auth_account_delegations_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthAccounts:
        assert isinstance(obj, HttplibJsonResponseDataModelsAuthAccounts)
        return httplib_json_response_data_models_auth_accounts_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthHouseholds:
        assert isinstance(obj, HttplibJsonResponseDataModelsAuthHouseholds)
        return httplib_json_response_data_models_auth_households_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthOIDCClients:
        assert isinstance(obj, HttplibJsonResponseDataModelsAuthOIDCClients)
        return httplib_json_response_data_models_auth_o_id_c_clients_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthOIDCCodes:
        assert isinstance(obj, HttplibJsonResponseDataModelsAuthOIDCCodes)
        return httplib_json_response_data_models_auth_o_id_c_codes_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsAuthSessions:
        assert isinstance(obj, HttplibJsonResponseDataModelsAuthSessions)
        return httplib_json_response_data_models_auth_sessions_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBookmarks:
        assert isinstance(obj, HttplibJsonResponseDataModelsBookmarks)
        return httplib_json_response_data_models_bookmarks_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetAccounts:
        assert isinstance(obj, HttplibJsonResponseDataModelsBudgetAccounts)
        return httplib_json_response_data_models_budget_accounts_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetCategories:
        assert isinstance(obj, HttplibJsonResponseDataModelsBudgetCategories)
        return httplib_json_response_data_models_budget_categories_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetMonthCategories:
        assert isinstance(obj, HttplibJsonResponseDataModelsBudgetMonthCategories)
        return httplib_json_response_data_models_budget_month_categories_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetMonths:
        assert isinstance(obj, HttplibJsonResponseDataModelsBudgetMonths)
        return httplib_json_response_data_models_budget_months_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetPayees:
        assert isinstance(obj, HttplibJsonResponseDataModelsBudgetPayees)
        return httplib_json_response_data_models_budget_payees_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetRecurrences:
        assert isinstance(obj, HttplibJsonResponseDataModelsBudgetRecurrences)
        return httplib_json_response_data_models_budget_recurrences_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsBudgetTransactions:
        assert isinstance(obj, HttplibJsonResponseDataModelsBudgetTransactions)
        return httplib_json_response_data_models_budget_transactions_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCalendarEvents:
        assert isinstance(obj, HttplibJsonResponseDataModelsCalendarEvents)
        return httplib_json_response_data_models_calendar_events_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCalendarICalendars:
        assert isinstance(obj, HttplibJsonResponseDataModelsCalendarICalendars)
        return httplib_json_response_data_models_calendar_i_calendars_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsChanges:
        assert isinstance(obj, HttplibJsonResponseDataModelsChanges)
        return httplib_json_response_data_models_changes_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsConfigKeys:
        assert isinstance(obj, HttplibJsonResponseDataModelsConfigKeys)
        return httplib_json_response_data_models_config_keys_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCookMealPlans:
        assert isinstance(obj, HttplibJsonResponseDataModelsCookMealPlans)
        return httplib_json_response_data_models_cook_meal_plans_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCookMealTimes:
        assert isinstance(obj, HttplibJsonResponseDataModelsCookMealTimes)
        return httplib_json_response_data_models_cook_meal_times_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsCookRecipes:
        assert isinstance(obj, HttplibJsonResponseDataModelsCookRecipes)
        return httplib_json_response_data_models_cook_recipes_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsFeatureCandidates:
        assert isinstance(obj, HttplibJsonResponseDataModelsFeatureCandidates)
        return httplib_json_response_data_models_feature_candidates_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsFeatureVotes:
        assert isinstance(obj, HttplibJsonResponseDataModelsFeatureVotes)
        return httplib_json_response_data_models_feature_votes_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsHealthItems:
        assert isinstance(obj, HttplibJsonResponseDataModelsHealthItems)
        return httplib_json_response_data_models_health_items_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsHealthLogItems:
        assert isinstance(obj, HttplibJsonResponseDataModelsHealthLogItems)
        return httplib_json_response_data_models_health_log_items_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsInventoryCollections:
        assert isinstance(obj, HttplibJsonResponseDataModelsInventoryCollections)
        return httplib_json_response_data_models_inventory_collections_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsInventoryItems:
        assert isinstance(obj, HttplibJsonResponseDataModelsInventoryItems)
        return httplib_json_response_data_models_inventory_items_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsLabelsValues:
        assert isinstance(obj, HttplibJsonResponseDataModelsLabelsValues)
        return httplib_json_response_data_models_labels_values_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsNotesPageVersions:
        assert isinstance(obj, HttplibJsonResponseDataModelsNotesPageVersions)
        return httplib_json_response_data_models_notes_page_versions_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsNotesPages:
        assert isinstance(obj, HttplibJsonResponseDataModelsNotesPages)
        return httplib_json_response_data_models_notes_pages_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsPlanProjects:
        assert isinstance(obj, HttplibJsonResponseDataModelsPlanProjects)
        return httplib_json_response_data_models_plan_projects_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsPlanTasks:
        assert isinstance(obj, HttplibJsonResponseDataModelsPlanTasks)
        return httplib_json_response_data_models_plan_tasks_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsRewardCards:
        assert isinstance(obj, HttplibJsonResponseDataModelsRewardCards)
        return httplib_json_response_data_models_reward_cards_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsSecretsValues:
        assert isinstance(obj, HttplibJsonResponseDataModelsSecretsValues)
        return httplib_json_response_data_models_secrets_values_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsSecretsVaults:
        assert isinstance(obj, HttplibJsonResponseDataModelsSecretsVaults)
        return httplib_json_response_data_models_secrets_vaults_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsShopCategories:
        assert isinstance(obj, HttplibJsonResponseDataModelsShopCategories)
        return httplib_json_response_data_models_shop_categories_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsShopItems:
        assert isinstance(obj, HttplibJsonResponseDataModelsShopItems)
        return httplib_json_response_data_models_shop_items_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataModelsShopLists:
        assert isinstance(obj, HttplibJsonResponseDataModelsShopLists)
        return httplib_json_response_data_models_shop_lists_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseDataWebauthnCredentialCreationOpts:
        assert isinstance(obj, HttplibJsonResponseDataWebauthnCredentialCreationOpts)
        return httplib_json_response_data_webauthn_credential_creation_opts_to_jsonable(obj, path=path)

    if exp == HttplibJsonResponseError:
        assert isinstance(obj, HttplibJsonResponseError)
        return httplib_json_response_error_to_jsonable(obj, path=path)

    if exp == HttplibServer:
        assert isinstance(obj, HttplibServer)
        return httplib_server_to_jsonable(obj, path=path)

    if exp == JsonnetJsonnet:
        assert isinstance(obj, JsonnetJsonnet)
        return jsonnet_jsonnet_to_jsonable(obj, path=path)

    if exp == JwtRegisteredClaims:
        assert isinstance(obj, JwtRegisteredClaims)
        return jwt_registered_claims_to_jsonable(obj, path=path)

    if exp == ModelsAuthAccount:
        assert isinstance(obj, ModelsAuthAccount)
        return models_auth_account_to_jsonable(obj, path=path)

    if exp == ModelsAuthAccountDelegation:
        assert isinstance(obj, ModelsAuthAccountDelegation)
        return models_auth_account_delegation_to_jsonable(obj, path=path)

    if exp == ModelsAuthAccountDelegationAccess:
        assert isinstance(obj, ModelsAuthAccountDelegationAccess)
        return models_auth_account_delegation_access_to_jsonable(obj, path=path)

    if exp == ModelsAuthAccountPreferences:
        assert isinstance(obj, ModelsAuthAccountPreferences)
        return models_auth_account_preferences_to_jsonable(obj, path=path)

    if exp == ModelsAuthAccountPreferencesNotificationsHousehold:
        assert isinstance(obj, ModelsAuthAccountPreferencesNotificationsHousehold)
        return models_auth_account_preferences_notifications_household_to_jsonable(obj, path=path)

    if exp == ModelsAuthAccountPrivateKey:
        assert isinstance(obj, ModelsAuthAccountPrivateKey)
        return models_auth_account_private_key_to_jsonable(obj, path=path)

    if exp == ModelsAuthHousehold:
        assert isinstance(obj, ModelsAuthHousehold)
        return models_auth_household_to_jsonable(obj, path=path)

    if exp == ModelsAuthHouseholdMember:
        assert isinstance(obj, ModelsAuthHouseholdMember)
        return models_auth_household_member_to_jsonable(obj, path=path)

    if exp == ModelsAuthHouseholdPreferences:
        assert isinstance(obj, ModelsAuthHouseholdPreferences)
        return models_auth_household_preferences_to_jsonable(obj, path=path)

    if exp == ModelsAuthOIDCClient:
        assert isinstance(obj, ModelsAuthOIDCClient)
        return models_auth_o_id_c_client_to_jsonable(obj, path=path)

    if exp == ModelsAuthOIDCCode:
        assert isinstance(obj, ModelsAuthOIDCCode)
        return models_auth_o_id_c_code_to_jsonable(obj, path=path)

    if exp == ModelsAuthSession:
        assert isinstance(obj, ModelsAuthSession)
        return models_auth_session_to_jsonable(obj, path=path)

    if exp == ModelsBookmark:
        assert isinstance(obj, ModelsBookmark)
        return models_bookmark_to_jsonable(obj, path=path)

    if exp == ModelsBudgetAccount:
        assert isinstance(obj, ModelsBudgetAccount)
        return models_budget_account_to_jsonable(obj, path=path)

    if exp == ModelsBudgetCategory:
        assert isinstance(obj, ModelsBudgetCategory)
        return models_budget_category_to_jsonable(obj, path=path)

    if exp == ModelsBudgetMonth:
        assert isinstance(obj, ModelsBudgetMonth)
        return models_budget_month_to_jsonable(obj, path=path)

    if exp == ModelsBudgetMonthCategory:
        assert isinstance(obj, ModelsBudgetMonthCategory)
        return models_budget_month_category_to_jsonable(obj, path=path)

    if exp == ModelsBudgetPayee:
        assert isinstance(obj, ModelsBudgetPayee)
        return models_budget_payee_to_jsonable(obj, path=path)

    if exp == ModelsBudgetRecurrence:
        assert isinstance(obj, ModelsBudgetRecurrence)
        return models_budget_recurrence_to_jsonable(obj, path=path)

    if exp == ModelsBudgetRecurrenceTemplate:
        assert isinstance(obj, ModelsBudgetRecurrenceTemplate)
        return models_budget_recurrence_template_to_jsonable(obj, path=path)

    if exp == ModelsBudgetTransaction:
        assert isinstance(obj, ModelsBudgetTransaction)
        return models_budget_transaction_to_jsonable(obj, path=path)

    if exp == ModelsBudgetTransactionAccount:
        assert isinstance(obj, ModelsBudgetTransactionAccount)
        return models_budget_transaction_account_to_jsonable(obj, path=path)

    if exp == ModelsBudgetTransactionCategory:
        assert isinstance(obj, ModelsBudgetTransactionCategory)
        return models_budget_transaction_category_to_jsonable(obj, path=path)

    if exp == ModelsCalendarEvent:
        assert isinstance(obj, ModelsCalendarEvent)
        return models_calendar_event_to_jsonable(obj, path=path)

    if exp == ModelsCalendarICalendar:
        assert isinstance(obj, ModelsCalendarICalendar)
        return models_calendar_i_calendar_to_jsonable(obj, path=path)

    if exp == ModelsChange:
        assert isinstance(obj, ModelsChange)
        return models_change_to_jsonable(obj, path=path)

    if exp == ModelsColor:
        assert isinstance(obj, ModelsColor)
        return models_color_to_jsonable(obj, path=path)

    if exp == ModelsConfigKey:
        assert isinstance(obj, ModelsConfigKey)
        return models_config_key_to_jsonable(obj, path=path)

    if exp == ModelsCookMealPlan:
        assert isinstance(obj, ModelsCookMealPlan)
        return models_cook_meal_plan_to_jsonable(obj, path=path)

    if exp == ModelsCookMealTime:
        assert isinstance(obj, ModelsCookMealTime)
        return models_cook_meal_time_to_jsonable(obj, path=path)

    if exp == ModelsCookRecipe:
        assert isinstance(obj, ModelsCookRecipe)
        return models_cook_recipe_to_jsonable(obj, path=path)

    if exp == ModelsCookRecipeNote:
        assert isinstance(obj, ModelsCookRecipeNote)
        return models_cook_recipe_note_to_jsonable(obj, path=path)

    if exp == ModelsEvent:
        assert isinstance(obj, ModelsEvent)
        return models_event_to_jsonable(obj, path=path)

    if exp == ModelsFeatureCandidate:
        assert isinstance(obj, ModelsFeatureCandidate)
        return models_feature_candidate_to_jsonable(obj, path=path)

    if exp == ModelsFeatureVote:
        assert isinstance(obj, ModelsFeatureVote)
        return models_feature_vote_to_jsonable(obj, path=path)

    if exp == ModelsHealthItem:
        assert isinstance(obj, ModelsHealthItem)
        return models_health_item_to_jsonable(obj, path=path)

    if exp == ModelsHealthLogItem:
        assert isinstance(obj, ModelsHealthLogItem)
        return models_health_log_item_to_jsonable(obj, path=path)

    if exp == ModelsInventoryCollection:
        assert isinstance(obj, ModelsInventoryCollection)
        return models_inventory_collection_to_jsonable(obj, path=path)

    if exp == ModelsInventoryCollectionSort:
        assert isinstance(obj, ModelsInventoryCollectionSort)
        return models_inventory_collection_sort_to_jsonable(obj, path=path)

    if exp == ModelsInventoryItem:
        assert isinstance(obj, ModelsInventoryItem)
        return models_inventory_item_to_jsonable(obj, path=path)

    if exp == ModelsLabelsValue:
        assert isinstance(obj, ModelsLabelsValue)
        return models_labels_value_to_jsonable(obj, path=path)

    if exp == ModelsNotesPage:
        assert isinstance(obj, ModelsNotesPage)
        return models_notes_page_to_jsonable(obj, path=path)

    if exp == ModelsNotesPageVersion:
        assert isinstance(obj, ModelsNotesPageVersion)
        return models_notes_page_version_to_jsonable(obj, path=path)

    if exp == ModelsPermissions:
        assert isinstance(obj, ModelsPermissions)
        return models_permissions_to_jsonable(obj, path=path)

    if exp == ModelsPlanProject:
        assert isinstance(obj, ModelsPlanProject)
        return models_plan_project_to_jsonable(obj, path=path)

    if exp == ModelsPlanTask:
        assert isinstance(obj, ModelsPlanTask)
        return models_plan_task_to_jsonable(obj, path=path)

    if exp == ModelsRewardCard:
        assert isinstance(obj, ModelsRewardCard)
        return models_reward_card_to_jsonable(obj, path=path)

    if exp == ModelsSecretsValue:
        assert isinstance(obj, ModelsSecretsValue)
        return models_secrets_value_to_jsonable(obj, path=path)

    if exp == ModelsSecretsVault:
        assert isinstance(obj, ModelsSecretsVault)
        return models_secrets_vault_to_jsonable(obj, path=path)

    if exp == ModelsSecretsVaultKey:
        assert isinstance(obj, ModelsSecretsVaultKey)
        return models_secrets_vault_key_to_jsonable(obj, path=path)

    if exp == ModelsShopCategory:
        assert isinstance(obj, ModelsShopCategory)
        return models_shop_category_to_jsonable(obj, path=path)

    if exp == ModelsShopItem:
        assert isinstance(obj, ModelsShopItem)
        return models_shop_item_to_jsonable(obj, path=path)

    if exp == ModelsShopList:
        assert isinstance(obj, ModelsShopList)
        return models_shop_list_to_jsonable(obj, path=path)

    if exp == NotifyAPN:
        assert isinstance(obj, NotifyAPN)
        return notify_a_p_n_to_jsonable(obj, path=path)

    if exp == NotifySMTP:
        assert isinstance(obj, NotifySMTP)
        return notify_s_m_t_p_to_jsonable(obj, path=path)

    if exp == NotifyWebPush:
        assert isinstance(obj, NotifyWebPush)
        return notify_web_push_to_jsonable(obj, path=path)

    if exp == NotifyWebPushClient:
        assert isinstance(obj, NotifyWebPushClient)
        return notify_web_push_client_to_jsonable(obj, path=path)

    if exp == OidcClientIssuer:
        assert isinstance(obj, OidcClientIssuer)
        return oidc_client_issuer_to_jsonable(obj, path=path)

    if exp == PaymentsApple:
        assert isinstance(obj, PaymentsApple)
        return payments_apple_to_jsonable(obj, path=path)

    if exp == PaymentsGoogle:
        assert isinstance(obj, PaymentsGoogle)
        return payments_google_to_jsonable(obj, path=path)

    if exp == PaymentsPaddle:
        assert isinstance(obj, PaymentsPaddle)
        return payments_paddle_to_jsonable(obj, path=path)

    if exp == RegexpRegexp:
        assert isinstance(obj, RegexpRegexp)
        return regexp_regexp_to_jsonable(obj, path=path)

    if exp == TypesCivilDate:
        assert isinstance(obj, TypesCivilDate)
        return types_civil_date_to_jsonable(obj, path=path)

    if exp == TypesFilter:
        assert isinstance(obj, TypesFilter)
        return types_filter_to_jsonable(obj, path=path)

    if exp == TypesRecurrence:
        assert isinstance(obj, TypesRecurrence)
        return types_recurrence_to_jsonable(obj, path=path)

    if exp == WebauthnCredential:
        assert isinstance(obj, WebauthnCredential)
        return webauthn_credential_to_jsonable(obj, path=path)

    if exp == WebauthnCredentialCreation:
        assert isinstance(obj, WebauthnCredentialCreation)
        return webauthn_credential_creation_to_jsonable(obj, path=path)

    if exp == WebauthnCredentialCreationOpts:
        assert isinstance(obj, WebauthnCredentialCreationOpts)
        return webauthn_credential_creation_opts_to_jsonable(obj, path=path)

    if exp == WebauthnCredentialCreationOptsParameter:
        assert isinstance(obj, WebauthnCredentialCreationOptsParameter)
        return webauthn_credential_creation_opts_parameter_to_jsonable(obj, path=path)

    if exp == WebauthnCredentialCreationOptsRelyingParty:
        assert isinstance(obj, WebauthnCredentialCreationOptsRelyingParty)
        return webauthn_credential_creation_opts_relying_party_to_jsonable(obj, path=path)

    if exp == WebauthnCredentialCreationOptsUser:
        assert isinstance(obj, WebauthnCredentialCreationOptsUser)
        return webauthn_credential_creation_opts_user_to_jsonable(obj, path=path)

    if exp == WebauthnCredentialRequest:
        assert isinstance(obj, WebauthnCredentialRequest)
        return webauthn_credential_request_to_jsonable(obj, path=path)

    raise ValueError("Unexpected `expected` type: {}".format(exp))


class AppCLI:
    def __init__(
            self,
            config_path: Optional[str] = None,
            config_reload: Optional[int] = None,
            config_watch: Optional[bool] = None,
            log_format: Optional[str] = None,
            log_level: Optional[str] = None,
            log_min_status: Optional[int] = None,
            macros: Optional[Dict[str, 'AppMacro']] = None,
            no_paging: Optional[bool] = None) -> None:
        """Initializes with the given values."""
        self.config_path = config_path

        self.config_reload = config_reload

        self.config_watch = config_watch

        self.log_format = log_format

        self.log_level = log_level

        self.log_min_status = log_min_status

        self.macros = macros

        self.no_paging = no_paging

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to app_c_l_i_to_jsonable.

        :return: JSON-able representation
        """
        return app_c_l_i_to_jsonable(self)


def new_app_c_l_i() -> AppCLI:
    """Generates an instance of AppCLI with default values."""
    return AppCLI()


def app_c_l_i_from_obj(obj: Any, path: str = "") -> AppCLI:
    """
    Generates an instance of AppCLI from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of AppCLI
    :param path: path to the object used for debugging
    :return: parsed instance of AppCLI
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_config_path = obj.get('configPath', None)
    if obj_config_path is not None:
        config_path_from_obj = from_obj(
            obj_config_path,
            expected=[str],
            path=path + '.configPath')  # type: Optional[str]
    else:
        config_path_from_obj = None

    obj_config_reload = obj.get('configReload', None)
    if obj_config_reload is not None:
        config_reload_from_obj = from_obj(
            obj_config_reload,
            expected=[int],
            path=path + '.configReload')  # type: Optional[int]
    else:
        config_reload_from_obj = None

    obj_config_watch = obj.get('configWatch', None)
    if obj_config_watch is not None:
        config_watch_from_obj = from_obj(
            obj_config_watch,
            expected=[bool],
            path=path + '.configWatch')  # type: Optional[bool]
    else:
        config_watch_from_obj = None

    obj_log_format = obj.get('logFormat', None)
    if obj_log_format is not None:
        log_format_from_obj = from_obj(
            obj_log_format,
            expected=[str],
            path=path + '.logFormat')  # type: Optional[str]
    else:
        log_format_from_obj = None

    obj_log_level = obj.get('logLevel', None)
    if obj_log_level is not None:
        log_level_from_obj = from_obj(
            obj_log_level,
            expected=[str],
            path=path + '.logLevel')  # type: Optional[str]
    else:
        log_level_from_obj = None

    obj_log_min_status = obj.get('logMinStatus', None)
    if obj_log_min_status is not None:
        log_min_status_from_obj = from_obj(
            obj_log_min_status,
            expected=[int],
            path=path + '.logMinStatus')  # type: Optional[int]
    else:
        log_min_status_from_obj = None

    obj_macros = obj.get('macros', None)
    if obj_macros is not None:
        macros_from_obj = from_obj(
            obj_macros,
            expected=[dict, AppMacro],
            path=path + '.macros')  # type: Optional[Dict[str, 'AppMacro']]
    else:
        macros_from_obj = None

    obj_no_paging = obj.get('noPaging', None)
    if obj_no_paging is not None:
        no_paging_from_obj = from_obj(
            obj_no_paging,
            expected=[bool],
            path=path + '.noPaging')  # type: Optional[bool]
    else:
        no_paging_from_obj = None

    return AppCLI(
        config_path=config_path_from_obj,
        config_reload=config_reload_from_obj,
        config_watch=config_watch_from_obj,
        log_format=log_format_from_obj,
        log_level=log_level_from_obj,
        log_min_status=log_min_status_from_obj,
        macros=macros_from_obj,
        no_paging=no_paging_from_obj)


def app_c_l_i_to_jsonable(
        app_c_l_i: AppCLI,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of AppCLI.

    :param app_c_l_i: instance of AppCLI to be JSON-ized
    :param path: path to the app_c_l_i used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if app_c_l_i.config_path is not None:
        res['configPath'] = app_c_l_i.config_path

    if app_c_l_i.config_reload is not None:
        res['configReload'] = app_c_l_i.config_reload

    if app_c_l_i.config_watch is not None:
        res['configWatch'] = app_c_l_i.config_watch

    if app_c_l_i.log_format is not None:
        res['logFormat'] = app_c_l_i.log_format

    if app_c_l_i.log_level is not None:
        res['logLevel'] = app_c_l_i.log_level

    if app_c_l_i.log_min_status is not None:
        res['logMinStatus'] = app_c_l_i.log_min_status

    if app_c_l_i.macros is not None:
        res['macros'] = to_jsonable(
        app_c_l_i.macros,
        expected=[dict, AppMacro],
        path='{}.macros'.format(path))

    if app_c_l_i.no_paging is not None:
        res['noPaging'] = app_c_l_i.no_paging

    return res


class AppMacro:
    def __init__(
            self,
            arguments_optional: Optional[List[str]] = None,
            arguments_required: Optional[List[str]] = None,
            flags: Optional[Dict[str, 'AppMacroFlag']] = None,
            template: Optional[str] = None,
            usage: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.arguments_optional = arguments_optional

        self.arguments_required = arguments_required

        self.flags = flags

        self.template = template

        self.usage = usage

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to app_macro_to_jsonable.

        :return: JSON-able representation
        """
        return app_macro_to_jsonable(self)


def new_app_macro() -> AppMacro:
    """Generates an instance of AppMacro with default values."""
    return AppMacro()


def app_macro_from_obj(obj: Any, path: str = "") -> AppMacro:
    """
    Generates an instance of AppMacro from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of AppMacro
    :param path: path to the object used for debugging
    :return: parsed instance of AppMacro
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_arguments_optional = obj.get('argumentsOptional', None)
    if obj_arguments_optional is not None:
        arguments_optional_from_obj = from_obj(
            obj_arguments_optional,
            expected=[list, str],
            path=path + '.argumentsOptional')  # type: Optional[List[str]]
    else:
        arguments_optional_from_obj = None

    obj_arguments_required = obj.get('argumentsRequired', None)
    if obj_arguments_required is not None:
        arguments_required_from_obj = from_obj(
            obj_arguments_required,
            expected=[list, str],
            path=path + '.argumentsRequired')  # type: Optional[List[str]]
    else:
        arguments_required_from_obj = None

    obj_flags = obj.get('flags', None)
    if obj_flags is not None:
        flags_from_obj = from_obj(
            obj_flags,
            expected=[dict, AppMacroFlag],
            path=path + '.flags')  # type: Optional[Dict[str, 'AppMacroFlag']]
    else:
        flags_from_obj = None

    obj_template = obj.get('template', None)
    if obj_template is not None:
        template_from_obj = from_obj(
            obj_template,
            expected=[str],
            path=path + '.template')  # type: Optional[str]
    else:
        template_from_obj = None

    obj_usage = obj.get('usage', None)
    if obj_usage is not None:
        usage_from_obj = from_obj(
            obj_usage,
            expected=[str],
            path=path + '.usage')  # type: Optional[str]
    else:
        usage_from_obj = None

    return AppMacro(
        arguments_optional=arguments_optional_from_obj,
        arguments_required=arguments_required_from_obj,
        flags=flags_from_obj,
        template=template_from_obj,
        usage=usage_from_obj)


def app_macro_to_jsonable(
        app_macro: AppMacro,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of AppMacro.

    :param app_macro: instance of AppMacro to be JSON-ized
    :param path: path to the app_macro used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if app_macro.arguments_optional is not None:
        res['argumentsOptional'] = to_jsonable(
        app_macro.arguments_optional,
        expected=[list, str],
        path='{}.argumentsOptional'.format(path))

    if app_macro.arguments_required is not None:
        res['argumentsRequired'] = to_jsonable(
        app_macro.arguments_required,
        expected=[list, str],
        path='{}.argumentsRequired'.format(path))

    if app_macro.flags is not None:
        res['flags'] = to_jsonable(
        app_macro.flags,
        expected=[dict, AppMacroFlag],
        path='{}.flags'.format(path))

    if app_macro.template is not None:
        res['template'] = app_macro.template

    if app_macro.usage is not None:
        res['usage'] = app_macro.usage

    return res


class AppMacroFlag:
    def __init__(
            self,
            default: Optional[str] = None,
            options: Optional[List[str]] = None,
            placeholder: Optional[str] = None,
            usage: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.default = default

        self.options = options

        self.placeholder = placeholder

        self.usage = usage

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to app_macro_flag_to_jsonable.

        :return: JSON-able representation
        """
        return app_macro_flag_to_jsonable(self)


def new_app_macro_flag() -> AppMacroFlag:
    """Generates an instance of AppMacroFlag with default values."""
    return AppMacroFlag()


def app_macro_flag_from_obj(obj: Any, path: str = "") -> AppMacroFlag:
    """
    Generates an instance of AppMacroFlag from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of AppMacroFlag
    :param path: path to the object used for debugging
    :return: parsed instance of AppMacroFlag
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_default = obj.get('default', None)
    if obj_default is not None:
        default_from_obj = from_obj(
            obj_default,
            expected=[str],
            path=path + '.default')  # type: Optional[str]
    else:
        default_from_obj = None

    obj_options = obj.get('options', None)
    if obj_options is not None:
        options_from_obj = from_obj(
            obj_options,
            expected=[list, str],
            path=path + '.options')  # type: Optional[List[str]]
    else:
        options_from_obj = None

    obj_placeholder = obj.get('placeholder', None)
    if obj_placeholder is not None:
        placeholder_from_obj = from_obj(
            obj_placeholder,
            expected=[str],
            path=path + '.placeholder')  # type: Optional[str]
    else:
        placeholder_from_obj = None

    obj_usage = obj.get('usage', None)
    if obj_usage is not None:
        usage_from_obj = from_obj(
            obj_usage,
            expected=[str],
            path=path + '.usage')  # type: Optional[str]
    else:
        usage_from_obj = None

    return AppMacroFlag(
        default=default_from_obj,
        options=options_from_obj,
        placeholder=placeholder_from_obj,
        usage=usage_from_obj)


def app_macro_flag_to_jsonable(
        app_macro_flag: AppMacroFlag,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of AppMacroFlag.

    :param app_macro_flag: instance of AppMacroFlag to be JSON-ized
    :param path: path to the app_macro_flag used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if app_macro_flag.default is not None:
        res['default'] = app_macro_flag.default

    if app_macro_flag.options is not None:
        res['options'] = to_jsonable(
        app_macro_flag.options,
        expected=[list, str],
        path='{}.options'.format(path))

    if app_macro_flag.placeholder is not None:
        res['placeholder'] = app_macro_flag.placeholder

    if app_macro_flag.usage is not None:
        res['usage'] = app_macro_flag.usage

    return res


class CachesProvider:
    def __init__(
            self,
            memory_max_size_m_b: Optional[int] = None,
            ttl: Optional[int] = None,
            type: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.memory_max_size_m_b = memory_max_size_m_b

        self.ttl = ttl

        self.type = type

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to caches_provider_to_jsonable.

        :return: JSON-able representation
        """
        return caches_provider_to_jsonable(self)


def new_caches_provider() -> CachesProvider:
    """Generates an instance of CachesProvider with default values."""
    return CachesProvider()


def caches_provider_from_obj(obj: Any, path: str = "") -> CachesProvider:
    """
    Generates an instance of CachesProvider from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of CachesProvider
    :param path: path to the object used for debugging
    :return: parsed instance of CachesProvider
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_memory_max_size_m_b = obj.get('memoryMaxSizeMB', None)
    if obj_memory_max_size_m_b is not None:
        memory_max_size_m_b_from_obj = from_obj(
            obj_memory_max_size_m_b,
            expected=[int],
            path=path + '.memoryMaxSizeMB')  # type: Optional[int]
    else:
        memory_max_size_m_b_from_obj = None

    obj_ttl = obj.get('ttl', None)
    if obj_ttl is not None:
        ttl_from_obj = from_obj(
            obj_ttl,
            expected=[int],
            path=path + '.ttl')  # type: Optional[int]
    else:
        ttl_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    return CachesProvider(
        memory_max_size_m_b=memory_max_size_m_b_from_obj,
        ttl=ttl_from_obj,
        type=type_from_obj)


def caches_provider_to_jsonable(
        caches_provider: CachesProvider,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of CachesProvider.

    :param caches_provider: instance of CachesProvider to be JSON-ized
    :param path: path to the caches_provider used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if caches_provider.memory_max_size_m_b is not None:
        res['memoryMaxSizeMB'] = caches_provider.memory_max_size_m_b

    if caches_provider.ttl is not None:
        res['ttl'] = caches_provider.ttl

    if caches_provider.type is not None:
        res['type'] = caches_provider.type

    return res


class ConfigApp:
    def __init__(
            self,
            admin_email_addresses: Optional[List[str]] = None,
            admin_trusted_c_id_rs: Optional[List[str]] = None,
            base_url: Optional[str] = None,
            cache_control: Optional[str] = None,
            cloud_dev_key: Optional[bool] = None,
            cloud_endpoint: Optional[str] = None,
            cloud_j_w_t: Optional[str] = None,
            cloud_private_key: Optional[Any] = None,
            contact_feedback: Optional[str] = None,
            contact_support: Optional[str] = None,
            counter_time_zone: Optional[str] = None,
            demo: Optional[bool] = None,
            disable_notifications: Optional[bool] = None,
            disable_signup: Optional[bool] = None,
            disable_tasks: Optional[bool] = None,
            disable_web_config: Optional[bool] = None,
            enable_custom_a_p_i: Optional[bool] = None,
            enable_demo: Optional[bool] = None,
            ignore_payment_failures: Optional[bool] = None,
            keep_calendar_event_days: Optional[int] = None,
            keep_cook_meal_plan_days: Optional[int] = None,
            keep_deleted_days: Optional[int] = None,
            keep_expired_auth_household_days: Optional[int] = None,
            keep_health_log_item_days: Optional[int] = None,
            keep_health_log_metric_months: Optional[int] = None,
            keep_inactive_auth_account_days: Optional[int] = None,
            keep_notes_page_versions: Optional[int] = None,
            keep_plan_task_days: Optional[int] = None,
            motd: Optional[str] = None,
            private_keys: Optional[List['CryptolibKeyCryptolibKeyProviderPrivate']] = None,
            proxy_address: Optional[str] = None,
            proxy_header_email: Optional[str] = None,
            proxy_header_name: Optional[str] = None,
            rollup_budget_month_categories_months: Optional[int] = None,
            rollup_budget_transactions_balance_months: Optional[int] = None,
            rollup_budget_transactions_summary_months: Optional[int] = None,
            rollup_health_log_metrics_days: Optional[int] = None,
            rollup_health_log_metrics_months: Optional[int] = None,
            session_expiration_default: Optional[int] = None,
            session_expiration_remember: Optional[int] = None,
            sse_timeout: Optional[int] = None,
            system_client_key: Optional[str] = None,
            system_health_key: Optional[str] = None,
            system_metrics_key: Optional[str] = None,
            system_pprof_key: Optional[str] = None,
            trial_days: Optional[int] = None,
            ui_dir: Optional[str] = None,
            ui_host: Optional[str] = None,
            well_known_responses: Optional[Dict[str, 'ConfigWellKnownResponse']] = None) -> None:
        """Initializes with the given values."""
        self.admin_email_addresses = admin_email_addresses

        self.admin_trusted_c_id_rs = admin_trusted_c_id_rs

        self.base_url = base_url

        self.cache_control = cache_control

        self.cloud_dev_key = cloud_dev_key

        self.cloud_endpoint = cloud_endpoint

        # nolint: tagliatelle
        self.cloud_j_w_t = cloud_j_w_t

        # nolint: tagliatelle
        self.cloud_private_key = cloud_private_key

        self.contact_feedback = contact_feedback

        self.contact_support = contact_support

        self.counter_time_zone = counter_time_zone

        # TODO remove 2026-02-27
        #
        # Deprecated: use EnableDemo
        self.demo = demo

        self.disable_notifications = disable_notifications

        self.disable_signup = disable_signup

        self.disable_tasks = disable_tasks

        self.disable_web_config = disable_web_config

        self.enable_custom_a_p_i = enable_custom_a_p_i

        self.enable_demo = enable_demo

        self.ignore_payment_failures = ignore_payment_failures

        self.keep_calendar_event_days = keep_calendar_event_days

        self.keep_cook_meal_plan_days = keep_cook_meal_plan_days

        self.keep_deleted_days = keep_deleted_days

        self.keep_expired_auth_household_days = keep_expired_auth_household_days

        self.keep_health_log_item_days = keep_health_log_item_days

        self.keep_health_log_metric_months = keep_health_log_metric_months

        self.keep_inactive_auth_account_days = keep_inactive_auth_account_days

        self.keep_notes_page_versions = keep_notes_page_versions

        self.keep_plan_task_days = keep_plan_task_days

        self.motd = motd

        self.private_keys = private_keys

        self.proxy_address = proxy_address

        self.proxy_header_email = proxy_header_email

        self.proxy_header_name = proxy_header_name

        self.rollup_budget_month_categories_months = rollup_budget_month_categories_months

        self.rollup_budget_transactions_balance_months = rollup_budget_transactions_balance_months

        self.rollup_budget_transactions_summary_months = rollup_budget_transactions_summary_months

        self.rollup_health_log_metrics_days = rollup_health_log_metrics_days

        self.rollup_health_log_metrics_months = rollup_health_log_metrics_months

        self.session_expiration_default = session_expiration_default

        self.session_expiration_remember = session_expiration_remember

        self.sse_timeout = sse_timeout

        self.system_client_key = system_client_key

        self.system_health_key = system_health_key

        self.system_metrics_key = system_metrics_key

        self.system_pprof_key = system_pprof_key

        self.trial_days = trial_days

        self.ui_dir = ui_dir

        self.ui_host = ui_host

        self.well_known_responses = well_known_responses

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to config_app_to_jsonable.

        :return: JSON-able representation
        """
        return config_app_to_jsonable(self)


def new_config_app() -> ConfigApp:
    """Generates an instance of ConfigApp with default values."""
    return ConfigApp()


def config_app_from_obj(obj: Any, path: str = "") -> ConfigApp:
    """
    Generates an instance of ConfigApp from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ConfigApp
    :param path: path to the object used for debugging
    :return: parsed instance of ConfigApp
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_admin_email_addresses = obj.get('adminEmailAddresses', None)
    if obj_admin_email_addresses is not None:
        admin_email_addresses_from_obj = from_obj(
            obj_admin_email_addresses,
            expected=[list, str],
            path=path + '.adminEmailAddresses')  # type: Optional[List[str]]
    else:
        admin_email_addresses_from_obj = None

    obj_admin_trusted_c_id_rs = obj.get('adminTrustedCIDRs', None)
    if obj_admin_trusted_c_id_rs is not None:
        admin_trusted_c_id_rs_from_obj = from_obj(
            obj_admin_trusted_c_id_rs,
            expected=[list, str],
            path=path + '.adminTrustedCIDRs')  # type: Optional[List[str]]
    else:
        admin_trusted_c_id_rs_from_obj = None

    obj_base_url = obj.get('baseURL', None)
    if obj_base_url is not None:
        base_url_from_obj = from_obj(
            obj_base_url,
            expected=[str],
            path=path + '.baseURL')  # type: Optional[str]
    else:
        base_url_from_obj = None

    obj_cache_control = obj.get('cacheControl', None)
    if obj_cache_control is not None:
        cache_control_from_obj = from_obj(
            obj_cache_control,
            expected=[str],
            path=path + '.cacheControl')  # type: Optional[str]
    else:
        cache_control_from_obj = None

    obj_cloud_dev_key = obj.get('cloudDevKey', None)
    if obj_cloud_dev_key is not None:
        cloud_dev_key_from_obj = from_obj(
            obj_cloud_dev_key,
            expected=[bool],
            path=path + '.cloudDevKey')  # type: Optional[bool]
    else:
        cloud_dev_key_from_obj = None

    obj_cloud_endpoint = obj.get('cloudEndpoint', None)
    if obj_cloud_endpoint is not None:
        cloud_endpoint_from_obj = from_obj(
            obj_cloud_endpoint,
            expected=[str],
            path=path + '.cloudEndpoint')  # type: Optional[str]
    else:
        cloud_endpoint_from_obj = None

    obj_cloud_j_w_t = obj.get('cloudJWT', None)
    if obj_cloud_j_w_t is not None:
        cloud_j_w_t_from_obj = from_obj(
            obj_cloud_j_w_t,
            expected=[str],
            path=path + '.cloudJWT')  # type: Optional[str]
    else:
        cloud_j_w_t_from_obj = None

    cloud_private_key_from_obj = obj.get('cloudPrivateKey', None)

    obj_contact_feedback = obj.get('contactFeedback', None)
    if obj_contact_feedback is not None:
        contact_feedback_from_obj = from_obj(
            obj_contact_feedback,
            expected=[str],
            path=path + '.contactFeedback')  # type: Optional[str]
    else:
        contact_feedback_from_obj = None

    obj_contact_support = obj.get('contactSupport', None)
    if obj_contact_support is not None:
        contact_support_from_obj = from_obj(
            obj_contact_support,
            expected=[str],
            path=path + '.contactSupport')  # type: Optional[str]
    else:
        contact_support_from_obj = None

    obj_counter_time_zone = obj.get('counterTimeZone', None)
    if obj_counter_time_zone is not None:
        counter_time_zone_from_obj = from_obj(
            obj_counter_time_zone,
            expected=[str],
            path=path + '.counterTimeZone')  # type: Optional[str]
    else:
        counter_time_zone_from_obj = None

    obj_demo = obj.get('demo', None)
    if obj_demo is not None:
        demo_from_obj = from_obj(
            obj_demo,
            expected=[bool],
            path=path + '.demo')  # type: Optional[bool]
    else:
        demo_from_obj = None

    obj_disable_notifications = obj.get('disableNotifications', None)
    if obj_disable_notifications is not None:
        disable_notifications_from_obj = from_obj(
            obj_disable_notifications,
            expected=[bool],
            path=path + '.disableNotifications')  # type: Optional[bool]
    else:
        disable_notifications_from_obj = None

    obj_disable_signup = obj.get('disableSignup', None)
    if obj_disable_signup is not None:
        disable_signup_from_obj = from_obj(
            obj_disable_signup,
            expected=[bool],
            path=path + '.disableSignup')  # type: Optional[bool]
    else:
        disable_signup_from_obj = None

    obj_disable_tasks = obj.get('disableTasks', None)
    if obj_disable_tasks is not None:
        disable_tasks_from_obj = from_obj(
            obj_disable_tasks,
            expected=[bool],
            path=path + '.disableTasks')  # type: Optional[bool]
    else:
        disable_tasks_from_obj = None

    obj_disable_web_config = obj.get('disableWebConfig', None)
    if obj_disable_web_config is not None:
        disable_web_config_from_obj = from_obj(
            obj_disable_web_config,
            expected=[bool],
            path=path + '.disableWebConfig')  # type: Optional[bool]
    else:
        disable_web_config_from_obj = None

    obj_enable_custom_a_p_i = obj.get('enableCustomAPI', None)
    if obj_enable_custom_a_p_i is not None:
        enable_custom_a_p_i_from_obj = from_obj(
            obj_enable_custom_a_p_i,
            expected=[bool],
            path=path + '.enableCustomAPI')  # type: Optional[bool]
    else:
        enable_custom_a_p_i_from_obj = None

    obj_enable_demo = obj.get('enableDemo', None)
    if obj_enable_demo is not None:
        enable_demo_from_obj = from_obj(
            obj_enable_demo,
            expected=[bool],
            path=path + '.enableDemo')  # type: Optional[bool]
    else:
        enable_demo_from_obj = None

    obj_ignore_payment_failures = obj.get('ignorePaymentFailures', None)
    if obj_ignore_payment_failures is not None:
        ignore_payment_failures_from_obj = from_obj(
            obj_ignore_payment_failures,
            expected=[bool],
            path=path + '.ignorePaymentFailures')  # type: Optional[bool]
    else:
        ignore_payment_failures_from_obj = None

    obj_keep_calendar_event_days = obj.get('keepCalendarEventDays', None)
    if obj_keep_calendar_event_days is not None:
        keep_calendar_event_days_from_obj = from_obj(
            obj_keep_calendar_event_days,
            expected=[int],
            path=path + '.keepCalendarEventDays')  # type: Optional[int]
    else:
        keep_calendar_event_days_from_obj = None

    obj_keep_cook_meal_plan_days = obj.get('keepCookMealPlanDays', None)
    if obj_keep_cook_meal_plan_days is not None:
        keep_cook_meal_plan_days_from_obj = from_obj(
            obj_keep_cook_meal_plan_days,
            expected=[int],
            path=path + '.keepCookMealPlanDays')  # type: Optional[int]
    else:
        keep_cook_meal_plan_days_from_obj = None

    obj_keep_deleted_days = obj.get('keepDeletedDays', None)
    if obj_keep_deleted_days is not None:
        keep_deleted_days_from_obj = from_obj(
            obj_keep_deleted_days,
            expected=[int],
            path=path + '.keepDeletedDays')  # type: Optional[int]
    else:
        keep_deleted_days_from_obj = None

    obj_keep_expired_auth_household_days = obj.get('keepExpiredAuthHouseholdDays', None)
    if obj_keep_expired_auth_household_days is not None:
        keep_expired_auth_household_days_from_obj = from_obj(
            obj_keep_expired_auth_household_days,
            expected=[int],
            path=path + '.keepExpiredAuthHouseholdDays')  # type: Optional[int]
    else:
        keep_expired_auth_household_days_from_obj = None

    obj_keep_health_log_item_days = obj.get('keepHealthLogItemDays', None)
    if obj_keep_health_log_item_days is not None:
        keep_health_log_item_days_from_obj = from_obj(
            obj_keep_health_log_item_days,
            expected=[int],
            path=path + '.keepHealthLogItemDays')  # type: Optional[int]
    else:
        keep_health_log_item_days_from_obj = None

    obj_keep_health_log_metric_months = obj.get('keepHealthLogMetricMonths', None)
    if obj_keep_health_log_metric_months is not None:
        keep_health_log_metric_months_from_obj = from_obj(
            obj_keep_health_log_metric_months,
            expected=[int],
            path=path + '.keepHealthLogMetricMonths')  # type: Optional[int]
    else:
        keep_health_log_metric_months_from_obj = None

    obj_keep_inactive_auth_account_days = obj.get('keepInactiveAuthAccountDays', None)
    if obj_keep_inactive_auth_account_days is not None:
        keep_inactive_auth_account_days_from_obj = from_obj(
            obj_keep_inactive_auth_account_days,
            expected=[int],
            path=path + '.keepInactiveAuthAccountDays')  # type: Optional[int]
    else:
        keep_inactive_auth_account_days_from_obj = None

    obj_keep_notes_page_versions = obj.get('keepNotesPageVersions', None)
    if obj_keep_notes_page_versions is not None:
        keep_notes_page_versions_from_obj = from_obj(
            obj_keep_notes_page_versions,
            expected=[int],
            path=path + '.keepNotesPageVersions')  # type: Optional[int]
    else:
        keep_notes_page_versions_from_obj = None

    obj_keep_plan_task_days = obj.get('keepPlanTaskDays', None)
    if obj_keep_plan_task_days is not None:
        keep_plan_task_days_from_obj = from_obj(
            obj_keep_plan_task_days,
            expected=[int],
            path=path + '.keepPlanTaskDays')  # type: Optional[int]
    else:
        keep_plan_task_days_from_obj = None

    obj_motd = obj.get('motd', None)
    if obj_motd is not None:
        motd_from_obj = from_obj(
            obj_motd,
            expected=[str],
            path=path + '.motd')  # type: Optional[str]
    else:
        motd_from_obj = None

    obj_private_keys = obj.get('privateKeys', None)
    if obj_private_keys is not None:
        private_keys_from_obj = from_obj(
            obj_private_keys,
            expected=[list, CryptolibKeyCryptolibKeyProviderPrivate],
            path=path + '.privateKeys')  # type: Optional[List['CryptolibKeyCryptolibKeyProviderPrivate']]
    else:
        private_keys_from_obj = None

    obj_proxy_address = obj.get('proxyAddress', None)
    if obj_proxy_address is not None:
        proxy_address_from_obj = from_obj(
            obj_proxy_address,
            expected=[str],
            path=path + '.proxyAddress')  # type: Optional[str]
    else:
        proxy_address_from_obj = None

    obj_proxy_header_email = obj.get('proxyHeaderEmail', None)
    if obj_proxy_header_email is not None:
        proxy_header_email_from_obj = from_obj(
            obj_proxy_header_email,
            expected=[str],
            path=path + '.proxyHeaderEmail')  # type: Optional[str]
    else:
        proxy_header_email_from_obj = None

    obj_proxy_header_name = obj.get('proxyHeaderName', None)
    if obj_proxy_header_name is not None:
        proxy_header_name_from_obj = from_obj(
            obj_proxy_header_name,
            expected=[str],
            path=path + '.proxyHeaderName')  # type: Optional[str]
    else:
        proxy_header_name_from_obj = None

    obj_rollup_budget_month_categories_months = obj.get('rollupBudgetMonthCategoriesMonths', None)
    if obj_rollup_budget_month_categories_months is not None:
        rollup_budget_month_categories_months_from_obj = from_obj(
            obj_rollup_budget_month_categories_months,
            expected=[int],
            path=path + '.rollupBudgetMonthCategoriesMonths')  # type: Optional[int]
    else:
        rollup_budget_month_categories_months_from_obj = None

    obj_rollup_budget_transactions_balance_months = obj.get('rollupBudgetTransactionsBalanceMonths', None)
    if obj_rollup_budget_transactions_balance_months is not None:
        rollup_budget_transactions_balance_months_from_obj = from_obj(
            obj_rollup_budget_transactions_balance_months,
            expected=[int],
            path=path + '.rollupBudgetTransactionsBalanceMonths')  # type: Optional[int]
    else:
        rollup_budget_transactions_balance_months_from_obj = None

    obj_rollup_budget_transactions_summary_months = obj.get('rollupBudgetTransactionsSummaryMonths', None)
    if obj_rollup_budget_transactions_summary_months is not None:
        rollup_budget_transactions_summary_months_from_obj = from_obj(
            obj_rollup_budget_transactions_summary_months,
            expected=[int],
            path=path + '.rollupBudgetTransactionsSummaryMonths')  # type: Optional[int]
    else:
        rollup_budget_transactions_summary_months_from_obj = None

    obj_rollup_health_log_metrics_days = obj.get('rollupHealthLogMetricsDays', None)
    if obj_rollup_health_log_metrics_days is not None:
        rollup_health_log_metrics_days_from_obj = from_obj(
            obj_rollup_health_log_metrics_days,
            expected=[int],
            path=path + '.rollupHealthLogMetricsDays')  # type: Optional[int]
    else:
        rollup_health_log_metrics_days_from_obj = None

    obj_rollup_health_log_metrics_months = obj.get('rollupHealthLogMetricsMonths', None)
    if obj_rollup_health_log_metrics_months is not None:
        rollup_health_log_metrics_months_from_obj = from_obj(
            obj_rollup_health_log_metrics_months,
            expected=[int],
            path=path + '.rollupHealthLogMetricsMonths')  # type: Optional[int]
    else:
        rollup_health_log_metrics_months_from_obj = None

    obj_session_expiration_default = obj.get('sessionExpirationDefault', None)
    if obj_session_expiration_default is not None:
        session_expiration_default_from_obj = from_obj(
            obj_session_expiration_default,
            expected=[int],
            path=path + '.sessionExpirationDefault')  # type: Optional[int]
    else:
        session_expiration_default_from_obj = None

    obj_session_expiration_remember = obj.get('sessionExpirationRemember', None)
    if obj_session_expiration_remember is not None:
        session_expiration_remember_from_obj = from_obj(
            obj_session_expiration_remember,
            expected=[int],
            path=path + '.sessionExpirationRemember')  # type: Optional[int]
    else:
        session_expiration_remember_from_obj = None

    obj_sse_timeout = obj.get('sseTimeout', None)
    if obj_sse_timeout is not None:
        sse_timeout_from_obj = from_obj(
            obj_sse_timeout,
            expected=[int],
            path=path + '.sseTimeout')  # type: Optional[int]
    else:
        sse_timeout_from_obj = None

    obj_system_client_key = obj.get('systemClientKey', None)
    if obj_system_client_key is not None:
        system_client_key_from_obj = from_obj(
            obj_system_client_key,
            expected=[str],
            path=path + '.systemClientKey')  # type: Optional[str]
    else:
        system_client_key_from_obj = None

    obj_system_health_key = obj.get('systemHealthKey', None)
    if obj_system_health_key is not None:
        system_health_key_from_obj = from_obj(
            obj_system_health_key,
            expected=[str],
            path=path + '.systemHealthKey')  # type: Optional[str]
    else:
        system_health_key_from_obj = None

    obj_system_metrics_key = obj.get('systemMetricsKey', None)
    if obj_system_metrics_key is not None:
        system_metrics_key_from_obj = from_obj(
            obj_system_metrics_key,
            expected=[str],
            path=path + '.systemMetricsKey')  # type: Optional[str]
    else:
        system_metrics_key_from_obj = None

    obj_system_pprof_key = obj.get('systemPprofKey', None)
    if obj_system_pprof_key is not None:
        system_pprof_key_from_obj = from_obj(
            obj_system_pprof_key,
            expected=[str],
            path=path + '.systemPprofKey')  # type: Optional[str]
    else:
        system_pprof_key_from_obj = None

    obj_trial_days = obj.get('trialDays', None)
    if obj_trial_days is not None:
        trial_days_from_obj = from_obj(
            obj_trial_days,
            expected=[int],
            path=path + '.trialDays')  # type: Optional[int]
    else:
        trial_days_from_obj = None

    obj_ui_dir = obj.get('uiDir', None)
    if obj_ui_dir is not None:
        ui_dir_from_obj = from_obj(
            obj_ui_dir,
            expected=[str],
            path=path + '.uiDir')  # type: Optional[str]
    else:
        ui_dir_from_obj = None

    obj_ui_host = obj.get('uiHost', None)
    if obj_ui_host is not None:
        ui_host_from_obj = from_obj(
            obj_ui_host,
            expected=[str],
            path=path + '.uiHost')  # type: Optional[str]
    else:
        ui_host_from_obj = None

    obj_well_known_responses = obj.get('wellKnownResponses', None)
    if obj_well_known_responses is not None:
        well_known_responses_from_obj = from_obj(
            obj_well_known_responses,
            expected=[dict, ConfigWellKnownResponse],
            path=path + '.wellKnownResponses')  # type: Optional[Dict[str, 'ConfigWellKnownResponse']]
    else:
        well_known_responses_from_obj = None

    return ConfigApp(
        admin_email_addresses=admin_email_addresses_from_obj,
        admin_trusted_c_id_rs=admin_trusted_c_id_rs_from_obj,
        base_url=base_url_from_obj,
        cache_control=cache_control_from_obj,
        cloud_dev_key=cloud_dev_key_from_obj,
        cloud_endpoint=cloud_endpoint_from_obj,
        cloud_j_w_t=cloud_j_w_t_from_obj,
        cloud_private_key=cloud_private_key_from_obj,
        contact_feedback=contact_feedback_from_obj,
        contact_support=contact_support_from_obj,
        counter_time_zone=counter_time_zone_from_obj,
        demo=demo_from_obj,
        disable_notifications=disable_notifications_from_obj,
        disable_signup=disable_signup_from_obj,
        disable_tasks=disable_tasks_from_obj,
        disable_web_config=disable_web_config_from_obj,
        enable_custom_a_p_i=enable_custom_a_p_i_from_obj,
        enable_demo=enable_demo_from_obj,
        ignore_payment_failures=ignore_payment_failures_from_obj,
        keep_calendar_event_days=keep_calendar_event_days_from_obj,
        keep_cook_meal_plan_days=keep_cook_meal_plan_days_from_obj,
        keep_deleted_days=keep_deleted_days_from_obj,
        keep_expired_auth_household_days=keep_expired_auth_household_days_from_obj,
        keep_health_log_item_days=keep_health_log_item_days_from_obj,
        keep_health_log_metric_months=keep_health_log_metric_months_from_obj,
        keep_inactive_auth_account_days=keep_inactive_auth_account_days_from_obj,
        keep_notes_page_versions=keep_notes_page_versions_from_obj,
        keep_plan_task_days=keep_plan_task_days_from_obj,
        motd=motd_from_obj,
        private_keys=private_keys_from_obj,
        proxy_address=proxy_address_from_obj,
        proxy_header_email=proxy_header_email_from_obj,
        proxy_header_name=proxy_header_name_from_obj,
        rollup_budget_month_categories_months=rollup_budget_month_categories_months_from_obj,
        rollup_budget_transactions_balance_months=rollup_budget_transactions_balance_months_from_obj,
        rollup_budget_transactions_summary_months=rollup_budget_transactions_summary_months_from_obj,
        rollup_health_log_metrics_days=rollup_health_log_metrics_days_from_obj,
        rollup_health_log_metrics_months=rollup_health_log_metrics_months_from_obj,
        session_expiration_default=session_expiration_default_from_obj,
        session_expiration_remember=session_expiration_remember_from_obj,
        sse_timeout=sse_timeout_from_obj,
        system_client_key=system_client_key_from_obj,
        system_health_key=system_health_key_from_obj,
        system_metrics_key=system_metrics_key_from_obj,
        system_pprof_key=system_pprof_key_from_obj,
        trial_days=trial_days_from_obj,
        ui_dir=ui_dir_from_obj,
        ui_host=ui_host_from_obj,
        well_known_responses=well_known_responses_from_obj)


def config_app_to_jsonable(
        config_app: ConfigApp,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ConfigApp.

    :param config_app: instance of ConfigApp to be JSON-ized
    :param path: path to the config_app used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if config_app.admin_email_addresses is not None:
        res['adminEmailAddresses'] = to_jsonable(
        config_app.admin_email_addresses,
        expected=[list, str],
        path='{}.adminEmailAddresses'.format(path))

    if config_app.admin_trusted_c_id_rs is not None:
        res['adminTrustedCIDRs'] = to_jsonable(
        config_app.admin_trusted_c_id_rs,
        expected=[list, str],
        path='{}.adminTrustedCIDRs'.format(path))

    if config_app.base_url is not None:
        res['baseURL'] = config_app.base_url

    if config_app.cache_control is not None:
        res['cacheControl'] = config_app.cache_control

    if config_app.cloud_dev_key is not None:
        res['cloudDevKey'] = config_app.cloud_dev_key

    if config_app.cloud_endpoint is not None:
        res['cloudEndpoint'] = config_app.cloud_endpoint

    if config_app.cloud_j_w_t is not None:
        res['cloudJWT'] = config_app.cloud_j_w_t

    if config_app.cloud_private_key is not None:
        res['cloudPrivateKey'] = config_app.cloud_private_key

    if config_app.contact_feedback is not None:
        res['contactFeedback'] = config_app.contact_feedback

    if config_app.contact_support is not None:
        res['contactSupport'] = config_app.contact_support

    if config_app.counter_time_zone is not None:
        res['counterTimeZone'] = config_app.counter_time_zone

    if config_app.demo is not None:
        res['demo'] = config_app.demo

    if config_app.disable_notifications is not None:
        res['disableNotifications'] = config_app.disable_notifications

    if config_app.disable_signup is not None:
        res['disableSignup'] = config_app.disable_signup

    if config_app.disable_tasks is not None:
        res['disableTasks'] = config_app.disable_tasks

    if config_app.disable_web_config is not None:
        res['disableWebConfig'] = config_app.disable_web_config

    if config_app.enable_custom_a_p_i is not None:
        res['enableCustomAPI'] = config_app.enable_custom_a_p_i

    if config_app.enable_demo is not None:
        res['enableDemo'] = config_app.enable_demo

    if config_app.ignore_payment_failures is not None:
        res['ignorePaymentFailures'] = config_app.ignore_payment_failures

    if config_app.keep_calendar_event_days is not None:
        res['keepCalendarEventDays'] = config_app.keep_calendar_event_days

    if config_app.keep_cook_meal_plan_days is not None:
        res['keepCookMealPlanDays'] = config_app.keep_cook_meal_plan_days

    if config_app.keep_deleted_days is not None:
        res['keepDeletedDays'] = config_app.keep_deleted_days

    if config_app.keep_expired_auth_household_days is not None:
        res['keepExpiredAuthHouseholdDays'] = config_app.keep_expired_auth_household_days

    if config_app.keep_health_log_item_days is not None:
        res['keepHealthLogItemDays'] = config_app.keep_health_log_item_days

    if config_app.keep_health_log_metric_months is not None:
        res['keepHealthLogMetricMonths'] = config_app.keep_health_log_metric_months

    if config_app.keep_inactive_auth_account_days is not None:
        res['keepInactiveAuthAccountDays'] = config_app.keep_inactive_auth_account_days

    if config_app.keep_notes_page_versions is not None:
        res['keepNotesPageVersions'] = config_app.keep_notes_page_versions

    if config_app.keep_plan_task_days is not None:
        res['keepPlanTaskDays'] = config_app.keep_plan_task_days

    if config_app.motd is not None:
        res['motd'] = config_app.motd

    if config_app.private_keys is not None:
        res['privateKeys'] = to_jsonable(
        config_app.private_keys,
        expected=[list, CryptolibKeyCryptolibKeyProviderPrivate],
        path='{}.privateKeys'.format(path))

    if config_app.proxy_address is not None:
        res['proxyAddress'] = config_app.proxy_address

    if config_app.proxy_header_email is not None:
        res['proxyHeaderEmail'] = config_app.proxy_header_email

    if config_app.proxy_header_name is not None:
        res['proxyHeaderName'] = config_app.proxy_header_name

    if config_app.rollup_budget_month_categories_months is not None:
        res['rollupBudgetMonthCategoriesMonths'] = config_app.rollup_budget_month_categories_months

    if config_app.rollup_budget_transactions_balance_months is not None:
        res['rollupBudgetTransactionsBalanceMonths'] = config_app.rollup_budget_transactions_balance_months

    if config_app.rollup_budget_transactions_summary_months is not None:
        res['rollupBudgetTransactionsSummaryMonths'] = config_app.rollup_budget_transactions_summary_months

    if config_app.rollup_health_log_metrics_days is not None:
        res['rollupHealthLogMetricsDays'] = config_app.rollup_health_log_metrics_days

    if config_app.rollup_health_log_metrics_months is not None:
        res['rollupHealthLogMetricsMonths'] = config_app.rollup_health_log_metrics_months

    if config_app.session_expiration_default is not None:
        res['sessionExpirationDefault'] = config_app.session_expiration_default

    if config_app.session_expiration_remember is not None:
        res['sessionExpirationRemember'] = config_app.session_expiration_remember

    if config_app.sse_timeout is not None:
        res['sseTimeout'] = config_app.sse_timeout

    if config_app.system_client_key is not None:
        res['systemClientKey'] = config_app.system_client_key

    if config_app.system_health_key is not None:
        res['systemHealthKey'] = config_app.system_health_key

    if config_app.system_metrics_key is not None:
        res['systemMetricsKey'] = config_app.system_metrics_key

    if config_app.system_pprof_key is not None:
        res['systemPprofKey'] = config_app.system_pprof_key

    if config_app.trial_days is not None:
        res['trialDays'] = config_app.trial_days

    if config_app.ui_dir is not None:
        res['uiDir'] = config_app.ui_dir

    if config_app.ui_host is not None:
        res['uiHost'] = config_app.ui_host

    if config_app.well_known_responses is not None:
        res['wellKnownResponses'] = to_jsonable(
        config_app.well_known_responses,
        expected=[dict, ConfigWellKnownResponse],
        path='{}.wellKnownResponses'.format(path))

    return res


class ConfigCloud:
    def __init__(
            self,
            apn: Optional['NotifyAPN'] = None,
            payments: Optional['ConfigCloudPayments'] = None) -> None:
        """Initializes with the given values."""
        self.apn = apn

        self.payments = payments

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to config_cloud_to_jsonable.

        :return: JSON-able representation
        """
        return config_cloud_to_jsonable(self)


def new_config_cloud() -> ConfigCloud:
    """Generates an instance of ConfigCloud with default values."""
    return ConfigCloud()


def config_cloud_from_obj(obj: Any, path: str = "") -> ConfigCloud:
    """
    Generates an instance of ConfigCloud from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ConfigCloud
    :param path: path to the object used for debugging
    :return: parsed instance of ConfigCloud
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_apn = obj.get('apn', None)
    if obj_apn is not None:
        apn_from_obj = from_obj(
            obj_apn,
            expected=[NotifyAPN],
            path=path + '.apn')  # type: Optional['NotifyAPN']
    else:
        apn_from_obj = None

    obj_payments = obj.get('payments', None)
    if obj_payments is not None:
        payments_from_obj = from_obj(
            obj_payments,
            expected=[ConfigCloudPayments],
            path=path + '.payments')  # type: Optional['ConfigCloudPayments']
    else:
        payments_from_obj = None

    return ConfigCloud(
        apn=apn_from_obj,
        payments=payments_from_obj)


def config_cloud_to_jsonable(
        config_cloud: ConfigCloud,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ConfigCloud.

    :param config_cloud: instance of ConfigCloud to be JSON-ized
    :param path: path to the config_cloud used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if config_cloud.apn is not None:
        res['apn'] = to_jsonable(
        config_cloud.apn,
        expected=[NotifyAPN],
        path='{}.apn'.format(path))

    if config_cloud.payments is not None:
        res['payments'] = to_jsonable(
        config_cloud.payments,
        expected=[ConfigCloudPayments],
        path='{}.payments'.format(path))

    return res


class ConfigCloudPayments:
    def __init__(
            self,
            apple: Optional['PaymentsApple'] = None,
            google: Optional['PaymentsGoogle'] = None,
            ignore_missing: Optional[bool] = None,
            paddle: Optional['PaymentsPaddle'] = None) -> None:
        """Initializes with the given values."""
        self.apple = apple

        self.google = google

        self.ignore_missing = ignore_missing

        self.paddle = paddle

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to config_cloud_payments_to_jsonable.

        :return: JSON-able representation
        """
        return config_cloud_payments_to_jsonable(self)


def new_config_cloud_payments() -> ConfigCloudPayments:
    """Generates an instance of ConfigCloudPayments with default values."""
    return ConfigCloudPayments()


def config_cloud_payments_from_obj(obj: Any, path: str = "") -> ConfigCloudPayments:
    """
    Generates an instance of ConfigCloudPayments from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ConfigCloudPayments
    :param path: path to the object used for debugging
    :return: parsed instance of ConfigCloudPayments
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_apple = obj.get('apple', None)
    if obj_apple is not None:
        apple_from_obj = from_obj(
            obj_apple,
            expected=[PaymentsApple],
            path=path + '.apple')  # type: Optional['PaymentsApple']
    else:
        apple_from_obj = None

    obj_google = obj.get('google', None)
    if obj_google is not None:
        google_from_obj = from_obj(
            obj_google,
            expected=[PaymentsGoogle],
            path=path + '.google')  # type: Optional['PaymentsGoogle']
    else:
        google_from_obj = None

    obj_ignore_missing = obj.get('ignoreMissing', None)
    if obj_ignore_missing is not None:
        ignore_missing_from_obj = from_obj(
            obj_ignore_missing,
            expected=[bool],
            path=path + '.ignoreMissing')  # type: Optional[bool]
    else:
        ignore_missing_from_obj = None

    obj_paddle = obj.get('paddle', None)
    if obj_paddle is not None:
        paddle_from_obj = from_obj(
            obj_paddle,
            expected=[PaymentsPaddle],
            path=path + '.paddle')  # type: Optional['PaymentsPaddle']
    else:
        paddle_from_obj = None

    return ConfigCloudPayments(
        apple=apple_from_obj,
        google=google_from_obj,
        ignore_missing=ignore_missing_from_obj,
        paddle=paddle_from_obj)


def config_cloud_payments_to_jsonable(
        config_cloud_payments: ConfigCloudPayments,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ConfigCloudPayments.

    :param config_cloud_payments: instance of ConfigCloudPayments to be JSON-ized
    :param path: path to the config_cloud_payments used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if config_cloud_payments.apple is not None:
        res['apple'] = to_jsonable(
        config_cloud_payments.apple,
        expected=[PaymentsApple],
        path='{}.apple'.format(path))

    if config_cloud_payments.google is not None:
        res['google'] = to_jsonable(
        config_cloud_payments.google,
        expected=[PaymentsGoogle],
        path='{}.google'.format(path))

    if config_cloud_payments.ignore_missing is not None:
        res['ignoreMissing'] = config_cloud_payments.ignore_missing

    if config_cloud_payments.paddle is not None:
        res['paddle'] = to_jsonable(
        config_cloud_payments.paddle,
        expected=[PaymentsPaddle],
        path='{}.paddle'.format(path))

    return res


class ConfigConfig:
    def __init__(
            self,
            app: Optional['ConfigApp'] = None,
            cache: Optional['CachesProvider'] = None,
            cli: Optional['AppCLI'] = None,
            cloud: Optional['ConfigCloud'] = None,
            database: Optional['DatabasesProvider'] = None,
            http_client: Optional['HttplibClient'] = None,
            http_server: Optional['HttplibServer'] = None,
            jsonnet: Optional['JsonnetJsonnet'] = None,
            oidc: Optional[Dict[str, 'OidcClientIssuer']] = None,
            smtp: Optional['NotifySMTP'] = None,
            web_push: Optional['NotifyWebPush'] = None) -> None:
        """Initializes with the given values."""
        self.app = app

        self.cache = cache

        self.cli = cli

        self.cloud = cloud

        self.database = database

        self.http_client = http_client

        self.http_server = http_server

        self.jsonnet = jsonnet

        self.oidc = oidc

        self.smtp = smtp

        self.web_push = web_push

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to config_config_to_jsonable.

        :return: JSON-able representation
        """
        return config_config_to_jsonable(self)


def new_config_config() -> ConfigConfig:
    """Generates an instance of ConfigConfig with default values."""
    return ConfigConfig()


def config_config_from_obj(obj: Any, path: str = "") -> ConfigConfig:
    """
    Generates an instance of ConfigConfig from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ConfigConfig
    :param path: path to the object used for debugging
    :return: parsed instance of ConfigConfig
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_app = obj.get('app', None)
    if obj_app is not None:
        app_from_obj = from_obj(
            obj_app,
            expected=[ConfigApp],
            path=path + '.app')  # type: Optional['ConfigApp']
    else:
        app_from_obj = None

    obj_cache = obj.get('cache', None)
    if obj_cache is not None:
        cache_from_obj = from_obj(
            obj_cache,
            expected=[CachesProvider],
            path=path + '.cache')  # type: Optional['CachesProvider']
    else:
        cache_from_obj = None

    obj_cli = obj.get('cli', None)
    if obj_cli is not None:
        cli_from_obj = from_obj(
            obj_cli,
            expected=[AppCLI],
            path=path + '.cli')  # type: Optional['AppCLI']
    else:
        cli_from_obj = None

    obj_cloud = obj.get('cloud', None)
    if obj_cloud is not None:
        cloud_from_obj = from_obj(
            obj_cloud,
            expected=[ConfigCloud],
            path=path + '.cloud')  # type: Optional['ConfigCloud']
    else:
        cloud_from_obj = None

    obj_database = obj.get('database', None)
    if obj_database is not None:
        database_from_obj = from_obj(
            obj_database,
            expected=[DatabasesProvider],
            path=path + '.database')  # type: Optional['DatabasesProvider']
    else:
        database_from_obj = None

    obj_http_client = obj.get('httpClient', None)
    if obj_http_client is not None:
        http_client_from_obj = from_obj(
            obj_http_client,
            expected=[HttplibClient],
            path=path + '.httpClient')  # type: Optional['HttplibClient']
    else:
        http_client_from_obj = None

    obj_http_server = obj.get('httpServer', None)
    if obj_http_server is not None:
        http_server_from_obj = from_obj(
            obj_http_server,
            expected=[HttplibServer],
            path=path + '.httpServer')  # type: Optional['HttplibServer']
    else:
        http_server_from_obj = None

    obj_jsonnet = obj.get('jsonnet', None)
    if obj_jsonnet is not None:
        jsonnet_from_obj = from_obj(
            obj_jsonnet,
            expected=[JsonnetJsonnet],
            path=path + '.jsonnet')  # type: Optional['JsonnetJsonnet']
    else:
        jsonnet_from_obj = None

    obj_oidc = obj.get('oidc', None)
    if obj_oidc is not None:
        oidc_from_obj = from_obj(
            obj_oidc,
            expected=[dict, OidcClientIssuer],
            path=path + '.oidc')  # type: Optional[Dict[str, 'OidcClientIssuer']]
    else:
        oidc_from_obj = None

    obj_smtp = obj.get('smtp', None)
    if obj_smtp is not None:
        smtp_from_obj = from_obj(
            obj_smtp,
            expected=[NotifySMTP],
            path=path + '.smtp')  # type: Optional['NotifySMTP']
    else:
        smtp_from_obj = None

    obj_web_push = obj.get('webPush', None)
    if obj_web_push is not None:
        web_push_from_obj = from_obj(
            obj_web_push,
            expected=[NotifyWebPush],
            path=path + '.webPush')  # type: Optional['NotifyWebPush']
    else:
        web_push_from_obj = None

    return ConfigConfig(
        app=app_from_obj,
        cache=cache_from_obj,
        cli=cli_from_obj,
        cloud=cloud_from_obj,
        database=database_from_obj,
        http_client=http_client_from_obj,
        http_server=http_server_from_obj,
        jsonnet=jsonnet_from_obj,
        oidc=oidc_from_obj,
        smtp=smtp_from_obj,
        web_push=web_push_from_obj)


def config_config_to_jsonable(
        config_config: ConfigConfig,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ConfigConfig.

    :param config_config: instance of ConfigConfig to be JSON-ized
    :param path: path to the config_config used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if config_config.app is not None:
        res['app'] = to_jsonable(
        config_config.app,
        expected=[ConfigApp],
        path='{}.app'.format(path))

    if config_config.cache is not None:
        res['cache'] = to_jsonable(
        config_config.cache,
        expected=[CachesProvider],
        path='{}.cache'.format(path))

    if config_config.cli is not None:
        res['cli'] = to_jsonable(
        config_config.cli,
        expected=[AppCLI],
        path='{}.cli'.format(path))

    if config_config.cloud is not None:
        res['cloud'] = to_jsonable(
        config_config.cloud,
        expected=[ConfigCloud],
        path='{}.cloud'.format(path))

    if config_config.database is not None:
        res['database'] = to_jsonable(
        config_config.database,
        expected=[DatabasesProvider],
        path='{}.database'.format(path))

    if config_config.http_client is not None:
        res['httpClient'] = to_jsonable(
        config_config.http_client,
        expected=[HttplibClient],
        path='{}.httpClient'.format(path))

    if config_config.http_server is not None:
        res['httpServer'] = to_jsonable(
        config_config.http_server,
        expected=[HttplibServer],
        path='{}.httpServer'.format(path))

    if config_config.jsonnet is not None:
        res['jsonnet'] = to_jsonable(
        config_config.jsonnet,
        expected=[JsonnetJsonnet],
        path='{}.jsonnet'.format(path))

    if config_config.oidc is not None:
        res['oidc'] = to_jsonable(
        config_config.oidc,
        expected=[dict, OidcClientIssuer],
        path='{}.oidc'.format(path))

    if config_config.smtp is not None:
        res['smtp'] = to_jsonable(
        config_config.smtp,
        expected=[NotifySMTP],
        path='{}.smtp'.format(path))

    if config_config.web_push is not None:
        res['webPush'] = to_jsonable(
        config_config.web_push,
        expected=[NotifyWebPush],
        path='{}.webPush'.format(path))

    return res


class ConfigWellKnownResponse:
    def __init__(
            self,
            body: Optional[str] = None,
            headers: Optional[Dict[str, str]] = None) -> None:
        """Initializes with the given values."""
        self.body = body

        self.headers = headers

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to config_well_known_response_to_jsonable.

        :return: JSON-able representation
        """
        return config_well_known_response_to_jsonable(self)


def new_config_well_known_response() -> ConfigWellKnownResponse:
    """Generates an instance of ConfigWellKnownResponse with default values."""
    return ConfigWellKnownResponse()


def config_well_known_response_from_obj(obj: Any, path: str = "") -> ConfigWellKnownResponse:
    """
    Generates an instance of ConfigWellKnownResponse from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ConfigWellKnownResponse
    :param path: path to the object used for debugging
    :return: parsed instance of ConfigWellKnownResponse
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_body = obj.get('body', None)
    if obj_body is not None:
        body_from_obj = from_obj(
            obj_body,
            expected=[str],
            path=path + '.body')  # type: Optional[str]
    else:
        body_from_obj = None

    obj_headers = obj.get('headers', None)
    if obj_headers is not None:
        headers_from_obj = from_obj(
            obj_headers,
            expected=[dict, str],
            path=path + '.headers')  # type: Optional[Dict[str, str]]
    else:
        headers_from_obj = None

    return ConfigWellKnownResponse(
        body=body_from_obj,
        headers=headers_from_obj)


def config_well_known_response_to_jsonable(
        config_well_known_response: ConfigWellKnownResponse,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ConfigWellKnownResponse.

    :param config_well_known_response: instance of ConfigWellKnownResponse to be JSON-ized
    :param path: path to the config_well_known_response used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if config_well_known_response.body is not None:
        res['body'] = config_well_known_response.body

    if config_well_known_response.headers is not None:
        res['headers'] = to_jsonable(
        config_well_known_response.headers,
        expected=[dict, str],
        path='{}.headers'.format(path))

    return res


class ControllersResponse:
    def __init__(
            self,
            data_hash: Optional[str] = None,
            data_ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            data_total: Optional[int] = None,
            data_type: Optional[str] = None,
            data_value: Optional[List[Any]] = None,
            message: Optional[str] = None,
            request_id: Optional[str] = None,
            status: Optional[int] = None,
            success: Optional[bool] = None) -> None:
        """Initializes with the given values."""
        self.data_hash = data_hash

        self.data_ids = data_ids

        self.data_total = data_total

        self.data_type = data_type

        self.data_value = data_value

        self.message = message

        self.request_id = request_id

        self.status = status

        self.success = success

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to controllers_response_to_jsonable.

        :return: JSON-able representation
        """
        return controllers_response_to_jsonable(self)


def new_controllers_response() -> ControllersResponse:
    """Generates an instance of ControllersResponse with default values."""
    return ControllersResponse()


def controllers_response_from_obj(obj: Any, path: str = "") -> ControllersResponse:
    """
    Generates an instance of ControllersResponse from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ControllersResponse
    :param path: path to the object used for debugging
    :return: parsed instance of ControllersResponse
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data_hash = obj.get('dataHash', None)
    if obj_data_hash is not None:
        data_hash_from_obj = from_obj(
            obj_data_hash,
            expected=[str],
            path=path + '.dataHash')  # type: Optional[str]
    else:
        data_hash_from_obj = None

    obj_data_ids = obj.get('dataIDs', None)
    if obj_data_ids is not None:
        data_ids_from_obj = from_obj(
            obj_data_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.dataIDs')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        data_ids_from_obj = None

    obj_data_total = obj.get('dataTotal', None)
    if obj_data_total is not None:
        data_total_from_obj = from_obj(
            obj_data_total,
            expected=[int],
            path=path + '.dataTotal')  # type: Optional[int]
    else:
        data_total_from_obj = None

    obj_data_type = obj.get('dataType', None)
    if obj_data_type is not None:
        data_type_from_obj = from_obj(
            obj_data_type,
            expected=[str],
            path=path + '.dataType')  # type: Optional[str]
    else:
        data_type_from_obj = None

    obj_data_value = obj.get('dataValue', None)
    if obj_data_value is not None:
        data_value_from_obj = from_obj(
            obj_data_value,
            expected=[list, Any],
            path=path + '.dataValue')  # type: Optional[List[Any]]
    else:
        data_value_from_obj = None

    obj_message = obj.get('message', None)
    if obj_message is not None:
        message_from_obj = from_obj(
            obj_message,
            expected=[str],
            path=path + '.message')  # type: Optional[str]
    else:
        message_from_obj = None

    obj_request_id = obj.get('requestID', None)
    if obj_request_id is not None:
        request_id_from_obj = from_obj(
            obj_request_id,
            expected=[str],
            path=path + '.requestID')  # type: Optional[str]
    else:
        request_id_from_obj = None

    obj_status = obj.get('status', None)
    if obj_status is not None:
        status_from_obj = from_obj(
            obj_status,
            expected=[int],
            path=path + '.status')  # type: Optional[int]
    else:
        status_from_obj = None

    obj_success = obj.get('success', None)
    if obj_success is not None:
        success_from_obj = from_obj(
            obj_success,
            expected=[bool],
            path=path + '.success')  # type: Optional[bool]
    else:
        success_from_obj = None

    return ControllersResponse(
        data_hash=data_hash_from_obj,
        data_ids=data_ids_from_obj,
        data_total=data_total_from_obj,
        data_type=data_type_from_obj,
        data_value=data_value_from_obj,
        message=message_from_obj,
        request_id=request_id_from_obj,
        status=status_from_obj,
        success=success_from_obj)


def controllers_response_to_jsonable(
        controllers_response: ControllersResponse,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ControllersResponse.

    :param controllers_response: instance of ControllersResponse to be JSON-ized
    :param path: path to the controllers_response used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if controllers_response.data_hash is not None:
        res['dataHash'] = controllers_response.data_hash

    if controllers_response.data_ids is not None:
        res['dataIDs'] = to_jsonable(
        controllers_response.data_ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.dataIDs'.format(path))

    if controllers_response.data_total is not None:
        res['dataTotal'] = controllers_response.data_total

    if controllers_response.data_type is not None:
        res['dataType'] = controllers_response.data_type

    if controllers_response.data_value is not None:
        res['dataValue'] = to_jsonable(
        controllers_response.data_value,
        expected=[list, Any],
        path='{}.dataValue'.format(path))

    if controllers_response.message is not None:
        res['message'] = controllers_response.message

    if controllers_response.request_id is not None:
        res['requestID'] = controllers_response.request_id

    if controllers_response.status is not None:
        res['status'] = controllers_response.status

    if controllers_response.success is not None:
        res['success'] = controllers_response.success

    return res


class CryptolibEncryptedValue:
    def __init__(
            self,
            ciphertext: Optional[str] = None,
            encryption: Optional[str] = None,
            kdf: Optional[str] = None,
            kdfinput: Optional[str] = None,
            key_id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.ciphertext = ciphertext

        self.encryption = encryption

        self.kdf = kdf

        self.kdfinput = kdfinput

        self.key_id = key_id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to cryptolib_encrypted_value_to_jsonable.

        :return: JSON-able representation
        """
        return cryptolib_encrypted_value_to_jsonable(self)


def new_cryptolib_encrypted_value() -> CryptolibEncryptedValue:
    """Generates an instance of CryptolibEncryptedValue with default values."""
    return CryptolibEncryptedValue()


def cryptolib_encrypted_value_from_obj(obj: Any, path: str = "") -> CryptolibEncryptedValue:
    """
    Generates an instance of CryptolibEncryptedValue from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of CryptolibEncryptedValue
    :param path: path to the object used for debugging
    :return: parsed instance of CryptolibEncryptedValue
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_ciphertext = obj.get('ciphertext', None)
    if obj_ciphertext is not None:
        ciphertext_from_obj = from_obj(
            obj_ciphertext,
            expected=[str],
            path=path + '.ciphertext')  # type: Optional[str]
    else:
        ciphertext_from_obj = None

    obj_encryption = obj.get('encryption', None)
    if obj_encryption is not None:
        encryption_from_obj = from_obj(
            obj_encryption,
            expected=[str],
            path=path + '.encryption')  # type: Optional[str]
    else:
        encryption_from_obj = None

    obj_kdf = obj.get('kdf', None)
    if obj_kdf is not None:
        kdf_from_obj = from_obj(
            obj_kdf,
            expected=[str],
            path=path + '.kdf')  # type: Optional[str]
    else:
        kdf_from_obj = None

    obj_kdfinput = obj.get('kdfinput', None)
    if obj_kdfinput is not None:
        kdfinput_from_obj = from_obj(
            obj_kdfinput,
            expected=[str],
            path=path + '.kdfinput')  # type: Optional[str]
    else:
        kdfinput_from_obj = None

    obj_key_id = obj.get('keyID', None)
    if obj_key_id is not None:
        key_id_from_obj = from_obj(
            obj_key_id,
            expected=[str],
            path=path + '.keyID')  # type: Optional[str]
    else:
        key_id_from_obj = None

    return CryptolibEncryptedValue(
        ciphertext=ciphertext_from_obj,
        encryption=encryption_from_obj,
        kdf=kdf_from_obj,
        kdfinput=kdfinput_from_obj,
        key_id=key_id_from_obj)


def cryptolib_encrypted_value_to_jsonable(
        cryptolib_encrypted_value: CryptolibEncryptedValue,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of CryptolibEncryptedValue.

    :param cryptolib_encrypted_value: instance of CryptolibEncryptedValue to be JSON-ized
    :param path: path to the cryptolib_encrypted_value used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if cryptolib_encrypted_value.ciphertext is not None:
        res['ciphertext'] = cryptolib_encrypted_value.ciphertext

    if cryptolib_encrypted_value.encryption is not None:
        res['encryption'] = cryptolib_encrypted_value.encryption

    if cryptolib_encrypted_value.kdf is not None:
        res['kdf'] = cryptolib_encrypted_value.kdf

    if cryptolib_encrypted_value.kdfinput is not None:
        res['kdfinput'] = cryptolib_encrypted_value.kdfinput

    if cryptolib_encrypted_value.key_id is not None:
        res['keyID'] = cryptolib_encrypted_value.key_id

    return res


class CryptolibKeyCryptolibKeyProviderPrivate:
    def __init__(
            self,
            id: Optional[str] = None,
            key: Optional[Any] = None) -> None:
        """Initializes with the given values."""
        self.id = id

        self.key = key

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to cryptolib_key_cryptolib_key_provider_private_to_jsonable.

        :return: JSON-able representation
        """
        return cryptolib_key_cryptolib_key_provider_private_to_jsonable(self)


def new_cryptolib_key_cryptolib_key_provider_private() -> CryptolibKeyCryptolibKeyProviderPrivate:
    """Generates an instance of CryptolibKeyCryptolibKeyProviderPrivate with default values."""
    return CryptolibKeyCryptolibKeyProviderPrivate()


def cryptolib_key_cryptolib_key_provider_private_from_obj(obj: Any, path: str = "") -> CryptolibKeyCryptolibKeyProviderPrivate:
    """
    Generates an instance of CryptolibKeyCryptolibKeyProviderPrivate from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of CryptolibKeyCryptolibKeyProviderPrivate
    :param path: path to the object used for debugging
    :return: parsed instance of CryptolibKeyCryptolibKeyProviderPrivate
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    key_from_obj = obj.get('key', None)

    return CryptolibKeyCryptolibKeyProviderPrivate(
        id=id_from_obj,
        key=key_from_obj)


def cryptolib_key_cryptolib_key_provider_private_to_jsonable(
        cryptolib_key_cryptolib_key_provider_private: CryptolibKeyCryptolibKeyProviderPrivate,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of CryptolibKeyCryptolibKeyProviderPrivate.

    :param cryptolib_key_cryptolib_key_provider_private: instance of CryptolibKeyCryptolibKeyProviderPrivate to be JSON-ized
    :param path: path to the cryptolib_key_cryptolib_key_provider_private used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if cryptolib_key_cryptolib_key_provider_private.id is not None:
        res['id'] = cryptolib_key_cryptolib_key_provider_private.id

    if cryptolib_key_cryptolib_key_provider_private.key is not None:
        res['key'] = cryptolib_key_cryptolib_key_provider_private.key

    return res


class CryptolibKeyCryptolibKeyProviderPublic:
    def __init__(
            self,
            id: Optional[str] = None,
            key: Optional[Any] = None) -> None:
        """Initializes with the given values."""
        self.id = id

        self.key = key

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to cryptolib_key_cryptolib_key_provider_public_to_jsonable.

        :return: JSON-able representation
        """
        return cryptolib_key_cryptolib_key_provider_public_to_jsonable(self)


def new_cryptolib_key_cryptolib_key_provider_public() -> CryptolibKeyCryptolibKeyProviderPublic:
    """Generates an instance of CryptolibKeyCryptolibKeyProviderPublic with default values."""
    return CryptolibKeyCryptolibKeyProviderPublic()


def cryptolib_key_cryptolib_key_provider_public_from_obj(obj: Any, path: str = "") -> CryptolibKeyCryptolibKeyProviderPublic:
    """
    Generates an instance of CryptolibKeyCryptolibKeyProviderPublic from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of CryptolibKeyCryptolibKeyProviderPublic
    :param path: path to the object used for debugging
    :return: parsed instance of CryptolibKeyCryptolibKeyProviderPublic
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    key_from_obj = obj.get('key', None)

    return CryptolibKeyCryptolibKeyProviderPublic(
        id=id_from_obj,
        key=key_from_obj)


def cryptolib_key_cryptolib_key_provider_public_to_jsonable(
        cryptolib_key_cryptolib_key_provider_public: CryptolibKeyCryptolibKeyProviderPublic,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of CryptolibKeyCryptolibKeyProviderPublic.

    :param cryptolib_key_cryptolib_key_provider_public: instance of CryptolibKeyCryptolibKeyProviderPublic to be JSON-ized
    :param path: path to the cryptolib_key_cryptolib_key_provider_public used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if cryptolib_key_cryptolib_key_provider_public.id is not None:
        res['id'] = cryptolib_key_cryptolib_key_provider_public.id

    if cryptolib_key_cryptolib_key_provider_public.key is not None:
        res['key'] = cryptolib_key_cryptolib_key_provider_public.key

    return res


class CryptolibKeyCryptolibRSA2048PublicKey:
    def __init__(
            self,
            id: Optional[str] = None,
            key: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.id = id

        self.key = key

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to cryptolib_key_cryptolib_r_s_a2048_public_key_to_jsonable.

        :return: JSON-able representation
        """
        return cryptolib_key_cryptolib_r_s_a2048_public_key_to_jsonable(self)


def new_cryptolib_key_cryptolib_r_s_a2048_public_key() -> CryptolibKeyCryptolibRSA2048PublicKey:
    """Generates an instance of CryptolibKeyCryptolibRSA2048PublicKey with default values."""
    return CryptolibKeyCryptolibRSA2048PublicKey()


def cryptolib_key_cryptolib_r_s_a2048_public_key_from_obj(obj: Any, path: str = "") -> CryptolibKeyCryptolibRSA2048PublicKey:
    """
    Generates an instance of CryptolibKeyCryptolibRSA2048PublicKey from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of CryptolibKeyCryptolibRSA2048PublicKey
    :param path: path to the object used for debugging
    :return: parsed instance of CryptolibKeyCryptolibRSA2048PublicKey
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_key = obj.get('key', None)
    if obj_key is not None:
        key_from_obj = from_obj(
            obj_key,
            expected=[str],
            path=path + '.key')  # type: Optional[str]
    else:
        key_from_obj = None

    return CryptolibKeyCryptolibRSA2048PublicKey(
        id=id_from_obj,
        key=key_from_obj)


def cryptolib_key_cryptolib_r_s_a2048_public_key_to_jsonable(
        cryptolib_key_cryptolib_r_s_a2048_public_key: CryptolibKeyCryptolibRSA2048PublicKey,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of CryptolibKeyCryptolibRSA2048PublicKey.

    :param cryptolib_key_cryptolib_r_s_a2048_public_key: instance of CryptolibKeyCryptolibRSA2048PublicKey to be JSON-ized
    :param path: path to the cryptolib_key_cryptolib_r_s_a2048_public_key used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if cryptolib_key_cryptolib_r_s_a2048_public_key.id is not None:
        res['id'] = cryptolib_key_cryptolib_r_s_a2048_public_key.id

    if cryptolib_key_cryptolib_r_s_a2048_public_key.key is not None:
        res['key'] = cryptolib_key_cryptolib_r_s_a2048_public_key.key

    return res


class DatabasesProvider:
    def __init__(
            self,
            max_connections: Optional[int] = None,
            max_idle_connections: Optional[int] = None,
            max_lifetime: Optional[int] = None,
            uri: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.max_connections = max_connections

        self.max_idle_connections = max_idle_connections

        self.max_lifetime = max_lifetime

        self.uri = uri

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to databases_provider_to_jsonable.

        :return: JSON-able representation
        """
        return databases_provider_to_jsonable(self)


def new_databases_provider() -> DatabasesProvider:
    """Generates an instance of DatabasesProvider with default values."""
    return DatabasesProvider()


def databases_provider_from_obj(obj: Any, path: str = "") -> DatabasesProvider:
    """
    Generates an instance of DatabasesProvider from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of DatabasesProvider
    :param path: path to the object used for debugging
    :return: parsed instance of DatabasesProvider
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_max_connections = obj.get('maxConnections', None)
    if obj_max_connections is not None:
        max_connections_from_obj = from_obj(
            obj_max_connections,
            expected=[int],
            path=path + '.maxConnections')  # type: Optional[int]
    else:
        max_connections_from_obj = None

    obj_max_idle_connections = obj.get('maxIdleConnections', None)
    if obj_max_idle_connections is not None:
        max_idle_connections_from_obj = from_obj(
            obj_max_idle_connections,
            expected=[int],
            path=path + '.maxIdleConnections')  # type: Optional[int]
    else:
        max_idle_connections_from_obj = None

    obj_max_lifetime = obj.get('maxLifetime', None)
    if obj_max_lifetime is not None:
        max_lifetime_from_obj = from_obj(
            obj_max_lifetime,
            expected=[int],
            path=path + '.maxLifetime')  # type: Optional[int]
    else:
        max_lifetime_from_obj = None

    obj_uri = obj.get('uri', None)
    if obj_uri is not None:
        uri_from_obj = from_obj(
            obj_uri,
            expected=[str],
            path=path + '.uri')  # type: Optional[str]
    else:
        uri_from_obj = None

    return DatabasesProvider(
        max_connections=max_connections_from_obj,
        max_idle_connections=max_idle_connections_from_obj,
        max_lifetime=max_lifetime_from_obj,
        uri=uri_from_obj)


def databases_provider_to_jsonable(
        databases_provider: DatabasesProvider,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of DatabasesProvider.

    :param databases_provider: instance of DatabasesProvider to be JSON-ized
    :param path: path to the databases_provider used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if databases_provider.max_connections is not None:
        res['maxConnections'] = databases_provider.max_connections

    if databases_provider.max_idle_connections is not None:
        res['maxIdleConnections'] = databases_provider.max_idle_connections

    if databases_provider.max_lifetime is not None:
        res['maxLifetime'] = databases_provider.max_lifetime

    if databases_provider.uri is not None:
        res['uri'] = databases_provider.uri

    return res


class HttplibClient:
    def __init__(
            self,
            no_system_c_as: Optional[bool] = None,
            timeout_dial: Optional[int] = None,
            timeout_t_l_s_handshake: Optional[int] = None,
            tls_c_a_base64: Optional[str] = None,
            tls_c_a_path: Optional[str] = None,
            tls_certificates_base64: Optional[List[str]] = None,
            tls_certificates_path: Optional[List[str]] = None,
            tls_keys_base64: Optional[List[str]] = None,
            tls_keys_path: Optional[List[str]] = None,
            tls_skip_verify: Optional[bool] = None) -> None:
        """Initializes with the given values."""
        self.no_system_c_as = no_system_c_as

        self.timeout_dial = timeout_dial

        self.timeout_t_l_s_handshake = timeout_t_l_s_handshake

        self.tls_c_a_base64 = tls_c_a_base64

        self.tls_c_a_path = tls_c_a_path

        self.tls_certificates_base64 = tls_certificates_base64

        self.tls_certificates_path = tls_certificates_path

        self.tls_keys_base64 = tls_keys_base64

        self.tls_keys_path = tls_keys_path

        self.tls_skip_verify = tls_skip_verify

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_client_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_client_to_jsonable(self)


def new_httplib_client() -> HttplibClient:
    """Generates an instance of HttplibClient with default values."""
    return HttplibClient()


def httplib_client_from_obj(obj: Any, path: str = "") -> HttplibClient:
    """
    Generates an instance of HttplibClient from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibClient
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibClient
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_no_system_c_as = obj.get('noSystemCAs', None)
    if obj_no_system_c_as is not None:
        no_system_c_as_from_obj = from_obj(
            obj_no_system_c_as,
            expected=[bool],
            path=path + '.noSystemCAs')  # type: Optional[bool]
    else:
        no_system_c_as_from_obj = None

    obj_timeout_dial = obj.get('timeoutDial', None)
    if obj_timeout_dial is not None:
        timeout_dial_from_obj = from_obj(
            obj_timeout_dial,
            expected=[int],
            path=path + '.timeoutDial')  # type: Optional[int]
    else:
        timeout_dial_from_obj = None

    obj_timeout_t_l_s_handshake = obj.get('timeoutTLSHandshake', None)
    if obj_timeout_t_l_s_handshake is not None:
        timeout_t_l_s_handshake_from_obj = from_obj(
            obj_timeout_t_l_s_handshake,
            expected=[int],
            path=path + '.timeoutTLSHandshake')  # type: Optional[int]
    else:
        timeout_t_l_s_handshake_from_obj = None

    obj_tls_c_a_base64 = obj.get('tlsCABase64', None)
    if obj_tls_c_a_base64 is not None:
        tls_c_a_base64_from_obj = from_obj(
            obj_tls_c_a_base64,
            expected=[str],
            path=path + '.tlsCABase64')  # type: Optional[str]
    else:
        tls_c_a_base64_from_obj = None

    obj_tls_c_a_path = obj.get('tlsCAPath', None)
    if obj_tls_c_a_path is not None:
        tls_c_a_path_from_obj = from_obj(
            obj_tls_c_a_path,
            expected=[str],
            path=path + '.tlsCAPath')  # type: Optional[str]
    else:
        tls_c_a_path_from_obj = None

    obj_tls_certificates_base64 = obj.get('tlsCertificatesBase64', None)
    if obj_tls_certificates_base64 is not None:
        tls_certificates_base64_from_obj = from_obj(
            obj_tls_certificates_base64,
            expected=[list, str],
            path=path + '.tlsCertificatesBase64')  # type: Optional[List[str]]
    else:
        tls_certificates_base64_from_obj = None

    obj_tls_certificates_path = obj.get('tlsCertificatesPath', None)
    if obj_tls_certificates_path is not None:
        tls_certificates_path_from_obj = from_obj(
            obj_tls_certificates_path,
            expected=[list, str],
            path=path + '.tlsCertificatesPath')  # type: Optional[List[str]]
    else:
        tls_certificates_path_from_obj = None

    obj_tls_keys_base64 = obj.get('tlsKeysBase64', None)
    if obj_tls_keys_base64 is not None:
        tls_keys_base64_from_obj = from_obj(
            obj_tls_keys_base64,
            expected=[list, str],
            path=path + '.tlsKeysBase64')  # type: Optional[List[str]]
    else:
        tls_keys_base64_from_obj = None

    obj_tls_keys_path = obj.get('tlsKeysPath', None)
    if obj_tls_keys_path is not None:
        tls_keys_path_from_obj = from_obj(
            obj_tls_keys_path,
            expected=[list, str],
            path=path + '.tlsKeysPath')  # type: Optional[List[str]]
    else:
        tls_keys_path_from_obj = None

    obj_tls_skip_verify = obj.get('tlsSkipVerify', None)
    if obj_tls_skip_verify is not None:
        tls_skip_verify_from_obj = from_obj(
            obj_tls_skip_verify,
            expected=[bool],
            path=path + '.tlsSkipVerify')  # type: Optional[bool]
    else:
        tls_skip_verify_from_obj = None

    return HttplibClient(
        no_system_c_as=no_system_c_as_from_obj,
        timeout_dial=timeout_dial_from_obj,
        timeout_t_l_s_handshake=timeout_t_l_s_handshake_from_obj,
        tls_c_a_base64=tls_c_a_base64_from_obj,
        tls_c_a_path=tls_c_a_path_from_obj,
        tls_certificates_base64=tls_certificates_base64_from_obj,
        tls_certificates_path=tls_certificates_path_from_obj,
        tls_keys_base64=tls_keys_base64_from_obj,
        tls_keys_path=tls_keys_path_from_obj,
        tls_skip_verify=tls_skip_verify_from_obj)


def httplib_client_to_jsonable(
        httplib_client: HttplibClient,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibClient.

    :param httplib_client: instance of HttplibClient to be JSON-ized
    :param path: path to the httplib_client used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_client.no_system_c_as is not None:
        res['noSystemCAs'] = httplib_client.no_system_c_as

    if httplib_client.timeout_dial is not None:
        res['timeoutDial'] = httplib_client.timeout_dial

    if httplib_client.timeout_t_l_s_handshake is not None:
        res['timeoutTLSHandshake'] = httplib_client.timeout_t_l_s_handshake

    if httplib_client.tls_c_a_base64 is not None:
        res['tlsCABase64'] = httplib_client.tls_c_a_base64

    if httplib_client.tls_c_a_path is not None:
        res['tlsCAPath'] = httplib_client.tls_c_a_path

    if httplib_client.tls_certificates_base64 is not None:
        res['tlsCertificatesBase64'] = to_jsonable(
        httplib_client.tls_certificates_base64,
        expected=[list, str],
        path='{}.tlsCertificatesBase64'.format(path))

    if httplib_client.tls_certificates_path is not None:
        res['tlsCertificatesPath'] = to_jsonable(
        httplib_client.tls_certificates_path,
        expected=[list, str],
        path='{}.tlsCertificatesPath'.format(path))

    if httplib_client.tls_keys_base64 is not None:
        res['tlsKeysBase64'] = to_jsonable(
        httplib_client.tls_keys_base64,
        expected=[list, str],
        path='{}.tlsKeysBase64'.format(path))

    if httplib_client.tls_keys_path is not None:
        res['tlsKeysPath'] = to_jsonable(
        httplib_client.tls_keys_path,
        expected=[list, str],
        path='{}.tlsKeysPath'.format(path))

    if httplib_client.tls_skip_verify is not None:
        res['tlsSkipVerify'] = httplib_client.tls_skip_verify

    return res


class HttplibJsonResponseConfigConfig:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataConfigConfig'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_config_config_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_config_config_to_jsonable(self)


def new_httplib_json_response_config_config() -> HttplibJsonResponseConfigConfig:
    """Generates an instance of HttplibJsonResponseConfigConfig with default values."""
    return HttplibJsonResponseConfigConfig()


def httplib_json_response_config_config_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseConfigConfig:
    """
    Generates an instance of HttplibJsonResponseConfigConfig from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseConfigConfig
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseConfigConfig
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataConfigConfig],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataConfigConfig']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseConfigConfig(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_config_config_to_jsonable(
        httplib_json_response_config_config: HttplibJsonResponseConfigConfig,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseConfigConfig.

    :param httplib_json_response_config_config: instance of HttplibJsonResponseConfigConfig to be JSON-ized
    :param path: path to the httplib_json_response_config_config used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_config_config.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_config_config.data,
        expected=[HttplibJsonResponseDataConfigConfig],
        path='{}.data'.format(path))

    if httplib_json_response_config_config.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_config_config.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_config_config.id is not None:
        res['id'] = httplib_json_response_config_config.id

    return res


class HttplibJsonResponseModelsAuthAccountDelegations:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsAuthAccountDelegations'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_auth_account_delegations_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_auth_account_delegations_to_jsonable(self)


def new_httplib_json_response_models_auth_account_delegations() -> HttplibJsonResponseModelsAuthAccountDelegations:
    """Generates an instance of HttplibJsonResponseModelsAuthAccountDelegations with default values."""
    return HttplibJsonResponseModelsAuthAccountDelegations()


def httplib_json_response_models_auth_account_delegations_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsAuthAccountDelegations:
    """
    Generates an instance of HttplibJsonResponseModelsAuthAccountDelegations from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsAuthAccountDelegations
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsAuthAccountDelegations
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsAuthAccountDelegations],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsAuthAccountDelegations']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsAuthAccountDelegations(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_auth_account_delegations_to_jsonable(
        httplib_json_response_models_auth_account_delegations: HttplibJsonResponseModelsAuthAccountDelegations,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsAuthAccountDelegations.

    :param httplib_json_response_models_auth_account_delegations: instance of HttplibJsonResponseModelsAuthAccountDelegations to be JSON-ized
    :param path: path to the httplib_json_response_models_auth_account_delegations used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_auth_account_delegations.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_auth_account_delegations.data,
        expected=[HttplibJsonResponseDataModelsAuthAccountDelegations],
        path='{}.data'.format(path))

    if httplib_json_response_models_auth_account_delegations.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_auth_account_delegations.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_auth_account_delegations.id is not None:
        res['id'] = httplib_json_response_models_auth_account_delegations.id

    return res


class HttplibJsonResponseModelsAuthAccounts:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsAuthAccounts'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_auth_accounts_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_auth_accounts_to_jsonable(self)


def new_httplib_json_response_models_auth_accounts() -> HttplibJsonResponseModelsAuthAccounts:
    """Generates an instance of HttplibJsonResponseModelsAuthAccounts with default values."""
    return HttplibJsonResponseModelsAuthAccounts()


def httplib_json_response_models_auth_accounts_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsAuthAccounts:
    """
    Generates an instance of HttplibJsonResponseModelsAuthAccounts from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsAuthAccounts
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsAuthAccounts
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsAuthAccounts],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsAuthAccounts']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsAuthAccounts(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_auth_accounts_to_jsonable(
        httplib_json_response_models_auth_accounts: HttplibJsonResponseModelsAuthAccounts,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsAuthAccounts.

    :param httplib_json_response_models_auth_accounts: instance of HttplibJsonResponseModelsAuthAccounts to be JSON-ized
    :param path: path to the httplib_json_response_models_auth_accounts used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_auth_accounts.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_auth_accounts.data,
        expected=[HttplibJsonResponseDataModelsAuthAccounts],
        path='{}.data'.format(path))

    if httplib_json_response_models_auth_accounts.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_auth_accounts.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_auth_accounts.id is not None:
        res['id'] = httplib_json_response_models_auth_accounts.id

    return res


class HttplibJsonResponseModelsAuthHouseholds:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsAuthHouseholds'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_auth_households_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_auth_households_to_jsonable(self)


def new_httplib_json_response_models_auth_households() -> HttplibJsonResponseModelsAuthHouseholds:
    """Generates an instance of HttplibJsonResponseModelsAuthHouseholds with default values."""
    return HttplibJsonResponseModelsAuthHouseholds()


def httplib_json_response_models_auth_households_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsAuthHouseholds:
    """
    Generates an instance of HttplibJsonResponseModelsAuthHouseholds from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsAuthHouseholds
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsAuthHouseholds
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsAuthHouseholds],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsAuthHouseholds']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsAuthHouseholds(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_auth_households_to_jsonable(
        httplib_json_response_models_auth_households: HttplibJsonResponseModelsAuthHouseholds,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsAuthHouseholds.

    :param httplib_json_response_models_auth_households: instance of HttplibJsonResponseModelsAuthHouseholds to be JSON-ized
    :param path: path to the httplib_json_response_models_auth_households used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_auth_households.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_auth_households.data,
        expected=[HttplibJsonResponseDataModelsAuthHouseholds],
        path='{}.data'.format(path))

    if httplib_json_response_models_auth_households.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_auth_households.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_auth_households.id is not None:
        res['id'] = httplib_json_response_models_auth_households.id

    return res


class HttplibJsonResponseModelsAuthOIDCClients:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsAuthOIDCClients'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_auth_o_id_c_clients_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_auth_o_id_c_clients_to_jsonable(self)


def new_httplib_json_response_models_auth_o_id_c_clients() -> HttplibJsonResponseModelsAuthOIDCClients:
    """Generates an instance of HttplibJsonResponseModelsAuthOIDCClients with default values."""
    return HttplibJsonResponseModelsAuthOIDCClients()


def httplib_json_response_models_auth_o_id_c_clients_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsAuthOIDCClients:
    """
    Generates an instance of HttplibJsonResponseModelsAuthOIDCClients from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsAuthOIDCClients
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsAuthOIDCClients
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsAuthOIDCClients],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsAuthOIDCClients']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsAuthOIDCClients(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_auth_o_id_c_clients_to_jsonable(
        httplib_json_response_models_auth_o_id_c_clients: HttplibJsonResponseModelsAuthOIDCClients,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsAuthOIDCClients.

    :param httplib_json_response_models_auth_o_id_c_clients: instance of HttplibJsonResponseModelsAuthOIDCClients to be JSON-ized
    :param path: path to the httplib_json_response_models_auth_o_id_c_clients used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_auth_o_id_c_clients.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_auth_o_id_c_clients.data,
        expected=[HttplibJsonResponseDataModelsAuthOIDCClients],
        path='{}.data'.format(path))

    if httplib_json_response_models_auth_o_id_c_clients.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_auth_o_id_c_clients.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_auth_o_id_c_clients.id is not None:
        res['id'] = httplib_json_response_models_auth_o_id_c_clients.id

    return res


class HttplibJsonResponseModelsAuthOIDCCodes:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsAuthOIDCCodes'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_auth_o_id_c_codes_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_auth_o_id_c_codes_to_jsonable(self)


def new_httplib_json_response_models_auth_o_id_c_codes() -> HttplibJsonResponseModelsAuthOIDCCodes:
    """Generates an instance of HttplibJsonResponseModelsAuthOIDCCodes with default values."""
    return HttplibJsonResponseModelsAuthOIDCCodes()


def httplib_json_response_models_auth_o_id_c_codes_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsAuthOIDCCodes:
    """
    Generates an instance of HttplibJsonResponseModelsAuthOIDCCodes from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsAuthOIDCCodes
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsAuthOIDCCodes
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsAuthOIDCCodes],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsAuthOIDCCodes']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsAuthOIDCCodes(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_auth_o_id_c_codes_to_jsonable(
        httplib_json_response_models_auth_o_id_c_codes: HttplibJsonResponseModelsAuthOIDCCodes,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsAuthOIDCCodes.

    :param httplib_json_response_models_auth_o_id_c_codes: instance of HttplibJsonResponseModelsAuthOIDCCodes to be JSON-ized
    :param path: path to the httplib_json_response_models_auth_o_id_c_codes used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_auth_o_id_c_codes.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_auth_o_id_c_codes.data,
        expected=[HttplibJsonResponseDataModelsAuthOIDCCodes],
        path='{}.data'.format(path))

    if httplib_json_response_models_auth_o_id_c_codes.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_auth_o_id_c_codes.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_auth_o_id_c_codes.id is not None:
        res['id'] = httplib_json_response_models_auth_o_id_c_codes.id

    return res


class HttplibJsonResponseModelsAuthSessions:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsAuthSessions'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_auth_sessions_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_auth_sessions_to_jsonable(self)


def new_httplib_json_response_models_auth_sessions() -> HttplibJsonResponseModelsAuthSessions:
    """Generates an instance of HttplibJsonResponseModelsAuthSessions with default values."""
    return HttplibJsonResponseModelsAuthSessions()


def httplib_json_response_models_auth_sessions_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsAuthSessions:
    """
    Generates an instance of HttplibJsonResponseModelsAuthSessions from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsAuthSessions
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsAuthSessions
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsAuthSessions],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsAuthSessions']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsAuthSessions(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_auth_sessions_to_jsonable(
        httplib_json_response_models_auth_sessions: HttplibJsonResponseModelsAuthSessions,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsAuthSessions.

    :param httplib_json_response_models_auth_sessions: instance of HttplibJsonResponseModelsAuthSessions to be JSON-ized
    :param path: path to the httplib_json_response_models_auth_sessions used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_auth_sessions.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_auth_sessions.data,
        expected=[HttplibJsonResponseDataModelsAuthSessions],
        path='{}.data'.format(path))

    if httplib_json_response_models_auth_sessions.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_auth_sessions.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_auth_sessions.id is not None:
        res['id'] = httplib_json_response_models_auth_sessions.id

    return res


class HttplibJsonResponseModelsBookmarks:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsBookmarks'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_bookmarks_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_bookmarks_to_jsonable(self)


def new_httplib_json_response_models_bookmarks() -> HttplibJsonResponseModelsBookmarks:
    """Generates an instance of HttplibJsonResponseModelsBookmarks with default values."""
    return HttplibJsonResponseModelsBookmarks()


def httplib_json_response_models_bookmarks_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsBookmarks:
    """
    Generates an instance of HttplibJsonResponseModelsBookmarks from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsBookmarks
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsBookmarks
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsBookmarks],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsBookmarks']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsBookmarks(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_bookmarks_to_jsonable(
        httplib_json_response_models_bookmarks: HttplibJsonResponseModelsBookmarks,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsBookmarks.

    :param httplib_json_response_models_bookmarks: instance of HttplibJsonResponseModelsBookmarks to be JSON-ized
    :param path: path to the httplib_json_response_models_bookmarks used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_bookmarks.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_bookmarks.data,
        expected=[HttplibJsonResponseDataModelsBookmarks],
        path='{}.data'.format(path))

    if httplib_json_response_models_bookmarks.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_bookmarks.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_bookmarks.id is not None:
        res['id'] = httplib_json_response_models_bookmarks.id

    return res


class HttplibJsonResponseModelsBudgetAccounts:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsBudgetAccounts'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_budget_accounts_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_budget_accounts_to_jsonable(self)


def new_httplib_json_response_models_budget_accounts() -> HttplibJsonResponseModelsBudgetAccounts:
    """Generates an instance of HttplibJsonResponseModelsBudgetAccounts with default values."""
    return HttplibJsonResponseModelsBudgetAccounts()


def httplib_json_response_models_budget_accounts_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsBudgetAccounts:
    """
    Generates an instance of HttplibJsonResponseModelsBudgetAccounts from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsBudgetAccounts
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsBudgetAccounts
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsBudgetAccounts],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsBudgetAccounts']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsBudgetAccounts(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_budget_accounts_to_jsonable(
        httplib_json_response_models_budget_accounts: HttplibJsonResponseModelsBudgetAccounts,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsBudgetAccounts.

    :param httplib_json_response_models_budget_accounts: instance of HttplibJsonResponseModelsBudgetAccounts to be JSON-ized
    :param path: path to the httplib_json_response_models_budget_accounts used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_budget_accounts.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_budget_accounts.data,
        expected=[HttplibJsonResponseDataModelsBudgetAccounts],
        path='{}.data'.format(path))

    if httplib_json_response_models_budget_accounts.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_budget_accounts.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_budget_accounts.id is not None:
        res['id'] = httplib_json_response_models_budget_accounts.id

    return res


class HttplibJsonResponseModelsBudgetCategories:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsBudgetCategories'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_budget_categories_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_budget_categories_to_jsonable(self)


def new_httplib_json_response_models_budget_categories() -> HttplibJsonResponseModelsBudgetCategories:
    """Generates an instance of HttplibJsonResponseModelsBudgetCategories with default values."""
    return HttplibJsonResponseModelsBudgetCategories()


def httplib_json_response_models_budget_categories_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsBudgetCategories:
    """
    Generates an instance of HttplibJsonResponseModelsBudgetCategories from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsBudgetCategories
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsBudgetCategories
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsBudgetCategories],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsBudgetCategories']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsBudgetCategories(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_budget_categories_to_jsonable(
        httplib_json_response_models_budget_categories: HttplibJsonResponseModelsBudgetCategories,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsBudgetCategories.

    :param httplib_json_response_models_budget_categories: instance of HttplibJsonResponseModelsBudgetCategories to be JSON-ized
    :param path: path to the httplib_json_response_models_budget_categories used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_budget_categories.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_budget_categories.data,
        expected=[HttplibJsonResponseDataModelsBudgetCategories],
        path='{}.data'.format(path))

    if httplib_json_response_models_budget_categories.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_budget_categories.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_budget_categories.id is not None:
        res['id'] = httplib_json_response_models_budget_categories.id

    return res


class HttplibJsonResponseModelsBudgetMonthCategories:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsBudgetMonthCategories'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_budget_month_categories_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_budget_month_categories_to_jsonable(self)


def new_httplib_json_response_models_budget_month_categories() -> HttplibJsonResponseModelsBudgetMonthCategories:
    """Generates an instance of HttplibJsonResponseModelsBudgetMonthCategories with default values."""
    return HttplibJsonResponseModelsBudgetMonthCategories()


def httplib_json_response_models_budget_month_categories_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsBudgetMonthCategories:
    """
    Generates an instance of HttplibJsonResponseModelsBudgetMonthCategories from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsBudgetMonthCategories
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsBudgetMonthCategories
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsBudgetMonthCategories],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsBudgetMonthCategories']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsBudgetMonthCategories(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_budget_month_categories_to_jsonable(
        httplib_json_response_models_budget_month_categories: HttplibJsonResponseModelsBudgetMonthCategories,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsBudgetMonthCategories.

    :param httplib_json_response_models_budget_month_categories: instance of HttplibJsonResponseModelsBudgetMonthCategories to be JSON-ized
    :param path: path to the httplib_json_response_models_budget_month_categories used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_budget_month_categories.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_budget_month_categories.data,
        expected=[HttplibJsonResponseDataModelsBudgetMonthCategories],
        path='{}.data'.format(path))

    if httplib_json_response_models_budget_month_categories.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_budget_month_categories.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_budget_month_categories.id is not None:
        res['id'] = httplib_json_response_models_budget_month_categories.id

    return res


class HttplibJsonResponseModelsBudgetMonths:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsBudgetMonths'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_budget_months_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_budget_months_to_jsonable(self)


def new_httplib_json_response_models_budget_months() -> HttplibJsonResponseModelsBudgetMonths:
    """Generates an instance of HttplibJsonResponseModelsBudgetMonths with default values."""
    return HttplibJsonResponseModelsBudgetMonths()


def httplib_json_response_models_budget_months_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsBudgetMonths:
    """
    Generates an instance of HttplibJsonResponseModelsBudgetMonths from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsBudgetMonths
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsBudgetMonths
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsBudgetMonths],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsBudgetMonths']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsBudgetMonths(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_budget_months_to_jsonable(
        httplib_json_response_models_budget_months: HttplibJsonResponseModelsBudgetMonths,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsBudgetMonths.

    :param httplib_json_response_models_budget_months: instance of HttplibJsonResponseModelsBudgetMonths to be JSON-ized
    :param path: path to the httplib_json_response_models_budget_months used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_budget_months.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_budget_months.data,
        expected=[HttplibJsonResponseDataModelsBudgetMonths],
        path='{}.data'.format(path))

    if httplib_json_response_models_budget_months.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_budget_months.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_budget_months.id is not None:
        res['id'] = httplib_json_response_models_budget_months.id

    return res


class HttplibJsonResponseModelsBudgetPayees:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsBudgetPayees'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_budget_payees_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_budget_payees_to_jsonable(self)


def new_httplib_json_response_models_budget_payees() -> HttplibJsonResponseModelsBudgetPayees:
    """Generates an instance of HttplibJsonResponseModelsBudgetPayees with default values."""
    return HttplibJsonResponseModelsBudgetPayees()


def httplib_json_response_models_budget_payees_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsBudgetPayees:
    """
    Generates an instance of HttplibJsonResponseModelsBudgetPayees from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsBudgetPayees
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsBudgetPayees
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsBudgetPayees],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsBudgetPayees']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsBudgetPayees(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_budget_payees_to_jsonable(
        httplib_json_response_models_budget_payees: HttplibJsonResponseModelsBudgetPayees,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsBudgetPayees.

    :param httplib_json_response_models_budget_payees: instance of HttplibJsonResponseModelsBudgetPayees to be JSON-ized
    :param path: path to the httplib_json_response_models_budget_payees used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_budget_payees.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_budget_payees.data,
        expected=[HttplibJsonResponseDataModelsBudgetPayees],
        path='{}.data'.format(path))

    if httplib_json_response_models_budget_payees.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_budget_payees.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_budget_payees.id is not None:
        res['id'] = httplib_json_response_models_budget_payees.id

    return res


class HttplibJsonResponseModelsBudgetRecurrences:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsBudgetRecurrences'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_budget_recurrences_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_budget_recurrences_to_jsonable(self)


def new_httplib_json_response_models_budget_recurrences() -> HttplibJsonResponseModelsBudgetRecurrences:
    """Generates an instance of HttplibJsonResponseModelsBudgetRecurrences with default values."""
    return HttplibJsonResponseModelsBudgetRecurrences()


def httplib_json_response_models_budget_recurrences_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsBudgetRecurrences:
    """
    Generates an instance of HttplibJsonResponseModelsBudgetRecurrences from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsBudgetRecurrences
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsBudgetRecurrences
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsBudgetRecurrences],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsBudgetRecurrences']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsBudgetRecurrences(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_budget_recurrences_to_jsonable(
        httplib_json_response_models_budget_recurrences: HttplibJsonResponseModelsBudgetRecurrences,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsBudgetRecurrences.

    :param httplib_json_response_models_budget_recurrences: instance of HttplibJsonResponseModelsBudgetRecurrences to be JSON-ized
    :param path: path to the httplib_json_response_models_budget_recurrences used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_budget_recurrences.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_budget_recurrences.data,
        expected=[HttplibJsonResponseDataModelsBudgetRecurrences],
        path='{}.data'.format(path))

    if httplib_json_response_models_budget_recurrences.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_budget_recurrences.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_budget_recurrences.id is not None:
        res['id'] = httplib_json_response_models_budget_recurrences.id

    return res


class HttplibJsonResponseModelsBudgetTransactions:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsBudgetTransactions'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_budget_transactions_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_budget_transactions_to_jsonable(self)


def new_httplib_json_response_models_budget_transactions() -> HttplibJsonResponseModelsBudgetTransactions:
    """Generates an instance of HttplibJsonResponseModelsBudgetTransactions with default values."""
    return HttplibJsonResponseModelsBudgetTransactions()


def httplib_json_response_models_budget_transactions_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsBudgetTransactions:
    """
    Generates an instance of HttplibJsonResponseModelsBudgetTransactions from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsBudgetTransactions
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsBudgetTransactions
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsBudgetTransactions],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsBudgetTransactions']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsBudgetTransactions(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_budget_transactions_to_jsonable(
        httplib_json_response_models_budget_transactions: HttplibJsonResponseModelsBudgetTransactions,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsBudgetTransactions.

    :param httplib_json_response_models_budget_transactions: instance of HttplibJsonResponseModelsBudgetTransactions to be JSON-ized
    :param path: path to the httplib_json_response_models_budget_transactions used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_budget_transactions.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_budget_transactions.data,
        expected=[HttplibJsonResponseDataModelsBudgetTransactions],
        path='{}.data'.format(path))

    if httplib_json_response_models_budget_transactions.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_budget_transactions.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_budget_transactions.id is not None:
        res['id'] = httplib_json_response_models_budget_transactions.id

    return res


class HttplibJsonResponseModelsCalendarEvents:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsCalendarEvents'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_calendar_events_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_calendar_events_to_jsonable(self)


def new_httplib_json_response_models_calendar_events() -> HttplibJsonResponseModelsCalendarEvents:
    """Generates an instance of HttplibJsonResponseModelsCalendarEvents with default values."""
    return HttplibJsonResponseModelsCalendarEvents()


def httplib_json_response_models_calendar_events_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsCalendarEvents:
    """
    Generates an instance of HttplibJsonResponseModelsCalendarEvents from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsCalendarEvents
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsCalendarEvents
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsCalendarEvents],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsCalendarEvents']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsCalendarEvents(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_calendar_events_to_jsonable(
        httplib_json_response_models_calendar_events: HttplibJsonResponseModelsCalendarEvents,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsCalendarEvents.

    :param httplib_json_response_models_calendar_events: instance of HttplibJsonResponseModelsCalendarEvents to be JSON-ized
    :param path: path to the httplib_json_response_models_calendar_events used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_calendar_events.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_calendar_events.data,
        expected=[HttplibJsonResponseDataModelsCalendarEvents],
        path='{}.data'.format(path))

    if httplib_json_response_models_calendar_events.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_calendar_events.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_calendar_events.id is not None:
        res['id'] = httplib_json_response_models_calendar_events.id

    return res


class HttplibJsonResponseModelsCalendarICalendars:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsCalendarICalendars'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_calendar_i_calendars_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_calendar_i_calendars_to_jsonable(self)


def new_httplib_json_response_models_calendar_i_calendars() -> HttplibJsonResponseModelsCalendarICalendars:
    """Generates an instance of HttplibJsonResponseModelsCalendarICalendars with default values."""
    return HttplibJsonResponseModelsCalendarICalendars()


def httplib_json_response_models_calendar_i_calendars_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsCalendarICalendars:
    """
    Generates an instance of HttplibJsonResponseModelsCalendarICalendars from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsCalendarICalendars
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsCalendarICalendars
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsCalendarICalendars],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsCalendarICalendars']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsCalendarICalendars(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_calendar_i_calendars_to_jsonable(
        httplib_json_response_models_calendar_i_calendars: HttplibJsonResponseModelsCalendarICalendars,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsCalendarICalendars.

    :param httplib_json_response_models_calendar_i_calendars: instance of HttplibJsonResponseModelsCalendarICalendars to be JSON-ized
    :param path: path to the httplib_json_response_models_calendar_i_calendars used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_calendar_i_calendars.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_calendar_i_calendars.data,
        expected=[HttplibJsonResponseDataModelsCalendarICalendars],
        path='{}.data'.format(path))

    if httplib_json_response_models_calendar_i_calendars.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_calendar_i_calendars.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_calendar_i_calendars.id is not None:
        res['id'] = httplib_json_response_models_calendar_i_calendars.id

    return res


class HttplibJsonResponseModelsChanges:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsChanges'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_changes_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_changes_to_jsonable(self)


def new_httplib_json_response_models_changes() -> HttplibJsonResponseModelsChanges:
    """Generates an instance of HttplibJsonResponseModelsChanges with default values."""
    return HttplibJsonResponseModelsChanges()


def httplib_json_response_models_changes_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsChanges:
    """
    Generates an instance of HttplibJsonResponseModelsChanges from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsChanges
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsChanges
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsChanges],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsChanges']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsChanges(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_changes_to_jsonable(
        httplib_json_response_models_changes: HttplibJsonResponseModelsChanges,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsChanges.

    :param httplib_json_response_models_changes: instance of HttplibJsonResponseModelsChanges to be JSON-ized
    :param path: path to the httplib_json_response_models_changes used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_changes.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_changes.data,
        expected=[HttplibJsonResponseDataModelsChanges],
        path='{}.data'.format(path))

    if httplib_json_response_models_changes.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_changes.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_changes.id is not None:
        res['id'] = httplib_json_response_models_changes.id

    return res


class HttplibJsonResponseModelsConfigKeys:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsConfigKeys'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_config_keys_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_config_keys_to_jsonable(self)


def new_httplib_json_response_models_config_keys() -> HttplibJsonResponseModelsConfigKeys:
    """Generates an instance of HttplibJsonResponseModelsConfigKeys with default values."""
    return HttplibJsonResponseModelsConfigKeys()


def httplib_json_response_models_config_keys_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsConfigKeys:
    """
    Generates an instance of HttplibJsonResponseModelsConfigKeys from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsConfigKeys
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsConfigKeys
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsConfigKeys],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsConfigKeys']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsConfigKeys(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_config_keys_to_jsonable(
        httplib_json_response_models_config_keys: HttplibJsonResponseModelsConfigKeys,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsConfigKeys.

    :param httplib_json_response_models_config_keys: instance of HttplibJsonResponseModelsConfigKeys to be JSON-ized
    :param path: path to the httplib_json_response_models_config_keys used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_config_keys.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_config_keys.data,
        expected=[HttplibJsonResponseDataModelsConfigKeys],
        path='{}.data'.format(path))

    if httplib_json_response_models_config_keys.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_config_keys.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_config_keys.id is not None:
        res['id'] = httplib_json_response_models_config_keys.id

    return res


class HttplibJsonResponseModelsCookMealPlans:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsCookMealPlans'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_cook_meal_plans_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_cook_meal_plans_to_jsonable(self)


def new_httplib_json_response_models_cook_meal_plans() -> HttplibJsonResponseModelsCookMealPlans:
    """Generates an instance of HttplibJsonResponseModelsCookMealPlans with default values."""
    return HttplibJsonResponseModelsCookMealPlans()


def httplib_json_response_models_cook_meal_plans_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsCookMealPlans:
    """
    Generates an instance of HttplibJsonResponseModelsCookMealPlans from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsCookMealPlans
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsCookMealPlans
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsCookMealPlans],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsCookMealPlans']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsCookMealPlans(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_cook_meal_plans_to_jsonable(
        httplib_json_response_models_cook_meal_plans: HttplibJsonResponseModelsCookMealPlans,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsCookMealPlans.

    :param httplib_json_response_models_cook_meal_plans: instance of HttplibJsonResponseModelsCookMealPlans to be JSON-ized
    :param path: path to the httplib_json_response_models_cook_meal_plans used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_cook_meal_plans.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_cook_meal_plans.data,
        expected=[HttplibJsonResponseDataModelsCookMealPlans],
        path='{}.data'.format(path))

    if httplib_json_response_models_cook_meal_plans.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_cook_meal_plans.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_cook_meal_plans.id is not None:
        res['id'] = httplib_json_response_models_cook_meal_plans.id

    return res


class HttplibJsonResponseModelsCookMealTimes:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsCookMealTimes'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_cook_meal_times_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_cook_meal_times_to_jsonable(self)


def new_httplib_json_response_models_cook_meal_times() -> HttplibJsonResponseModelsCookMealTimes:
    """Generates an instance of HttplibJsonResponseModelsCookMealTimes with default values."""
    return HttplibJsonResponseModelsCookMealTimes()


def httplib_json_response_models_cook_meal_times_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsCookMealTimes:
    """
    Generates an instance of HttplibJsonResponseModelsCookMealTimes from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsCookMealTimes
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsCookMealTimes
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsCookMealTimes],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsCookMealTimes']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsCookMealTimes(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_cook_meal_times_to_jsonable(
        httplib_json_response_models_cook_meal_times: HttplibJsonResponseModelsCookMealTimes,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsCookMealTimes.

    :param httplib_json_response_models_cook_meal_times: instance of HttplibJsonResponseModelsCookMealTimes to be JSON-ized
    :param path: path to the httplib_json_response_models_cook_meal_times used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_cook_meal_times.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_cook_meal_times.data,
        expected=[HttplibJsonResponseDataModelsCookMealTimes],
        path='{}.data'.format(path))

    if httplib_json_response_models_cook_meal_times.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_cook_meal_times.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_cook_meal_times.id is not None:
        res['id'] = httplib_json_response_models_cook_meal_times.id

    return res


class HttplibJsonResponseModelsCookRecipes:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsCookRecipes'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_cook_recipes_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_cook_recipes_to_jsonable(self)


def new_httplib_json_response_models_cook_recipes() -> HttplibJsonResponseModelsCookRecipes:
    """Generates an instance of HttplibJsonResponseModelsCookRecipes with default values."""
    return HttplibJsonResponseModelsCookRecipes()


def httplib_json_response_models_cook_recipes_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsCookRecipes:
    """
    Generates an instance of HttplibJsonResponseModelsCookRecipes from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsCookRecipes
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsCookRecipes
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsCookRecipes],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsCookRecipes']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsCookRecipes(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_cook_recipes_to_jsonable(
        httplib_json_response_models_cook_recipes: HttplibJsonResponseModelsCookRecipes,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsCookRecipes.

    :param httplib_json_response_models_cook_recipes: instance of HttplibJsonResponseModelsCookRecipes to be JSON-ized
    :param path: path to the httplib_json_response_models_cook_recipes used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_cook_recipes.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_cook_recipes.data,
        expected=[HttplibJsonResponseDataModelsCookRecipes],
        path='{}.data'.format(path))

    if httplib_json_response_models_cook_recipes.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_cook_recipes.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_cook_recipes.id is not None:
        res['id'] = httplib_json_response_models_cook_recipes.id

    return res


class HttplibJsonResponseModelsFeatureCandidates:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsFeatureCandidates'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_feature_candidates_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_feature_candidates_to_jsonable(self)


def new_httplib_json_response_models_feature_candidates() -> HttplibJsonResponseModelsFeatureCandidates:
    """Generates an instance of HttplibJsonResponseModelsFeatureCandidates with default values."""
    return HttplibJsonResponseModelsFeatureCandidates()


def httplib_json_response_models_feature_candidates_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsFeatureCandidates:
    """
    Generates an instance of HttplibJsonResponseModelsFeatureCandidates from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsFeatureCandidates
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsFeatureCandidates
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsFeatureCandidates],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsFeatureCandidates']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsFeatureCandidates(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_feature_candidates_to_jsonable(
        httplib_json_response_models_feature_candidates: HttplibJsonResponseModelsFeatureCandidates,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsFeatureCandidates.

    :param httplib_json_response_models_feature_candidates: instance of HttplibJsonResponseModelsFeatureCandidates to be JSON-ized
    :param path: path to the httplib_json_response_models_feature_candidates used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_feature_candidates.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_feature_candidates.data,
        expected=[HttplibJsonResponseDataModelsFeatureCandidates],
        path='{}.data'.format(path))

    if httplib_json_response_models_feature_candidates.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_feature_candidates.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_feature_candidates.id is not None:
        res['id'] = httplib_json_response_models_feature_candidates.id

    return res


class HttplibJsonResponseModelsFeatureVotes:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsFeatureVotes'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_feature_votes_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_feature_votes_to_jsonable(self)


def new_httplib_json_response_models_feature_votes() -> HttplibJsonResponseModelsFeatureVotes:
    """Generates an instance of HttplibJsonResponseModelsFeatureVotes with default values."""
    return HttplibJsonResponseModelsFeatureVotes()


def httplib_json_response_models_feature_votes_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsFeatureVotes:
    """
    Generates an instance of HttplibJsonResponseModelsFeatureVotes from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsFeatureVotes
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsFeatureVotes
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsFeatureVotes],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsFeatureVotes']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsFeatureVotes(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_feature_votes_to_jsonable(
        httplib_json_response_models_feature_votes: HttplibJsonResponseModelsFeatureVotes,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsFeatureVotes.

    :param httplib_json_response_models_feature_votes: instance of HttplibJsonResponseModelsFeatureVotes to be JSON-ized
    :param path: path to the httplib_json_response_models_feature_votes used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_feature_votes.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_feature_votes.data,
        expected=[HttplibJsonResponseDataModelsFeatureVotes],
        path='{}.data'.format(path))

    if httplib_json_response_models_feature_votes.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_feature_votes.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_feature_votes.id is not None:
        res['id'] = httplib_json_response_models_feature_votes.id

    return res


class HttplibJsonResponseModelsHealthItems:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsHealthItems'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_health_items_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_health_items_to_jsonable(self)


def new_httplib_json_response_models_health_items() -> HttplibJsonResponseModelsHealthItems:
    """Generates an instance of HttplibJsonResponseModelsHealthItems with default values."""
    return HttplibJsonResponseModelsHealthItems()


def httplib_json_response_models_health_items_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsHealthItems:
    """
    Generates an instance of HttplibJsonResponseModelsHealthItems from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsHealthItems
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsHealthItems
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsHealthItems],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsHealthItems']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsHealthItems(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_health_items_to_jsonable(
        httplib_json_response_models_health_items: HttplibJsonResponseModelsHealthItems,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsHealthItems.

    :param httplib_json_response_models_health_items: instance of HttplibJsonResponseModelsHealthItems to be JSON-ized
    :param path: path to the httplib_json_response_models_health_items used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_health_items.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_health_items.data,
        expected=[HttplibJsonResponseDataModelsHealthItems],
        path='{}.data'.format(path))

    if httplib_json_response_models_health_items.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_health_items.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_health_items.id is not None:
        res['id'] = httplib_json_response_models_health_items.id

    return res


class HttplibJsonResponseModelsHealthLogItems:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsHealthLogItems'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_health_log_items_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_health_log_items_to_jsonable(self)


def new_httplib_json_response_models_health_log_items() -> HttplibJsonResponseModelsHealthLogItems:
    """Generates an instance of HttplibJsonResponseModelsHealthLogItems with default values."""
    return HttplibJsonResponseModelsHealthLogItems()


def httplib_json_response_models_health_log_items_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsHealthLogItems:
    """
    Generates an instance of HttplibJsonResponseModelsHealthLogItems from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsHealthLogItems
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsHealthLogItems
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsHealthLogItems],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsHealthLogItems']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsHealthLogItems(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_health_log_items_to_jsonable(
        httplib_json_response_models_health_log_items: HttplibJsonResponseModelsHealthLogItems,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsHealthLogItems.

    :param httplib_json_response_models_health_log_items: instance of HttplibJsonResponseModelsHealthLogItems to be JSON-ized
    :param path: path to the httplib_json_response_models_health_log_items used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_health_log_items.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_health_log_items.data,
        expected=[HttplibJsonResponseDataModelsHealthLogItems],
        path='{}.data'.format(path))

    if httplib_json_response_models_health_log_items.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_health_log_items.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_health_log_items.id is not None:
        res['id'] = httplib_json_response_models_health_log_items.id

    return res


class HttplibJsonResponseModelsInventoryCollections:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsInventoryCollections'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_inventory_collections_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_inventory_collections_to_jsonable(self)


def new_httplib_json_response_models_inventory_collections() -> HttplibJsonResponseModelsInventoryCollections:
    """Generates an instance of HttplibJsonResponseModelsInventoryCollections with default values."""
    return HttplibJsonResponseModelsInventoryCollections()


def httplib_json_response_models_inventory_collections_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsInventoryCollections:
    """
    Generates an instance of HttplibJsonResponseModelsInventoryCollections from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsInventoryCollections
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsInventoryCollections
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsInventoryCollections],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsInventoryCollections']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsInventoryCollections(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_inventory_collections_to_jsonable(
        httplib_json_response_models_inventory_collections: HttplibJsonResponseModelsInventoryCollections,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsInventoryCollections.

    :param httplib_json_response_models_inventory_collections: instance of HttplibJsonResponseModelsInventoryCollections to be JSON-ized
    :param path: path to the httplib_json_response_models_inventory_collections used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_inventory_collections.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_inventory_collections.data,
        expected=[HttplibJsonResponseDataModelsInventoryCollections],
        path='{}.data'.format(path))

    if httplib_json_response_models_inventory_collections.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_inventory_collections.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_inventory_collections.id is not None:
        res['id'] = httplib_json_response_models_inventory_collections.id

    return res


class HttplibJsonResponseModelsInventoryItems:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsInventoryItems'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_inventory_items_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_inventory_items_to_jsonable(self)


def new_httplib_json_response_models_inventory_items() -> HttplibJsonResponseModelsInventoryItems:
    """Generates an instance of HttplibJsonResponseModelsInventoryItems with default values."""
    return HttplibJsonResponseModelsInventoryItems()


def httplib_json_response_models_inventory_items_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsInventoryItems:
    """
    Generates an instance of HttplibJsonResponseModelsInventoryItems from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsInventoryItems
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsInventoryItems
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsInventoryItems],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsInventoryItems']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsInventoryItems(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_inventory_items_to_jsonable(
        httplib_json_response_models_inventory_items: HttplibJsonResponseModelsInventoryItems,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsInventoryItems.

    :param httplib_json_response_models_inventory_items: instance of HttplibJsonResponseModelsInventoryItems to be JSON-ized
    :param path: path to the httplib_json_response_models_inventory_items used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_inventory_items.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_inventory_items.data,
        expected=[HttplibJsonResponseDataModelsInventoryItems],
        path='{}.data'.format(path))

    if httplib_json_response_models_inventory_items.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_inventory_items.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_inventory_items.id is not None:
        res['id'] = httplib_json_response_models_inventory_items.id

    return res


class HttplibJsonResponseModelsLabelsValues:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsLabelsValues'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_labels_values_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_labels_values_to_jsonable(self)


def new_httplib_json_response_models_labels_values() -> HttplibJsonResponseModelsLabelsValues:
    """Generates an instance of HttplibJsonResponseModelsLabelsValues with default values."""
    return HttplibJsonResponseModelsLabelsValues()


def httplib_json_response_models_labels_values_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsLabelsValues:
    """
    Generates an instance of HttplibJsonResponseModelsLabelsValues from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsLabelsValues
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsLabelsValues
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsLabelsValues],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsLabelsValues']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsLabelsValues(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_labels_values_to_jsonable(
        httplib_json_response_models_labels_values: HttplibJsonResponseModelsLabelsValues,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsLabelsValues.

    :param httplib_json_response_models_labels_values: instance of HttplibJsonResponseModelsLabelsValues to be JSON-ized
    :param path: path to the httplib_json_response_models_labels_values used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_labels_values.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_labels_values.data,
        expected=[HttplibJsonResponseDataModelsLabelsValues],
        path='{}.data'.format(path))

    if httplib_json_response_models_labels_values.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_labels_values.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_labels_values.id is not None:
        res['id'] = httplib_json_response_models_labels_values.id

    return res


class HttplibJsonResponseModelsNotesPageVersions:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsNotesPageVersions'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_notes_page_versions_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_notes_page_versions_to_jsonable(self)


def new_httplib_json_response_models_notes_page_versions() -> HttplibJsonResponseModelsNotesPageVersions:
    """Generates an instance of HttplibJsonResponseModelsNotesPageVersions with default values."""
    return HttplibJsonResponseModelsNotesPageVersions()


def httplib_json_response_models_notes_page_versions_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsNotesPageVersions:
    """
    Generates an instance of HttplibJsonResponseModelsNotesPageVersions from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsNotesPageVersions
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsNotesPageVersions
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsNotesPageVersions],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsNotesPageVersions']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsNotesPageVersions(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_notes_page_versions_to_jsonable(
        httplib_json_response_models_notes_page_versions: HttplibJsonResponseModelsNotesPageVersions,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsNotesPageVersions.

    :param httplib_json_response_models_notes_page_versions: instance of HttplibJsonResponseModelsNotesPageVersions to be JSON-ized
    :param path: path to the httplib_json_response_models_notes_page_versions used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_notes_page_versions.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_notes_page_versions.data,
        expected=[HttplibJsonResponseDataModelsNotesPageVersions],
        path='{}.data'.format(path))

    if httplib_json_response_models_notes_page_versions.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_notes_page_versions.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_notes_page_versions.id is not None:
        res['id'] = httplib_json_response_models_notes_page_versions.id

    return res


class HttplibJsonResponseModelsNotesPages:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsNotesPages'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_notes_pages_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_notes_pages_to_jsonable(self)


def new_httplib_json_response_models_notes_pages() -> HttplibJsonResponseModelsNotesPages:
    """Generates an instance of HttplibJsonResponseModelsNotesPages with default values."""
    return HttplibJsonResponseModelsNotesPages()


def httplib_json_response_models_notes_pages_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsNotesPages:
    """
    Generates an instance of HttplibJsonResponseModelsNotesPages from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsNotesPages
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsNotesPages
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsNotesPages],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsNotesPages']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsNotesPages(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_notes_pages_to_jsonable(
        httplib_json_response_models_notes_pages: HttplibJsonResponseModelsNotesPages,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsNotesPages.

    :param httplib_json_response_models_notes_pages: instance of HttplibJsonResponseModelsNotesPages to be JSON-ized
    :param path: path to the httplib_json_response_models_notes_pages used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_notes_pages.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_notes_pages.data,
        expected=[HttplibJsonResponseDataModelsNotesPages],
        path='{}.data'.format(path))

    if httplib_json_response_models_notes_pages.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_notes_pages.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_notes_pages.id is not None:
        res['id'] = httplib_json_response_models_notes_pages.id

    return res


class HttplibJsonResponseModelsPlanProjects:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsPlanProjects'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_plan_projects_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_plan_projects_to_jsonable(self)


def new_httplib_json_response_models_plan_projects() -> HttplibJsonResponseModelsPlanProjects:
    """Generates an instance of HttplibJsonResponseModelsPlanProjects with default values."""
    return HttplibJsonResponseModelsPlanProjects()


def httplib_json_response_models_plan_projects_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsPlanProjects:
    """
    Generates an instance of HttplibJsonResponseModelsPlanProjects from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsPlanProjects
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsPlanProjects
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsPlanProjects],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsPlanProjects']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsPlanProjects(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_plan_projects_to_jsonable(
        httplib_json_response_models_plan_projects: HttplibJsonResponseModelsPlanProjects,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsPlanProjects.

    :param httplib_json_response_models_plan_projects: instance of HttplibJsonResponseModelsPlanProjects to be JSON-ized
    :param path: path to the httplib_json_response_models_plan_projects used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_plan_projects.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_plan_projects.data,
        expected=[HttplibJsonResponseDataModelsPlanProjects],
        path='{}.data'.format(path))

    if httplib_json_response_models_plan_projects.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_plan_projects.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_plan_projects.id is not None:
        res['id'] = httplib_json_response_models_plan_projects.id

    return res


class HttplibJsonResponseModelsPlanTasks:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsPlanTasks'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_plan_tasks_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_plan_tasks_to_jsonable(self)


def new_httplib_json_response_models_plan_tasks() -> HttplibJsonResponseModelsPlanTasks:
    """Generates an instance of HttplibJsonResponseModelsPlanTasks with default values."""
    return HttplibJsonResponseModelsPlanTasks()


def httplib_json_response_models_plan_tasks_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsPlanTasks:
    """
    Generates an instance of HttplibJsonResponseModelsPlanTasks from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsPlanTasks
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsPlanTasks
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsPlanTasks],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsPlanTasks']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsPlanTasks(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_plan_tasks_to_jsonable(
        httplib_json_response_models_plan_tasks: HttplibJsonResponseModelsPlanTasks,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsPlanTasks.

    :param httplib_json_response_models_plan_tasks: instance of HttplibJsonResponseModelsPlanTasks to be JSON-ized
    :param path: path to the httplib_json_response_models_plan_tasks used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_plan_tasks.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_plan_tasks.data,
        expected=[HttplibJsonResponseDataModelsPlanTasks],
        path='{}.data'.format(path))

    if httplib_json_response_models_plan_tasks.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_plan_tasks.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_plan_tasks.id is not None:
        res['id'] = httplib_json_response_models_plan_tasks.id

    return res


class HttplibJsonResponseModelsRewardCards:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsRewardCards'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_reward_cards_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_reward_cards_to_jsonable(self)


def new_httplib_json_response_models_reward_cards() -> HttplibJsonResponseModelsRewardCards:
    """Generates an instance of HttplibJsonResponseModelsRewardCards with default values."""
    return HttplibJsonResponseModelsRewardCards()


def httplib_json_response_models_reward_cards_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsRewardCards:
    """
    Generates an instance of HttplibJsonResponseModelsRewardCards from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsRewardCards
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsRewardCards
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsRewardCards],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsRewardCards']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsRewardCards(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_reward_cards_to_jsonable(
        httplib_json_response_models_reward_cards: HttplibJsonResponseModelsRewardCards,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsRewardCards.

    :param httplib_json_response_models_reward_cards: instance of HttplibJsonResponseModelsRewardCards to be JSON-ized
    :param path: path to the httplib_json_response_models_reward_cards used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_reward_cards.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_reward_cards.data,
        expected=[HttplibJsonResponseDataModelsRewardCards],
        path='{}.data'.format(path))

    if httplib_json_response_models_reward_cards.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_reward_cards.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_reward_cards.id is not None:
        res['id'] = httplib_json_response_models_reward_cards.id

    return res


class HttplibJsonResponseModelsSecretsValues:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsSecretsValues'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_secrets_values_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_secrets_values_to_jsonable(self)


def new_httplib_json_response_models_secrets_values() -> HttplibJsonResponseModelsSecretsValues:
    """Generates an instance of HttplibJsonResponseModelsSecretsValues with default values."""
    return HttplibJsonResponseModelsSecretsValues()


def httplib_json_response_models_secrets_values_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsSecretsValues:
    """
    Generates an instance of HttplibJsonResponseModelsSecretsValues from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsSecretsValues
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsSecretsValues
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsSecretsValues],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsSecretsValues']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsSecretsValues(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_secrets_values_to_jsonable(
        httplib_json_response_models_secrets_values: HttplibJsonResponseModelsSecretsValues,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsSecretsValues.

    :param httplib_json_response_models_secrets_values: instance of HttplibJsonResponseModelsSecretsValues to be JSON-ized
    :param path: path to the httplib_json_response_models_secrets_values used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_secrets_values.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_secrets_values.data,
        expected=[HttplibJsonResponseDataModelsSecretsValues],
        path='{}.data'.format(path))

    if httplib_json_response_models_secrets_values.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_secrets_values.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_secrets_values.id is not None:
        res['id'] = httplib_json_response_models_secrets_values.id

    return res


class HttplibJsonResponseModelsSecretsVaults:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsSecretsVaults'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_secrets_vaults_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_secrets_vaults_to_jsonable(self)


def new_httplib_json_response_models_secrets_vaults() -> HttplibJsonResponseModelsSecretsVaults:
    """Generates an instance of HttplibJsonResponseModelsSecretsVaults with default values."""
    return HttplibJsonResponseModelsSecretsVaults()


def httplib_json_response_models_secrets_vaults_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsSecretsVaults:
    """
    Generates an instance of HttplibJsonResponseModelsSecretsVaults from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsSecretsVaults
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsSecretsVaults
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsSecretsVaults],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsSecretsVaults']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsSecretsVaults(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_secrets_vaults_to_jsonable(
        httplib_json_response_models_secrets_vaults: HttplibJsonResponseModelsSecretsVaults,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsSecretsVaults.

    :param httplib_json_response_models_secrets_vaults: instance of HttplibJsonResponseModelsSecretsVaults to be JSON-ized
    :param path: path to the httplib_json_response_models_secrets_vaults used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_secrets_vaults.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_secrets_vaults.data,
        expected=[HttplibJsonResponseDataModelsSecretsVaults],
        path='{}.data'.format(path))

    if httplib_json_response_models_secrets_vaults.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_secrets_vaults.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_secrets_vaults.id is not None:
        res['id'] = httplib_json_response_models_secrets_vaults.id

    return res


class HttplibJsonResponseModelsShopCategories:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsShopCategories'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_shop_categories_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_shop_categories_to_jsonable(self)


def new_httplib_json_response_models_shop_categories() -> HttplibJsonResponseModelsShopCategories:
    """Generates an instance of HttplibJsonResponseModelsShopCategories with default values."""
    return HttplibJsonResponseModelsShopCategories()


def httplib_json_response_models_shop_categories_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsShopCategories:
    """
    Generates an instance of HttplibJsonResponseModelsShopCategories from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsShopCategories
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsShopCategories
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsShopCategories],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsShopCategories']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsShopCategories(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_shop_categories_to_jsonable(
        httplib_json_response_models_shop_categories: HttplibJsonResponseModelsShopCategories,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsShopCategories.

    :param httplib_json_response_models_shop_categories: instance of HttplibJsonResponseModelsShopCategories to be JSON-ized
    :param path: path to the httplib_json_response_models_shop_categories used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_shop_categories.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_shop_categories.data,
        expected=[HttplibJsonResponseDataModelsShopCategories],
        path='{}.data'.format(path))

    if httplib_json_response_models_shop_categories.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_shop_categories.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_shop_categories.id is not None:
        res['id'] = httplib_json_response_models_shop_categories.id

    return res


class HttplibJsonResponseModelsShopItems:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsShopItems'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_shop_items_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_shop_items_to_jsonable(self)


def new_httplib_json_response_models_shop_items() -> HttplibJsonResponseModelsShopItems:
    """Generates an instance of HttplibJsonResponseModelsShopItems with default values."""
    return HttplibJsonResponseModelsShopItems()


def httplib_json_response_models_shop_items_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsShopItems:
    """
    Generates an instance of HttplibJsonResponseModelsShopItems from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsShopItems
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsShopItems
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsShopItems],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsShopItems']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsShopItems(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_shop_items_to_jsonable(
        httplib_json_response_models_shop_items: HttplibJsonResponseModelsShopItems,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsShopItems.

    :param httplib_json_response_models_shop_items: instance of HttplibJsonResponseModelsShopItems to be JSON-ized
    :param path: path to the httplib_json_response_models_shop_items used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_shop_items.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_shop_items.data,
        expected=[HttplibJsonResponseDataModelsShopItems],
        path='{}.data'.format(path))

    if httplib_json_response_models_shop_items.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_shop_items.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_shop_items.id is not None:
        res['id'] = httplib_json_response_models_shop_items.id

    return res


class HttplibJsonResponseModelsShopLists:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataModelsShopLists'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_models_shop_lists_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_models_shop_lists_to_jsonable(self)


def new_httplib_json_response_models_shop_lists() -> HttplibJsonResponseModelsShopLists:
    """Generates an instance of HttplibJsonResponseModelsShopLists with default values."""
    return HttplibJsonResponseModelsShopLists()


def httplib_json_response_models_shop_lists_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseModelsShopLists:
    """
    Generates an instance of HttplibJsonResponseModelsShopLists from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseModelsShopLists
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseModelsShopLists
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataModelsShopLists],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataModelsShopLists']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseModelsShopLists(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_models_shop_lists_to_jsonable(
        httplib_json_response_models_shop_lists: HttplibJsonResponseModelsShopLists,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseModelsShopLists.

    :param httplib_json_response_models_shop_lists: instance of HttplibJsonResponseModelsShopLists to be JSON-ized
    :param path: path to the httplib_json_response_models_shop_lists used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_models_shop_lists.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_models_shop_lists.data,
        expected=[HttplibJsonResponseDataModelsShopLists],
        path='{}.data'.format(path))

    if httplib_json_response_models_shop_lists.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_models_shop_lists.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_models_shop_lists.id is not None:
        res['id'] = httplib_json_response_models_shop_lists.id

    return res


class HttplibJsonResponseWebauthnCredentialCreationOpts:
    def __init__(
            self,
            data: Optional['HttplibJsonResponseDataWebauthnCredentialCreationOpts'] = None,
            error: Optional['HttplibJsonResponseError'] = None,
            id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data = data

        self.error = error

        self.id = id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_webauthn_credential_creation_opts_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_webauthn_credential_creation_opts_to_jsonable(self)


def new_httplib_json_response_webauthn_credential_creation_opts() -> HttplibJsonResponseWebauthnCredentialCreationOpts:
    """Generates an instance of HttplibJsonResponseWebauthnCredentialCreationOpts with default values."""
    return HttplibJsonResponseWebauthnCredentialCreationOpts()


def httplib_json_response_webauthn_credential_creation_opts_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseWebauthnCredentialCreationOpts:
    """
    Generates an instance of HttplibJsonResponseWebauthnCredentialCreationOpts from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseWebauthnCredentialCreationOpts
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseWebauthnCredentialCreationOpts
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data = obj.get('data', None)
    if obj_data is not None:
        data_from_obj = from_obj(
            obj_data,
            expected=[HttplibJsonResponseDataWebauthnCredentialCreationOpts],
            path=path + '.data')  # type: Optional['HttplibJsonResponseDataWebauthnCredentialCreationOpts']
    else:
        data_from_obj = None

    obj_error = obj.get('error', None)
    if obj_error is not None:
        error_from_obj = from_obj(
            obj_error,
            expected=[HttplibJsonResponseError],
            path=path + '.error')  # type: Optional['HttplibJsonResponseError']
    else:
        error_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    return HttplibJsonResponseWebauthnCredentialCreationOpts(
        data=data_from_obj,
        error=error_from_obj,
        id=id_from_obj)


def httplib_json_response_webauthn_credential_creation_opts_to_jsonable(
        httplib_json_response_webauthn_credential_creation_opts: HttplibJsonResponseWebauthnCredentialCreationOpts,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseWebauthnCredentialCreationOpts.

    :param httplib_json_response_webauthn_credential_creation_opts: instance of HttplibJsonResponseWebauthnCredentialCreationOpts to be JSON-ized
    :param path: path to the httplib_json_response_webauthn_credential_creation_opts used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_webauthn_credential_creation_opts.data is not None:
        res['data'] = to_jsonable(
        httplib_json_response_webauthn_credential_creation_opts.data,
        expected=[HttplibJsonResponseDataWebauthnCredentialCreationOpts],
        path='{}.data'.format(path))

    if httplib_json_response_webauthn_credential_creation_opts.error is not None:
        res['error'] = to_jsonable(
        httplib_json_response_webauthn_credential_creation_opts.error,
        expected=[HttplibJsonResponseError],
        path='{}.error'.format(path))

    if httplib_json_response_webauthn_credential_creation_opts.id is not None:
        res['id'] = httplib_json_response_webauthn_credential_creation_opts.id

    return res


class HttplibJsonResponseCacheID:
    def __init__(
            self,
            id: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.id = id

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_cache_id_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_cache_id_to_jsonable(self)


def new_httplib_json_response_cache_id() -> HttplibJsonResponseCacheID:
    """Generates an instance of HttplibJsonResponseCacheID with default values."""
    return HttplibJsonResponseCacheID()


def httplib_json_response_cache_id_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseCacheID:
    """
    Generates an instance of HttplibJsonResponseCacheID from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseCacheID
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseCacheID
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return HttplibJsonResponseCacheID(
        id=id_from_obj,
        updated=updated_from_obj)


def httplib_json_response_cache_id_to_jsonable(
        httplib_json_response_cache_id: HttplibJsonResponseCacheID,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseCacheID.

    :param httplib_json_response_cache_id: instance of HttplibJsonResponseCacheID to be JSON-ized
    :param path: path to the httplib_json_response_cache_id used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_cache_id.id is not None:
        res['id'] = httplib_json_response_cache_id.id

    if httplib_json_response_cache_id.updated is not None:
        res['updated'] = httplib_json_response_cache_id.updated

    return res


class HttplibJsonResponseDataConfigConfig:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional['ConfigConfig'] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_config_config_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_config_config_to_jsonable(self)


def new_httplib_json_response_data_config_config() -> HttplibJsonResponseDataConfigConfig:
    """Generates an instance of HttplibJsonResponseDataConfigConfig with default values."""
    return HttplibJsonResponseDataConfigConfig()


def httplib_json_response_data_config_config_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataConfigConfig:
    """
    Generates an instance of HttplibJsonResponseDataConfigConfig from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataConfigConfig
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataConfigConfig
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[ConfigConfig],
            path=path + '.value')  # type: Optional['ConfigConfig']
    else:
        value_from_obj = None

    return HttplibJsonResponseDataConfigConfig(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_config_config_to_jsonable(
        httplib_json_response_data_config_config: HttplibJsonResponseDataConfigConfig,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataConfigConfig.

    :param httplib_json_response_data_config_config: instance of HttplibJsonResponseDataConfigConfig to be JSON-ized
    :param path: path to the httplib_json_response_data_config_config used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_config_config.hash is not None:
        res['hash'] = httplib_json_response_data_config_config.hash

    if httplib_json_response_data_config_config.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_config_config.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_config_config.total is not None:
        res['total'] = httplib_json_response_data_config_config.total

    if httplib_json_response_data_config_config.type is not None:
        res['type'] = httplib_json_response_data_config_config.type

    if httplib_json_response_data_config_config.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_config_config.value,
        expected=[ConfigConfig],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsAuthAccountDelegations:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsAuthAccountDelegation']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_auth_account_delegations_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_auth_account_delegations_to_jsonable(self)


def new_httplib_json_response_data_models_auth_account_delegations() -> HttplibJsonResponseDataModelsAuthAccountDelegations:
    """Generates an instance of HttplibJsonResponseDataModelsAuthAccountDelegations with default values."""
    return HttplibJsonResponseDataModelsAuthAccountDelegations()


def httplib_json_response_data_models_auth_account_delegations_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsAuthAccountDelegations:
    """
    Generates an instance of HttplibJsonResponseDataModelsAuthAccountDelegations from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsAuthAccountDelegations
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsAuthAccountDelegations
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsAuthAccountDelegation],
            path=path + '.value')  # type: Optional[List['ModelsAuthAccountDelegation']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsAuthAccountDelegations(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_auth_account_delegations_to_jsonable(
        httplib_json_response_data_models_auth_account_delegations: HttplibJsonResponseDataModelsAuthAccountDelegations,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsAuthAccountDelegations.

    :param httplib_json_response_data_models_auth_account_delegations: instance of HttplibJsonResponseDataModelsAuthAccountDelegations to be JSON-ized
    :param path: path to the httplib_json_response_data_models_auth_account_delegations used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_auth_account_delegations.hash is not None:
        res['hash'] = httplib_json_response_data_models_auth_account_delegations.hash

    if httplib_json_response_data_models_auth_account_delegations.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_auth_account_delegations.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_auth_account_delegations.total is not None:
        res['total'] = httplib_json_response_data_models_auth_account_delegations.total

    if httplib_json_response_data_models_auth_account_delegations.type is not None:
        res['type'] = httplib_json_response_data_models_auth_account_delegations.type

    if httplib_json_response_data_models_auth_account_delegations.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_auth_account_delegations.value,
        expected=[list, ModelsAuthAccountDelegation],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsAuthAccounts:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsAuthAccount']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_auth_accounts_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_auth_accounts_to_jsonable(self)


def new_httplib_json_response_data_models_auth_accounts() -> HttplibJsonResponseDataModelsAuthAccounts:
    """Generates an instance of HttplibJsonResponseDataModelsAuthAccounts with default values."""
    return HttplibJsonResponseDataModelsAuthAccounts()


def httplib_json_response_data_models_auth_accounts_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsAuthAccounts:
    """
    Generates an instance of HttplibJsonResponseDataModelsAuthAccounts from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsAuthAccounts
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsAuthAccounts
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsAuthAccount],
            path=path + '.value')  # type: Optional[List['ModelsAuthAccount']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsAuthAccounts(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_auth_accounts_to_jsonable(
        httplib_json_response_data_models_auth_accounts: HttplibJsonResponseDataModelsAuthAccounts,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsAuthAccounts.

    :param httplib_json_response_data_models_auth_accounts: instance of HttplibJsonResponseDataModelsAuthAccounts to be JSON-ized
    :param path: path to the httplib_json_response_data_models_auth_accounts used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_auth_accounts.hash is not None:
        res['hash'] = httplib_json_response_data_models_auth_accounts.hash

    if httplib_json_response_data_models_auth_accounts.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_auth_accounts.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_auth_accounts.total is not None:
        res['total'] = httplib_json_response_data_models_auth_accounts.total

    if httplib_json_response_data_models_auth_accounts.type is not None:
        res['type'] = httplib_json_response_data_models_auth_accounts.type

    if httplib_json_response_data_models_auth_accounts.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_auth_accounts.value,
        expected=[list, ModelsAuthAccount],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsAuthHouseholds:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsAuthHousehold']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_auth_households_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_auth_households_to_jsonable(self)


def new_httplib_json_response_data_models_auth_households() -> HttplibJsonResponseDataModelsAuthHouseholds:
    """Generates an instance of HttplibJsonResponseDataModelsAuthHouseholds with default values."""
    return HttplibJsonResponseDataModelsAuthHouseholds()


def httplib_json_response_data_models_auth_households_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsAuthHouseholds:
    """
    Generates an instance of HttplibJsonResponseDataModelsAuthHouseholds from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsAuthHouseholds
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsAuthHouseholds
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsAuthHousehold],
            path=path + '.value')  # type: Optional[List['ModelsAuthHousehold']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsAuthHouseholds(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_auth_households_to_jsonable(
        httplib_json_response_data_models_auth_households: HttplibJsonResponseDataModelsAuthHouseholds,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsAuthHouseholds.

    :param httplib_json_response_data_models_auth_households: instance of HttplibJsonResponseDataModelsAuthHouseholds to be JSON-ized
    :param path: path to the httplib_json_response_data_models_auth_households used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_auth_households.hash is not None:
        res['hash'] = httplib_json_response_data_models_auth_households.hash

    if httplib_json_response_data_models_auth_households.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_auth_households.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_auth_households.total is not None:
        res['total'] = httplib_json_response_data_models_auth_households.total

    if httplib_json_response_data_models_auth_households.type is not None:
        res['type'] = httplib_json_response_data_models_auth_households.type

    if httplib_json_response_data_models_auth_households.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_auth_households.value,
        expected=[list, ModelsAuthHousehold],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsAuthOIDCClients:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsAuthOIDCClient']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_auth_o_id_c_clients_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_auth_o_id_c_clients_to_jsonable(self)


def new_httplib_json_response_data_models_auth_o_id_c_clients() -> HttplibJsonResponseDataModelsAuthOIDCClients:
    """Generates an instance of HttplibJsonResponseDataModelsAuthOIDCClients with default values."""
    return HttplibJsonResponseDataModelsAuthOIDCClients()


def httplib_json_response_data_models_auth_o_id_c_clients_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsAuthOIDCClients:
    """
    Generates an instance of HttplibJsonResponseDataModelsAuthOIDCClients from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsAuthOIDCClients
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsAuthOIDCClients
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsAuthOIDCClient],
            path=path + '.value')  # type: Optional[List['ModelsAuthOIDCClient']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsAuthOIDCClients(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_auth_o_id_c_clients_to_jsonable(
        httplib_json_response_data_models_auth_o_id_c_clients: HttplibJsonResponseDataModelsAuthOIDCClients,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsAuthOIDCClients.

    :param httplib_json_response_data_models_auth_o_id_c_clients: instance of HttplibJsonResponseDataModelsAuthOIDCClients to be JSON-ized
    :param path: path to the httplib_json_response_data_models_auth_o_id_c_clients used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_auth_o_id_c_clients.hash is not None:
        res['hash'] = httplib_json_response_data_models_auth_o_id_c_clients.hash

    if httplib_json_response_data_models_auth_o_id_c_clients.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_auth_o_id_c_clients.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_auth_o_id_c_clients.total is not None:
        res['total'] = httplib_json_response_data_models_auth_o_id_c_clients.total

    if httplib_json_response_data_models_auth_o_id_c_clients.type is not None:
        res['type'] = httplib_json_response_data_models_auth_o_id_c_clients.type

    if httplib_json_response_data_models_auth_o_id_c_clients.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_auth_o_id_c_clients.value,
        expected=[list, ModelsAuthOIDCClient],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsAuthOIDCCodes:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsAuthOIDCCode']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_auth_o_id_c_codes_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_auth_o_id_c_codes_to_jsonable(self)


def new_httplib_json_response_data_models_auth_o_id_c_codes() -> HttplibJsonResponseDataModelsAuthOIDCCodes:
    """Generates an instance of HttplibJsonResponseDataModelsAuthOIDCCodes with default values."""
    return HttplibJsonResponseDataModelsAuthOIDCCodes()


def httplib_json_response_data_models_auth_o_id_c_codes_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsAuthOIDCCodes:
    """
    Generates an instance of HttplibJsonResponseDataModelsAuthOIDCCodes from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsAuthOIDCCodes
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsAuthOIDCCodes
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsAuthOIDCCode],
            path=path + '.value')  # type: Optional[List['ModelsAuthOIDCCode']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsAuthOIDCCodes(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_auth_o_id_c_codes_to_jsonable(
        httplib_json_response_data_models_auth_o_id_c_codes: HttplibJsonResponseDataModelsAuthOIDCCodes,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsAuthOIDCCodes.

    :param httplib_json_response_data_models_auth_o_id_c_codes: instance of HttplibJsonResponseDataModelsAuthOIDCCodes to be JSON-ized
    :param path: path to the httplib_json_response_data_models_auth_o_id_c_codes used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_auth_o_id_c_codes.hash is not None:
        res['hash'] = httplib_json_response_data_models_auth_o_id_c_codes.hash

    if httplib_json_response_data_models_auth_o_id_c_codes.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_auth_o_id_c_codes.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_auth_o_id_c_codes.total is not None:
        res['total'] = httplib_json_response_data_models_auth_o_id_c_codes.total

    if httplib_json_response_data_models_auth_o_id_c_codes.type is not None:
        res['type'] = httplib_json_response_data_models_auth_o_id_c_codes.type

    if httplib_json_response_data_models_auth_o_id_c_codes.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_auth_o_id_c_codes.value,
        expected=[list, ModelsAuthOIDCCode],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsAuthSessions:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsAuthSession']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_auth_sessions_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_auth_sessions_to_jsonable(self)


def new_httplib_json_response_data_models_auth_sessions() -> HttplibJsonResponseDataModelsAuthSessions:
    """Generates an instance of HttplibJsonResponseDataModelsAuthSessions with default values."""
    return HttplibJsonResponseDataModelsAuthSessions()


def httplib_json_response_data_models_auth_sessions_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsAuthSessions:
    """
    Generates an instance of HttplibJsonResponseDataModelsAuthSessions from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsAuthSessions
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsAuthSessions
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsAuthSession],
            path=path + '.value')  # type: Optional[List['ModelsAuthSession']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsAuthSessions(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_auth_sessions_to_jsonable(
        httplib_json_response_data_models_auth_sessions: HttplibJsonResponseDataModelsAuthSessions,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsAuthSessions.

    :param httplib_json_response_data_models_auth_sessions: instance of HttplibJsonResponseDataModelsAuthSessions to be JSON-ized
    :param path: path to the httplib_json_response_data_models_auth_sessions used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_auth_sessions.hash is not None:
        res['hash'] = httplib_json_response_data_models_auth_sessions.hash

    if httplib_json_response_data_models_auth_sessions.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_auth_sessions.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_auth_sessions.total is not None:
        res['total'] = httplib_json_response_data_models_auth_sessions.total

    if httplib_json_response_data_models_auth_sessions.type is not None:
        res['type'] = httplib_json_response_data_models_auth_sessions.type

    if httplib_json_response_data_models_auth_sessions.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_auth_sessions.value,
        expected=[list, ModelsAuthSession],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsBookmarks:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsBookmark']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_bookmarks_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_bookmarks_to_jsonable(self)


def new_httplib_json_response_data_models_bookmarks() -> HttplibJsonResponseDataModelsBookmarks:
    """Generates an instance of HttplibJsonResponseDataModelsBookmarks with default values."""
    return HttplibJsonResponseDataModelsBookmarks()


def httplib_json_response_data_models_bookmarks_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsBookmarks:
    """
    Generates an instance of HttplibJsonResponseDataModelsBookmarks from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsBookmarks
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsBookmarks
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsBookmark],
            path=path + '.value')  # type: Optional[List['ModelsBookmark']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsBookmarks(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_bookmarks_to_jsonable(
        httplib_json_response_data_models_bookmarks: HttplibJsonResponseDataModelsBookmarks,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsBookmarks.

    :param httplib_json_response_data_models_bookmarks: instance of HttplibJsonResponseDataModelsBookmarks to be JSON-ized
    :param path: path to the httplib_json_response_data_models_bookmarks used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_bookmarks.hash is not None:
        res['hash'] = httplib_json_response_data_models_bookmarks.hash

    if httplib_json_response_data_models_bookmarks.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_bookmarks.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_bookmarks.total is not None:
        res['total'] = httplib_json_response_data_models_bookmarks.total

    if httplib_json_response_data_models_bookmarks.type is not None:
        res['type'] = httplib_json_response_data_models_bookmarks.type

    if httplib_json_response_data_models_bookmarks.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_bookmarks.value,
        expected=[list, ModelsBookmark],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsBudgetAccounts:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsBudgetAccount']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_budget_accounts_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_budget_accounts_to_jsonable(self)


def new_httplib_json_response_data_models_budget_accounts() -> HttplibJsonResponseDataModelsBudgetAccounts:
    """Generates an instance of HttplibJsonResponseDataModelsBudgetAccounts with default values."""
    return HttplibJsonResponseDataModelsBudgetAccounts()


def httplib_json_response_data_models_budget_accounts_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsBudgetAccounts:
    """
    Generates an instance of HttplibJsonResponseDataModelsBudgetAccounts from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsBudgetAccounts
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsBudgetAccounts
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsBudgetAccount],
            path=path + '.value')  # type: Optional[List['ModelsBudgetAccount']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsBudgetAccounts(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_budget_accounts_to_jsonable(
        httplib_json_response_data_models_budget_accounts: HttplibJsonResponseDataModelsBudgetAccounts,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsBudgetAccounts.

    :param httplib_json_response_data_models_budget_accounts: instance of HttplibJsonResponseDataModelsBudgetAccounts to be JSON-ized
    :param path: path to the httplib_json_response_data_models_budget_accounts used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_budget_accounts.hash is not None:
        res['hash'] = httplib_json_response_data_models_budget_accounts.hash

    if httplib_json_response_data_models_budget_accounts.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_budget_accounts.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_budget_accounts.total is not None:
        res['total'] = httplib_json_response_data_models_budget_accounts.total

    if httplib_json_response_data_models_budget_accounts.type is not None:
        res['type'] = httplib_json_response_data_models_budget_accounts.type

    if httplib_json_response_data_models_budget_accounts.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_budget_accounts.value,
        expected=[list, ModelsBudgetAccount],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsBudgetCategories:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsBudgetCategory']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_budget_categories_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_budget_categories_to_jsonable(self)


def new_httplib_json_response_data_models_budget_categories() -> HttplibJsonResponseDataModelsBudgetCategories:
    """Generates an instance of HttplibJsonResponseDataModelsBudgetCategories with default values."""
    return HttplibJsonResponseDataModelsBudgetCategories()


def httplib_json_response_data_models_budget_categories_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsBudgetCategories:
    """
    Generates an instance of HttplibJsonResponseDataModelsBudgetCategories from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsBudgetCategories
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsBudgetCategories
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsBudgetCategory],
            path=path + '.value')  # type: Optional[List['ModelsBudgetCategory']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsBudgetCategories(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_budget_categories_to_jsonable(
        httplib_json_response_data_models_budget_categories: HttplibJsonResponseDataModelsBudgetCategories,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsBudgetCategories.

    :param httplib_json_response_data_models_budget_categories: instance of HttplibJsonResponseDataModelsBudgetCategories to be JSON-ized
    :param path: path to the httplib_json_response_data_models_budget_categories used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_budget_categories.hash is not None:
        res['hash'] = httplib_json_response_data_models_budget_categories.hash

    if httplib_json_response_data_models_budget_categories.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_budget_categories.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_budget_categories.total is not None:
        res['total'] = httplib_json_response_data_models_budget_categories.total

    if httplib_json_response_data_models_budget_categories.type is not None:
        res['type'] = httplib_json_response_data_models_budget_categories.type

    if httplib_json_response_data_models_budget_categories.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_budget_categories.value,
        expected=[list, ModelsBudgetCategory],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsBudgetMonthCategories:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsBudgetMonthCategory']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_budget_month_categories_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_budget_month_categories_to_jsonable(self)


def new_httplib_json_response_data_models_budget_month_categories() -> HttplibJsonResponseDataModelsBudgetMonthCategories:
    """Generates an instance of HttplibJsonResponseDataModelsBudgetMonthCategories with default values."""
    return HttplibJsonResponseDataModelsBudgetMonthCategories()


def httplib_json_response_data_models_budget_month_categories_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsBudgetMonthCategories:
    """
    Generates an instance of HttplibJsonResponseDataModelsBudgetMonthCategories from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsBudgetMonthCategories
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsBudgetMonthCategories
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsBudgetMonthCategory],
            path=path + '.value')  # type: Optional[List['ModelsBudgetMonthCategory']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsBudgetMonthCategories(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_budget_month_categories_to_jsonable(
        httplib_json_response_data_models_budget_month_categories: HttplibJsonResponseDataModelsBudgetMonthCategories,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsBudgetMonthCategories.

    :param httplib_json_response_data_models_budget_month_categories: instance of HttplibJsonResponseDataModelsBudgetMonthCategories to be JSON-ized
    :param path: path to the httplib_json_response_data_models_budget_month_categories used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_budget_month_categories.hash is not None:
        res['hash'] = httplib_json_response_data_models_budget_month_categories.hash

    if httplib_json_response_data_models_budget_month_categories.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_budget_month_categories.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_budget_month_categories.total is not None:
        res['total'] = httplib_json_response_data_models_budget_month_categories.total

    if httplib_json_response_data_models_budget_month_categories.type is not None:
        res['type'] = httplib_json_response_data_models_budget_month_categories.type

    if httplib_json_response_data_models_budget_month_categories.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_budget_month_categories.value,
        expected=[list, ModelsBudgetMonthCategory],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsBudgetMonths:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsBudgetMonth']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_budget_months_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_budget_months_to_jsonable(self)


def new_httplib_json_response_data_models_budget_months() -> HttplibJsonResponseDataModelsBudgetMonths:
    """Generates an instance of HttplibJsonResponseDataModelsBudgetMonths with default values."""
    return HttplibJsonResponseDataModelsBudgetMonths()


def httplib_json_response_data_models_budget_months_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsBudgetMonths:
    """
    Generates an instance of HttplibJsonResponseDataModelsBudgetMonths from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsBudgetMonths
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsBudgetMonths
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsBudgetMonth],
            path=path + '.value')  # type: Optional[List['ModelsBudgetMonth']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsBudgetMonths(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_budget_months_to_jsonable(
        httplib_json_response_data_models_budget_months: HttplibJsonResponseDataModelsBudgetMonths,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsBudgetMonths.

    :param httplib_json_response_data_models_budget_months: instance of HttplibJsonResponseDataModelsBudgetMonths to be JSON-ized
    :param path: path to the httplib_json_response_data_models_budget_months used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_budget_months.hash is not None:
        res['hash'] = httplib_json_response_data_models_budget_months.hash

    if httplib_json_response_data_models_budget_months.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_budget_months.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_budget_months.total is not None:
        res['total'] = httplib_json_response_data_models_budget_months.total

    if httplib_json_response_data_models_budget_months.type is not None:
        res['type'] = httplib_json_response_data_models_budget_months.type

    if httplib_json_response_data_models_budget_months.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_budget_months.value,
        expected=[list, ModelsBudgetMonth],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsBudgetPayees:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsBudgetPayee']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_budget_payees_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_budget_payees_to_jsonable(self)


def new_httplib_json_response_data_models_budget_payees() -> HttplibJsonResponseDataModelsBudgetPayees:
    """Generates an instance of HttplibJsonResponseDataModelsBudgetPayees with default values."""
    return HttplibJsonResponseDataModelsBudgetPayees()


def httplib_json_response_data_models_budget_payees_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsBudgetPayees:
    """
    Generates an instance of HttplibJsonResponseDataModelsBudgetPayees from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsBudgetPayees
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsBudgetPayees
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsBudgetPayee],
            path=path + '.value')  # type: Optional[List['ModelsBudgetPayee']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsBudgetPayees(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_budget_payees_to_jsonable(
        httplib_json_response_data_models_budget_payees: HttplibJsonResponseDataModelsBudgetPayees,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsBudgetPayees.

    :param httplib_json_response_data_models_budget_payees: instance of HttplibJsonResponseDataModelsBudgetPayees to be JSON-ized
    :param path: path to the httplib_json_response_data_models_budget_payees used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_budget_payees.hash is not None:
        res['hash'] = httplib_json_response_data_models_budget_payees.hash

    if httplib_json_response_data_models_budget_payees.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_budget_payees.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_budget_payees.total is not None:
        res['total'] = httplib_json_response_data_models_budget_payees.total

    if httplib_json_response_data_models_budget_payees.type is not None:
        res['type'] = httplib_json_response_data_models_budget_payees.type

    if httplib_json_response_data_models_budget_payees.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_budget_payees.value,
        expected=[list, ModelsBudgetPayee],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsBudgetRecurrences:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsBudgetRecurrence']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_budget_recurrences_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_budget_recurrences_to_jsonable(self)


def new_httplib_json_response_data_models_budget_recurrences() -> HttplibJsonResponseDataModelsBudgetRecurrences:
    """Generates an instance of HttplibJsonResponseDataModelsBudgetRecurrences with default values."""
    return HttplibJsonResponseDataModelsBudgetRecurrences()


def httplib_json_response_data_models_budget_recurrences_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsBudgetRecurrences:
    """
    Generates an instance of HttplibJsonResponseDataModelsBudgetRecurrences from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsBudgetRecurrences
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsBudgetRecurrences
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsBudgetRecurrence],
            path=path + '.value')  # type: Optional[List['ModelsBudgetRecurrence']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsBudgetRecurrences(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_budget_recurrences_to_jsonable(
        httplib_json_response_data_models_budget_recurrences: HttplibJsonResponseDataModelsBudgetRecurrences,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsBudgetRecurrences.

    :param httplib_json_response_data_models_budget_recurrences: instance of HttplibJsonResponseDataModelsBudgetRecurrences to be JSON-ized
    :param path: path to the httplib_json_response_data_models_budget_recurrences used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_budget_recurrences.hash is not None:
        res['hash'] = httplib_json_response_data_models_budget_recurrences.hash

    if httplib_json_response_data_models_budget_recurrences.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_budget_recurrences.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_budget_recurrences.total is not None:
        res['total'] = httplib_json_response_data_models_budget_recurrences.total

    if httplib_json_response_data_models_budget_recurrences.type is not None:
        res['type'] = httplib_json_response_data_models_budget_recurrences.type

    if httplib_json_response_data_models_budget_recurrences.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_budget_recurrences.value,
        expected=[list, ModelsBudgetRecurrence],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsBudgetTransactions:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsBudgetTransaction']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_budget_transactions_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_budget_transactions_to_jsonable(self)


def new_httplib_json_response_data_models_budget_transactions() -> HttplibJsonResponseDataModelsBudgetTransactions:
    """Generates an instance of HttplibJsonResponseDataModelsBudgetTransactions with default values."""
    return HttplibJsonResponseDataModelsBudgetTransactions()


def httplib_json_response_data_models_budget_transactions_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsBudgetTransactions:
    """
    Generates an instance of HttplibJsonResponseDataModelsBudgetTransactions from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsBudgetTransactions
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsBudgetTransactions
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsBudgetTransaction],
            path=path + '.value')  # type: Optional[List['ModelsBudgetTransaction']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsBudgetTransactions(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_budget_transactions_to_jsonable(
        httplib_json_response_data_models_budget_transactions: HttplibJsonResponseDataModelsBudgetTransactions,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsBudgetTransactions.

    :param httplib_json_response_data_models_budget_transactions: instance of HttplibJsonResponseDataModelsBudgetTransactions to be JSON-ized
    :param path: path to the httplib_json_response_data_models_budget_transactions used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_budget_transactions.hash is not None:
        res['hash'] = httplib_json_response_data_models_budget_transactions.hash

    if httplib_json_response_data_models_budget_transactions.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_budget_transactions.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_budget_transactions.total is not None:
        res['total'] = httplib_json_response_data_models_budget_transactions.total

    if httplib_json_response_data_models_budget_transactions.type is not None:
        res['type'] = httplib_json_response_data_models_budget_transactions.type

    if httplib_json_response_data_models_budget_transactions.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_budget_transactions.value,
        expected=[list, ModelsBudgetTransaction],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsCalendarEvents:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsCalendarEvent']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_calendar_events_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_calendar_events_to_jsonable(self)


def new_httplib_json_response_data_models_calendar_events() -> HttplibJsonResponseDataModelsCalendarEvents:
    """Generates an instance of HttplibJsonResponseDataModelsCalendarEvents with default values."""
    return HttplibJsonResponseDataModelsCalendarEvents()


def httplib_json_response_data_models_calendar_events_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsCalendarEvents:
    """
    Generates an instance of HttplibJsonResponseDataModelsCalendarEvents from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsCalendarEvents
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsCalendarEvents
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsCalendarEvent],
            path=path + '.value')  # type: Optional[List['ModelsCalendarEvent']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsCalendarEvents(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_calendar_events_to_jsonable(
        httplib_json_response_data_models_calendar_events: HttplibJsonResponseDataModelsCalendarEvents,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsCalendarEvents.

    :param httplib_json_response_data_models_calendar_events: instance of HttplibJsonResponseDataModelsCalendarEvents to be JSON-ized
    :param path: path to the httplib_json_response_data_models_calendar_events used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_calendar_events.hash is not None:
        res['hash'] = httplib_json_response_data_models_calendar_events.hash

    if httplib_json_response_data_models_calendar_events.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_calendar_events.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_calendar_events.total is not None:
        res['total'] = httplib_json_response_data_models_calendar_events.total

    if httplib_json_response_data_models_calendar_events.type is not None:
        res['type'] = httplib_json_response_data_models_calendar_events.type

    if httplib_json_response_data_models_calendar_events.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_calendar_events.value,
        expected=[list, ModelsCalendarEvent],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsCalendarICalendars:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsCalendarICalendar']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_calendar_i_calendars_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_calendar_i_calendars_to_jsonable(self)


def new_httplib_json_response_data_models_calendar_i_calendars() -> HttplibJsonResponseDataModelsCalendarICalendars:
    """Generates an instance of HttplibJsonResponseDataModelsCalendarICalendars with default values."""
    return HttplibJsonResponseDataModelsCalendarICalendars()


def httplib_json_response_data_models_calendar_i_calendars_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsCalendarICalendars:
    """
    Generates an instance of HttplibJsonResponseDataModelsCalendarICalendars from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsCalendarICalendars
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsCalendarICalendars
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsCalendarICalendar],
            path=path + '.value')  # type: Optional[List['ModelsCalendarICalendar']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsCalendarICalendars(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_calendar_i_calendars_to_jsonable(
        httplib_json_response_data_models_calendar_i_calendars: HttplibJsonResponseDataModelsCalendarICalendars,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsCalendarICalendars.

    :param httplib_json_response_data_models_calendar_i_calendars: instance of HttplibJsonResponseDataModelsCalendarICalendars to be JSON-ized
    :param path: path to the httplib_json_response_data_models_calendar_i_calendars used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_calendar_i_calendars.hash is not None:
        res['hash'] = httplib_json_response_data_models_calendar_i_calendars.hash

    if httplib_json_response_data_models_calendar_i_calendars.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_calendar_i_calendars.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_calendar_i_calendars.total is not None:
        res['total'] = httplib_json_response_data_models_calendar_i_calendars.total

    if httplib_json_response_data_models_calendar_i_calendars.type is not None:
        res['type'] = httplib_json_response_data_models_calendar_i_calendars.type

    if httplib_json_response_data_models_calendar_i_calendars.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_calendar_i_calendars.value,
        expected=[list, ModelsCalendarICalendar],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsChanges:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsChange']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_changes_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_changes_to_jsonable(self)


def new_httplib_json_response_data_models_changes() -> HttplibJsonResponseDataModelsChanges:
    """Generates an instance of HttplibJsonResponseDataModelsChanges with default values."""
    return HttplibJsonResponseDataModelsChanges()


def httplib_json_response_data_models_changes_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsChanges:
    """
    Generates an instance of HttplibJsonResponseDataModelsChanges from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsChanges
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsChanges
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsChange],
            path=path + '.value')  # type: Optional[List['ModelsChange']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsChanges(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_changes_to_jsonable(
        httplib_json_response_data_models_changes: HttplibJsonResponseDataModelsChanges,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsChanges.

    :param httplib_json_response_data_models_changes: instance of HttplibJsonResponseDataModelsChanges to be JSON-ized
    :param path: path to the httplib_json_response_data_models_changes used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_changes.hash is not None:
        res['hash'] = httplib_json_response_data_models_changes.hash

    if httplib_json_response_data_models_changes.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_changes.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_changes.total is not None:
        res['total'] = httplib_json_response_data_models_changes.total

    if httplib_json_response_data_models_changes.type is not None:
        res['type'] = httplib_json_response_data_models_changes.type

    if httplib_json_response_data_models_changes.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_changes.value,
        expected=[list, ModelsChange],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsConfigKeys:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsConfigKey']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_config_keys_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_config_keys_to_jsonable(self)


def new_httplib_json_response_data_models_config_keys() -> HttplibJsonResponseDataModelsConfigKeys:
    """Generates an instance of HttplibJsonResponseDataModelsConfigKeys with default values."""
    return HttplibJsonResponseDataModelsConfigKeys()


def httplib_json_response_data_models_config_keys_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsConfigKeys:
    """
    Generates an instance of HttplibJsonResponseDataModelsConfigKeys from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsConfigKeys
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsConfigKeys
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsConfigKey],
            path=path + '.value')  # type: Optional[List['ModelsConfigKey']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsConfigKeys(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_config_keys_to_jsonable(
        httplib_json_response_data_models_config_keys: HttplibJsonResponseDataModelsConfigKeys,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsConfigKeys.

    :param httplib_json_response_data_models_config_keys: instance of HttplibJsonResponseDataModelsConfigKeys to be JSON-ized
    :param path: path to the httplib_json_response_data_models_config_keys used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_config_keys.hash is not None:
        res['hash'] = httplib_json_response_data_models_config_keys.hash

    if httplib_json_response_data_models_config_keys.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_config_keys.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_config_keys.total is not None:
        res['total'] = httplib_json_response_data_models_config_keys.total

    if httplib_json_response_data_models_config_keys.type is not None:
        res['type'] = httplib_json_response_data_models_config_keys.type

    if httplib_json_response_data_models_config_keys.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_config_keys.value,
        expected=[list, ModelsConfigKey],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsCookMealPlans:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsCookMealPlan']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_cook_meal_plans_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_cook_meal_plans_to_jsonable(self)


def new_httplib_json_response_data_models_cook_meal_plans() -> HttplibJsonResponseDataModelsCookMealPlans:
    """Generates an instance of HttplibJsonResponseDataModelsCookMealPlans with default values."""
    return HttplibJsonResponseDataModelsCookMealPlans()


def httplib_json_response_data_models_cook_meal_plans_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsCookMealPlans:
    """
    Generates an instance of HttplibJsonResponseDataModelsCookMealPlans from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsCookMealPlans
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsCookMealPlans
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsCookMealPlan],
            path=path + '.value')  # type: Optional[List['ModelsCookMealPlan']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsCookMealPlans(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_cook_meal_plans_to_jsonable(
        httplib_json_response_data_models_cook_meal_plans: HttplibJsonResponseDataModelsCookMealPlans,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsCookMealPlans.

    :param httplib_json_response_data_models_cook_meal_plans: instance of HttplibJsonResponseDataModelsCookMealPlans to be JSON-ized
    :param path: path to the httplib_json_response_data_models_cook_meal_plans used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_cook_meal_plans.hash is not None:
        res['hash'] = httplib_json_response_data_models_cook_meal_plans.hash

    if httplib_json_response_data_models_cook_meal_plans.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_cook_meal_plans.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_cook_meal_plans.total is not None:
        res['total'] = httplib_json_response_data_models_cook_meal_plans.total

    if httplib_json_response_data_models_cook_meal_plans.type is not None:
        res['type'] = httplib_json_response_data_models_cook_meal_plans.type

    if httplib_json_response_data_models_cook_meal_plans.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_cook_meal_plans.value,
        expected=[list, ModelsCookMealPlan],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsCookMealTimes:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsCookMealTime']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_cook_meal_times_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_cook_meal_times_to_jsonable(self)


def new_httplib_json_response_data_models_cook_meal_times() -> HttplibJsonResponseDataModelsCookMealTimes:
    """Generates an instance of HttplibJsonResponseDataModelsCookMealTimes with default values."""
    return HttplibJsonResponseDataModelsCookMealTimes()


def httplib_json_response_data_models_cook_meal_times_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsCookMealTimes:
    """
    Generates an instance of HttplibJsonResponseDataModelsCookMealTimes from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsCookMealTimes
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsCookMealTimes
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsCookMealTime],
            path=path + '.value')  # type: Optional[List['ModelsCookMealTime']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsCookMealTimes(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_cook_meal_times_to_jsonable(
        httplib_json_response_data_models_cook_meal_times: HttplibJsonResponseDataModelsCookMealTimes,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsCookMealTimes.

    :param httplib_json_response_data_models_cook_meal_times: instance of HttplibJsonResponseDataModelsCookMealTimes to be JSON-ized
    :param path: path to the httplib_json_response_data_models_cook_meal_times used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_cook_meal_times.hash is not None:
        res['hash'] = httplib_json_response_data_models_cook_meal_times.hash

    if httplib_json_response_data_models_cook_meal_times.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_cook_meal_times.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_cook_meal_times.total is not None:
        res['total'] = httplib_json_response_data_models_cook_meal_times.total

    if httplib_json_response_data_models_cook_meal_times.type is not None:
        res['type'] = httplib_json_response_data_models_cook_meal_times.type

    if httplib_json_response_data_models_cook_meal_times.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_cook_meal_times.value,
        expected=[list, ModelsCookMealTime],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsCookRecipes:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsCookRecipe']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_cook_recipes_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_cook_recipes_to_jsonable(self)


def new_httplib_json_response_data_models_cook_recipes() -> HttplibJsonResponseDataModelsCookRecipes:
    """Generates an instance of HttplibJsonResponseDataModelsCookRecipes with default values."""
    return HttplibJsonResponseDataModelsCookRecipes()


def httplib_json_response_data_models_cook_recipes_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsCookRecipes:
    """
    Generates an instance of HttplibJsonResponseDataModelsCookRecipes from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsCookRecipes
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsCookRecipes
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsCookRecipe],
            path=path + '.value')  # type: Optional[List['ModelsCookRecipe']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsCookRecipes(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_cook_recipes_to_jsonable(
        httplib_json_response_data_models_cook_recipes: HttplibJsonResponseDataModelsCookRecipes,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsCookRecipes.

    :param httplib_json_response_data_models_cook_recipes: instance of HttplibJsonResponseDataModelsCookRecipes to be JSON-ized
    :param path: path to the httplib_json_response_data_models_cook_recipes used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_cook_recipes.hash is not None:
        res['hash'] = httplib_json_response_data_models_cook_recipes.hash

    if httplib_json_response_data_models_cook_recipes.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_cook_recipes.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_cook_recipes.total is not None:
        res['total'] = httplib_json_response_data_models_cook_recipes.total

    if httplib_json_response_data_models_cook_recipes.type is not None:
        res['type'] = httplib_json_response_data_models_cook_recipes.type

    if httplib_json_response_data_models_cook_recipes.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_cook_recipes.value,
        expected=[list, ModelsCookRecipe],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsFeatureCandidates:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsFeatureCandidate']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_feature_candidates_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_feature_candidates_to_jsonable(self)


def new_httplib_json_response_data_models_feature_candidates() -> HttplibJsonResponseDataModelsFeatureCandidates:
    """Generates an instance of HttplibJsonResponseDataModelsFeatureCandidates with default values."""
    return HttplibJsonResponseDataModelsFeatureCandidates()


def httplib_json_response_data_models_feature_candidates_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsFeatureCandidates:
    """
    Generates an instance of HttplibJsonResponseDataModelsFeatureCandidates from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsFeatureCandidates
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsFeatureCandidates
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsFeatureCandidate],
            path=path + '.value')  # type: Optional[List['ModelsFeatureCandidate']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsFeatureCandidates(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_feature_candidates_to_jsonable(
        httplib_json_response_data_models_feature_candidates: HttplibJsonResponseDataModelsFeatureCandidates,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsFeatureCandidates.

    :param httplib_json_response_data_models_feature_candidates: instance of HttplibJsonResponseDataModelsFeatureCandidates to be JSON-ized
    :param path: path to the httplib_json_response_data_models_feature_candidates used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_feature_candidates.hash is not None:
        res['hash'] = httplib_json_response_data_models_feature_candidates.hash

    if httplib_json_response_data_models_feature_candidates.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_feature_candidates.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_feature_candidates.total is not None:
        res['total'] = httplib_json_response_data_models_feature_candidates.total

    if httplib_json_response_data_models_feature_candidates.type is not None:
        res['type'] = httplib_json_response_data_models_feature_candidates.type

    if httplib_json_response_data_models_feature_candidates.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_feature_candidates.value,
        expected=[list, ModelsFeatureCandidate],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsFeatureVotes:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsFeatureVote']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_feature_votes_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_feature_votes_to_jsonable(self)


def new_httplib_json_response_data_models_feature_votes() -> HttplibJsonResponseDataModelsFeatureVotes:
    """Generates an instance of HttplibJsonResponseDataModelsFeatureVotes with default values."""
    return HttplibJsonResponseDataModelsFeatureVotes()


def httplib_json_response_data_models_feature_votes_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsFeatureVotes:
    """
    Generates an instance of HttplibJsonResponseDataModelsFeatureVotes from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsFeatureVotes
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsFeatureVotes
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsFeatureVote],
            path=path + '.value')  # type: Optional[List['ModelsFeatureVote']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsFeatureVotes(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_feature_votes_to_jsonable(
        httplib_json_response_data_models_feature_votes: HttplibJsonResponseDataModelsFeatureVotes,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsFeatureVotes.

    :param httplib_json_response_data_models_feature_votes: instance of HttplibJsonResponseDataModelsFeatureVotes to be JSON-ized
    :param path: path to the httplib_json_response_data_models_feature_votes used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_feature_votes.hash is not None:
        res['hash'] = httplib_json_response_data_models_feature_votes.hash

    if httplib_json_response_data_models_feature_votes.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_feature_votes.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_feature_votes.total is not None:
        res['total'] = httplib_json_response_data_models_feature_votes.total

    if httplib_json_response_data_models_feature_votes.type is not None:
        res['type'] = httplib_json_response_data_models_feature_votes.type

    if httplib_json_response_data_models_feature_votes.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_feature_votes.value,
        expected=[list, ModelsFeatureVote],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsHealthItems:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsHealthItem']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_health_items_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_health_items_to_jsonable(self)


def new_httplib_json_response_data_models_health_items() -> HttplibJsonResponseDataModelsHealthItems:
    """Generates an instance of HttplibJsonResponseDataModelsHealthItems with default values."""
    return HttplibJsonResponseDataModelsHealthItems()


def httplib_json_response_data_models_health_items_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsHealthItems:
    """
    Generates an instance of HttplibJsonResponseDataModelsHealthItems from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsHealthItems
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsHealthItems
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsHealthItem],
            path=path + '.value')  # type: Optional[List['ModelsHealthItem']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsHealthItems(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_health_items_to_jsonable(
        httplib_json_response_data_models_health_items: HttplibJsonResponseDataModelsHealthItems,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsHealthItems.

    :param httplib_json_response_data_models_health_items: instance of HttplibJsonResponseDataModelsHealthItems to be JSON-ized
    :param path: path to the httplib_json_response_data_models_health_items used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_health_items.hash is not None:
        res['hash'] = httplib_json_response_data_models_health_items.hash

    if httplib_json_response_data_models_health_items.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_health_items.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_health_items.total is not None:
        res['total'] = httplib_json_response_data_models_health_items.total

    if httplib_json_response_data_models_health_items.type is not None:
        res['type'] = httplib_json_response_data_models_health_items.type

    if httplib_json_response_data_models_health_items.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_health_items.value,
        expected=[list, ModelsHealthItem],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsHealthLogItems:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsHealthLogItem']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_health_log_items_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_health_log_items_to_jsonable(self)


def new_httplib_json_response_data_models_health_log_items() -> HttplibJsonResponseDataModelsHealthLogItems:
    """Generates an instance of HttplibJsonResponseDataModelsHealthLogItems with default values."""
    return HttplibJsonResponseDataModelsHealthLogItems()


def httplib_json_response_data_models_health_log_items_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsHealthLogItems:
    """
    Generates an instance of HttplibJsonResponseDataModelsHealthLogItems from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsHealthLogItems
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsHealthLogItems
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsHealthLogItem],
            path=path + '.value')  # type: Optional[List['ModelsHealthLogItem']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsHealthLogItems(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_health_log_items_to_jsonable(
        httplib_json_response_data_models_health_log_items: HttplibJsonResponseDataModelsHealthLogItems,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsHealthLogItems.

    :param httplib_json_response_data_models_health_log_items: instance of HttplibJsonResponseDataModelsHealthLogItems to be JSON-ized
    :param path: path to the httplib_json_response_data_models_health_log_items used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_health_log_items.hash is not None:
        res['hash'] = httplib_json_response_data_models_health_log_items.hash

    if httplib_json_response_data_models_health_log_items.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_health_log_items.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_health_log_items.total is not None:
        res['total'] = httplib_json_response_data_models_health_log_items.total

    if httplib_json_response_data_models_health_log_items.type is not None:
        res['type'] = httplib_json_response_data_models_health_log_items.type

    if httplib_json_response_data_models_health_log_items.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_health_log_items.value,
        expected=[list, ModelsHealthLogItem],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsInventoryCollections:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsInventoryCollection']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_inventory_collections_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_inventory_collections_to_jsonable(self)


def new_httplib_json_response_data_models_inventory_collections() -> HttplibJsonResponseDataModelsInventoryCollections:
    """Generates an instance of HttplibJsonResponseDataModelsInventoryCollections with default values."""
    return HttplibJsonResponseDataModelsInventoryCollections()


def httplib_json_response_data_models_inventory_collections_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsInventoryCollections:
    """
    Generates an instance of HttplibJsonResponseDataModelsInventoryCollections from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsInventoryCollections
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsInventoryCollections
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsInventoryCollection],
            path=path + '.value')  # type: Optional[List['ModelsInventoryCollection']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsInventoryCollections(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_inventory_collections_to_jsonable(
        httplib_json_response_data_models_inventory_collections: HttplibJsonResponseDataModelsInventoryCollections,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsInventoryCollections.

    :param httplib_json_response_data_models_inventory_collections: instance of HttplibJsonResponseDataModelsInventoryCollections to be JSON-ized
    :param path: path to the httplib_json_response_data_models_inventory_collections used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_inventory_collections.hash is not None:
        res['hash'] = httplib_json_response_data_models_inventory_collections.hash

    if httplib_json_response_data_models_inventory_collections.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_inventory_collections.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_inventory_collections.total is not None:
        res['total'] = httplib_json_response_data_models_inventory_collections.total

    if httplib_json_response_data_models_inventory_collections.type is not None:
        res['type'] = httplib_json_response_data_models_inventory_collections.type

    if httplib_json_response_data_models_inventory_collections.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_inventory_collections.value,
        expected=[list, ModelsInventoryCollection],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsInventoryItems:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsInventoryItem']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_inventory_items_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_inventory_items_to_jsonable(self)


def new_httplib_json_response_data_models_inventory_items() -> HttplibJsonResponseDataModelsInventoryItems:
    """Generates an instance of HttplibJsonResponseDataModelsInventoryItems with default values."""
    return HttplibJsonResponseDataModelsInventoryItems()


def httplib_json_response_data_models_inventory_items_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsInventoryItems:
    """
    Generates an instance of HttplibJsonResponseDataModelsInventoryItems from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsInventoryItems
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsInventoryItems
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsInventoryItem],
            path=path + '.value')  # type: Optional[List['ModelsInventoryItem']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsInventoryItems(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_inventory_items_to_jsonable(
        httplib_json_response_data_models_inventory_items: HttplibJsonResponseDataModelsInventoryItems,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsInventoryItems.

    :param httplib_json_response_data_models_inventory_items: instance of HttplibJsonResponseDataModelsInventoryItems to be JSON-ized
    :param path: path to the httplib_json_response_data_models_inventory_items used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_inventory_items.hash is not None:
        res['hash'] = httplib_json_response_data_models_inventory_items.hash

    if httplib_json_response_data_models_inventory_items.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_inventory_items.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_inventory_items.total is not None:
        res['total'] = httplib_json_response_data_models_inventory_items.total

    if httplib_json_response_data_models_inventory_items.type is not None:
        res['type'] = httplib_json_response_data_models_inventory_items.type

    if httplib_json_response_data_models_inventory_items.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_inventory_items.value,
        expected=[list, ModelsInventoryItem],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsLabelsValues:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsLabelsValue']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_labels_values_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_labels_values_to_jsonable(self)


def new_httplib_json_response_data_models_labels_values() -> HttplibJsonResponseDataModelsLabelsValues:
    """Generates an instance of HttplibJsonResponseDataModelsLabelsValues with default values."""
    return HttplibJsonResponseDataModelsLabelsValues()


def httplib_json_response_data_models_labels_values_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsLabelsValues:
    """
    Generates an instance of HttplibJsonResponseDataModelsLabelsValues from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsLabelsValues
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsLabelsValues
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsLabelsValue],
            path=path + '.value')  # type: Optional[List['ModelsLabelsValue']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsLabelsValues(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_labels_values_to_jsonable(
        httplib_json_response_data_models_labels_values: HttplibJsonResponseDataModelsLabelsValues,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsLabelsValues.

    :param httplib_json_response_data_models_labels_values: instance of HttplibJsonResponseDataModelsLabelsValues to be JSON-ized
    :param path: path to the httplib_json_response_data_models_labels_values used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_labels_values.hash is not None:
        res['hash'] = httplib_json_response_data_models_labels_values.hash

    if httplib_json_response_data_models_labels_values.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_labels_values.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_labels_values.total is not None:
        res['total'] = httplib_json_response_data_models_labels_values.total

    if httplib_json_response_data_models_labels_values.type is not None:
        res['type'] = httplib_json_response_data_models_labels_values.type

    if httplib_json_response_data_models_labels_values.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_labels_values.value,
        expected=[list, ModelsLabelsValue],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsNotesPageVersions:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsNotesPageVersion']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_notes_page_versions_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_notes_page_versions_to_jsonable(self)


def new_httplib_json_response_data_models_notes_page_versions() -> HttplibJsonResponseDataModelsNotesPageVersions:
    """Generates an instance of HttplibJsonResponseDataModelsNotesPageVersions with default values."""
    return HttplibJsonResponseDataModelsNotesPageVersions()


def httplib_json_response_data_models_notes_page_versions_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsNotesPageVersions:
    """
    Generates an instance of HttplibJsonResponseDataModelsNotesPageVersions from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsNotesPageVersions
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsNotesPageVersions
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsNotesPageVersion],
            path=path + '.value')  # type: Optional[List['ModelsNotesPageVersion']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsNotesPageVersions(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_notes_page_versions_to_jsonable(
        httplib_json_response_data_models_notes_page_versions: HttplibJsonResponseDataModelsNotesPageVersions,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsNotesPageVersions.

    :param httplib_json_response_data_models_notes_page_versions: instance of HttplibJsonResponseDataModelsNotesPageVersions to be JSON-ized
    :param path: path to the httplib_json_response_data_models_notes_page_versions used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_notes_page_versions.hash is not None:
        res['hash'] = httplib_json_response_data_models_notes_page_versions.hash

    if httplib_json_response_data_models_notes_page_versions.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_notes_page_versions.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_notes_page_versions.total is not None:
        res['total'] = httplib_json_response_data_models_notes_page_versions.total

    if httplib_json_response_data_models_notes_page_versions.type is not None:
        res['type'] = httplib_json_response_data_models_notes_page_versions.type

    if httplib_json_response_data_models_notes_page_versions.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_notes_page_versions.value,
        expected=[list, ModelsNotesPageVersion],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsNotesPages:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsNotesPage']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_notes_pages_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_notes_pages_to_jsonable(self)


def new_httplib_json_response_data_models_notes_pages() -> HttplibJsonResponseDataModelsNotesPages:
    """Generates an instance of HttplibJsonResponseDataModelsNotesPages with default values."""
    return HttplibJsonResponseDataModelsNotesPages()


def httplib_json_response_data_models_notes_pages_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsNotesPages:
    """
    Generates an instance of HttplibJsonResponseDataModelsNotesPages from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsNotesPages
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsNotesPages
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsNotesPage],
            path=path + '.value')  # type: Optional[List['ModelsNotesPage']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsNotesPages(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_notes_pages_to_jsonable(
        httplib_json_response_data_models_notes_pages: HttplibJsonResponseDataModelsNotesPages,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsNotesPages.

    :param httplib_json_response_data_models_notes_pages: instance of HttplibJsonResponseDataModelsNotesPages to be JSON-ized
    :param path: path to the httplib_json_response_data_models_notes_pages used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_notes_pages.hash is not None:
        res['hash'] = httplib_json_response_data_models_notes_pages.hash

    if httplib_json_response_data_models_notes_pages.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_notes_pages.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_notes_pages.total is not None:
        res['total'] = httplib_json_response_data_models_notes_pages.total

    if httplib_json_response_data_models_notes_pages.type is not None:
        res['type'] = httplib_json_response_data_models_notes_pages.type

    if httplib_json_response_data_models_notes_pages.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_notes_pages.value,
        expected=[list, ModelsNotesPage],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsPlanProjects:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsPlanProject']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_plan_projects_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_plan_projects_to_jsonable(self)


def new_httplib_json_response_data_models_plan_projects() -> HttplibJsonResponseDataModelsPlanProjects:
    """Generates an instance of HttplibJsonResponseDataModelsPlanProjects with default values."""
    return HttplibJsonResponseDataModelsPlanProjects()


def httplib_json_response_data_models_plan_projects_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsPlanProjects:
    """
    Generates an instance of HttplibJsonResponseDataModelsPlanProjects from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsPlanProjects
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsPlanProjects
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsPlanProject],
            path=path + '.value')  # type: Optional[List['ModelsPlanProject']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsPlanProjects(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_plan_projects_to_jsonable(
        httplib_json_response_data_models_plan_projects: HttplibJsonResponseDataModelsPlanProjects,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsPlanProjects.

    :param httplib_json_response_data_models_plan_projects: instance of HttplibJsonResponseDataModelsPlanProjects to be JSON-ized
    :param path: path to the httplib_json_response_data_models_plan_projects used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_plan_projects.hash is not None:
        res['hash'] = httplib_json_response_data_models_plan_projects.hash

    if httplib_json_response_data_models_plan_projects.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_plan_projects.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_plan_projects.total is not None:
        res['total'] = httplib_json_response_data_models_plan_projects.total

    if httplib_json_response_data_models_plan_projects.type is not None:
        res['type'] = httplib_json_response_data_models_plan_projects.type

    if httplib_json_response_data_models_plan_projects.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_plan_projects.value,
        expected=[list, ModelsPlanProject],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsPlanTasks:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsPlanTask']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_plan_tasks_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_plan_tasks_to_jsonable(self)


def new_httplib_json_response_data_models_plan_tasks() -> HttplibJsonResponseDataModelsPlanTasks:
    """Generates an instance of HttplibJsonResponseDataModelsPlanTasks with default values."""
    return HttplibJsonResponseDataModelsPlanTasks()


def httplib_json_response_data_models_plan_tasks_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsPlanTasks:
    """
    Generates an instance of HttplibJsonResponseDataModelsPlanTasks from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsPlanTasks
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsPlanTasks
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsPlanTask],
            path=path + '.value')  # type: Optional[List['ModelsPlanTask']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsPlanTasks(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_plan_tasks_to_jsonable(
        httplib_json_response_data_models_plan_tasks: HttplibJsonResponseDataModelsPlanTasks,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsPlanTasks.

    :param httplib_json_response_data_models_plan_tasks: instance of HttplibJsonResponseDataModelsPlanTasks to be JSON-ized
    :param path: path to the httplib_json_response_data_models_plan_tasks used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_plan_tasks.hash is not None:
        res['hash'] = httplib_json_response_data_models_plan_tasks.hash

    if httplib_json_response_data_models_plan_tasks.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_plan_tasks.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_plan_tasks.total is not None:
        res['total'] = httplib_json_response_data_models_plan_tasks.total

    if httplib_json_response_data_models_plan_tasks.type is not None:
        res['type'] = httplib_json_response_data_models_plan_tasks.type

    if httplib_json_response_data_models_plan_tasks.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_plan_tasks.value,
        expected=[list, ModelsPlanTask],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsRewardCards:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsRewardCard']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_reward_cards_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_reward_cards_to_jsonable(self)


def new_httplib_json_response_data_models_reward_cards() -> HttplibJsonResponseDataModelsRewardCards:
    """Generates an instance of HttplibJsonResponseDataModelsRewardCards with default values."""
    return HttplibJsonResponseDataModelsRewardCards()


def httplib_json_response_data_models_reward_cards_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsRewardCards:
    """
    Generates an instance of HttplibJsonResponseDataModelsRewardCards from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsRewardCards
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsRewardCards
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsRewardCard],
            path=path + '.value')  # type: Optional[List['ModelsRewardCard']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsRewardCards(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_reward_cards_to_jsonable(
        httplib_json_response_data_models_reward_cards: HttplibJsonResponseDataModelsRewardCards,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsRewardCards.

    :param httplib_json_response_data_models_reward_cards: instance of HttplibJsonResponseDataModelsRewardCards to be JSON-ized
    :param path: path to the httplib_json_response_data_models_reward_cards used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_reward_cards.hash is not None:
        res['hash'] = httplib_json_response_data_models_reward_cards.hash

    if httplib_json_response_data_models_reward_cards.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_reward_cards.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_reward_cards.total is not None:
        res['total'] = httplib_json_response_data_models_reward_cards.total

    if httplib_json_response_data_models_reward_cards.type is not None:
        res['type'] = httplib_json_response_data_models_reward_cards.type

    if httplib_json_response_data_models_reward_cards.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_reward_cards.value,
        expected=[list, ModelsRewardCard],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsSecretsValues:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsSecretsValue']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_secrets_values_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_secrets_values_to_jsonable(self)


def new_httplib_json_response_data_models_secrets_values() -> HttplibJsonResponseDataModelsSecretsValues:
    """Generates an instance of HttplibJsonResponseDataModelsSecretsValues with default values."""
    return HttplibJsonResponseDataModelsSecretsValues()


def httplib_json_response_data_models_secrets_values_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsSecretsValues:
    """
    Generates an instance of HttplibJsonResponseDataModelsSecretsValues from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsSecretsValues
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsSecretsValues
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsSecretsValue],
            path=path + '.value')  # type: Optional[List['ModelsSecretsValue']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsSecretsValues(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_secrets_values_to_jsonable(
        httplib_json_response_data_models_secrets_values: HttplibJsonResponseDataModelsSecretsValues,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsSecretsValues.

    :param httplib_json_response_data_models_secrets_values: instance of HttplibJsonResponseDataModelsSecretsValues to be JSON-ized
    :param path: path to the httplib_json_response_data_models_secrets_values used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_secrets_values.hash is not None:
        res['hash'] = httplib_json_response_data_models_secrets_values.hash

    if httplib_json_response_data_models_secrets_values.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_secrets_values.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_secrets_values.total is not None:
        res['total'] = httplib_json_response_data_models_secrets_values.total

    if httplib_json_response_data_models_secrets_values.type is not None:
        res['type'] = httplib_json_response_data_models_secrets_values.type

    if httplib_json_response_data_models_secrets_values.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_secrets_values.value,
        expected=[list, ModelsSecretsValue],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsSecretsVaults:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsSecretsVault']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_secrets_vaults_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_secrets_vaults_to_jsonable(self)


def new_httplib_json_response_data_models_secrets_vaults() -> HttplibJsonResponseDataModelsSecretsVaults:
    """Generates an instance of HttplibJsonResponseDataModelsSecretsVaults with default values."""
    return HttplibJsonResponseDataModelsSecretsVaults()


def httplib_json_response_data_models_secrets_vaults_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsSecretsVaults:
    """
    Generates an instance of HttplibJsonResponseDataModelsSecretsVaults from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsSecretsVaults
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsSecretsVaults
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsSecretsVault],
            path=path + '.value')  # type: Optional[List['ModelsSecretsVault']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsSecretsVaults(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_secrets_vaults_to_jsonable(
        httplib_json_response_data_models_secrets_vaults: HttplibJsonResponseDataModelsSecretsVaults,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsSecretsVaults.

    :param httplib_json_response_data_models_secrets_vaults: instance of HttplibJsonResponseDataModelsSecretsVaults to be JSON-ized
    :param path: path to the httplib_json_response_data_models_secrets_vaults used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_secrets_vaults.hash is not None:
        res['hash'] = httplib_json_response_data_models_secrets_vaults.hash

    if httplib_json_response_data_models_secrets_vaults.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_secrets_vaults.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_secrets_vaults.total is not None:
        res['total'] = httplib_json_response_data_models_secrets_vaults.total

    if httplib_json_response_data_models_secrets_vaults.type is not None:
        res['type'] = httplib_json_response_data_models_secrets_vaults.type

    if httplib_json_response_data_models_secrets_vaults.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_secrets_vaults.value,
        expected=[list, ModelsSecretsVault],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsShopCategories:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsShopCategory']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_shop_categories_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_shop_categories_to_jsonable(self)


def new_httplib_json_response_data_models_shop_categories() -> HttplibJsonResponseDataModelsShopCategories:
    """Generates an instance of HttplibJsonResponseDataModelsShopCategories with default values."""
    return HttplibJsonResponseDataModelsShopCategories()


def httplib_json_response_data_models_shop_categories_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsShopCategories:
    """
    Generates an instance of HttplibJsonResponseDataModelsShopCategories from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsShopCategories
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsShopCategories
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsShopCategory],
            path=path + '.value')  # type: Optional[List['ModelsShopCategory']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsShopCategories(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_shop_categories_to_jsonable(
        httplib_json_response_data_models_shop_categories: HttplibJsonResponseDataModelsShopCategories,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsShopCategories.

    :param httplib_json_response_data_models_shop_categories: instance of HttplibJsonResponseDataModelsShopCategories to be JSON-ized
    :param path: path to the httplib_json_response_data_models_shop_categories used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_shop_categories.hash is not None:
        res['hash'] = httplib_json_response_data_models_shop_categories.hash

    if httplib_json_response_data_models_shop_categories.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_shop_categories.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_shop_categories.total is not None:
        res['total'] = httplib_json_response_data_models_shop_categories.total

    if httplib_json_response_data_models_shop_categories.type is not None:
        res['type'] = httplib_json_response_data_models_shop_categories.type

    if httplib_json_response_data_models_shop_categories.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_shop_categories.value,
        expected=[list, ModelsShopCategory],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsShopItems:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsShopItem']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_shop_items_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_shop_items_to_jsonable(self)


def new_httplib_json_response_data_models_shop_items() -> HttplibJsonResponseDataModelsShopItems:
    """Generates an instance of HttplibJsonResponseDataModelsShopItems with default values."""
    return HttplibJsonResponseDataModelsShopItems()


def httplib_json_response_data_models_shop_items_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsShopItems:
    """
    Generates an instance of HttplibJsonResponseDataModelsShopItems from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsShopItems
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsShopItems
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsShopItem],
            path=path + '.value')  # type: Optional[List['ModelsShopItem']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsShopItems(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_shop_items_to_jsonable(
        httplib_json_response_data_models_shop_items: HttplibJsonResponseDataModelsShopItems,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsShopItems.

    :param httplib_json_response_data_models_shop_items: instance of HttplibJsonResponseDataModelsShopItems to be JSON-ized
    :param path: path to the httplib_json_response_data_models_shop_items used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_shop_items.hash is not None:
        res['hash'] = httplib_json_response_data_models_shop_items.hash

    if httplib_json_response_data_models_shop_items.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_shop_items.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_shop_items.total is not None:
        res['total'] = httplib_json_response_data_models_shop_items.total

    if httplib_json_response_data_models_shop_items.type is not None:
        res['type'] = httplib_json_response_data_models_shop_items.type

    if httplib_json_response_data_models_shop_items.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_shop_items.value,
        expected=[list, ModelsShopItem],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataModelsShopLists:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional[List['ModelsShopList']] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_models_shop_lists_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_models_shop_lists_to_jsonable(self)


def new_httplib_json_response_data_models_shop_lists() -> HttplibJsonResponseDataModelsShopLists:
    """Generates an instance of HttplibJsonResponseDataModelsShopLists with default values."""
    return HttplibJsonResponseDataModelsShopLists()


def httplib_json_response_data_models_shop_lists_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataModelsShopLists:
    """
    Generates an instance of HttplibJsonResponseDataModelsShopLists from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataModelsShopLists
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataModelsShopLists
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[list, ModelsShopList],
            path=path + '.value')  # type: Optional[List['ModelsShopList']]
    else:
        value_from_obj = None

    return HttplibJsonResponseDataModelsShopLists(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_models_shop_lists_to_jsonable(
        httplib_json_response_data_models_shop_lists: HttplibJsonResponseDataModelsShopLists,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataModelsShopLists.

    :param httplib_json_response_data_models_shop_lists: instance of HttplibJsonResponseDataModelsShopLists to be JSON-ized
    :param path: path to the httplib_json_response_data_models_shop_lists used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_models_shop_lists.hash is not None:
        res['hash'] = httplib_json_response_data_models_shop_lists.hash

    if httplib_json_response_data_models_shop_lists.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_models_shop_lists.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_models_shop_lists.total is not None:
        res['total'] = httplib_json_response_data_models_shop_lists.total

    if httplib_json_response_data_models_shop_lists.type is not None:
        res['type'] = httplib_json_response_data_models_shop_lists.type

    if httplib_json_response_data_models_shop_lists.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_models_shop_lists.value,
        expected=[list, ModelsShopList],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseDataWebauthnCredentialCreationOpts:
    def __init__(
            self,
            hash: Optional[str] = None,
            ids: Optional[List['HttplibJsonResponseCacheID']] = None,
            total: Optional[int] = None,
            type: Optional[str] = None,
            value: Optional['WebauthnCredentialCreationOpts'] = None) -> None:
        """Initializes with the given values."""
        self.hash = hash

        self.ids = ids

        self.total = total

        self.type = type

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_data_webauthn_credential_creation_opts_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_data_webauthn_credential_creation_opts_to_jsonable(self)


def new_httplib_json_response_data_webauthn_credential_creation_opts() -> HttplibJsonResponseDataWebauthnCredentialCreationOpts:
    """Generates an instance of HttplibJsonResponseDataWebauthnCredentialCreationOpts with default values."""
    return HttplibJsonResponseDataWebauthnCredentialCreationOpts()


def httplib_json_response_data_webauthn_credential_creation_opts_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseDataWebauthnCredentialCreationOpts:
    """
    Generates an instance of HttplibJsonResponseDataWebauthnCredentialCreationOpts from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseDataWebauthnCredentialCreationOpts
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseDataWebauthnCredentialCreationOpts
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hash = obj.get('hash', None)
    if obj_hash is not None:
        hash_from_obj = from_obj(
            obj_hash,
            expected=[str],
            path=path + '.hash')  # type: Optional[str]
    else:
        hash_from_obj = None

    obj_ids = obj.get('ids', None)
    if obj_ids is not None:
        ids_from_obj = from_obj(
            obj_ids,
            expected=[list, HttplibJsonResponseCacheID],
            path=path + '.ids')  # type: Optional[List['HttplibJsonResponseCacheID']]
    else:
        ids_from_obj = None

    obj_total = obj.get('total', None)
    if obj_total is not None:
        total_from_obj = from_obj(
            obj_total,
            expected=[int],
            path=path + '.total')  # type: Optional[int]
    else:
        total_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[WebauthnCredentialCreationOpts],
            path=path + '.value')  # type: Optional['WebauthnCredentialCreationOpts']
    else:
        value_from_obj = None

    return HttplibJsonResponseDataWebauthnCredentialCreationOpts(
        hash=hash_from_obj,
        ids=ids_from_obj,
        total=total_from_obj,
        type=type_from_obj,
        value=value_from_obj)


def httplib_json_response_data_webauthn_credential_creation_opts_to_jsonable(
        httplib_json_response_data_webauthn_credential_creation_opts: HttplibJsonResponseDataWebauthnCredentialCreationOpts,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseDataWebauthnCredentialCreationOpts.

    :param httplib_json_response_data_webauthn_credential_creation_opts: instance of HttplibJsonResponseDataWebauthnCredentialCreationOpts to be JSON-ized
    :param path: path to the httplib_json_response_data_webauthn_credential_creation_opts used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_data_webauthn_credential_creation_opts.hash is not None:
        res['hash'] = httplib_json_response_data_webauthn_credential_creation_opts.hash

    if httplib_json_response_data_webauthn_credential_creation_opts.ids is not None:
        res['ids'] = to_jsonable(
        httplib_json_response_data_webauthn_credential_creation_opts.ids,
        expected=[list, HttplibJsonResponseCacheID],
        path='{}.ids'.format(path))

    if httplib_json_response_data_webauthn_credential_creation_opts.total is not None:
        res['total'] = httplib_json_response_data_webauthn_credential_creation_opts.total

    if httplib_json_response_data_webauthn_credential_creation_opts.type is not None:
        res['type'] = httplib_json_response_data_webauthn_credential_creation_opts.type

    if httplib_json_response_data_webauthn_credential_creation_opts.value is not None:
        res['value'] = to_jsonable(
        httplib_json_response_data_webauthn_credential_creation_opts.value,
        expected=[WebauthnCredentialCreationOpts],
        path='{}.value'.format(path))

    return res


class HttplibJsonResponseError:
    def __init__(
            self,
            code: Optional[int] = None,
            details: Optional[str] = None,
            message: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.code = code

        self.details = details

        self.message = message

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_json_response_error_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_json_response_error_to_jsonable(self)


def new_httplib_json_response_error() -> HttplibJsonResponseError:
    """Generates an instance of HttplibJsonResponseError with default values."""
    return HttplibJsonResponseError()


def httplib_json_response_error_from_obj(obj: Any, path: str = "") -> HttplibJsonResponseError:
    """
    Generates an instance of HttplibJsonResponseError from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibJsonResponseError
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibJsonResponseError
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_code = obj.get('code', None)
    if obj_code is not None:
        code_from_obj = from_obj(
            obj_code,
            expected=[int],
            path=path + '.code')  # type: Optional[int]
    else:
        code_from_obj = None

    obj_details = obj.get('details', None)
    if obj_details is not None:
        details_from_obj = from_obj(
            obj_details,
            expected=[str],
            path=path + '.details')  # type: Optional[str]
    else:
        details_from_obj = None

    obj_message = obj.get('message', None)
    if obj_message is not None:
        message_from_obj = from_obj(
            obj_message,
            expected=[str],
            path=path + '.message')  # type: Optional[str]
    else:
        message_from_obj = None

    return HttplibJsonResponseError(
        code=code_from_obj,
        details=details_from_obj,
        message=message_from_obj)


def httplib_json_response_error_to_jsonable(
        httplib_json_response_error: HttplibJsonResponseError,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibJsonResponseError.

    :param httplib_json_response_error: instance of HttplibJsonResponseError to be JSON-ized
    :param path: path to the httplib_json_response_error used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_json_response_error.code is not None:
        res['code'] = httplib_json_response_error.code

    if httplib_json_response_error.details is not None:
        res['details'] = httplib_json_response_error.details

    if httplib_json_response_error.message is not None:
        res['message'] = httplib_json_response_error.message

    return res


class HttplibServer:
    def __init__(
            self,
            listen_address: Optional[str] = None,
            rate_limit_key: Optional[str] = None,
            rate_limit_patterns: Optional[Dict[str, str]] = None,
            timeout_read: Optional[int] = None,
            timeout_read_header: Optional[int] = None,
            timeout_write: Optional[int] = None,
            tls_certificate_base64: Optional[str] = None,
            tls_certificate_path: Optional[str] = None,
            tls_client_auth_c_a_base64: Optional[str] = None,
            tls_client_auth_c_a_path: Optional[str] = None,
            tls_key_base64: Optional[str] = None,
            tls_key_path: Optional[str] = None,
            x_forwarded_trusted_c_id_rs: Optional[List[str]] = None) -> None:
        """Initializes with the given values."""
        self.listen_address = listen_address

        self.rate_limit_key = rate_limit_key

        self.rate_limit_patterns = rate_limit_patterns

        self.timeout_read = timeout_read

        self.timeout_read_header = timeout_read_header

        self.timeout_write = timeout_write

        self.tls_certificate_base64 = tls_certificate_base64

        self.tls_certificate_path = tls_certificate_path

        self.tls_client_auth_c_a_base64 = tls_client_auth_c_a_base64

        self.tls_client_auth_c_a_path = tls_client_auth_c_a_path

        self.tls_key_base64 = tls_key_base64

        self.tls_key_path = tls_key_path

        self.x_forwarded_trusted_c_id_rs = x_forwarded_trusted_c_id_rs

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to httplib_server_to_jsonable.

        :return: JSON-able representation
        """
        return httplib_server_to_jsonable(self)


def new_httplib_server() -> HttplibServer:
    """Generates an instance of HttplibServer with default values."""
    return HttplibServer()


def httplib_server_from_obj(obj: Any, path: str = "") -> HttplibServer:
    """
    Generates an instance of HttplibServer from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of HttplibServer
    :param path: path to the object used for debugging
    :return: parsed instance of HttplibServer
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_listen_address = obj.get('listenAddress', None)
    if obj_listen_address is not None:
        listen_address_from_obj = from_obj(
            obj_listen_address,
            expected=[str],
            path=path + '.listenAddress')  # type: Optional[str]
    else:
        listen_address_from_obj = None

    obj_rate_limit_key = obj.get('rateLimitKey', None)
    if obj_rate_limit_key is not None:
        rate_limit_key_from_obj = from_obj(
            obj_rate_limit_key,
            expected=[str],
            path=path + '.rateLimitKey')  # type: Optional[str]
    else:
        rate_limit_key_from_obj = None

    obj_rate_limit_patterns = obj.get('rateLimitPatterns', None)
    if obj_rate_limit_patterns is not None:
        rate_limit_patterns_from_obj = from_obj(
            obj_rate_limit_patterns,
            expected=[dict, str],
            path=path + '.rateLimitPatterns')  # type: Optional[Dict[str, str]]
    else:
        rate_limit_patterns_from_obj = None

    obj_timeout_read = obj.get('timeoutRead', None)
    if obj_timeout_read is not None:
        timeout_read_from_obj = from_obj(
            obj_timeout_read,
            expected=[int],
            path=path + '.timeoutRead')  # type: Optional[int]
    else:
        timeout_read_from_obj = None

    obj_timeout_read_header = obj.get('timeoutReadHeader', None)
    if obj_timeout_read_header is not None:
        timeout_read_header_from_obj = from_obj(
            obj_timeout_read_header,
            expected=[int],
            path=path + '.timeoutReadHeader')  # type: Optional[int]
    else:
        timeout_read_header_from_obj = None

    obj_timeout_write = obj.get('timeoutWrite', None)
    if obj_timeout_write is not None:
        timeout_write_from_obj = from_obj(
            obj_timeout_write,
            expected=[int],
            path=path + '.timeoutWrite')  # type: Optional[int]
    else:
        timeout_write_from_obj = None

    obj_tls_certificate_base64 = obj.get('tlsCertificateBase64', None)
    if obj_tls_certificate_base64 is not None:
        tls_certificate_base64_from_obj = from_obj(
            obj_tls_certificate_base64,
            expected=[str],
            path=path + '.tlsCertificateBase64')  # type: Optional[str]
    else:
        tls_certificate_base64_from_obj = None

    obj_tls_certificate_path = obj.get('tlsCertificatePath', None)
    if obj_tls_certificate_path is not None:
        tls_certificate_path_from_obj = from_obj(
            obj_tls_certificate_path,
            expected=[str],
            path=path + '.tlsCertificatePath')  # type: Optional[str]
    else:
        tls_certificate_path_from_obj = None

    obj_tls_client_auth_c_a_base64 = obj.get('tlsClientAuthCABase64', None)
    if obj_tls_client_auth_c_a_base64 is not None:
        tls_client_auth_c_a_base64_from_obj = from_obj(
            obj_tls_client_auth_c_a_base64,
            expected=[str],
            path=path + '.tlsClientAuthCABase64')  # type: Optional[str]
    else:
        tls_client_auth_c_a_base64_from_obj = None

    obj_tls_client_auth_c_a_path = obj.get('tlsClientAuthCAPath', None)
    if obj_tls_client_auth_c_a_path is not None:
        tls_client_auth_c_a_path_from_obj = from_obj(
            obj_tls_client_auth_c_a_path,
            expected=[str],
            path=path + '.tlsClientAuthCAPath')  # type: Optional[str]
    else:
        tls_client_auth_c_a_path_from_obj = None

    obj_tls_key_base64 = obj.get('tlsKeyBase64', None)
    if obj_tls_key_base64 is not None:
        tls_key_base64_from_obj = from_obj(
            obj_tls_key_base64,
            expected=[str],
            path=path + '.tlsKeyBase64')  # type: Optional[str]
    else:
        tls_key_base64_from_obj = None

    obj_tls_key_path = obj.get('tlsKeyPath', None)
    if obj_tls_key_path is not None:
        tls_key_path_from_obj = from_obj(
            obj_tls_key_path,
            expected=[str],
            path=path + '.tlsKeyPath')  # type: Optional[str]
    else:
        tls_key_path_from_obj = None

    obj_x_forwarded_trusted_c_id_rs = obj.get('xForwardedTrustedCIDRs', None)
    if obj_x_forwarded_trusted_c_id_rs is not None:
        x_forwarded_trusted_c_id_rs_from_obj = from_obj(
            obj_x_forwarded_trusted_c_id_rs,
            expected=[list, str],
            path=path + '.xForwardedTrustedCIDRs')  # type: Optional[List[str]]
    else:
        x_forwarded_trusted_c_id_rs_from_obj = None

    return HttplibServer(
        listen_address=listen_address_from_obj,
        rate_limit_key=rate_limit_key_from_obj,
        rate_limit_patterns=rate_limit_patterns_from_obj,
        timeout_read=timeout_read_from_obj,
        timeout_read_header=timeout_read_header_from_obj,
        timeout_write=timeout_write_from_obj,
        tls_certificate_base64=tls_certificate_base64_from_obj,
        tls_certificate_path=tls_certificate_path_from_obj,
        tls_client_auth_c_a_base64=tls_client_auth_c_a_base64_from_obj,
        tls_client_auth_c_a_path=tls_client_auth_c_a_path_from_obj,
        tls_key_base64=tls_key_base64_from_obj,
        tls_key_path=tls_key_path_from_obj,
        x_forwarded_trusted_c_id_rs=x_forwarded_trusted_c_id_rs_from_obj)


def httplib_server_to_jsonable(
        httplib_server: HttplibServer,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of HttplibServer.

    :param httplib_server: instance of HttplibServer to be JSON-ized
    :param path: path to the httplib_server used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if httplib_server.listen_address is not None:
        res['listenAddress'] = httplib_server.listen_address

    if httplib_server.rate_limit_key is not None:
        res['rateLimitKey'] = httplib_server.rate_limit_key

    if httplib_server.rate_limit_patterns is not None:
        res['rateLimitPatterns'] = to_jsonable(
        httplib_server.rate_limit_patterns,
        expected=[dict, str],
        path='{}.rateLimitPatterns'.format(path))

    if httplib_server.timeout_read is not None:
        res['timeoutRead'] = httplib_server.timeout_read

    if httplib_server.timeout_read_header is not None:
        res['timeoutReadHeader'] = httplib_server.timeout_read_header

    if httplib_server.timeout_write is not None:
        res['timeoutWrite'] = httplib_server.timeout_write

    if httplib_server.tls_certificate_base64 is not None:
        res['tlsCertificateBase64'] = httplib_server.tls_certificate_base64

    if httplib_server.tls_certificate_path is not None:
        res['tlsCertificatePath'] = httplib_server.tls_certificate_path

    if httplib_server.tls_client_auth_c_a_base64 is not None:
        res['tlsClientAuthCABase64'] = httplib_server.tls_client_auth_c_a_base64

    if httplib_server.tls_client_auth_c_a_path is not None:
        res['tlsClientAuthCAPath'] = httplib_server.tls_client_auth_c_a_path

    if httplib_server.tls_key_base64 is not None:
        res['tlsKeyBase64'] = httplib_server.tls_key_base64

    if httplib_server.tls_key_path is not None:
        res['tlsKeyPath'] = httplib_server.tls_key_path

    if httplib_server.x_forwarded_trusted_c_id_rs is not None:
        res['xForwardedTrustedCIDRs'] = to_jsonable(
        httplib_server.x_forwarded_trusted_c_id_rs,
        expected=[list, str],
        path='{}.xForwardedTrustedCIDRs'.format(path))

    return res


class JsonnetJsonnet:
    def __init__(
            self,
            disable_get_arch: Optional[bool] = None,
            disable_get_cmd: Optional[bool] = None,
            disable_get_config: Optional[bool] = None,
            disable_get_env: Optional[bool] = None,
            disable_get_file: Optional[bool] = None,
            disable_get_file_http: Optional[bool] = None,
            disable_get_o_s: Optional[bool] = None,
            disable_get_path: Optional[bool] = None,
            disable_get_record: Optional[bool] = None) -> None:
        """Initializes with the given values."""
        self.disable_get_arch = disable_get_arch

        self.disable_get_cmd = disable_get_cmd

        self.disable_get_config = disable_get_config

        self.disable_get_env = disable_get_env

        self.disable_get_file = disable_get_file

        self.disable_get_file_http = disable_get_file_http

        self.disable_get_o_s = disable_get_o_s

        self.disable_get_path = disable_get_path

        self.disable_get_record = disable_get_record

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to jsonnet_jsonnet_to_jsonable.

        :return: JSON-able representation
        """
        return jsonnet_jsonnet_to_jsonable(self)


def new_jsonnet_jsonnet() -> JsonnetJsonnet:
    """Generates an instance of JsonnetJsonnet with default values."""
    return JsonnetJsonnet()


def jsonnet_jsonnet_from_obj(obj: Any, path: str = "") -> JsonnetJsonnet:
    """
    Generates an instance of JsonnetJsonnet from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of JsonnetJsonnet
    :param path: path to the object used for debugging
    :return: parsed instance of JsonnetJsonnet
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_disable_get_arch = obj.get('disableGetArch', None)
    if obj_disable_get_arch is not None:
        disable_get_arch_from_obj = from_obj(
            obj_disable_get_arch,
            expected=[bool],
            path=path + '.disableGetArch')  # type: Optional[bool]
    else:
        disable_get_arch_from_obj = None

    obj_disable_get_cmd = obj.get('disableGetCmd', None)
    if obj_disable_get_cmd is not None:
        disable_get_cmd_from_obj = from_obj(
            obj_disable_get_cmd,
            expected=[bool],
            path=path + '.disableGetCmd')  # type: Optional[bool]
    else:
        disable_get_cmd_from_obj = None

    obj_disable_get_config = obj.get('disableGetConfig', None)
    if obj_disable_get_config is not None:
        disable_get_config_from_obj = from_obj(
            obj_disable_get_config,
            expected=[bool],
            path=path + '.disableGetConfig')  # type: Optional[bool]
    else:
        disable_get_config_from_obj = None

    obj_disable_get_env = obj.get('disableGetEnv', None)
    if obj_disable_get_env is not None:
        disable_get_env_from_obj = from_obj(
            obj_disable_get_env,
            expected=[bool],
            path=path + '.disableGetEnv')  # type: Optional[bool]
    else:
        disable_get_env_from_obj = None

    obj_disable_get_file = obj.get('disableGetFile', None)
    if obj_disable_get_file is not None:
        disable_get_file_from_obj = from_obj(
            obj_disable_get_file,
            expected=[bool],
            path=path + '.disableGetFile')  # type: Optional[bool]
    else:
        disable_get_file_from_obj = None

    obj_disable_get_file_http = obj.get('disableGetFileHTTP', None)
    if obj_disable_get_file_http is not None:
        disable_get_file_http_from_obj = from_obj(
            obj_disable_get_file_http,
            expected=[bool],
            path=path + '.disableGetFileHTTP')  # type: Optional[bool]
    else:
        disable_get_file_http_from_obj = None

    obj_disable_get_o_s = obj.get('disableGetOS', None)
    if obj_disable_get_o_s is not None:
        disable_get_o_s_from_obj = from_obj(
            obj_disable_get_o_s,
            expected=[bool],
            path=path + '.disableGetOS')  # type: Optional[bool]
    else:
        disable_get_o_s_from_obj = None

    obj_disable_get_path = obj.get('disableGetPath', None)
    if obj_disable_get_path is not None:
        disable_get_path_from_obj = from_obj(
            obj_disable_get_path,
            expected=[bool],
            path=path + '.disableGetPath')  # type: Optional[bool]
    else:
        disable_get_path_from_obj = None

    obj_disable_get_record = obj.get('disableGetRecord', None)
    if obj_disable_get_record is not None:
        disable_get_record_from_obj = from_obj(
            obj_disable_get_record,
            expected=[bool],
            path=path + '.disableGetRecord')  # type: Optional[bool]
    else:
        disable_get_record_from_obj = None

    return JsonnetJsonnet(
        disable_get_arch=disable_get_arch_from_obj,
        disable_get_cmd=disable_get_cmd_from_obj,
        disable_get_config=disable_get_config_from_obj,
        disable_get_env=disable_get_env_from_obj,
        disable_get_file=disable_get_file_from_obj,
        disable_get_file_http=disable_get_file_http_from_obj,
        disable_get_o_s=disable_get_o_s_from_obj,
        disable_get_path=disable_get_path_from_obj,
        disable_get_record=disable_get_record_from_obj)


def jsonnet_jsonnet_to_jsonable(
        jsonnet_jsonnet: JsonnetJsonnet,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of JsonnetJsonnet.

    :param jsonnet_jsonnet: instance of JsonnetJsonnet to be JSON-ized
    :param path: path to the jsonnet_jsonnet used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if jsonnet_jsonnet.disable_get_arch is not None:
        res['disableGetArch'] = jsonnet_jsonnet.disable_get_arch

    if jsonnet_jsonnet.disable_get_cmd is not None:
        res['disableGetCmd'] = jsonnet_jsonnet.disable_get_cmd

    if jsonnet_jsonnet.disable_get_config is not None:
        res['disableGetConfig'] = jsonnet_jsonnet.disable_get_config

    if jsonnet_jsonnet.disable_get_env is not None:
        res['disableGetEnv'] = jsonnet_jsonnet.disable_get_env

    if jsonnet_jsonnet.disable_get_file is not None:
        res['disableGetFile'] = jsonnet_jsonnet.disable_get_file

    if jsonnet_jsonnet.disable_get_file_http is not None:
        res['disableGetFileHTTP'] = jsonnet_jsonnet.disable_get_file_http

    if jsonnet_jsonnet.disable_get_o_s is not None:
        res['disableGetOS'] = jsonnet_jsonnet.disable_get_o_s

    if jsonnet_jsonnet.disable_get_path is not None:
        res['disableGetPath'] = jsonnet_jsonnet.disable_get_path

    if jsonnet_jsonnet.disable_get_record is not None:
        res['disableGetRecord'] = jsonnet_jsonnet.disable_get_record

    return res


class JwtRegisteredClaims:
    def __init__(
            self,
            aud: Optional[List[str]] = None,
            exp: Optional[int] = None,
            iat: Optional[int] = None,
            iss: Optional[str] = None,
            jti: Optional[str] = None,
            nbf: Optional[int] = None,
            sub: Optional[str] = None) -> None:
        """Initializes with the given values."""
        # The "aud" (audience) claim identifies the recipients that the JWT is
        # 		intended for.  Each principal intended to process the JWT MUST
        # 		identify itself with a value in the audience claim.  If the principal
        # 		processing the claim does not identify itself with a value in the
        # 		"aud" claim when this claim is present, then the JWT MUST be
        # 		rejected.  In the general case, the "aud" value is an array of case-
        # 		sensitive strings, each containing a StringOrURI value.  In the
        # 		special case when the JWT has one audience, the "aud" value MAY be a
        # 		single case-sensitive string containing a StringOrURI value.  The
        # 		interpretation of audience values is generally application specific.
        # 		Use of this claim is OPTIONAL.
        self.aud = aud

        # The "exp" (expiration time) claim identifies the expiration time on
        # 		or after which the JWT MUST NOT be accepted for processing.  The
        # 		processing of the "exp" claim requires that the current date/time
        # 		MUST be before the expiration date/time listed in the "exp" claim.
        # 		Implementers MAY provide for some small leeway, usually no more than
        # 		a few minutes, to account for clock skew.  Its value MUST be a number
        # 		containing a NumericDate value.  Use of this claim is OPTIONAL.
        self.exp = exp

        # The "iat" (issued at) claim identifies the time at which the JWT was
        # 		issued.  This claim can be used to determine the age of the JWT.  Its
        # 		value MUST be a number containing a NumericDate value.  Use of this
        # 		claim is OPTIONAL.
        self.iat = iat

        # The "iss" (issuer) claim identifies the principal that issued the
        # 		JWT.  The processing of this claim is generally application specific.
        # 		The "iss" value is a case-sensitive string containing a StringOrURI
        # 		value.  Use of this claim is OPTIONAL.
        self.iss = iss

        # The "jti" (JWT ID) claim provides a unique identifier for the JWT.
        # 		The identifier value MUST be assigned in a manner that ensures that
        # 		there is a negligible probability that the same value will be
        # 		accidentally assigned to a different data object; if the application
        # 		uses multiple issuers, collisions MUST be prevented among values
        # 		produced by different issuers as well.  The "jti" claim can be used
        # 		to prevent the JWT from being replayed.  The "jti" value is a case-
        # 		sensitive string.  Use of this claim is OPTIONAL.
        self.jti = jti

        # The "nbf" (not before) claim identifies the time before which the JWT
        # 		MUST NOT be accepted for processing.  The processing of the "nbf"
        # 		claim requires that the current date/time MUST be after or equal to
        # 		the not-before date/time listed in the "nbf" claim.  Implementers MAY
        # 		provide for some small leeway, usually no more than a few minutes, to
        # 		account for clock skew.  Its value MUST be a number containing a
        # 		NumericDate value.  Use of this claim is OPTIONAL.
        self.nbf = nbf

        # The "sub" (subject) claim identifies the principal that is the
        # 		subject of the JWT.  The claims in a JWT are normally statements
        # 		about the subject.  The subject value MUST either be scoped to be
        # 		locally unique in the context of the issuer or be globally unique.
        # 		The processing of this claim is generally application specific.  The
        # 		"sub" value is a case-sensitive string containing a StringOrURI
        # 		value.  Use of this claim is OPTIONAL.
        self.sub = sub

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to jwt_registered_claims_to_jsonable.

        :return: JSON-able representation
        """
        return jwt_registered_claims_to_jsonable(self)


def new_jwt_registered_claims() -> JwtRegisteredClaims:
    """Generates an instance of JwtRegisteredClaims with default values."""
    return JwtRegisteredClaims()


def jwt_registered_claims_from_obj(obj: Any, path: str = "") -> JwtRegisteredClaims:
    """
    Generates an instance of JwtRegisteredClaims from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of JwtRegisteredClaims
    :param path: path to the object used for debugging
    :return: parsed instance of JwtRegisteredClaims
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_aud = obj.get('aud', None)
    if obj_aud is not None:
        aud_from_obj = from_obj(
            obj_aud,
            expected=[list, str],
            path=path + '.aud')  # type: Optional[List[str]]
    else:
        aud_from_obj = None

    obj_exp = obj.get('exp', None)
    if obj_exp is not None:
        exp_from_obj = from_obj(
            obj_exp,
            expected=[int],
            path=path + '.exp')  # type: Optional[int]
    else:
        exp_from_obj = None

    obj_iat = obj.get('iat', None)
    if obj_iat is not None:
        iat_from_obj = from_obj(
            obj_iat,
            expected=[int],
            path=path + '.iat')  # type: Optional[int]
    else:
        iat_from_obj = None

    obj_iss = obj.get('iss', None)
    if obj_iss is not None:
        iss_from_obj = from_obj(
            obj_iss,
            expected=[str],
            path=path + '.iss')  # type: Optional[str]
    else:
        iss_from_obj = None

    obj_jti = obj.get('jti', None)
    if obj_jti is not None:
        jti_from_obj = from_obj(
            obj_jti,
            expected=[str],
            path=path + '.jti')  # type: Optional[str]
    else:
        jti_from_obj = None

    obj_nbf = obj.get('nbf', None)
    if obj_nbf is not None:
        nbf_from_obj = from_obj(
            obj_nbf,
            expected=[int],
            path=path + '.nbf')  # type: Optional[int]
    else:
        nbf_from_obj = None

    obj_sub = obj.get('sub', None)
    if obj_sub is not None:
        sub_from_obj = from_obj(
            obj_sub,
            expected=[str],
            path=path + '.sub')  # type: Optional[str]
    else:
        sub_from_obj = None

    return JwtRegisteredClaims(
        aud=aud_from_obj,
        exp=exp_from_obj,
        iat=iat_from_obj,
        iss=iss_from_obj,
        jti=jti_from_obj,
        nbf=nbf_from_obj,
        sub=sub_from_obj)


def jwt_registered_claims_to_jsonable(
        jwt_registered_claims: JwtRegisteredClaims,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of JwtRegisteredClaims.

    :param jwt_registered_claims: instance of JwtRegisteredClaims to be JSON-ized
    :param path: path to the jwt_registered_claims used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if jwt_registered_claims.aud is not None:
        res['aud'] = to_jsonable(
        jwt_registered_claims.aud,
        expected=[list, str],
        path='{}.aud'.format(path))

    if jwt_registered_claims.exp is not None:
        res['exp'] = jwt_registered_claims.exp

    if jwt_registered_claims.iat is not None:
        res['iat'] = jwt_registered_claims.iat

    if jwt_registered_claims.iss is not None:
        res['iss'] = jwt_registered_claims.iss

    if jwt_registered_claims.jti is not None:
        res['jti'] = jwt_registered_claims.jti

    if jwt_registered_claims.nbf is not None:
        res['nbf'] = jwt_registered_claims.nbf

    if jwt_registered_claims.sub is not None:
        res['sub'] = jwt_registered_claims.sub

    return res


class ModelsAuthAccount:
    def __init__(
            self,
            auth_o_id_c_client_ids: Optional[Any] = None,
            collapsed_notes_pages: Optional[List[str]] = None,
            collapsed_plan_projects: Optional[List[str]] = None,
            collapsed_plan_tasks: Optional[List[str]] = None,
            created: Optional[str] = None,
            daily_agenda_next: Optional[str] = None,
            daily_agenda_time: Optional[str] = None,
            delegations: Optional[List['ModelsAuthAccountDelegation']] = None,
            email_address: Optional[str] = None,
            email_auth_disabled: Optional[bool] = None,
            email_auth_token: Optional[str] = None,
            health_item_correlation_hours: Optional[int] = None,
            hide_calendar_i_calendars: Optional[List[str]] = None,
            icalendar_id: Optional[str] = None,
            id: Optional[str] = None,
            iso639_code: Optional[str] = None,
            last_activity: Optional[str] = None,
            name: Optional[str] = None,
            oidc_code: Optional[str] = None,
            oidc_issuer: Optional[str] = None,
            oidc_state: Optional[str] = None,
            password: Optional[str] = None,
            password_enabled: Optional[bool] = None,
            permissions_account: Optional[Any] = None,
            permissions_households: Optional[Any] = None,
            preferences: Optional[Any] = None,
            primary_auth_household_id: Optional[str] = None,
            private_keys: Optional[List['ModelsAuthAccountPrivateKey']] = None,
            public_key: Optional[Any] = None,
            remember_me: Optional[bool] = None,
            self_hosted_id: Optional[str] = None,
            setup: Optional[bool] = None,
            time_zone: Optional[str] = None,
            tos_accepted: Optional[bool] = None,
            totp_backup: Optional[str] = None,
            totp_code: Optional[str] = None,
            totp_enabled: Optional[bool] = None,
            totp_q_r: Optional[str] = None,
            totp_secret: Optional[str] = None,
            updated: Optional[str] = None,
            user_agent: Optional[Any] = None,
            verified: Optional[bool] = None,
            web_authn_creation: Optional[Any] = None,
            web_authn_credentials: Optional[List['WebauthnCredential']] = None,
            web_authn_request: Optional[Any] = None) -> None:
        """Initializes with the given values."""
        # AuthOIDCClientIDs and the scopes the AuthAccountID has granted access to.
        self.auth_o_id_c_client_ids = auth_o_id_c_client_ids

        # A list of IDs to collapse.
        self.collapsed_notes_pages = collapsed_notes_pages

        # A list of IDs to collapse.
        self.collapsed_plan_projects = collapsed_plan_projects

        # A list of IDs to collapse.
        self.collapsed_plan_tasks = collapsed_plan_tasks

        # Timestamp account was created.
        self.created = created

        # The next timestamp for the agenda.
        self.daily_agenda_next = daily_agenda_next

        # When to send the daily agenda.
        self.daily_agenda_time = daily_agenda_time

        # List of Delegations
        self.delegations = delegations

        # Primary email address of user.
        self.email_address = email_address

        # EmailAuthDisabled disables EmailAuth.
        self.email_auth_disabled = email_auth_disabled

        # EmailAuthTokenJSON is used for EmailAuth during signin.
        self.email_auth_token = email_auth_token

        # Number of hours to associate health item outputs to inputs.
        self.health_item_correlation_hours = health_item_correlation_hours

        # A list of iCalendar IDs to hide.
        self.hide_calendar_i_calendars = hide_calendar_i_calendars

        # ICalendarID for the account.
        self.icalendar_id = icalendar_id

        # ID of the account.
        self.id = id

        # ISO639Code is the code used for translations.
        self.iso639_code = iso639_code

        # Timestamp of the last time the account signed in.
        self.last_activity = last_activity

        # Name of the AuthAccount user.
        self.name = name

        # Code from OIDC provider to check during sign in/up.
        self.oidc_code = oidc_code

        # Issuer name used for OIDC.
        self.oidc_issuer = oidc_issuer

        # State used to generate OIDC keys.
        self.oidc_state = oidc_state

        # Password to use for sign in/up.
        self.password = password

        # Whether the account is enabled for password authentication.
        self.password_enabled = password_enabled

        # Permissions for the account when creating a new session.
        self.permissions_account = permissions_account

        # Permissions for the households when creating a new session.
        self.permissions_households = permissions_households

        # Preferences for the account.
        self.preferences = preferences

        # The primary AuthHouseholdID, used by short links.
        self.primary_auth_household_id = primary_auth_household_id

        # PrivateKeys for decrypting secrets.
        self.private_keys = private_keys

        # PublicKey for encrypting secrets.
        self.public_key = public_key

        # Sets a longer timeout for the AuthSession.
        self.remember_me = remember_me

        # SelfHosted ID of the account, used when creating CloudHouseholds.
        self.self_hosted_id = self_hosted_id

        # Whether the account has gone through setup.
        self.setup = setup

        # Used by notifications and UI to determine local times.
        self.time_zone = time_zone

        # ToS must be accepted to use the app.
        self.tos_accepted = tos_accepted

        # Backup code to recover TOTP for JSON.
        self.totp_backup = totp_backup

        # Code from the TOTP generator.
        self.totp_code = totp_code

        # Will check for TOTP code during sign in.
        self.totp_enabled = totp_enabled

        # QR Code version of the TOTPSecret.
        self.totp_q_r = totp_q_r

        # Secret to setup a TOTP generator for JSON.
        self.totp_secret = totp_secret

        # Timestamp for when account was last updated.
        self.updated = updated

        # Sets the UserAgent for the initial session after account creation.
        self.user_agent = user_agent

        # Accounts must be verified to receive email notifications.
        self.verified = verified

        # WebAuthnCreation is used during signup and webauthnenrollment.
        self.web_authn_creation = web_authn_creation

        # WebAuthnCredentials is a list of usable WebAuthn credentials for authenticating an AuthAccount.
        self.web_authn_credentials = web_authn_credentials

        # WebAuthnRequest is used during signin.
        self.web_authn_request = web_authn_request

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_account_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_account_to_jsonable(self)


def new_models_auth_account() -> ModelsAuthAccount:
    """Generates an instance of ModelsAuthAccount with default values."""
    return ModelsAuthAccount()


def models_auth_account_from_obj(obj: Any, path: str = "") -> ModelsAuthAccount:
    """
    Generates an instance of ModelsAuthAccount from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthAccount
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthAccount
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    auth_o_id_c_client_ids_from_obj = obj.get('authOIDCClientIDs', None)

    obj_collapsed_notes_pages = obj.get('collapsedNotesPages', None)
    if obj_collapsed_notes_pages is not None:
        collapsed_notes_pages_from_obj = from_obj(
            obj_collapsed_notes_pages,
            expected=[list, str],
            path=path + '.collapsedNotesPages')  # type: Optional[List[str]]
    else:
        collapsed_notes_pages_from_obj = None

    obj_collapsed_plan_projects = obj.get('collapsedPlanProjects', None)
    if obj_collapsed_plan_projects is not None:
        collapsed_plan_projects_from_obj = from_obj(
            obj_collapsed_plan_projects,
            expected=[list, str],
            path=path + '.collapsedPlanProjects')  # type: Optional[List[str]]
    else:
        collapsed_plan_projects_from_obj = None

    obj_collapsed_plan_tasks = obj.get('collapsedPlanTasks', None)
    if obj_collapsed_plan_tasks is not None:
        collapsed_plan_tasks_from_obj = from_obj(
            obj_collapsed_plan_tasks,
            expected=[list, str],
            path=path + '.collapsedPlanTasks')  # type: Optional[List[str]]
    else:
        collapsed_plan_tasks_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_daily_agenda_next = obj.get('dailyAgendaNext', None)
    if obj_daily_agenda_next is not None:
        daily_agenda_next_from_obj = from_obj(
            obj_daily_agenda_next,
            expected=[str],
            path=path + '.dailyAgendaNext')  # type: Optional[str]
    else:
        daily_agenda_next_from_obj = None

    obj_daily_agenda_time = obj.get('dailyAgendaTime', None)
    if obj_daily_agenda_time is not None:
        daily_agenda_time_from_obj = from_obj(
            obj_daily_agenda_time,
            expected=[str],
            path=path + '.dailyAgendaTime')  # type: Optional[str]
    else:
        daily_agenda_time_from_obj = None

    obj_delegations = obj.get('delegations', None)
    if obj_delegations is not None:
        delegations_from_obj = from_obj(
            obj_delegations,
            expected=[list, ModelsAuthAccountDelegation],
            path=path + '.delegations')  # type: Optional[List['ModelsAuthAccountDelegation']]
    else:
        delegations_from_obj = None

    obj_email_address = obj.get('emailAddress', None)
    if obj_email_address is not None:
        email_address_from_obj = from_obj(
            obj_email_address,
            expected=[str],
            path=path + '.emailAddress')  # type: Optional[str]
    else:
        email_address_from_obj = None

    obj_email_auth_disabled = obj.get('emailAuthDisabled', None)
    if obj_email_auth_disabled is not None:
        email_auth_disabled_from_obj = from_obj(
            obj_email_auth_disabled,
            expected=[bool],
            path=path + '.emailAuthDisabled')  # type: Optional[bool]
    else:
        email_auth_disabled_from_obj = None

    obj_email_auth_token = obj.get('emailAuthToken', None)
    if obj_email_auth_token is not None:
        email_auth_token_from_obj = from_obj(
            obj_email_auth_token,
            expected=[str],
            path=path + '.emailAuthToken')  # type: Optional[str]
    else:
        email_auth_token_from_obj = None

    obj_health_item_correlation_hours = obj.get('healthItemCorrelationHours', None)
    if obj_health_item_correlation_hours is not None:
        health_item_correlation_hours_from_obj = from_obj(
            obj_health_item_correlation_hours,
            expected=[int],
            path=path + '.healthItemCorrelationHours')  # type: Optional[int]
    else:
        health_item_correlation_hours_from_obj = None

    obj_hide_calendar_i_calendars = obj.get('hideCalendarICalendars', None)
    if obj_hide_calendar_i_calendars is not None:
        hide_calendar_i_calendars_from_obj = from_obj(
            obj_hide_calendar_i_calendars,
            expected=[list, str],
            path=path + '.hideCalendarICalendars')  # type: Optional[List[str]]
    else:
        hide_calendar_i_calendars_from_obj = None

    obj_icalendar_id = obj.get('icalendarID', None)
    if obj_icalendar_id is not None:
        icalendar_id_from_obj = from_obj(
            obj_icalendar_id,
            expected=[str],
            path=path + '.icalendarID')  # type: Optional[str]
    else:
        icalendar_id_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_iso639_code = obj.get('iso639Code', None)
    if obj_iso639_code is not None:
        iso639_code_from_obj = from_obj(
            obj_iso639_code,
            expected=[str],
            path=path + '.iso639Code')  # type: Optional[str]
    else:
        iso639_code_from_obj = None

    obj_last_activity = obj.get('lastActivity', None)
    if obj_last_activity is not None:
        last_activity_from_obj = from_obj(
            obj_last_activity,
            expected=[str],
            path=path + '.lastActivity')  # type: Optional[str]
    else:
        last_activity_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_oidc_code = obj.get('oidcCode', None)
    if obj_oidc_code is not None:
        oidc_code_from_obj = from_obj(
            obj_oidc_code,
            expected=[str],
            path=path + '.oidcCode')  # type: Optional[str]
    else:
        oidc_code_from_obj = None

    obj_oidc_issuer = obj.get('oidcIssuer', None)
    if obj_oidc_issuer is not None:
        oidc_issuer_from_obj = from_obj(
            obj_oidc_issuer,
            expected=[str],
            path=path + '.oidcIssuer')  # type: Optional[str]
    else:
        oidc_issuer_from_obj = None

    obj_oidc_state = obj.get('oidcState', None)
    if obj_oidc_state is not None:
        oidc_state_from_obj = from_obj(
            obj_oidc_state,
            expected=[str],
            path=path + '.oidcState')  # type: Optional[str]
    else:
        oidc_state_from_obj = None

    obj_password = obj.get('password', None)
    if obj_password is not None:
        password_from_obj = from_obj(
            obj_password,
            expected=[str],
            path=path + '.password')  # type: Optional[str]
    else:
        password_from_obj = None

    obj_password_enabled = obj.get('passwordEnabled', None)
    if obj_password_enabled is not None:
        password_enabled_from_obj = from_obj(
            obj_password_enabled,
            expected=[bool],
            path=path + '.passwordEnabled')  # type: Optional[bool]
    else:
        password_enabled_from_obj = None

    permissions_account_from_obj = obj.get('permissionsAccount', None)

    permissions_households_from_obj = obj.get('permissionsHouseholds', None)

    preferences_from_obj = obj.get('preferences', None)

    obj_primary_auth_household_id = obj.get('primaryAuthHouseholdID', None)
    if obj_primary_auth_household_id is not None:
        primary_auth_household_id_from_obj = from_obj(
            obj_primary_auth_household_id,
            expected=[str],
            path=path + '.primaryAuthHouseholdID')  # type: Optional[str]
    else:
        primary_auth_household_id_from_obj = None

    obj_private_keys = obj.get('privateKeys', None)
    if obj_private_keys is not None:
        private_keys_from_obj = from_obj(
            obj_private_keys,
            expected=[list, ModelsAuthAccountPrivateKey],
            path=path + '.privateKeys')  # type: Optional[List['ModelsAuthAccountPrivateKey']]
    else:
        private_keys_from_obj = None

    public_key_from_obj = obj.get('publicKey', None)

    obj_remember_me = obj.get('rememberMe', None)
    if obj_remember_me is not None:
        remember_me_from_obj = from_obj(
            obj_remember_me,
            expected=[bool],
            path=path + '.rememberMe')  # type: Optional[bool]
    else:
        remember_me_from_obj = None

    obj_self_hosted_id = obj.get('selfHostedID', None)
    if obj_self_hosted_id is not None:
        self_hosted_id_from_obj = from_obj(
            obj_self_hosted_id,
            expected=[str],
            path=path + '.selfHostedID')  # type: Optional[str]
    else:
        self_hosted_id_from_obj = None

    obj_setup = obj.get('setup', None)
    if obj_setup is not None:
        setup_from_obj = from_obj(
            obj_setup,
            expected=[bool],
            path=path + '.setup')  # type: Optional[bool]
    else:
        setup_from_obj = None

    obj_time_zone = obj.get('timeZone', None)
    if obj_time_zone is not None:
        time_zone_from_obj = from_obj(
            obj_time_zone,
            expected=[str],
            path=path + '.timeZone')  # type: Optional[str]
    else:
        time_zone_from_obj = None

    obj_tos_accepted = obj.get('tosAccepted', None)
    if obj_tos_accepted is not None:
        tos_accepted_from_obj = from_obj(
            obj_tos_accepted,
            expected=[bool],
            path=path + '.tosAccepted')  # type: Optional[bool]
    else:
        tos_accepted_from_obj = None

    obj_totp_backup = obj.get('totpBackup', None)
    if obj_totp_backup is not None:
        totp_backup_from_obj = from_obj(
            obj_totp_backup,
            expected=[str],
            path=path + '.totpBackup')  # type: Optional[str]
    else:
        totp_backup_from_obj = None

    obj_totp_code = obj.get('totpCode', None)
    if obj_totp_code is not None:
        totp_code_from_obj = from_obj(
            obj_totp_code,
            expected=[str],
            path=path + '.totpCode')  # type: Optional[str]
    else:
        totp_code_from_obj = None

    obj_totp_enabled = obj.get('totpEnabled', None)
    if obj_totp_enabled is not None:
        totp_enabled_from_obj = from_obj(
            obj_totp_enabled,
            expected=[bool],
            path=path + '.totpEnabled')  # type: Optional[bool]
    else:
        totp_enabled_from_obj = None

    obj_totp_q_r = obj.get('totpQR', None)
    if obj_totp_q_r is not None:
        totp_q_r_from_obj = from_obj(
            obj_totp_q_r,
            expected=[str],
            path=path + '.totpQR')  # type: Optional[str]
    else:
        totp_q_r_from_obj = None

    obj_totp_secret = obj.get('totpSecret', None)
    if obj_totp_secret is not None:
        totp_secret_from_obj = from_obj(
            obj_totp_secret,
            expected=[str],
            path=path + '.totpSecret')  # type: Optional[str]
    else:
        totp_secret_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    user_agent_from_obj = obj.get('userAgent', None)

    obj_verified = obj.get('verified', None)
    if obj_verified is not None:
        verified_from_obj = from_obj(
            obj_verified,
            expected=[bool],
            path=path + '.verified')  # type: Optional[bool]
    else:
        verified_from_obj = None

    web_authn_creation_from_obj = obj.get('webAuthnCreation', None)

    obj_web_authn_credentials = obj.get('webAuthnCredentials', None)
    if obj_web_authn_credentials is not None:
        web_authn_credentials_from_obj = from_obj(
            obj_web_authn_credentials,
            expected=[list, WebauthnCredential],
            path=path + '.webAuthnCredentials')  # type: Optional[List['WebauthnCredential']]
    else:
        web_authn_credentials_from_obj = None

    web_authn_request_from_obj = obj.get('webAuthnRequest', None)

    return ModelsAuthAccount(
        auth_o_id_c_client_ids=auth_o_id_c_client_ids_from_obj,
        collapsed_notes_pages=collapsed_notes_pages_from_obj,
        collapsed_plan_projects=collapsed_plan_projects_from_obj,
        collapsed_plan_tasks=collapsed_plan_tasks_from_obj,
        created=created_from_obj,
        daily_agenda_next=daily_agenda_next_from_obj,
        daily_agenda_time=daily_agenda_time_from_obj,
        delegations=delegations_from_obj,
        email_address=email_address_from_obj,
        email_auth_disabled=email_auth_disabled_from_obj,
        email_auth_token=email_auth_token_from_obj,
        health_item_correlation_hours=health_item_correlation_hours_from_obj,
        hide_calendar_i_calendars=hide_calendar_i_calendars_from_obj,
        icalendar_id=icalendar_id_from_obj,
        id=id_from_obj,
        iso639_code=iso639_code_from_obj,
        last_activity=last_activity_from_obj,
        name=name_from_obj,
        oidc_code=oidc_code_from_obj,
        oidc_issuer=oidc_issuer_from_obj,
        oidc_state=oidc_state_from_obj,
        password=password_from_obj,
        password_enabled=password_enabled_from_obj,
        permissions_account=permissions_account_from_obj,
        permissions_households=permissions_households_from_obj,
        preferences=preferences_from_obj,
        primary_auth_household_id=primary_auth_household_id_from_obj,
        private_keys=private_keys_from_obj,
        public_key=public_key_from_obj,
        remember_me=remember_me_from_obj,
        self_hosted_id=self_hosted_id_from_obj,
        setup=setup_from_obj,
        time_zone=time_zone_from_obj,
        tos_accepted=tos_accepted_from_obj,
        totp_backup=totp_backup_from_obj,
        totp_code=totp_code_from_obj,
        totp_enabled=totp_enabled_from_obj,
        totp_q_r=totp_q_r_from_obj,
        totp_secret=totp_secret_from_obj,
        updated=updated_from_obj,
        user_agent=user_agent_from_obj,
        verified=verified_from_obj,
        web_authn_creation=web_authn_creation_from_obj,
        web_authn_credentials=web_authn_credentials_from_obj,
        web_authn_request=web_authn_request_from_obj)


def models_auth_account_to_jsonable(
        models_auth_account: ModelsAuthAccount,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthAccount.

    :param models_auth_account: instance of ModelsAuthAccount to be JSON-ized
    :param path: path to the models_auth_account used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_account.auth_o_id_c_client_ids is not None:
        res['authOIDCClientIDs'] = models_auth_account.auth_o_id_c_client_ids

    if models_auth_account.collapsed_notes_pages is not None:
        res['collapsedNotesPages'] = to_jsonable(
        models_auth_account.collapsed_notes_pages,
        expected=[list, str],
        path='{}.collapsedNotesPages'.format(path))

    if models_auth_account.collapsed_plan_projects is not None:
        res['collapsedPlanProjects'] = to_jsonable(
        models_auth_account.collapsed_plan_projects,
        expected=[list, str],
        path='{}.collapsedPlanProjects'.format(path))

    if models_auth_account.collapsed_plan_tasks is not None:
        res['collapsedPlanTasks'] = to_jsonable(
        models_auth_account.collapsed_plan_tasks,
        expected=[list, str],
        path='{}.collapsedPlanTasks'.format(path))

    if models_auth_account.created is not None:
        res['created'] = models_auth_account.created

    if models_auth_account.daily_agenda_next is not None:
        res['dailyAgendaNext'] = models_auth_account.daily_agenda_next

    if models_auth_account.daily_agenda_time is not None:
        res['dailyAgendaTime'] = models_auth_account.daily_agenda_time

    if models_auth_account.delegations is not None:
        res['delegations'] = to_jsonable(
        models_auth_account.delegations,
        expected=[list, ModelsAuthAccountDelegation],
        path='{}.delegations'.format(path))

    if models_auth_account.email_address is not None:
        res['emailAddress'] = models_auth_account.email_address

    if models_auth_account.email_auth_disabled is not None:
        res['emailAuthDisabled'] = models_auth_account.email_auth_disabled

    if models_auth_account.email_auth_token is not None:
        res['emailAuthToken'] = models_auth_account.email_auth_token

    if models_auth_account.health_item_correlation_hours is not None:
        res['healthItemCorrelationHours'] = models_auth_account.health_item_correlation_hours

    if models_auth_account.hide_calendar_i_calendars is not None:
        res['hideCalendarICalendars'] = to_jsonable(
        models_auth_account.hide_calendar_i_calendars,
        expected=[list, str],
        path='{}.hideCalendarICalendars'.format(path))

    if models_auth_account.icalendar_id is not None:
        res['icalendarID'] = models_auth_account.icalendar_id

    if models_auth_account.id is not None:
        res['id'] = models_auth_account.id

    if models_auth_account.iso639_code is not None:
        res['iso639Code'] = models_auth_account.iso639_code

    if models_auth_account.last_activity is not None:
        res['lastActivity'] = models_auth_account.last_activity

    if models_auth_account.name is not None:
        res['name'] = models_auth_account.name

    if models_auth_account.oidc_code is not None:
        res['oidcCode'] = models_auth_account.oidc_code

    if models_auth_account.oidc_issuer is not None:
        res['oidcIssuer'] = models_auth_account.oidc_issuer

    if models_auth_account.oidc_state is not None:
        res['oidcState'] = models_auth_account.oidc_state

    if models_auth_account.password is not None:
        res['password'] = models_auth_account.password

    if models_auth_account.password_enabled is not None:
        res['passwordEnabled'] = models_auth_account.password_enabled

    if models_auth_account.permissions_account is not None:
        res['permissionsAccount'] = models_auth_account.permissions_account

    if models_auth_account.permissions_households is not None:
        res['permissionsHouseholds'] = models_auth_account.permissions_households

    if models_auth_account.preferences is not None:
        res['preferences'] = models_auth_account.preferences

    if models_auth_account.primary_auth_household_id is not None:
        res['primaryAuthHouseholdID'] = models_auth_account.primary_auth_household_id

    if models_auth_account.private_keys is not None:
        res['privateKeys'] = to_jsonable(
        models_auth_account.private_keys,
        expected=[list, ModelsAuthAccountPrivateKey],
        path='{}.privateKeys'.format(path))

    if models_auth_account.public_key is not None:
        res['publicKey'] = models_auth_account.public_key

    if models_auth_account.remember_me is not None:
        res['rememberMe'] = models_auth_account.remember_me

    if models_auth_account.self_hosted_id is not None:
        res['selfHostedID'] = models_auth_account.self_hosted_id

    if models_auth_account.setup is not None:
        res['setup'] = models_auth_account.setup

    if models_auth_account.time_zone is not None:
        res['timeZone'] = models_auth_account.time_zone

    if models_auth_account.tos_accepted is not None:
        res['tosAccepted'] = models_auth_account.tos_accepted

    if models_auth_account.totp_backup is not None:
        res['totpBackup'] = models_auth_account.totp_backup

    if models_auth_account.totp_code is not None:
        res['totpCode'] = models_auth_account.totp_code

    if models_auth_account.totp_enabled is not None:
        res['totpEnabled'] = models_auth_account.totp_enabled

    if models_auth_account.totp_q_r is not None:
        res['totpQR'] = models_auth_account.totp_q_r

    if models_auth_account.totp_secret is not None:
        res['totpSecret'] = models_auth_account.totp_secret

    if models_auth_account.updated is not None:
        res['updated'] = models_auth_account.updated

    if models_auth_account.user_agent is not None:
        res['userAgent'] = models_auth_account.user_agent

    if models_auth_account.verified is not None:
        res['verified'] = models_auth_account.verified

    if models_auth_account.web_authn_creation is not None:
        res['webAuthnCreation'] = models_auth_account.web_authn_creation

    if models_auth_account.web_authn_credentials is not None:
        res['webAuthnCredentials'] = to_jsonable(
        models_auth_account.web_authn_credentials,
        expected=[list, WebauthnCredential],
        path='{}.webAuthnCredentials'.format(path))

    if models_auth_account.web_authn_request is not None:
        res['webAuthnRequest'] = models_auth_account.web_authn_request

    return res


class ModelsAuthAccountDelegation:
    def __init__(
            self,
            access: Optional['ModelsAuthAccountDelegationAccess'] = None,
            id: Optional[str] = None,
            source_id: Optional[str] = None,
            target_id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.access = access

        self.id = id

        self.source_id = source_id

        self.target_id = target_id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_account_delegation_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_account_delegation_to_jsonable(self)


def new_models_auth_account_delegation() -> ModelsAuthAccountDelegation:
    """Generates an instance of ModelsAuthAccountDelegation with default values."""
    return ModelsAuthAccountDelegation()


def models_auth_account_delegation_from_obj(obj: Any, path: str = "") -> ModelsAuthAccountDelegation:
    """
    Generates an instance of ModelsAuthAccountDelegation from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthAccountDelegation
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthAccountDelegation
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_access = obj.get('access', None)
    if obj_access is not None:
        access_from_obj = from_obj(
            obj_access,
            expected=[ModelsAuthAccountDelegationAccess],
            path=path + '.access')  # type: Optional['ModelsAuthAccountDelegationAccess']
    else:
        access_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_source_id = obj.get('sourceID', None)
    if obj_source_id is not None:
        source_id_from_obj = from_obj(
            obj_source_id,
            expected=[str],
            path=path + '.sourceID')  # type: Optional[str]
    else:
        source_id_from_obj = None

    obj_target_id = obj.get('targetID', None)
    if obj_target_id is not None:
        target_id_from_obj = from_obj(
            obj_target_id,
            expected=[str],
            path=path + '.targetID')  # type: Optional[str]
    else:
        target_id_from_obj = None

    return ModelsAuthAccountDelegation(
        access=access_from_obj,
        id=id_from_obj,
        source_id=source_id_from_obj,
        target_id=target_id_from_obj)


def models_auth_account_delegation_to_jsonable(
        models_auth_account_delegation: ModelsAuthAccountDelegation,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthAccountDelegation.

    :param models_auth_account_delegation: instance of ModelsAuthAccountDelegation to be JSON-ized
    :param path: path to the models_auth_account_delegation used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_account_delegation.access is not None:
        res['access'] = to_jsonable(
        models_auth_account_delegation.access,
        expected=[ModelsAuthAccountDelegationAccess],
        path='{}.access'.format(path))

    if models_auth_account_delegation.id is not None:
        res['id'] = models_auth_account_delegation.id

    if models_auth_account_delegation.source_id is not None:
        res['sourceID'] = models_auth_account_delegation.source_id

    if models_auth_account_delegation.target_id is not None:
        res['targetID'] = models_auth_account_delegation.target_id

    return res


class ModelsAuthAccountDelegationAccess:
    def __init__(
            self,
            health: Optional[bool] = None,
            target_managed: Optional[bool] = None) -> None:
        """Initializes with the given values."""
        self.health = health

        self.target_managed = target_managed

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_account_delegation_access_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_account_delegation_access_to_jsonable(self)


def new_models_auth_account_delegation_access() -> ModelsAuthAccountDelegationAccess:
    """Generates an instance of ModelsAuthAccountDelegationAccess with default values."""
    return ModelsAuthAccountDelegationAccess()


def models_auth_account_delegation_access_from_obj(obj: Any, path: str = "") -> ModelsAuthAccountDelegationAccess:
    """
    Generates an instance of ModelsAuthAccountDelegationAccess from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthAccountDelegationAccess
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthAccountDelegationAccess
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_health = obj.get('health', None)
    if obj_health is not None:
        health_from_obj = from_obj(
            obj_health,
            expected=[bool],
            path=path + '.health')  # type: Optional[bool]
    else:
        health_from_obj = None

    obj_target_managed = obj.get('targetManaged', None)
    if obj_target_managed is not None:
        target_managed_from_obj = from_obj(
            obj_target_managed,
            expected=[bool],
            path=path + '.targetManaged')  # type: Optional[bool]
    else:
        target_managed_from_obj = None

    return ModelsAuthAccountDelegationAccess(
        health=health_from_obj,
        target_managed=target_managed_from_obj)


def models_auth_account_delegation_access_to_jsonable(
        models_auth_account_delegation_access: ModelsAuthAccountDelegationAccess,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthAccountDelegationAccess.

    :param models_auth_account_delegation_access: instance of ModelsAuthAccountDelegationAccess to be JSON-ized
    :param path: path to the models_auth_account_delegation_access used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_account_delegation_access.health is not None:
        res['health'] = models_auth_account_delegation_access.health

    if models_auth_account_delegation_access.target_managed is not None:
        res['targetManaged'] = models_auth_account_delegation_access.target_managed

    return res


class ModelsAuthAccountPreferences:
    def __init__(
            self,
            color_accent: Optional[str] = None,
            color_negative: Optional[str] = None,
            color_positive: Optional[str] = None,
            color_primary: Optional[str] = None,
            color_secondary: Optional[str] = None,
            colors: Optional[List['ModelsColor']] = None,
            dark_mode: Optional[bool] = None,
            format_date_order: Optional[int] = None,
            format_date_separator: Optional[int] = None,
            format_time24: Optional[bool] = None,
            format_week8601: Optional[bool] = None,
            hide_calendar_budget_recurrences: Optional[bool] = None,
            hide_calendar_cook_meal_plans: Optional[bool] = None,
            hide_calendar_events: Optional[bool] = None,
            hide_calendar_health_logs: Optional[List[str]] = None,
            hide_calendar_plan_tasks: Optional[bool] = None,
            hide_components: Optional[List[str]] = None,
            ignore_device_agenda: Optional[bool] = None,
            ignore_device_calendar_event: Optional[bool] = None,
            ignore_device_plan_task: Optional[bool] = None,
            ignore_email_agenda: Optional[bool] = None,
            ignore_email_calendar_event: Optional[bool] = None,
            ignore_email_plan_task: Optional[bool] = None,
            notifications_households: Optional[List['ModelsAuthAccountPreferencesNotificationsHousehold']] = None,
            show_calendar_plan_tasks_completed: Optional[bool] = None) -> None:
        """Initializes with the given values."""
        self.color_accent = color_accent

        self.color_negative = color_negative

        self.color_positive = color_positive

        self.color_primary = color_primary

        self.color_secondary = color_secondary

        self.colors = colors

        self.dark_mode = dark_mode

        self.format_date_order = format_date_order

        self.format_date_separator = format_date_separator

        self.format_time24 = format_time24

        self.format_week8601 = format_week8601

        self.hide_calendar_budget_recurrences = hide_calendar_budget_recurrences

        self.hide_calendar_cook_meal_plans = hide_calendar_cook_meal_plans

        self.hide_calendar_events = hide_calendar_events

        self.hide_calendar_health_logs = hide_calendar_health_logs

        self.hide_calendar_plan_tasks = hide_calendar_plan_tasks

        self.hide_components = hide_components

        self.ignore_device_agenda = ignore_device_agenda

        self.ignore_device_calendar_event = ignore_device_calendar_event

        self.ignore_device_plan_task = ignore_device_plan_task

        self.ignore_email_agenda = ignore_email_agenda

        self.ignore_email_calendar_event = ignore_email_calendar_event

        self.ignore_email_plan_task = ignore_email_plan_task

        self.notifications_households = notifications_households

        self.show_calendar_plan_tasks_completed = show_calendar_plan_tasks_completed

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_account_preferences_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_account_preferences_to_jsonable(self)


def new_models_auth_account_preferences() -> ModelsAuthAccountPreferences:
    """Generates an instance of ModelsAuthAccountPreferences with default values."""
    return ModelsAuthAccountPreferences()


def models_auth_account_preferences_from_obj(obj: Any, path: str = "") -> ModelsAuthAccountPreferences:
    """
    Generates an instance of ModelsAuthAccountPreferences from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthAccountPreferences
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthAccountPreferences
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_color_accent = obj.get('colorAccent', None)
    if obj_color_accent is not None:
        color_accent_from_obj = from_obj(
            obj_color_accent,
            expected=[str],
            path=path + '.colorAccent')  # type: Optional[str]
    else:
        color_accent_from_obj = None

    obj_color_negative = obj.get('colorNegative', None)
    if obj_color_negative is not None:
        color_negative_from_obj = from_obj(
            obj_color_negative,
            expected=[str],
            path=path + '.colorNegative')  # type: Optional[str]
    else:
        color_negative_from_obj = None

    obj_color_positive = obj.get('colorPositive', None)
    if obj_color_positive is not None:
        color_positive_from_obj = from_obj(
            obj_color_positive,
            expected=[str],
            path=path + '.colorPositive')  # type: Optional[str]
    else:
        color_positive_from_obj = None

    obj_color_primary = obj.get('colorPrimary', None)
    if obj_color_primary is not None:
        color_primary_from_obj = from_obj(
            obj_color_primary,
            expected=[str],
            path=path + '.colorPrimary')  # type: Optional[str]
    else:
        color_primary_from_obj = None

    obj_color_secondary = obj.get('colorSecondary', None)
    if obj_color_secondary is not None:
        color_secondary_from_obj = from_obj(
            obj_color_secondary,
            expected=[str],
            path=path + '.colorSecondary')  # type: Optional[str]
    else:
        color_secondary_from_obj = None

    obj_colors = obj.get('colors', None)
    if obj_colors is not None:
        colors_from_obj = from_obj(
            obj_colors,
            expected=[list, ModelsColor],
            path=path + '.colors')  # type: Optional[List['ModelsColor']]
    else:
        colors_from_obj = None

    obj_dark_mode = obj.get('darkMode', None)
    if obj_dark_mode is not None:
        dark_mode_from_obj = from_obj(
            obj_dark_mode,
            expected=[bool],
            path=path + '.darkMode')  # type: Optional[bool]
    else:
        dark_mode_from_obj = None

    obj_format_date_order = obj.get('formatDateOrder', None)
    if obj_format_date_order is not None:
        format_date_order_from_obj = from_obj(
            obj_format_date_order,
            expected=[int],
            path=path + '.formatDateOrder')  # type: Optional[int]
    else:
        format_date_order_from_obj = None

    obj_format_date_separator = obj.get('formatDateSeparator', None)
    if obj_format_date_separator is not None:
        format_date_separator_from_obj = from_obj(
            obj_format_date_separator,
            expected=[int],
            path=path + '.formatDateSeparator')  # type: Optional[int]
    else:
        format_date_separator_from_obj = None

    obj_format_time24 = obj.get('formatTime24', None)
    if obj_format_time24 is not None:
        format_time24_from_obj = from_obj(
            obj_format_time24,
            expected=[bool],
            path=path + '.formatTime24')  # type: Optional[bool]
    else:
        format_time24_from_obj = None

    obj_format_week8601 = obj.get('formatWeek8601', None)
    if obj_format_week8601 is not None:
        format_week8601_from_obj = from_obj(
            obj_format_week8601,
            expected=[bool],
            path=path + '.formatWeek8601')  # type: Optional[bool]
    else:
        format_week8601_from_obj = None

    obj_hide_calendar_budget_recurrences = obj.get('hideCalendarBudgetRecurrences', None)
    if obj_hide_calendar_budget_recurrences is not None:
        hide_calendar_budget_recurrences_from_obj = from_obj(
            obj_hide_calendar_budget_recurrences,
            expected=[bool],
            path=path + '.hideCalendarBudgetRecurrences')  # type: Optional[bool]
    else:
        hide_calendar_budget_recurrences_from_obj = None

    obj_hide_calendar_cook_meal_plans = obj.get('hideCalendarCookMealPlans', None)
    if obj_hide_calendar_cook_meal_plans is not None:
        hide_calendar_cook_meal_plans_from_obj = from_obj(
            obj_hide_calendar_cook_meal_plans,
            expected=[bool],
            path=path + '.hideCalendarCookMealPlans')  # type: Optional[bool]
    else:
        hide_calendar_cook_meal_plans_from_obj = None

    obj_hide_calendar_events = obj.get('hideCalendarEvents', None)
    if obj_hide_calendar_events is not None:
        hide_calendar_events_from_obj = from_obj(
            obj_hide_calendar_events,
            expected=[bool],
            path=path + '.hideCalendarEvents')  # type: Optional[bool]
    else:
        hide_calendar_events_from_obj = None

    obj_hide_calendar_health_logs = obj.get('hideCalendarHealthLogs', None)
    if obj_hide_calendar_health_logs is not None:
        hide_calendar_health_logs_from_obj = from_obj(
            obj_hide_calendar_health_logs,
            expected=[list, str],
            path=path + '.hideCalendarHealthLogs')  # type: Optional[List[str]]
    else:
        hide_calendar_health_logs_from_obj = None

    obj_hide_calendar_plan_tasks = obj.get('hideCalendarPlanTasks', None)
    if obj_hide_calendar_plan_tasks is not None:
        hide_calendar_plan_tasks_from_obj = from_obj(
            obj_hide_calendar_plan_tasks,
            expected=[bool],
            path=path + '.hideCalendarPlanTasks')  # type: Optional[bool]
    else:
        hide_calendar_plan_tasks_from_obj = None

    obj_hide_components = obj.get('hideComponents', None)
    if obj_hide_components is not None:
        hide_components_from_obj = from_obj(
            obj_hide_components,
            expected=[list, str],
            path=path + '.hideComponents')  # type: Optional[List[str]]
    else:
        hide_components_from_obj = None

    obj_ignore_device_agenda = obj.get('ignoreDeviceAgenda', None)
    if obj_ignore_device_agenda is not None:
        ignore_device_agenda_from_obj = from_obj(
            obj_ignore_device_agenda,
            expected=[bool],
            path=path + '.ignoreDeviceAgenda')  # type: Optional[bool]
    else:
        ignore_device_agenda_from_obj = None

    obj_ignore_device_calendar_event = obj.get('ignoreDeviceCalendarEvent', None)
    if obj_ignore_device_calendar_event is not None:
        ignore_device_calendar_event_from_obj = from_obj(
            obj_ignore_device_calendar_event,
            expected=[bool],
            path=path + '.ignoreDeviceCalendarEvent')  # type: Optional[bool]
    else:
        ignore_device_calendar_event_from_obj = None

    obj_ignore_device_plan_task = obj.get('ignoreDevicePlanTask', None)
    if obj_ignore_device_plan_task is not None:
        ignore_device_plan_task_from_obj = from_obj(
            obj_ignore_device_plan_task,
            expected=[bool],
            path=path + '.ignoreDevicePlanTask')  # type: Optional[bool]
    else:
        ignore_device_plan_task_from_obj = None

    obj_ignore_email_agenda = obj.get('ignoreEmailAgenda', None)
    if obj_ignore_email_agenda is not None:
        ignore_email_agenda_from_obj = from_obj(
            obj_ignore_email_agenda,
            expected=[bool],
            path=path + '.ignoreEmailAgenda')  # type: Optional[bool]
    else:
        ignore_email_agenda_from_obj = None

    obj_ignore_email_calendar_event = obj.get('ignoreEmailCalendarEvent', None)
    if obj_ignore_email_calendar_event is not None:
        ignore_email_calendar_event_from_obj = from_obj(
            obj_ignore_email_calendar_event,
            expected=[bool],
            path=path + '.ignoreEmailCalendarEvent')  # type: Optional[bool]
    else:
        ignore_email_calendar_event_from_obj = None

    obj_ignore_email_plan_task = obj.get('ignoreEmailPlanTask', None)
    if obj_ignore_email_plan_task is not None:
        ignore_email_plan_task_from_obj = from_obj(
            obj_ignore_email_plan_task,
            expected=[bool],
            path=path + '.ignoreEmailPlanTask')  # type: Optional[bool]
    else:
        ignore_email_plan_task_from_obj = None

    obj_notifications_households = obj.get('notificationsHouseholds', None)
    if obj_notifications_households is not None:
        notifications_households_from_obj = from_obj(
            obj_notifications_households,
            expected=[list, ModelsAuthAccountPreferencesNotificationsHousehold],
            path=path + '.notificationsHouseholds')  # type: Optional[List['ModelsAuthAccountPreferencesNotificationsHousehold']]
    else:
        notifications_households_from_obj = None

    obj_show_calendar_plan_tasks_completed = obj.get('showCalendarPlanTasksCompleted', None)
    if obj_show_calendar_plan_tasks_completed is not None:
        show_calendar_plan_tasks_completed_from_obj = from_obj(
            obj_show_calendar_plan_tasks_completed,
            expected=[bool],
            path=path + '.showCalendarPlanTasksCompleted')  # type: Optional[bool]
    else:
        show_calendar_plan_tasks_completed_from_obj = None

    return ModelsAuthAccountPreferences(
        color_accent=color_accent_from_obj,
        color_negative=color_negative_from_obj,
        color_positive=color_positive_from_obj,
        color_primary=color_primary_from_obj,
        color_secondary=color_secondary_from_obj,
        colors=colors_from_obj,
        dark_mode=dark_mode_from_obj,
        format_date_order=format_date_order_from_obj,
        format_date_separator=format_date_separator_from_obj,
        format_time24=format_time24_from_obj,
        format_week8601=format_week8601_from_obj,
        hide_calendar_budget_recurrences=hide_calendar_budget_recurrences_from_obj,
        hide_calendar_cook_meal_plans=hide_calendar_cook_meal_plans_from_obj,
        hide_calendar_events=hide_calendar_events_from_obj,
        hide_calendar_health_logs=hide_calendar_health_logs_from_obj,
        hide_calendar_plan_tasks=hide_calendar_plan_tasks_from_obj,
        hide_components=hide_components_from_obj,
        ignore_device_agenda=ignore_device_agenda_from_obj,
        ignore_device_calendar_event=ignore_device_calendar_event_from_obj,
        ignore_device_plan_task=ignore_device_plan_task_from_obj,
        ignore_email_agenda=ignore_email_agenda_from_obj,
        ignore_email_calendar_event=ignore_email_calendar_event_from_obj,
        ignore_email_plan_task=ignore_email_plan_task_from_obj,
        notifications_households=notifications_households_from_obj,
        show_calendar_plan_tasks_completed=show_calendar_plan_tasks_completed_from_obj)


def models_auth_account_preferences_to_jsonable(
        models_auth_account_preferences: ModelsAuthAccountPreferences,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthAccountPreferences.

    :param models_auth_account_preferences: instance of ModelsAuthAccountPreferences to be JSON-ized
    :param path: path to the models_auth_account_preferences used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_account_preferences.color_accent is not None:
        res['colorAccent'] = models_auth_account_preferences.color_accent

    if models_auth_account_preferences.color_negative is not None:
        res['colorNegative'] = models_auth_account_preferences.color_negative

    if models_auth_account_preferences.color_positive is not None:
        res['colorPositive'] = models_auth_account_preferences.color_positive

    if models_auth_account_preferences.color_primary is not None:
        res['colorPrimary'] = models_auth_account_preferences.color_primary

    if models_auth_account_preferences.color_secondary is not None:
        res['colorSecondary'] = models_auth_account_preferences.color_secondary

    if models_auth_account_preferences.colors is not None:
        res['colors'] = to_jsonable(
        models_auth_account_preferences.colors,
        expected=[list, ModelsColor],
        path='{}.colors'.format(path))

    if models_auth_account_preferences.dark_mode is not None:
        res['darkMode'] = models_auth_account_preferences.dark_mode

    if models_auth_account_preferences.format_date_order is not None:
        res['formatDateOrder'] = models_auth_account_preferences.format_date_order

    if models_auth_account_preferences.format_date_separator is not None:
        res['formatDateSeparator'] = models_auth_account_preferences.format_date_separator

    if models_auth_account_preferences.format_time24 is not None:
        res['formatTime24'] = models_auth_account_preferences.format_time24

    if models_auth_account_preferences.format_week8601 is not None:
        res['formatWeek8601'] = models_auth_account_preferences.format_week8601

    if models_auth_account_preferences.hide_calendar_budget_recurrences is not None:
        res['hideCalendarBudgetRecurrences'] = models_auth_account_preferences.hide_calendar_budget_recurrences

    if models_auth_account_preferences.hide_calendar_cook_meal_plans is not None:
        res['hideCalendarCookMealPlans'] = models_auth_account_preferences.hide_calendar_cook_meal_plans

    if models_auth_account_preferences.hide_calendar_events is not None:
        res['hideCalendarEvents'] = models_auth_account_preferences.hide_calendar_events

    if models_auth_account_preferences.hide_calendar_health_logs is not None:
        res['hideCalendarHealthLogs'] = to_jsonable(
        models_auth_account_preferences.hide_calendar_health_logs,
        expected=[list, str],
        path='{}.hideCalendarHealthLogs'.format(path))

    if models_auth_account_preferences.hide_calendar_plan_tasks is not None:
        res['hideCalendarPlanTasks'] = models_auth_account_preferences.hide_calendar_plan_tasks

    if models_auth_account_preferences.hide_components is not None:
        res['hideComponents'] = to_jsonable(
        models_auth_account_preferences.hide_components,
        expected=[list, str],
        path='{}.hideComponents'.format(path))

    if models_auth_account_preferences.ignore_device_agenda is not None:
        res['ignoreDeviceAgenda'] = models_auth_account_preferences.ignore_device_agenda

    if models_auth_account_preferences.ignore_device_calendar_event is not None:
        res['ignoreDeviceCalendarEvent'] = models_auth_account_preferences.ignore_device_calendar_event

    if models_auth_account_preferences.ignore_device_plan_task is not None:
        res['ignoreDevicePlanTask'] = models_auth_account_preferences.ignore_device_plan_task

    if models_auth_account_preferences.ignore_email_agenda is not None:
        res['ignoreEmailAgenda'] = models_auth_account_preferences.ignore_email_agenda

    if models_auth_account_preferences.ignore_email_calendar_event is not None:
        res['ignoreEmailCalendarEvent'] = models_auth_account_preferences.ignore_email_calendar_event

    if models_auth_account_preferences.ignore_email_plan_task is not None:
        res['ignoreEmailPlanTask'] = models_auth_account_preferences.ignore_email_plan_task

    if models_auth_account_preferences.notifications_households is not None:
        res['notificationsHouseholds'] = to_jsonable(
        models_auth_account_preferences.notifications_households,
        expected=[list, ModelsAuthAccountPreferencesNotificationsHousehold],
        path='{}.notificationsHouseholds'.format(path))

    if models_auth_account_preferences.show_calendar_plan_tasks_completed is not None:
        res['showCalendarPlanTasksCompleted'] = models_auth_account_preferences.show_calendar_plan_tasks_completed

    return res


class ModelsAuthAccountPreferencesNotificationsHousehold:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            ignore_device_bookmark_create: Optional[bool] = None,
            ignore_device_budget_create: Optional[bool] = None,
            ignore_device_calendar_create: Optional[bool] = None,
            ignore_device_calendar_event: Optional[bool] = None,
            ignore_device_cook_create: Optional[bool] = None,
            ignore_device_cook_meal_plan_cook: Optional[bool] = None,
            ignore_device_cook_meal_plan_leave: Optional[bool] = None,
            ignore_device_cook_meal_plan_prep: Optional[bool] = None,
            ignore_device_inventory_create: Optional[bool] = None,
            ignore_device_notes_create: Optional[bool] = None,
            ignore_device_plan_create: Optional[bool] = None,
            ignore_device_plan_task: Optional[bool] = None,
            ignore_device_plan_task_complete: Optional[bool] = None,
            ignore_device_reward_create: Optional[bool] = None,
            ignore_device_secrets_create: Optional[bool] = None,
            ignore_device_shop_create: Optional[bool] = None,
            ignore_email_calendar_event: Optional[bool] = None,
            ignore_email_cook_meal_plan_cook: Optional[bool] = None,
            ignore_email_cook_meal_plan_leave: Optional[bool] = None,
            ignore_email_cook_meal_plan_prep: Optional[bool] = None,
            ignore_email_plan_task: Optional[bool] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.ignore_device_bookmark_create = ignore_device_bookmark_create

        self.ignore_device_budget_create = ignore_device_budget_create

        self.ignore_device_calendar_create = ignore_device_calendar_create

        self.ignore_device_calendar_event = ignore_device_calendar_event

        self.ignore_device_cook_create = ignore_device_cook_create

        self.ignore_device_cook_meal_plan_cook = ignore_device_cook_meal_plan_cook

        self.ignore_device_cook_meal_plan_leave = ignore_device_cook_meal_plan_leave

        self.ignore_device_cook_meal_plan_prep = ignore_device_cook_meal_plan_prep

        self.ignore_device_inventory_create = ignore_device_inventory_create

        self.ignore_device_notes_create = ignore_device_notes_create

        self.ignore_device_plan_create = ignore_device_plan_create

        self.ignore_device_plan_task = ignore_device_plan_task

        self.ignore_device_plan_task_complete = ignore_device_plan_task_complete

        self.ignore_device_reward_create = ignore_device_reward_create

        self.ignore_device_secrets_create = ignore_device_secrets_create

        self.ignore_device_shop_create = ignore_device_shop_create

        self.ignore_email_calendar_event = ignore_email_calendar_event

        self.ignore_email_cook_meal_plan_cook = ignore_email_cook_meal_plan_cook

        self.ignore_email_cook_meal_plan_leave = ignore_email_cook_meal_plan_leave

        self.ignore_email_cook_meal_plan_prep = ignore_email_cook_meal_plan_prep

        self.ignore_email_plan_task = ignore_email_plan_task

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_account_preferences_notifications_household_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_account_preferences_notifications_household_to_jsonable(self)


def new_models_auth_account_preferences_notifications_household() -> ModelsAuthAccountPreferencesNotificationsHousehold:
    """Generates an instance of ModelsAuthAccountPreferencesNotificationsHousehold with default values."""
    return ModelsAuthAccountPreferencesNotificationsHousehold()


def models_auth_account_preferences_notifications_household_from_obj(obj: Any, path: str = "") -> ModelsAuthAccountPreferencesNotificationsHousehold:
    """
    Generates an instance of ModelsAuthAccountPreferencesNotificationsHousehold from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthAccountPreferencesNotificationsHousehold
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthAccountPreferencesNotificationsHousehold
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_ignore_device_bookmark_create = obj.get('ignoreDeviceBookmarkCreate', None)
    if obj_ignore_device_bookmark_create is not None:
        ignore_device_bookmark_create_from_obj = from_obj(
            obj_ignore_device_bookmark_create,
            expected=[bool],
            path=path + '.ignoreDeviceBookmarkCreate')  # type: Optional[bool]
    else:
        ignore_device_bookmark_create_from_obj = None

    obj_ignore_device_budget_create = obj.get('ignoreDeviceBudgetCreate', None)
    if obj_ignore_device_budget_create is not None:
        ignore_device_budget_create_from_obj = from_obj(
            obj_ignore_device_budget_create,
            expected=[bool],
            path=path + '.ignoreDeviceBudgetCreate')  # type: Optional[bool]
    else:
        ignore_device_budget_create_from_obj = None

    obj_ignore_device_calendar_create = obj.get('ignoreDeviceCalendarCreate', None)
    if obj_ignore_device_calendar_create is not None:
        ignore_device_calendar_create_from_obj = from_obj(
            obj_ignore_device_calendar_create,
            expected=[bool],
            path=path + '.ignoreDeviceCalendarCreate')  # type: Optional[bool]
    else:
        ignore_device_calendar_create_from_obj = None

    obj_ignore_device_calendar_event = obj.get('ignoreDeviceCalendarEvent', None)
    if obj_ignore_device_calendar_event is not None:
        ignore_device_calendar_event_from_obj = from_obj(
            obj_ignore_device_calendar_event,
            expected=[bool],
            path=path + '.ignoreDeviceCalendarEvent')  # type: Optional[bool]
    else:
        ignore_device_calendar_event_from_obj = None

    obj_ignore_device_cook_create = obj.get('ignoreDeviceCookCreate', None)
    if obj_ignore_device_cook_create is not None:
        ignore_device_cook_create_from_obj = from_obj(
            obj_ignore_device_cook_create,
            expected=[bool],
            path=path + '.ignoreDeviceCookCreate')  # type: Optional[bool]
    else:
        ignore_device_cook_create_from_obj = None

    obj_ignore_device_cook_meal_plan_cook = obj.get('ignoreDeviceCookMealPlanCook', None)
    if obj_ignore_device_cook_meal_plan_cook is not None:
        ignore_device_cook_meal_plan_cook_from_obj = from_obj(
            obj_ignore_device_cook_meal_plan_cook,
            expected=[bool],
            path=path + '.ignoreDeviceCookMealPlanCook')  # type: Optional[bool]
    else:
        ignore_device_cook_meal_plan_cook_from_obj = None

    obj_ignore_device_cook_meal_plan_leave = obj.get('ignoreDeviceCookMealPlanLeave', None)
    if obj_ignore_device_cook_meal_plan_leave is not None:
        ignore_device_cook_meal_plan_leave_from_obj = from_obj(
            obj_ignore_device_cook_meal_plan_leave,
            expected=[bool],
            path=path + '.ignoreDeviceCookMealPlanLeave')  # type: Optional[bool]
    else:
        ignore_device_cook_meal_plan_leave_from_obj = None

    obj_ignore_device_cook_meal_plan_prep = obj.get('ignoreDeviceCookMealPlanPrep', None)
    if obj_ignore_device_cook_meal_plan_prep is not None:
        ignore_device_cook_meal_plan_prep_from_obj = from_obj(
            obj_ignore_device_cook_meal_plan_prep,
            expected=[bool],
            path=path + '.ignoreDeviceCookMealPlanPrep')  # type: Optional[bool]
    else:
        ignore_device_cook_meal_plan_prep_from_obj = None

    obj_ignore_device_inventory_create = obj.get('ignoreDeviceInventoryCreate', None)
    if obj_ignore_device_inventory_create is not None:
        ignore_device_inventory_create_from_obj = from_obj(
            obj_ignore_device_inventory_create,
            expected=[bool],
            path=path + '.ignoreDeviceInventoryCreate')  # type: Optional[bool]
    else:
        ignore_device_inventory_create_from_obj = None

    obj_ignore_device_notes_create = obj.get('ignoreDeviceNotesCreate', None)
    if obj_ignore_device_notes_create is not None:
        ignore_device_notes_create_from_obj = from_obj(
            obj_ignore_device_notes_create,
            expected=[bool],
            path=path + '.ignoreDeviceNotesCreate')  # type: Optional[bool]
    else:
        ignore_device_notes_create_from_obj = None

    obj_ignore_device_plan_create = obj.get('ignoreDevicePlanCreate', None)
    if obj_ignore_device_plan_create is not None:
        ignore_device_plan_create_from_obj = from_obj(
            obj_ignore_device_plan_create,
            expected=[bool],
            path=path + '.ignoreDevicePlanCreate')  # type: Optional[bool]
    else:
        ignore_device_plan_create_from_obj = None

    obj_ignore_device_plan_task = obj.get('ignoreDevicePlanTask', None)
    if obj_ignore_device_plan_task is not None:
        ignore_device_plan_task_from_obj = from_obj(
            obj_ignore_device_plan_task,
            expected=[bool],
            path=path + '.ignoreDevicePlanTask')  # type: Optional[bool]
    else:
        ignore_device_plan_task_from_obj = None

    obj_ignore_device_plan_task_complete = obj.get('ignoreDevicePlanTaskComplete', None)
    if obj_ignore_device_plan_task_complete is not None:
        ignore_device_plan_task_complete_from_obj = from_obj(
            obj_ignore_device_plan_task_complete,
            expected=[bool],
            path=path + '.ignoreDevicePlanTaskComplete')  # type: Optional[bool]
    else:
        ignore_device_plan_task_complete_from_obj = None

    obj_ignore_device_reward_create = obj.get('ignoreDeviceRewardCreate', None)
    if obj_ignore_device_reward_create is not None:
        ignore_device_reward_create_from_obj = from_obj(
            obj_ignore_device_reward_create,
            expected=[bool],
            path=path + '.ignoreDeviceRewardCreate')  # type: Optional[bool]
    else:
        ignore_device_reward_create_from_obj = None

    obj_ignore_device_secrets_create = obj.get('ignoreDeviceSecretsCreate', None)
    if obj_ignore_device_secrets_create is not None:
        ignore_device_secrets_create_from_obj = from_obj(
            obj_ignore_device_secrets_create,
            expected=[bool],
            path=path + '.ignoreDeviceSecretsCreate')  # type: Optional[bool]
    else:
        ignore_device_secrets_create_from_obj = None

    obj_ignore_device_shop_create = obj.get('ignoreDeviceShopCreate', None)
    if obj_ignore_device_shop_create is not None:
        ignore_device_shop_create_from_obj = from_obj(
            obj_ignore_device_shop_create,
            expected=[bool],
            path=path + '.ignoreDeviceShopCreate')  # type: Optional[bool]
    else:
        ignore_device_shop_create_from_obj = None

    obj_ignore_email_calendar_event = obj.get('ignoreEmailCalendarEvent', None)
    if obj_ignore_email_calendar_event is not None:
        ignore_email_calendar_event_from_obj = from_obj(
            obj_ignore_email_calendar_event,
            expected=[bool],
            path=path + '.ignoreEmailCalendarEvent')  # type: Optional[bool]
    else:
        ignore_email_calendar_event_from_obj = None

    obj_ignore_email_cook_meal_plan_cook = obj.get('ignoreEmailCookMealPlanCook', None)
    if obj_ignore_email_cook_meal_plan_cook is not None:
        ignore_email_cook_meal_plan_cook_from_obj = from_obj(
            obj_ignore_email_cook_meal_plan_cook,
            expected=[bool],
            path=path + '.ignoreEmailCookMealPlanCook')  # type: Optional[bool]
    else:
        ignore_email_cook_meal_plan_cook_from_obj = None

    obj_ignore_email_cook_meal_plan_leave = obj.get('ignoreEmailCookMealPlanLeave', None)
    if obj_ignore_email_cook_meal_plan_leave is not None:
        ignore_email_cook_meal_plan_leave_from_obj = from_obj(
            obj_ignore_email_cook_meal_plan_leave,
            expected=[bool],
            path=path + '.ignoreEmailCookMealPlanLeave')  # type: Optional[bool]
    else:
        ignore_email_cook_meal_plan_leave_from_obj = None

    obj_ignore_email_cook_meal_plan_prep = obj.get('ignoreEmailCookMealPlanPrep', None)
    if obj_ignore_email_cook_meal_plan_prep is not None:
        ignore_email_cook_meal_plan_prep_from_obj = from_obj(
            obj_ignore_email_cook_meal_plan_prep,
            expected=[bool],
            path=path + '.ignoreEmailCookMealPlanPrep')  # type: Optional[bool]
    else:
        ignore_email_cook_meal_plan_prep_from_obj = None

    obj_ignore_email_plan_task = obj.get('ignoreEmailPlanTask', None)
    if obj_ignore_email_plan_task is not None:
        ignore_email_plan_task_from_obj = from_obj(
            obj_ignore_email_plan_task,
            expected=[bool],
            path=path + '.ignoreEmailPlanTask')  # type: Optional[bool]
    else:
        ignore_email_plan_task_from_obj = None

    return ModelsAuthAccountPreferencesNotificationsHousehold(
        auth_household_id=auth_household_id_from_obj,
        ignore_device_bookmark_create=ignore_device_bookmark_create_from_obj,
        ignore_device_budget_create=ignore_device_budget_create_from_obj,
        ignore_device_calendar_create=ignore_device_calendar_create_from_obj,
        ignore_device_calendar_event=ignore_device_calendar_event_from_obj,
        ignore_device_cook_create=ignore_device_cook_create_from_obj,
        ignore_device_cook_meal_plan_cook=ignore_device_cook_meal_plan_cook_from_obj,
        ignore_device_cook_meal_plan_leave=ignore_device_cook_meal_plan_leave_from_obj,
        ignore_device_cook_meal_plan_prep=ignore_device_cook_meal_plan_prep_from_obj,
        ignore_device_inventory_create=ignore_device_inventory_create_from_obj,
        ignore_device_notes_create=ignore_device_notes_create_from_obj,
        ignore_device_plan_create=ignore_device_plan_create_from_obj,
        ignore_device_plan_task=ignore_device_plan_task_from_obj,
        ignore_device_plan_task_complete=ignore_device_plan_task_complete_from_obj,
        ignore_device_reward_create=ignore_device_reward_create_from_obj,
        ignore_device_secrets_create=ignore_device_secrets_create_from_obj,
        ignore_device_shop_create=ignore_device_shop_create_from_obj,
        ignore_email_calendar_event=ignore_email_calendar_event_from_obj,
        ignore_email_cook_meal_plan_cook=ignore_email_cook_meal_plan_cook_from_obj,
        ignore_email_cook_meal_plan_leave=ignore_email_cook_meal_plan_leave_from_obj,
        ignore_email_cook_meal_plan_prep=ignore_email_cook_meal_plan_prep_from_obj,
        ignore_email_plan_task=ignore_email_plan_task_from_obj)


def models_auth_account_preferences_notifications_household_to_jsonable(
        models_auth_account_preferences_notifications_household: ModelsAuthAccountPreferencesNotificationsHousehold,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthAccountPreferencesNotificationsHousehold.

    :param models_auth_account_preferences_notifications_household: instance of ModelsAuthAccountPreferencesNotificationsHousehold to be JSON-ized
    :param path: path to the models_auth_account_preferences_notifications_household used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_account_preferences_notifications_household.auth_household_id is not None:
        res['authHouseholdID'] = models_auth_account_preferences_notifications_household.auth_household_id

    if models_auth_account_preferences_notifications_household.ignore_device_bookmark_create is not None:
        res['ignoreDeviceBookmarkCreate'] = models_auth_account_preferences_notifications_household.ignore_device_bookmark_create

    if models_auth_account_preferences_notifications_household.ignore_device_budget_create is not None:
        res['ignoreDeviceBudgetCreate'] = models_auth_account_preferences_notifications_household.ignore_device_budget_create

    if models_auth_account_preferences_notifications_household.ignore_device_calendar_create is not None:
        res['ignoreDeviceCalendarCreate'] = models_auth_account_preferences_notifications_household.ignore_device_calendar_create

    if models_auth_account_preferences_notifications_household.ignore_device_calendar_event is not None:
        res['ignoreDeviceCalendarEvent'] = models_auth_account_preferences_notifications_household.ignore_device_calendar_event

    if models_auth_account_preferences_notifications_household.ignore_device_cook_create is not None:
        res['ignoreDeviceCookCreate'] = models_auth_account_preferences_notifications_household.ignore_device_cook_create

    if models_auth_account_preferences_notifications_household.ignore_device_cook_meal_plan_cook is not None:
        res['ignoreDeviceCookMealPlanCook'] = models_auth_account_preferences_notifications_household.ignore_device_cook_meal_plan_cook

    if models_auth_account_preferences_notifications_household.ignore_device_cook_meal_plan_leave is not None:
        res['ignoreDeviceCookMealPlanLeave'] = models_auth_account_preferences_notifications_household.ignore_device_cook_meal_plan_leave

    if models_auth_account_preferences_notifications_household.ignore_device_cook_meal_plan_prep is not None:
        res['ignoreDeviceCookMealPlanPrep'] = models_auth_account_preferences_notifications_household.ignore_device_cook_meal_plan_prep

    if models_auth_account_preferences_notifications_household.ignore_device_inventory_create is not None:
        res['ignoreDeviceInventoryCreate'] = models_auth_account_preferences_notifications_household.ignore_device_inventory_create

    if models_auth_account_preferences_notifications_household.ignore_device_notes_create is not None:
        res['ignoreDeviceNotesCreate'] = models_auth_account_preferences_notifications_household.ignore_device_notes_create

    if models_auth_account_preferences_notifications_household.ignore_device_plan_create is not None:
        res['ignoreDevicePlanCreate'] = models_auth_account_preferences_notifications_household.ignore_device_plan_create

    if models_auth_account_preferences_notifications_household.ignore_device_plan_task is not None:
        res['ignoreDevicePlanTask'] = models_auth_account_preferences_notifications_household.ignore_device_plan_task

    if models_auth_account_preferences_notifications_household.ignore_device_plan_task_complete is not None:
        res['ignoreDevicePlanTaskComplete'] = models_auth_account_preferences_notifications_household.ignore_device_plan_task_complete

    if models_auth_account_preferences_notifications_household.ignore_device_reward_create is not None:
        res['ignoreDeviceRewardCreate'] = models_auth_account_preferences_notifications_household.ignore_device_reward_create

    if models_auth_account_preferences_notifications_household.ignore_device_secrets_create is not None:
        res['ignoreDeviceSecretsCreate'] = models_auth_account_preferences_notifications_household.ignore_device_secrets_create

    if models_auth_account_preferences_notifications_household.ignore_device_shop_create is not None:
        res['ignoreDeviceShopCreate'] = models_auth_account_preferences_notifications_household.ignore_device_shop_create

    if models_auth_account_preferences_notifications_household.ignore_email_calendar_event is not None:
        res['ignoreEmailCalendarEvent'] = models_auth_account_preferences_notifications_household.ignore_email_calendar_event

    if models_auth_account_preferences_notifications_household.ignore_email_cook_meal_plan_cook is not None:
        res['ignoreEmailCookMealPlanCook'] = models_auth_account_preferences_notifications_household.ignore_email_cook_meal_plan_cook

    if models_auth_account_preferences_notifications_household.ignore_email_cook_meal_plan_leave is not None:
        res['ignoreEmailCookMealPlanLeave'] = models_auth_account_preferences_notifications_household.ignore_email_cook_meal_plan_leave

    if models_auth_account_preferences_notifications_household.ignore_email_cook_meal_plan_prep is not None:
        res['ignoreEmailCookMealPlanPrep'] = models_auth_account_preferences_notifications_household.ignore_email_cook_meal_plan_prep

    if models_auth_account_preferences_notifications_household.ignore_email_plan_task is not None:
        res['ignoreEmailPlanTask'] = models_auth_account_preferences_notifications_household.ignore_email_plan_task

    return res


class ModelsAuthAccountPrivateKey:
    def __init__(
            self,
            key: Optional['CryptolibEncryptedValue'] = None,
            name: Optional[str] = None,
            provider: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.key = key

        self.name = name

        self.provider = provider

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_account_private_key_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_account_private_key_to_jsonable(self)


def new_models_auth_account_private_key() -> ModelsAuthAccountPrivateKey:
    """Generates an instance of ModelsAuthAccountPrivateKey with default values."""
    return ModelsAuthAccountPrivateKey()


def models_auth_account_private_key_from_obj(obj: Any, path: str = "") -> ModelsAuthAccountPrivateKey:
    """
    Generates an instance of ModelsAuthAccountPrivateKey from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthAccountPrivateKey
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthAccountPrivateKey
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_key = obj.get('key', None)
    if obj_key is not None:
        key_from_obj = from_obj(
            obj_key,
            expected=[CryptolibEncryptedValue],
            path=path + '.key')  # type: Optional['CryptolibEncryptedValue']
    else:
        key_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_provider = obj.get('provider', None)
    if obj_provider is not None:
        provider_from_obj = from_obj(
            obj_provider,
            expected=[str],
            path=path + '.provider')  # type: Optional[str]
    else:
        provider_from_obj = None

    return ModelsAuthAccountPrivateKey(
        key=key_from_obj,
        name=name_from_obj,
        provider=provider_from_obj)


def models_auth_account_private_key_to_jsonable(
        models_auth_account_private_key: ModelsAuthAccountPrivateKey,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthAccountPrivateKey.

    :param models_auth_account_private_key: instance of ModelsAuthAccountPrivateKey to be JSON-ized
    :param path: path to the models_auth_account_private_key used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_account_private_key.key is not None:
        res['key'] = to_jsonable(
        models_auth_account_private_key.key,
        expected=[CryptolibEncryptedValue],
        path='{}.key'.format(path))

    if models_auth_account_private_key.name is not None:
        res['name'] = models_auth_account_private_key.name

    if models_auth_account_private_key.provider is not None:
        res['provider'] = models_auth_account_private_key.provider

    return res


class ModelsAuthHousehold:
    def __init__(
            self,
            backup_encryption_key: Optional[str] = None,
            count_members: Optional[int] = None,
            created: Optional[str] = None,
            demo: Optional[bool] = None,
            id: Optional[str] = None,
            members: Optional[List['ModelsAuthHouseholdMember']] = None,
            name: Optional[str] = None,
            preferences: Optional['ModelsAuthHouseholdPreferences'] = None,
            self_hosted_id: Optional[str] = None,
            subscription_customer_id: Optional[str] = None,
            subscription_expires: Optional[str] = None,
            subscription_id: Optional[str] = None,
            subscription_last_transaction_id: Optional[str] = None,
            subscription_processor: Optional[int] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.backup_encryption_key = backup_encryption_key

        self.count_members = count_members

        self.created = created

        self.demo = demo

        self.id = id

        self.members = members

        self.name = name

        self.preferences = preferences

        self.self_hosted_id = self_hosted_id

        self.subscription_customer_id = subscription_customer_id

        self.subscription_expires = subscription_expires

        self.subscription_id = subscription_id

        self.subscription_last_transaction_id = subscription_last_transaction_id

        self.subscription_processor = subscription_processor

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_household_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_household_to_jsonable(self)


def new_models_auth_household() -> ModelsAuthHousehold:
    """Generates an instance of ModelsAuthHousehold with default values."""
    return ModelsAuthHousehold()


def models_auth_household_from_obj(obj: Any, path: str = "") -> ModelsAuthHousehold:
    """
    Generates an instance of ModelsAuthHousehold from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthHousehold
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthHousehold
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_backup_encryption_key = obj.get('backupEncryptionKey', None)
    if obj_backup_encryption_key is not None:
        backup_encryption_key_from_obj = from_obj(
            obj_backup_encryption_key,
            expected=[str],
            path=path + '.backupEncryptionKey')  # type: Optional[str]
    else:
        backup_encryption_key_from_obj = None

    obj_count_members = obj.get('countMembers', None)
    if obj_count_members is not None:
        count_members_from_obj = from_obj(
            obj_count_members,
            expected=[int],
            path=path + '.countMembers')  # type: Optional[int]
    else:
        count_members_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_demo = obj.get('demo', None)
    if obj_demo is not None:
        demo_from_obj = from_obj(
            obj_demo,
            expected=[bool],
            path=path + '.demo')  # type: Optional[bool]
    else:
        demo_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_members = obj.get('members', None)
    if obj_members is not None:
        members_from_obj = from_obj(
            obj_members,
            expected=[list, ModelsAuthHouseholdMember],
            path=path + '.members')  # type: Optional[List['ModelsAuthHouseholdMember']]
    else:
        members_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_preferences = obj.get('preferences', None)
    if obj_preferences is not None:
        preferences_from_obj = from_obj(
            obj_preferences,
            expected=[ModelsAuthHouseholdPreferences],
            path=path + '.preferences')  # type: Optional['ModelsAuthHouseholdPreferences']
    else:
        preferences_from_obj = None

    obj_self_hosted_id = obj.get('selfHostedID', None)
    if obj_self_hosted_id is not None:
        self_hosted_id_from_obj = from_obj(
            obj_self_hosted_id,
            expected=[str],
            path=path + '.selfHostedID')  # type: Optional[str]
    else:
        self_hosted_id_from_obj = None

    obj_subscription_customer_id = obj.get('subscriptionCustomerID', None)
    if obj_subscription_customer_id is not None:
        subscription_customer_id_from_obj = from_obj(
            obj_subscription_customer_id,
            expected=[str],
            path=path + '.subscriptionCustomerID')  # type: Optional[str]
    else:
        subscription_customer_id_from_obj = None

    obj_subscription_expires = obj.get('subscriptionExpires', None)
    if obj_subscription_expires is not None:
        subscription_expires_from_obj = from_obj(
            obj_subscription_expires,
            expected=[str],
            path=path + '.subscriptionExpires')  # type: Optional[str]
    else:
        subscription_expires_from_obj = None

    obj_subscription_id = obj.get('subscriptionID', None)
    if obj_subscription_id is not None:
        subscription_id_from_obj = from_obj(
            obj_subscription_id,
            expected=[str],
            path=path + '.subscriptionID')  # type: Optional[str]
    else:
        subscription_id_from_obj = None

    obj_subscription_last_transaction_id = obj.get('subscriptionLastTransactionID', None)
    if obj_subscription_last_transaction_id is not None:
        subscription_last_transaction_id_from_obj = from_obj(
            obj_subscription_last_transaction_id,
            expected=[str],
            path=path + '.subscriptionLastTransactionID')  # type: Optional[str]
    else:
        subscription_last_transaction_id_from_obj = None

    obj_subscription_processor = obj.get('subscriptionProcessor', None)
    if obj_subscription_processor is not None:
        subscription_processor_from_obj = from_obj(
            obj_subscription_processor,
            expected=[int],
            path=path + '.subscriptionProcessor')  # type: Optional[int]
    else:
        subscription_processor_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsAuthHousehold(
        backup_encryption_key=backup_encryption_key_from_obj,
        count_members=count_members_from_obj,
        created=created_from_obj,
        demo=demo_from_obj,
        id=id_from_obj,
        members=members_from_obj,
        name=name_from_obj,
        preferences=preferences_from_obj,
        self_hosted_id=self_hosted_id_from_obj,
        subscription_customer_id=subscription_customer_id_from_obj,
        subscription_expires=subscription_expires_from_obj,
        subscription_id=subscription_id_from_obj,
        subscription_last_transaction_id=subscription_last_transaction_id_from_obj,
        subscription_processor=subscription_processor_from_obj,
        updated=updated_from_obj)


def models_auth_household_to_jsonable(
        models_auth_household: ModelsAuthHousehold,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthHousehold.

    :param models_auth_household: instance of ModelsAuthHousehold to be JSON-ized
    :param path: path to the models_auth_household used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_household.backup_encryption_key is not None:
        res['backupEncryptionKey'] = models_auth_household.backup_encryption_key

    if models_auth_household.count_members is not None:
        res['countMembers'] = models_auth_household.count_members

    if models_auth_household.created is not None:
        res['created'] = models_auth_household.created

    if models_auth_household.demo is not None:
        res['demo'] = models_auth_household.demo

    if models_auth_household.id is not None:
        res['id'] = models_auth_household.id

    if models_auth_household.members is not None:
        res['members'] = to_jsonable(
        models_auth_household.members,
        expected=[list, ModelsAuthHouseholdMember],
        path='{}.members'.format(path))

    if models_auth_household.name is not None:
        res['name'] = models_auth_household.name

    if models_auth_household.preferences is not None:
        res['preferences'] = to_jsonable(
        models_auth_household.preferences,
        expected=[ModelsAuthHouseholdPreferences],
        path='{}.preferences'.format(path))

    if models_auth_household.self_hosted_id is not None:
        res['selfHostedID'] = models_auth_household.self_hosted_id

    if models_auth_household.subscription_customer_id is not None:
        res['subscriptionCustomerID'] = models_auth_household.subscription_customer_id

    if models_auth_household.subscription_expires is not None:
        res['subscriptionExpires'] = models_auth_household.subscription_expires

    if models_auth_household.subscription_id is not None:
        res['subscriptionID'] = models_auth_household.subscription_id

    if models_auth_household.subscription_last_transaction_id is not None:
        res['subscriptionLastTransactionID'] = models_auth_household.subscription_last_transaction_id

    if models_auth_household.subscription_processor is not None:
        res['subscriptionProcessor'] = models_auth_household.subscription_processor

    if models_auth_household.updated is not None:
        res['updated'] = models_auth_household.updated

    return res


class ModelsAuthHouseholdMember:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            color: Optional[str] = None,
            created: Optional[str] = None,
            email_address: Optional[str] = None,
            id: Optional[str] = None,
            invite_token: Optional[str] = None,
            name: Optional[str] = None,
            permissions: Optional['ModelsPermissions'] = None,
            permissions_labels: Optional[Dict[str, int]] = None,
            public_key: Optional['CryptolibKeyCryptolibKeyProviderPublic'] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.color = color

        self.created = created

        self.email_address = email_address

        self.id = id

        self.invite_token = invite_token

        self.name = name

        self.permissions = permissions

        self.permissions_labels = permissions_labels

        self.public_key = public_key

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_household_member_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_household_member_to_jsonable(self)


def new_models_auth_household_member() -> ModelsAuthHouseholdMember:
    """Generates an instance of ModelsAuthHouseholdMember with default values."""
    return ModelsAuthHouseholdMember()


def models_auth_household_member_from_obj(obj: Any, path: str = "") -> ModelsAuthHouseholdMember:
    """
    Generates an instance of ModelsAuthHouseholdMember from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthHouseholdMember
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthHouseholdMember
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_color = obj.get('color', None)
    if obj_color is not None:
        color_from_obj = from_obj(
            obj_color,
            expected=[str],
            path=path + '.color')  # type: Optional[str]
    else:
        color_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_email_address = obj.get('emailAddress', None)
    if obj_email_address is not None:
        email_address_from_obj = from_obj(
            obj_email_address,
            expected=[str],
            path=path + '.emailAddress')  # type: Optional[str]
    else:
        email_address_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_invite_token = obj.get('inviteToken', None)
    if obj_invite_token is not None:
        invite_token_from_obj = from_obj(
            obj_invite_token,
            expected=[str],
            path=path + '.inviteToken')  # type: Optional[str]
    else:
        invite_token_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_permissions = obj.get('permissions', None)
    if obj_permissions is not None:
        permissions_from_obj = from_obj(
            obj_permissions,
            expected=[ModelsPermissions],
            path=path + '.permissions')  # type: Optional['ModelsPermissions']
    else:
        permissions_from_obj = None

    obj_permissions_labels = obj.get('permissionsLabels', None)
    if obj_permissions_labels is not None:
        permissions_labels_from_obj = from_obj(
            obj_permissions_labels,
            expected=[dict, int],
            path=path + '.permissionsLabels')  # type: Optional[Dict[str, int]]
    else:
        permissions_labels_from_obj = None

    obj_public_key = obj.get('publicKey', None)
    if obj_public_key is not None:
        public_key_from_obj = from_obj(
            obj_public_key,
            expected=[CryptolibKeyCryptolibKeyProviderPublic],
            path=path + '.publicKey')  # type: Optional['CryptolibKeyCryptolibKeyProviderPublic']
    else:
        public_key_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsAuthHouseholdMember(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        color=color_from_obj,
        created=created_from_obj,
        email_address=email_address_from_obj,
        id=id_from_obj,
        invite_token=invite_token_from_obj,
        name=name_from_obj,
        permissions=permissions_from_obj,
        permissions_labels=permissions_labels_from_obj,
        public_key=public_key_from_obj,
        updated=updated_from_obj)


def models_auth_household_member_to_jsonable(
        models_auth_household_member: ModelsAuthHouseholdMember,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthHouseholdMember.

    :param models_auth_household_member: instance of ModelsAuthHouseholdMember to be JSON-ized
    :param path: path to the models_auth_household_member used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_household_member.auth_account_id is not None:
        res['authAccountID'] = models_auth_household_member.auth_account_id

    if models_auth_household_member.auth_household_id is not None:
        res['authHouseholdID'] = models_auth_household_member.auth_household_id

    if models_auth_household_member.color is not None:
        res['color'] = models_auth_household_member.color

    if models_auth_household_member.created is not None:
        res['created'] = models_auth_household_member.created

    if models_auth_household_member.email_address is not None:
        res['emailAddress'] = models_auth_household_member.email_address

    if models_auth_household_member.id is not None:
        res['id'] = models_auth_household_member.id

    if models_auth_household_member.invite_token is not None:
        res['inviteToken'] = models_auth_household_member.invite_token

    if models_auth_household_member.name is not None:
        res['name'] = models_auth_household_member.name

    if models_auth_household_member.permissions is not None:
        res['permissions'] = to_jsonable(
        models_auth_household_member.permissions,
        expected=[ModelsPermissions],
        path='{}.permissions'.format(path))

    if models_auth_household_member.permissions_labels is not None:
        res['permissionsLabels'] = to_jsonable(
        models_auth_household_member.permissions_labels,
        expected=[dict, int],
        path='{}.permissionsLabels'.format(path))

    if models_auth_household_member.public_key is not None:
        res['publicKey'] = to_jsonable(
        models_auth_household_member.public_key,
        expected=[CryptolibKeyCryptolibKeyProviderPublic],
        path='{}.publicKey'.format(path))

    if models_auth_household_member.updated is not None:
        res['updated'] = models_auth_household_member.updated

    return res


class ModelsAuthHouseholdPreferences:
    def __init__(
            self,
            color_budget_recurrence_events: Optional[str] = None,
            color_calendar_events: Optional[str] = None,
            color_cook_meal_plan_events: Optional[str] = None,
            color_plan_task_events: Optional[str] = None,
            colors: Optional[List['ModelsColor']] = None,
            currency: Optional[int] = None,
            disable_cloud_a_p_n: Optional[bool] = None,
            hide_components: Optional[List[str]] = None) -> None:
        """Initializes with the given values."""
        self.color_budget_recurrence_events = color_budget_recurrence_events

        self.color_calendar_events = color_calendar_events

        self.color_cook_meal_plan_events = color_cook_meal_plan_events

        self.color_plan_task_events = color_plan_task_events

        self.colors = colors

        self.currency = currency

        self.disable_cloud_a_p_n = disable_cloud_a_p_n

        self.hide_components = hide_components

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_household_preferences_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_household_preferences_to_jsonable(self)


def new_models_auth_household_preferences() -> ModelsAuthHouseholdPreferences:
    """Generates an instance of ModelsAuthHouseholdPreferences with default values."""
    return ModelsAuthHouseholdPreferences()


def models_auth_household_preferences_from_obj(obj: Any, path: str = "") -> ModelsAuthHouseholdPreferences:
    """
    Generates an instance of ModelsAuthHouseholdPreferences from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthHouseholdPreferences
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthHouseholdPreferences
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_color_budget_recurrence_events = obj.get('colorBudgetRecurrenceEvents', None)
    if obj_color_budget_recurrence_events is not None:
        color_budget_recurrence_events_from_obj = from_obj(
            obj_color_budget_recurrence_events,
            expected=[str],
            path=path + '.colorBudgetRecurrenceEvents')  # type: Optional[str]
    else:
        color_budget_recurrence_events_from_obj = None

    obj_color_calendar_events = obj.get('colorCalendarEvents', None)
    if obj_color_calendar_events is not None:
        color_calendar_events_from_obj = from_obj(
            obj_color_calendar_events,
            expected=[str],
            path=path + '.colorCalendarEvents')  # type: Optional[str]
    else:
        color_calendar_events_from_obj = None

    obj_color_cook_meal_plan_events = obj.get('colorCookMealPlanEvents', None)
    if obj_color_cook_meal_plan_events is not None:
        color_cook_meal_plan_events_from_obj = from_obj(
            obj_color_cook_meal_plan_events,
            expected=[str],
            path=path + '.colorCookMealPlanEvents')  # type: Optional[str]
    else:
        color_cook_meal_plan_events_from_obj = None

    obj_color_plan_task_events = obj.get('colorPlanTaskEvents', None)
    if obj_color_plan_task_events is not None:
        color_plan_task_events_from_obj = from_obj(
            obj_color_plan_task_events,
            expected=[str],
            path=path + '.colorPlanTaskEvents')  # type: Optional[str]
    else:
        color_plan_task_events_from_obj = None

    obj_colors = obj.get('colors', None)
    if obj_colors is not None:
        colors_from_obj = from_obj(
            obj_colors,
            expected=[list, ModelsColor],
            path=path + '.colors')  # type: Optional[List['ModelsColor']]
    else:
        colors_from_obj = None

    obj_currency = obj.get('currency', None)
    if obj_currency is not None:
        currency_from_obj = from_obj(
            obj_currency,
            expected=[int],
            path=path + '.currency')  # type: Optional[int]
    else:
        currency_from_obj = None

    obj_disable_cloud_a_p_n = obj.get('disableCloudAPN', None)
    if obj_disable_cloud_a_p_n is not None:
        disable_cloud_a_p_n_from_obj = from_obj(
            obj_disable_cloud_a_p_n,
            expected=[bool],
            path=path + '.disableCloudAPN')  # type: Optional[bool]
    else:
        disable_cloud_a_p_n_from_obj = None

    obj_hide_components = obj.get('hideComponents', None)
    if obj_hide_components is not None:
        hide_components_from_obj = from_obj(
            obj_hide_components,
            expected=[list, str],
            path=path + '.hideComponents')  # type: Optional[List[str]]
    else:
        hide_components_from_obj = None

    return ModelsAuthHouseholdPreferences(
        color_budget_recurrence_events=color_budget_recurrence_events_from_obj,
        color_calendar_events=color_calendar_events_from_obj,
        color_cook_meal_plan_events=color_cook_meal_plan_events_from_obj,
        color_plan_task_events=color_plan_task_events_from_obj,
        colors=colors_from_obj,
        currency=currency_from_obj,
        disable_cloud_a_p_n=disable_cloud_a_p_n_from_obj,
        hide_components=hide_components_from_obj)


def models_auth_household_preferences_to_jsonable(
        models_auth_household_preferences: ModelsAuthHouseholdPreferences,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthHouseholdPreferences.

    :param models_auth_household_preferences: instance of ModelsAuthHouseholdPreferences to be JSON-ized
    :param path: path to the models_auth_household_preferences used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_household_preferences.color_budget_recurrence_events is not None:
        res['colorBudgetRecurrenceEvents'] = models_auth_household_preferences.color_budget_recurrence_events

    if models_auth_household_preferences.color_calendar_events is not None:
        res['colorCalendarEvents'] = models_auth_household_preferences.color_calendar_events

    if models_auth_household_preferences.color_cook_meal_plan_events is not None:
        res['colorCookMealPlanEvents'] = models_auth_household_preferences.color_cook_meal_plan_events

    if models_auth_household_preferences.color_plan_task_events is not None:
        res['colorPlanTaskEvents'] = models_auth_household_preferences.color_plan_task_events

    if models_auth_household_preferences.colors is not None:
        res['colors'] = to_jsonable(
        models_auth_household_preferences.colors,
        expected=[list, ModelsColor],
        path='{}.colors'.format(path))

    if models_auth_household_preferences.currency is not None:
        res['currency'] = models_auth_household_preferences.currency

    if models_auth_household_preferences.disable_cloud_a_p_n is not None:
        res['disableCloudAPN'] = models_auth_household_preferences.disable_cloud_a_p_n

    if models_auth_household_preferences.hide_components is not None:
        res['hideComponents'] = to_jsonable(
        models_auth_household_preferences.hide_components,
        expected=[list, str],
        path='{}.hideComponents'.format(path))

    return res


class ModelsAuthOIDCClient:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            created: Optional[str] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            redirect_u_r_is: Optional[List[str]] = None,
            secret: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.created = created

        self.id = id

        self.name = name

        self.redirect_u_r_is = redirect_u_r_is

        self.secret = secret

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_o_id_c_client_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_o_id_c_client_to_jsonable(self)


def new_models_auth_o_id_c_client() -> ModelsAuthOIDCClient:
    """Generates an instance of ModelsAuthOIDCClient with default values."""
    return ModelsAuthOIDCClient()


def models_auth_o_id_c_client_from_obj(obj: Any, path: str = "") -> ModelsAuthOIDCClient:
    """
    Generates an instance of ModelsAuthOIDCClient from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthOIDCClient
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthOIDCClient
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_redirect_u_r_is = obj.get('redirectURIs', None)
    if obj_redirect_u_r_is is not None:
        redirect_u_r_is_from_obj = from_obj(
            obj_redirect_u_r_is,
            expected=[list, str],
            path=path + '.redirectURIs')  # type: Optional[List[str]]
    else:
        redirect_u_r_is_from_obj = None

    obj_secret = obj.get('secret', None)
    if obj_secret is not None:
        secret_from_obj = from_obj(
            obj_secret,
            expected=[str],
            path=path + '.secret')  # type: Optional[str]
    else:
        secret_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsAuthOIDCClient(
        auth_household_id=auth_household_id_from_obj,
        created=created_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        redirect_u_r_is=redirect_u_r_is_from_obj,
        secret=secret_from_obj,
        updated=updated_from_obj)


def models_auth_o_id_c_client_to_jsonable(
        models_auth_o_id_c_client: ModelsAuthOIDCClient,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthOIDCClient.

    :param models_auth_o_id_c_client: instance of ModelsAuthOIDCClient to be JSON-ized
    :param path: path to the models_auth_o_id_c_client used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_o_id_c_client.auth_household_id is not None:
        res['authHouseholdID'] = models_auth_o_id_c_client.auth_household_id

    if models_auth_o_id_c_client.created is not None:
        res['created'] = models_auth_o_id_c_client.created

    if models_auth_o_id_c_client.id is not None:
        res['id'] = models_auth_o_id_c_client.id

    if models_auth_o_id_c_client.name is not None:
        res['name'] = models_auth_o_id_c_client.name

    if models_auth_o_id_c_client.redirect_u_r_is is not None:
        res['redirectURIs'] = to_jsonable(
        models_auth_o_id_c_client.redirect_u_r_is,
        expected=[list, str],
        path='{}.redirectURIs'.format(path))

    if models_auth_o_id_c_client.secret is not None:
        res['secret'] = models_auth_o_id_c_client.secret

    if models_auth_o_id_c_client.updated is not None:
        res['updated'] = models_auth_o_id_c_client.updated

    return res


class ModelsAuthOIDCCode:
    def __init__(
            self,
            client_id: Optional[str] = None,
            code_challenge: Optional[str] = None,
            redirect_u_r_i: Optional[str] = None,
            scopes: Optional[List[str]] = None,
            state: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.client_id = client_id

        self.code_challenge = code_challenge

        self.redirect_u_r_i = redirect_u_r_i

        self.scopes = scopes

        self.state = state

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_o_id_c_code_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_o_id_c_code_to_jsonable(self)


def new_models_auth_o_id_c_code() -> ModelsAuthOIDCCode:
    """Generates an instance of ModelsAuthOIDCCode with default values."""
    return ModelsAuthOIDCCode()


def models_auth_o_id_c_code_from_obj(obj: Any, path: str = "") -> ModelsAuthOIDCCode:
    """
    Generates an instance of ModelsAuthOIDCCode from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthOIDCCode
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthOIDCCode
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_client_id = obj.get('clientID', None)
    if obj_client_id is not None:
        client_id_from_obj = from_obj(
            obj_client_id,
            expected=[str],
            path=path + '.clientID')  # type: Optional[str]
    else:
        client_id_from_obj = None

    obj_code_challenge = obj.get('codeChallenge', None)
    if obj_code_challenge is not None:
        code_challenge_from_obj = from_obj(
            obj_code_challenge,
            expected=[str],
            path=path + '.codeChallenge')  # type: Optional[str]
    else:
        code_challenge_from_obj = None

    obj_redirect_u_r_i = obj.get('redirectURI', None)
    if obj_redirect_u_r_i is not None:
        redirect_u_r_i_from_obj = from_obj(
            obj_redirect_u_r_i,
            expected=[str],
            path=path + '.redirectURI')  # type: Optional[str]
    else:
        redirect_u_r_i_from_obj = None

    obj_scopes = obj.get('scopes', None)
    if obj_scopes is not None:
        scopes_from_obj = from_obj(
            obj_scopes,
            expected=[list, str],
            path=path + '.scopes')  # type: Optional[List[str]]
    else:
        scopes_from_obj = None

    obj_state = obj.get('state', None)
    if obj_state is not None:
        state_from_obj = from_obj(
            obj_state,
            expected=[str],
            path=path + '.state')  # type: Optional[str]
    else:
        state_from_obj = None

    return ModelsAuthOIDCCode(
        client_id=client_id_from_obj,
        code_challenge=code_challenge_from_obj,
        redirect_u_r_i=redirect_u_r_i_from_obj,
        scopes=scopes_from_obj,
        state=state_from_obj)


def models_auth_o_id_c_code_to_jsonable(
        models_auth_o_id_c_code: ModelsAuthOIDCCode,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthOIDCCode.

    :param models_auth_o_id_c_code: instance of ModelsAuthOIDCCode to be JSON-ized
    :param path: path to the models_auth_o_id_c_code used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_o_id_c_code.client_id is not None:
        res['clientID'] = models_auth_o_id_c_code.client_id

    if models_auth_o_id_c_code.code_challenge is not None:
        res['codeChallenge'] = models_auth_o_id_c_code.code_challenge

    if models_auth_o_id_c_code.redirect_u_r_i is not None:
        res['redirectURI'] = models_auth_o_id_c_code.redirect_u_r_i

    if models_auth_o_id_c_code.scopes is not None:
        res['scopes'] = to_jsonable(
        models_auth_o_id_c_code.scopes,
        expected=[list, str],
        path='{}.scopes'.format(path))

    if models_auth_o_id_c_code.state is not None:
        res['state'] = models_auth_o_id_c_code.state

    return res


class ModelsAuthSession:
    def __init__(
            self,
            admin: Optional[bool] = None,
            auth_account_id: Optional[str] = None,
            auth_households_permissions: Optional[Dict[str, 'ModelsPermissions']] = None,
            auth_households_permissions_labels: Optional[Dict[str, Dict[str, int]]] = None,
            created: Optional[str] = None,
            delegations: Optional[List['ModelsAuthAccountDelegation']] = None,
            expires: Optional[str] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            notify_a_p_n: Optional[str] = None,
            notify_web_push: Optional['NotifyWebPushClient'] = None,
            permissions_account: Optional['ModelsPermissions'] = None,
            permissions_households: Optional[Dict[str, 'ModelsPermissions']] = None,
            primary_auth_household_id: Optional[str] = None,
            token: Optional[str] = None,
            user_agent: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.admin = admin

        self.auth_account_id = auth_account_id

        self.auth_households_permissions = auth_households_permissions

        self.auth_households_permissions_labels = auth_households_permissions_labels

        self.created = created

        self.delegations = delegations

        self.expires = expires

        self.id = id

        self.name = name

        self.notify_a_p_n = notify_a_p_n

        self.notify_web_push = notify_web_push

        self.permissions_account = permissions_account

        self.permissions_households = permissions_households

        self.primary_auth_household_id = primary_auth_household_id

        self.token = token

        self.user_agent = user_agent

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_auth_session_to_jsonable.

        :return: JSON-able representation
        """
        return models_auth_session_to_jsonable(self)


def new_models_auth_session() -> ModelsAuthSession:
    """Generates an instance of ModelsAuthSession with default values."""
    return ModelsAuthSession()


def models_auth_session_from_obj(obj: Any, path: str = "") -> ModelsAuthSession:
    """
    Generates an instance of ModelsAuthSession from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsAuthSession
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsAuthSession
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_admin = obj.get('admin', None)
    if obj_admin is not None:
        admin_from_obj = from_obj(
            obj_admin,
            expected=[bool],
            path=path + '.admin')  # type: Optional[bool]
    else:
        admin_from_obj = None

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_households_permissions = obj.get('authHouseholdsPermissions', None)
    if obj_auth_households_permissions is not None:
        auth_households_permissions_from_obj = from_obj(
            obj_auth_households_permissions,
            expected=[dict, ModelsPermissions],
            path=path + '.authHouseholdsPermissions')  # type: Optional[Dict[str, 'ModelsPermissions']]
    else:
        auth_households_permissions_from_obj = None

    obj_auth_households_permissions_labels = obj.get('authHouseholdsPermissionsLabels', None)
    if obj_auth_households_permissions_labels is not None:
        auth_households_permissions_labels_from_obj = from_obj(
            obj_auth_households_permissions_labels,
            expected=[dict, dict, int],
            path=path + '.authHouseholdsPermissionsLabels')  # type: Optional[Dict[str, Dict[str, int]]]
    else:
        auth_households_permissions_labels_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_delegations = obj.get('delegations', None)
    if obj_delegations is not None:
        delegations_from_obj = from_obj(
            obj_delegations,
            expected=[list, ModelsAuthAccountDelegation],
            path=path + '.delegations')  # type: Optional[List['ModelsAuthAccountDelegation']]
    else:
        delegations_from_obj = None

    obj_expires = obj.get('expires', None)
    if obj_expires is not None:
        expires_from_obj = from_obj(
            obj_expires,
            expected=[str],
            path=path + '.expires')  # type: Optional[str]
    else:
        expires_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_notify_a_p_n = obj.get('notifyAPN', None)
    if obj_notify_a_p_n is not None:
        notify_a_p_n_from_obj = from_obj(
            obj_notify_a_p_n,
            expected=[str],
            path=path + '.notifyAPN')  # type: Optional[str]
    else:
        notify_a_p_n_from_obj = None

    obj_notify_web_push = obj.get('notifyWebPush', None)
    if obj_notify_web_push is not None:
        notify_web_push_from_obj = from_obj(
            obj_notify_web_push,
            expected=[NotifyWebPushClient],
            path=path + '.notifyWebPush')  # type: Optional['NotifyWebPushClient']
    else:
        notify_web_push_from_obj = None

    obj_permissions_account = obj.get('permissionsAccount', None)
    if obj_permissions_account is not None:
        permissions_account_from_obj = from_obj(
            obj_permissions_account,
            expected=[ModelsPermissions],
            path=path + '.permissionsAccount')  # type: Optional['ModelsPermissions']
    else:
        permissions_account_from_obj = None

    obj_permissions_households = obj.get('permissionsHouseholds', None)
    if obj_permissions_households is not None:
        permissions_households_from_obj = from_obj(
            obj_permissions_households,
            expected=[dict, ModelsPermissions],
            path=path + '.permissionsHouseholds')  # type: Optional[Dict[str, 'ModelsPermissions']]
    else:
        permissions_households_from_obj = None

    obj_primary_auth_household_id = obj.get('primaryAuthHouseholdID', None)
    if obj_primary_auth_household_id is not None:
        primary_auth_household_id_from_obj = from_obj(
            obj_primary_auth_household_id,
            expected=[str],
            path=path + '.primaryAuthHouseholdID')  # type: Optional[str]
    else:
        primary_auth_household_id_from_obj = None

    obj_token = obj.get('token', None)
    if obj_token is not None:
        token_from_obj = from_obj(
            obj_token,
            expected=[str],
            path=path + '.token')  # type: Optional[str]
    else:
        token_from_obj = None

    obj_user_agent = obj.get('userAgent', None)
    if obj_user_agent is not None:
        user_agent_from_obj = from_obj(
            obj_user_agent,
            expected=[str],
            path=path + '.userAgent')  # type: Optional[str]
    else:
        user_agent_from_obj = None

    return ModelsAuthSession(
        admin=admin_from_obj,
        auth_account_id=auth_account_id_from_obj,
        auth_households_permissions=auth_households_permissions_from_obj,
        auth_households_permissions_labels=auth_households_permissions_labels_from_obj,
        created=created_from_obj,
        delegations=delegations_from_obj,
        expires=expires_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        notify_a_p_n=notify_a_p_n_from_obj,
        notify_web_push=notify_web_push_from_obj,
        permissions_account=permissions_account_from_obj,
        permissions_households=permissions_households_from_obj,
        primary_auth_household_id=primary_auth_household_id_from_obj,
        token=token_from_obj,
        user_agent=user_agent_from_obj)


def models_auth_session_to_jsonable(
        models_auth_session: ModelsAuthSession,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsAuthSession.

    :param models_auth_session: instance of ModelsAuthSession to be JSON-ized
    :param path: path to the models_auth_session used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_auth_session.admin is not None:
        res['admin'] = models_auth_session.admin

    if models_auth_session.auth_account_id is not None:
        res['authAccountID'] = models_auth_session.auth_account_id

    if models_auth_session.auth_households_permissions is not None:
        res['authHouseholdsPermissions'] = to_jsonable(
        models_auth_session.auth_households_permissions,
        expected=[dict, ModelsPermissions],
        path='{}.authHouseholdsPermissions'.format(path))

    if models_auth_session.auth_households_permissions_labels is not None:
        res['authHouseholdsPermissionsLabels'] = to_jsonable(
        models_auth_session.auth_households_permissions_labels,
        expected=[dict, dict, int],
        path='{}.authHouseholdsPermissionsLabels'.format(path))

    if models_auth_session.created is not None:
        res['created'] = models_auth_session.created

    if models_auth_session.delegations is not None:
        res['delegations'] = to_jsonable(
        models_auth_session.delegations,
        expected=[list, ModelsAuthAccountDelegation],
        path='{}.delegations'.format(path))

    if models_auth_session.expires is not None:
        res['expires'] = models_auth_session.expires

    if models_auth_session.id is not None:
        res['id'] = models_auth_session.id

    if models_auth_session.name is not None:
        res['name'] = models_auth_session.name

    if models_auth_session.notify_a_p_n is not None:
        res['notifyAPN'] = models_auth_session.notify_a_p_n

    if models_auth_session.notify_web_push is not None:
        res['notifyWebPush'] = to_jsonable(
        models_auth_session.notify_web_push,
        expected=[NotifyWebPushClient],
        path='{}.notifyWebPush'.format(path))

    if models_auth_session.permissions_account is not None:
        res['permissionsAccount'] = to_jsonable(
        models_auth_session.permissions_account,
        expected=[ModelsPermissions],
        path='{}.permissionsAccount'.format(path))

    if models_auth_session.permissions_households is not None:
        res['permissionsHouseholds'] = to_jsonable(
        models_auth_session.permissions_households,
        expected=[dict, ModelsPermissions],
        path='{}.permissionsHouseholds'.format(path))

    if models_auth_session.primary_auth_household_id is not None:
        res['primaryAuthHouseholdID'] = models_auth_session.primary_auth_household_id

    if models_auth_session.token is not None:
        res['token'] = models_auth_session.token

    if models_auth_session.user_agent is not None:
        res['userAgent'] = models_auth_session.user_agent

    return res


class ModelsBookmark:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            created: Optional[str] = None,
            home: Optional[bool] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            link: Optional[str] = None,
            name: Optional[str] = None,
            new_window: Optional[bool] = None,
            short_id: Optional[str] = None,
            tags: Optional[List[str]] = None,
            updated: Optional[str] = None,
            updated_by: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.created = created

        self.home = home

        self.icon = icon

        self.id = id

        self.labels_values_ids = labels_values_ids

        self.link = link

        self.name = name

        self.new_window = new_window

        self.short_id = short_id

        self.tags = tags

        self.updated = updated

        self.updated_by = updated_by

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_bookmark_to_jsonable.

        :return: JSON-able representation
        """
        return models_bookmark_to_jsonable(self)


def new_models_bookmark() -> ModelsBookmark:
    """Generates an instance of ModelsBookmark with default values."""
    return ModelsBookmark()


def models_bookmark_from_obj(obj: Any, path: str = "") -> ModelsBookmark:
    """
    Generates an instance of ModelsBookmark from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBookmark
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBookmark
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_home = obj.get('home', None)
    if obj_home is not None:
        home_from_obj = from_obj(
            obj_home,
            expected=[bool],
            path=path + '.home')  # type: Optional[bool]
    else:
        home_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_link = obj.get('link', None)
    if obj_link is not None:
        link_from_obj = from_obj(
            obj_link,
            expected=[str],
            path=path + '.link')  # type: Optional[str]
    else:
        link_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_new_window = obj.get('newWindow', None)
    if obj_new_window is not None:
        new_window_from_obj = from_obj(
            obj_new_window,
            expected=[bool],
            path=path + '.newWindow')  # type: Optional[bool]
    else:
        new_window_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_tags = obj.get('tags', None)
    if obj_tags is not None:
        tags_from_obj = from_obj(
            obj_tags,
            expected=[list, str],
            path=path + '.tags')  # type: Optional[List[str]]
    else:
        tags_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    obj_updated_by = obj.get('updatedBy', None)
    if obj_updated_by is not None:
        updated_by_from_obj = from_obj(
            obj_updated_by,
            expected=[str],
            path=path + '.updatedBy')  # type: Optional[str]
    else:
        updated_by_from_obj = None

    return ModelsBookmark(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        created=created_from_obj,
        home=home_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        link=link_from_obj,
        name=name_from_obj,
        new_window=new_window_from_obj,
        short_id=short_id_from_obj,
        tags=tags_from_obj,
        updated=updated_from_obj,
        updated_by=updated_by_from_obj)


def models_bookmark_to_jsonable(
        models_bookmark: ModelsBookmark,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBookmark.

    :param models_bookmark: instance of ModelsBookmark to be JSON-ized
    :param path: path to the models_bookmark used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_bookmark.auth_account_id is not None:
        res['authAccountID'] = models_bookmark.auth_account_id

    if models_bookmark.auth_household_id is not None:
        res['authHouseholdID'] = models_bookmark.auth_household_id

    if models_bookmark.created is not None:
        res['created'] = models_bookmark.created

    if models_bookmark.home is not None:
        res['home'] = models_bookmark.home

    if models_bookmark.icon is not None:
        res['icon'] = models_bookmark.icon

    if models_bookmark.id is not None:
        res['id'] = models_bookmark.id

    if models_bookmark.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_bookmark.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_bookmark.link is not None:
        res['link'] = models_bookmark.link

    if models_bookmark.name is not None:
        res['name'] = models_bookmark.name

    if models_bookmark.new_window is not None:
        res['newWindow'] = models_bookmark.new_window

    if models_bookmark.short_id is not None:
        res['shortID'] = models_bookmark.short_id

    if models_bookmark.tags is not None:
        res['tags'] = to_jsonable(
        models_bookmark.tags,
        expected=[list, str],
        path='{}.tags'.format(path))

    if models_bookmark.updated is not None:
        res['updated'] = models_bookmark.updated

    if models_bookmark.updated_by is not None:
        res['updatedBy'] = models_bookmark.updated_by

    return res


class ModelsBudgetAccount:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            budget: Optional[bool] = None,
            budget_transaction_amount: Optional[int] = None,
            budget_transaction_amount_cleared: Optional[int] = None,
            budget_transaction_amount_reconciled: Optional[int] = None,
            created: Optional[str] = None,
            hidden: Optional[bool] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            name: Optional[str] = None,
            short_id: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.budget = budget

        self.budget_transaction_amount = budget_transaction_amount

        self.budget_transaction_amount_cleared = budget_transaction_amount_cleared

        self.budget_transaction_amount_reconciled = budget_transaction_amount_reconciled

        self.created = created

        self.hidden = hidden

        self.icon = icon

        self.id = id

        self.labels_values_ids = labels_values_ids

        self.name = name

        self.short_id = short_id

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_account_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_account_to_jsonable(self)


def new_models_budget_account() -> ModelsBudgetAccount:
    """Generates an instance of ModelsBudgetAccount with default values."""
    return ModelsBudgetAccount()


def models_budget_account_from_obj(obj: Any, path: str = "") -> ModelsBudgetAccount:
    """
    Generates an instance of ModelsBudgetAccount from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetAccount
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetAccount
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget = obj.get('budget', None)
    if obj_budget is not None:
        budget_from_obj = from_obj(
            obj_budget,
            expected=[bool],
            path=path + '.budget')  # type: Optional[bool]
    else:
        budget_from_obj = None

    obj_budget_transaction_amount = obj.get('budgetTransactionAmount', None)
    if obj_budget_transaction_amount is not None:
        budget_transaction_amount_from_obj = from_obj(
            obj_budget_transaction_amount,
            expected=[int],
            path=path + '.budgetTransactionAmount')  # type: Optional[int]
    else:
        budget_transaction_amount_from_obj = None

    obj_budget_transaction_amount_cleared = obj.get('budgetTransactionAmountCleared', None)
    if obj_budget_transaction_amount_cleared is not None:
        budget_transaction_amount_cleared_from_obj = from_obj(
            obj_budget_transaction_amount_cleared,
            expected=[int],
            path=path + '.budgetTransactionAmountCleared')  # type: Optional[int]
    else:
        budget_transaction_amount_cleared_from_obj = None

    obj_budget_transaction_amount_reconciled = obj.get('budgetTransactionAmountReconciled', None)
    if obj_budget_transaction_amount_reconciled is not None:
        budget_transaction_amount_reconciled_from_obj = from_obj(
            obj_budget_transaction_amount_reconciled,
            expected=[int],
            path=path + '.budgetTransactionAmountReconciled')  # type: Optional[int]
    else:
        budget_transaction_amount_reconciled_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_hidden = obj.get('hidden', None)
    if obj_hidden is not None:
        hidden_from_obj = from_obj(
            obj_hidden,
            expected=[bool],
            path=path + '.hidden')  # type: Optional[bool]
    else:
        hidden_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsBudgetAccount(
        auth_household_id=auth_household_id_from_obj,
        budget=budget_from_obj,
        budget_transaction_amount=budget_transaction_amount_from_obj,
        budget_transaction_amount_cleared=budget_transaction_amount_cleared_from_obj,
        budget_transaction_amount_reconciled=budget_transaction_amount_reconciled_from_obj,
        created=created_from_obj,
        hidden=hidden_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        name=name_from_obj,
        short_id=short_id_from_obj,
        updated=updated_from_obj)


def models_budget_account_to_jsonable(
        models_budget_account: ModelsBudgetAccount,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetAccount.

    :param models_budget_account: instance of ModelsBudgetAccount to be JSON-ized
    :param path: path to the models_budget_account used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_account.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_account.auth_household_id

    if models_budget_account.budget is not None:
        res['budget'] = models_budget_account.budget

    if models_budget_account.budget_transaction_amount is not None:
        res['budgetTransactionAmount'] = models_budget_account.budget_transaction_amount

    if models_budget_account.budget_transaction_amount_cleared is not None:
        res['budgetTransactionAmountCleared'] = models_budget_account.budget_transaction_amount_cleared

    if models_budget_account.budget_transaction_amount_reconciled is not None:
        res['budgetTransactionAmountReconciled'] = models_budget_account.budget_transaction_amount_reconciled

    if models_budget_account.created is not None:
        res['created'] = models_budget_account.created

    if models_budget_account.hidden is not None:
        res['hidden'] = models_budget_account.hidden

    if models_budget_account.icon is not None:
        res['icon'] = models_budget_account.icon

    if models_budget_account.id is not None:
        res['id'] = models_budget_account.id

    if models_budget_account.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_budget_account.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_budget_account.name is not None:
        res['name'] = models_budget_account.name

    if models_budget_account.short_id is not None:
        res['shortID'] = models_budget_account.short_id

    if models_budget_account.updated is not None:
        res['updated'] = models_budget_account.updated

    return res


class ModelsBudgetCategory:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            budget_month_category_amount: Optional[int] = None,
            budget_transaction_amount: Optional[int] = None,
            created: Optional[str] = None,
            grouping: Optional[str] = None,
            id: Optional[str] = None,
            income: Optional[bool] = None,
            labels_values_ids: Optional[List[str]] = None,
            name: Optional[str] = None,
            short_id: Optional[str] = None,
            target_amount: Optional[int] = None,
            target_month: Optional[int] = None,
            target_monthly_limit: Optional[int] = None,
            target_year: Optional[int] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.budget_month_category_amount = budget_month_category_amount

        self.budget_transaction_amount = budget_transaction_amount

        self.created = created

        self.grouping = grouping

        self.id = id

        self.income = income

        self.labels_values_ids = labels_values_ids

        self.name = name

        self.short_id = short_id

        self.target_amount = target_amount

        self.target_month = target_month

        self.target_monthly_limit = target_monthly_limit

        self.target_year = target_year

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_category_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_category_to_jsonable(self)


def new_models_budget_category() -> ModelsBudgetCategory:
    """Generates an instance of ModelsBudgetCategory with default values."""
    return ModelsBudgetCategory()


def models_budget_category_from_obj(obj: Any, path: str = "") -> ModelsBudgetCategory:
    """
    Generates an instance of ModelsBudgetCategory from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetCategory
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetCategory
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_month_category_amount = obj.get('budgetMonthCategoryAmount', None)
    if obj_budget_month_category_amount is not None:
        budget_month_category_amount_from_obj = from_obj(
            obj_budget_month_category_amount,
            expected=[int],
            path=path + '.budgetMonthCategoryAmount')  # type: Optional[int]
    else:
        budget_month_category_amount_from_obj = None

    obj_budget_transaction_amount = obj.get('budgetTransactionAmount', None)
    if obj_budget_transaction_amount is not None:
        budget_transaction_amount_from_obj = from_obj(
            obj_budget_transaction_amount,
            expected=[int],
            path=path + '.budgetTransactionAmount')  # type: Optional[int]
    else:
        budget_transaction_amount_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_grouping = obj.get('grouping', None)
    if obj_grouping is not None:
        grouping_from_obj = from_obj(
            obj_grouping,
            expected=[str],
            path=path + '.grouping')  # type: Optional[str]
    else:
        grouping_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_income = obj.get('income', None)
    if obj_income is not None:
        income_from_obj = from_obj(
            obj_income,
            expected=[bool],
            path=path + '.income')  # type: Optional[bool]
    else:
        income_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_target_amount = obj.get('targetAmount', None)
    if obj_target_amount is not None:
        target_amount_from_obj = from_obj(
            obj_target_amount,
            expected=[int],
            path=path + '.targetAmount')  # type: Optional[int]
    else:
        target_amount_from_obj = None

    obj_target_month = obj.get('targetMonth', None)
    if obj_target_month is not None:
        target_month_from_obj = from_obj(
            obj_target_month,
            expected=[int],
            path=path + '.targetMonth')  # type: Optional[int]
    else:
        target_month_from_obj = None

    obj_target_monthly_limit = obj.get('targetMonthlyLimit', None)
    if obj_target_monthly_limit is not None:
        target_monthly_limit_from_obj = from_obj(
            obj_target_monthly_limit,
            expected=[int],
            path=path + '.targetMonthlyLimit')  # type: Optional[int]
    else:
        target_monthly_limit_from_obj = None

    obj_target_year = obj.get('targetYear', None)
    if obj_target_year is not None:
        target_year_from_obj = from_obj(
            obj_target_year,
            expected=[int],
            path=path + '.targetYear')  # type: Optional[int]
    else:
        target_year_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsBudgetCategory(
        auth_household_id=auth_household_id_from_obj,
        budget_month_category_amount=budget_month_category_amount_from_obj,
        budget_transaction_amount=budget_transaction_amount_from_obj,
        created=created_from_obj,
        grouping=grouping_from_obj,
        id=id_from_obj,
        income=income_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        name=name_from_obj,
        short_id=short_id_from_obj,
        target_amount=target_amount_from_obj,
        target_month=target_month_from_obj,
        target_monthly_limit=target_monthly_limit_from_obj,
        target_year=target_year_from_obj,
        updated=updated_from_obj)


def models_budget_category_to_jsonable(
        models_budget_category: ModelsBudgetCategory,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetCategory.

    :param models_budget_category: instance of ModelsBudgetCategory to be JSON-ized
    :param path: path to the models_budget_category used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_category.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_category.auth_household_id

    if models_budget_category.budget_month_category_amount is not None:
        res['budgetMonthCategoryAmount'] = models_budget_category.budget_month_category_amount

    if models_budget_category.budget_transaction_amount is not None:
        res['budgetTransactionAmount'] = models_budget_category.budget_transaction_amount

    if models_budget_category.created is not None:
        res['created'] = models_budget_category.created

    if models_budget_category.grouping is not None:
        res['grouping'] = models_budget_category.grouping

    if models_budget_category.id is not None:
        res['id'] = models_budget_category.id

    if models_budget_category.income is not None:
        res['income'] = models_budget_category.income

    if models_budget_category.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_budget_category.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_budget_category.name is not None:
        res['name'] = models_budget_category.name

    if models_budget_category.short_id is not None:
        res['shortID'] = models_budget_category.short_id

    if models_budget_category.target_amount is not None:
        res['targetAmount'] = models_budget_category.target_amount

    if models_budget_category.target_month is not None:
        res['targetMonth'] = models_budget_category.target_month

    if models_budget_category.target_monthly_limit is not None:
        res['targetMonthlyLimit'] = models_budget_category.target_monthly_limit

    if models_budget_category.target_year is not None:
        res['targetYear'] = models_budget_category.target_year

    if models_budget_category.updated is not None:
        res['updated'] = models_budget_category.updated

    return res


class ModelsBudgetMonth:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            budget_month_categories: Optional[List['ModelsBudgetMonthCategory']] = None,
            budget_month_category_amount: Optional[int] = None,
            budget_transaction_amount_income: Optional[int] = None,
            budget_transaction_amount_income_remaining: Optional[int] = None,
            year_month: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.budget_month_categories = budget_month_categories

        self.budget_month_category_amount = budget_month_category_amount

        self.budget_transaction_amount_income = budget_transaction_amount_income

        self.budget_transaction_amount_income_remaining = budget_transaction_amount_income_remaining

        self.year_month = year_month

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_month_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_month_to_jsonable(self)


def new_models_budget_month() -> ModelsBudgetMonth:
    """Generates an instance of ModelsBudgetMonth with default values."""
    return ModelsBudgetMonth()


def models_budget_month_from_obj(obj: Any, path: str = "") -> ModelsBudgetMonth:
    """
    Generates an instance of ModelsBudgetMonth from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetMonth
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetMonth
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_month_categories = obj.get('budgetMonthCategories', None)
    if obj_budget_month_categories is not None:
        budget_month_categories_from_obj = from_obj(
            obj_budget_month_categories,
            expected=[list, ModelsBudgetMonthCategory],
            path=path + '.budgetMonthCategories')  # type: Optional[List['ModelsBudgetMonthCategory']]
    else:
        budget_month_categories_from_obj = None

    obj_budget_month_category_amount = obj.get('budgetMonthCategoryAmount', None)
    if obj_budget_month_category_amount is not None:
        budget_month_category_amount_from_obj = from_obj(
            obj_budget_month_category_amount,
            expected=[int],
            path=path + '.budgetMonthCategoryAmount')  # type: Optional[int]
    else:
        budget_month_category_amount_from_obj = None

    obj_budget_transaction_amount_income = obj.get('budgetTransactionAmountIncome', None)
    if obj_budget_transaction_amount_income is not None:
        budget_transaction_amount_income_from_obj = from_obj(
            obj_budget_transaction_amount_income,
            expected=[int],
            path=path + '.budgetTransactionAmountIncome')  # type: Optional[int]
    else:
        budget_transaction_amount_income_from_obj = None

    obj_budget_transaction_amount_income_remaining = obj.get('budgetTransactionAmountIncomeRemaining', None)
    if obj_budget_transaction_amount_income_remaining is not None:
        budget_transaction_amount_income_remaining_from_obj = from_obj(
            obj_budget_transaction_amount_income_remaining,
            expected=[int],
            path=path + '.budgetTransactionAmountIncomeRemaining')  # type: Optional[int]
    else:
        budget_transaction_amount_income_remaining_from_obj = None

    obj_year_month = obj.get('yearMonth', None)
    if obj_year_month is not None:
        year_month_from_obj = from_obj(
            obj_year_month,
            expected=[int],
            path=path + '.yearMonth')  # type: Optional[int]
    else:
        year_month_from_obj = None

    return ModelsBudgetMonth(
        auth_household_id=auth_household_id_from_obj,
        budget_month_categories=budget_month_categories_from_obj,
        budget_month_category_amount=budget_month_category_amount_from_obj,
        budget_transaction_amount_income=budget_transaction_amount_income_from_obj,
        budget_transaction_amount_income_remaining=budget_transaction_amount_income_remaining_from_obj,
        year_month=year_month_from_obj)


def models_budget_month_to_jsonable(
        models_budget_month: ModelsBudgetMonth,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetMonth.

    :param models_budget_month: instance of ModelsBudgetMonth to be JSON-ized
    :param path: path to the models_budget_month used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_month.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_month.auth_household_id

    if models_budget_month.budget_month_categories is not None:
        res['budgetMonthCategories'] = to_jsonable(
        models_budget_month.budget_month_categories,
        expected=[list, ModelsBudgetMonthCategory],
        path='{}.budgetMonthCategories'.format(path))

    if models_budget_month.budget_month_category_amount is not None:
        res['budgetMonthCategoryAmount'] = models_budget_month.budget_month_category_amount

    if models_budget_month.budget_transaction_amount_income is not None:
        res['budgetTransactionAmountIncome'] = models_budget_month.budget_transaction_amount_income

    if models_budget_month.budget_transaction_amount_income_remaining is not None:
        res['budgetTransactionAmountIncomeRemaining'] = models_budget_month.budget_transaction_amount_income_remaining

    if models_budget_month.year_month is not None:
        res['yearMonth'] = models_budget_month.year_month

    return res


class ModelsBudgetMonthCategory:
    def __init__(
            self,
            amount: Optional[int] = None,
            auth_household_id: Optional[str] = None,
            balance: Optional[int] = None,
            budget_category_id: Optional[str] = None,
            budget_transaction_amount: Optional[int] = None,
            created: Optional[str] = None,
            year_month: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.amount = amount

        self.auth_household_id = auth_household_id

        self.balance = balance

        self.budget_category_id = budget_category_id

        self.budget_transaction_amount = budget_transaction_amount

        self.created = created

        self.year_month = year_month

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_month_category_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_month_category_to_jsonable(self)


def new_models_budget_month_category() -> ModelsBudgetMonthCategory:
    """Generates an instance of ModelsBudgetMonthCategory with default values."""
    return ModelsBudgetMonthCategory()


def models_budget_month_category_from_obj(obj: Any, path: str = "") -> ModelsBudgetMonthCategory:
    """
    Generates an instance of ModelsBudgetMonthCategory from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetMonthCategory
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetMonthCategory
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_amount = obj.get('amount', None)
    if obj_amount is not None:
        amount_from_obj = from_obj(
            obj_amount,
            expected=[int],
            path=path + '.amount')  # type: Optional[int]
    else:
        amount_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_balance = obj.get('balance', None)
    if obj_balance is not None:
        balance_from_obj = from_obj(
            obj_balance,
            expected=[int],
            path=path + '.balance')  # type: Optional[int]
    else:
        balance_from_obj = None

    obj_budget_category_id = obj.get('budgetCategoryID', None)
    if obj_budget_category_id is not None:
        budget_category_id_from_obj = from_obj(
            obj_budget_category_id,
            expected=[str],
            path=path + '.budgetCategoryID')  # type: Optional[str]
    else:
        budget_category_id_from_obj = None

    obj_budget_transaction_amount = obj.get('budgetTransactionAmount', None)
    if obj_budget_transaction_amount is not None:
        budget_transaction_amount_from_obj = from_obj(
            obj_budget_transaction_amount,
            expected=[int],
            path=path + '.budgetTransactionAmount')  # type: Optional[int]
    else:
        budget_transaction_amount_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_year_month = obj.get('yearMonth', None)
    if obj_year_month is not None:
        year_month_from_obj = from_obj(
            obj_year_month,
            expected=[int],
            path=path + '.yearMonth')  # type: Optional[int]
    else:
        year_month_from_obj = None

    return ModelsBudgetMonthCategory(
        amount=amount_from_obj,
        auth_household_id=auth_household_id_from_obj,
        balance=balance_from_obj,
        budget_category_id=budget_category_id_from_obj,
        budget_transaction_amount=budget_transaction_amount_from_obj,
        created=created_from_obj,
        year_month=year_month_from_obj)


def models_budget_month_category_to_jsonable(
        models_budget_month_category: ModelsBudgetMonthCategory,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetMonthCategory.

    :param models_budget_month_category: instance of ModelsBudgetMonthCategory to be JSON-ized
    :param path: path to the models_budget_month_category used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_month_category.amount is not None:
        res['amount'] = models_budget_month_category.amount

    if models_budget_month_category.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_month_category.auth_household_id

    if models_budget_month_category.balance is not None:
        res['balance'] = models_budget_month_category.balance

    if models_budget_month_category.budget_category_id is not None:
        res['budgetCategoryID'] = models_budget_month_category.budget_category_id

    if models_budget_month_category.budget_transaction_amount is not None:
        res['budgetTransactionAmount'] = models_budget_month_category.budget_transaction_amount

    if models_budget_month_category.created is not None:
        res['created'] = models_budget_month_category.created

    if models_budget_month_category.year_month is not None:
        res['yearMonth'] = models_budget_month_category.year_month

    return res


class ModelsBudgetPayee:
    def __init__(
            self,
            address: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            budget_category_id: Optional[str] = None,
            budget_transaction_amount: Optional[int] = None,
            cook_meal_plan_count: Optional[int] = None,
            cook_meal_plan_last: Optional[str] = None,
            cook_restaurant: Optional[bool] = None,
            created: Optional[str] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            meals_disliked: Optional[List[str]] = None,
            meals_liked: Optional[List[str]] = None,
            menu_link: Optional[str] = None,
            name: Optional[str] = None,
            phone_number: Optional[str] = None,
            price: Optional[int] = None,
            rating: Optional[int] = None,
            shop_store: Optional[bool] = None,
            short_id: Optional[str] = None,
            travel_time: Optional[int] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.address = address

        self.auth_household_id = auth_household_id

        self.budget_category_id = budget_category_id

        self.budget_transaction_amount = budget_transaction_amount

        self.cook_meal_plan_count = cook_meal_plan_count

        self.cook_meal_plan_last = cook_meal_plan_last

        self.cook_restaurant = cook_restaurant

        self.created = created

        self.icon = icon

        self.id = id

        self.labels_values_ids = labels_values_ids

        self.meals_disliked = meals_disliked

        self.meals_liked = meals_liked

        self.menu_link = menu_link

        self.name = name

        self.phone_number = phone_number

        self.price = price

        self.rating = rating

        self.shop_store = shop_store

        self.short_id = short_id

        self.travel_time = travel_time

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_payee_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_payee_to_jsonable(self)


def new_models_budget_payee() -> ModelsBudgetPayee:
    """Generates an instance of ModelsBudgetPayee with default values."""
    return ModelsBudgetPayee()


def models_budget_payee_from_obj(obj: Any, path: str = "") -> ModelsBudgetPayee:
    """
    Generates an instance of ModelsBudgetPayee from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetPayee
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetPayee
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_address = obj.get('address', None)
    if obj_address is not None:
        address_from_obj = from_obj(
            obj_address,
            expected=[str],
            path=path + '.address')  # type: Optional[str]
    else:
        address_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_category_id = obj.get('budgetCategoryID', None)
    if obj_budget_category_id is not None:
        budget_category_id_from_obj = from_obj(
            obj_budget_category_id,
            expected=[str],
            path=path + '.budgetCategoryID')  # type: Optional[str]
    else:
        budget_category_id_from_obj = None

    obj_budget_transaction_amount = obj.get('budgetTransactionAmount', None)
    if obj_budget_transaction_amount is not None:
        budget_transaction_amount_from_obj = from_obj(
            obj_budget_transaction_amount,
            expected=[int],
            path=path + '.budgetTransactionAmount')  # type: Optional[int]
    else:
        budget_transaction_amount_from_obj = None

    obj_cook_meal_plan_count = obj.get('cookMealPlanCount', None)
    if obj_cook_meal_plan_count is not None:
        cook_meal_plan_count_from_obj = from_obj(
            obj_cook_meal_plan_count,
            expected=[int],
            path=path + '.cookMealPlanCount')  # type: Optional[int]
    else:
        cook_meal_plan_count_from_obj = None

    obj_cook_meal_plan_last = obj.get('cookMealPlanLast', None)
    if obj_cook_meal_plan_last is not None:
        cook_meal_plan_last_from_obj = from_obj(
            obj_cook_meal_plan_last,
            expected=[str],
            path=path + '.cookMealPlanLast')  # type: Optional[str]
    else:
        cook_meal_plan_last_from_obj = None

    obj_cook_restaurant = obj.get('cookRestaurant', None)
    if obj_cook_restaurant is not None:
        cook_restaurant_from_obj = from_obj(
            obj_cook_restaurant,
            expected=[bool],
            path=path + '.cookRestaurant')  # type: Optional[bool]
    else:
        cook_restaurant_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_meals_disliked = obj.get('mealsDisliked', None)
    if obj_meals_disliked is not None:
        meals_disliked_from_obj = from_obj(
            obj_meals_disliked,
            expected=[list, str],
            path=path + '.mealsDisliked')  # type: Optional[List[str]]
    else:
        meals_disliked_from_obj = None

    obj_meals_liked = obj.get('mealsLiked', None)
    if obj_meals_liked is not None:
        meals_liked_from_obj = from_obj(
            obj_meals_liked,
            expected=[list, str],
            path=path + '.mealsLiked')  # type: Optional[List[str]]
    else:
        meals_liked_from_obj = None

    obj_menu_link = obj.get('menuLink', None)
    if obj_menu_link is not None:
        menu_link_from_obj = from_obj(
            obj_menu_link,
            expected=[str],
            path=path + '.menuLink')  # type: Optional[str]
    else:
        menu_link_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_phone_number = obj.get('phoneNumber', None)
    if obj_phone_number is not None:
        phone_number_from_obj = from_obj(
            obj_phone_number,
            expected=[str],
            path=path + '.phoneNumber')  # type: Optional[str]
    else:
        phone_number_from_obj = None

    obj_price = obj.get('price', None)
    if obj_price is not None:
        price_from_obj = from_obj(
            obj_price,
            expected=[int],
            path=path + '.price')  # type: Optional[int]
    else:
        price_from_obj = None

    obj_rating = obj.get('rating', None)
    if obj_rating is not None:
        rating_from_obj = from_obj(
            obj_rating,
            expected=[int],
            path=path + '.rating')  # type: Optional[int]
    else:
        rating_from_obj = None

    obj_shop_store = obj.get('shopStore', None)
    if obj_shop_store is not None:
        shop_store_from_obj = from_obj(
            obj_shop_store,
            expected=[bool],
            path=path + '.shopStore')  # type: Optional[bool]
    else:
        shop_store_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_travel_time = obj.get('travelTime', None)
    if obj_travel_time is not None:
        travel_time_from_obj = from_obj(
            obj_travel_time,
            expected=[int],
            path=path + '.travelTime')  # type: Optional[int]
    else:
        travel_time_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsBudgetPayee(
        address=address_from_obj,
        auth_household_id=auth_household_id_from_obj,
        budget_category_id=budget_category_id_from_obj,
        budget_transaction_amount=budget_transaction_amount_from_obj,
        cook_meal_plan_count=cook_meal_plan_count_from_obj,
        cook_meal_plan_last=cook_meal_plan_last_from_obj,
        cook_restaurant=cook_restaurant_from_obj,
        created=created_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        meals_disliked=meals_disliked_from_obj,
        meals_liked=meals_liked_from_obj,
        menu_link=menu_link_from_obj,
        name=name_from_obj,
        phone_number=phone_number_from_obj,
        price=price_from_obj,
        rating=rating_from_obj,
        shop_store=shop_store_from_obj,
        short_id=short_id_from_obj,
        travel_time=travel_time_from_obj,
        updated=updated_from_obj)


def models_budget_payee_to_jsonable(
        models_budget_payee: ModelsBudgetPayee,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetPayee.

    :param models_budget_payee: instance of ModelsBudgetPayee to be JSON-ized
    :param path: path to the models_budget_payee used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_payee.address is not None:
        res['address'] = models_budget_payee.address

    if models_budget_payee.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_payee.auth_household_id

    if models_budget_payee.budget_category_id is not None:
        res['budgetCategoryID'] = models_budget_payee.budget_category_id

    if models_budget_payee.budget_transaction_amount is not None:
        res['budgetTransactionAmount'] = models_budget_payee.budget_transaction_amount

    if models_budget_payee.cook_meal_plan_count is not None:
        res['cookMealPlanCount'] = models_budget_payee.cook_meal_plan_count

    if models_budget_payee.cook_meal_plan_last is not None:
        res['cookMealPlanLast'] = models_budget_payee.cook_meal_plan_last

    if models_budget_payee.cook_restaurant is not None:
        res['cookRestaurant'] = models_budget_payee.cook_restaurant

    if models_budget_payee.created is not None:
        res['created'] = models_budget_payee.created

    if models_budget_payee.icon is not None:
        res['icon'] = models_budget_payee.icon

    if models_budget_payee.id is not None:
        res['id'] = models_budget_payee.id

    if models_budget_payee.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_budget_payee.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_budget_payee.meals_disliked is not None:
        res['mealsDisliked'] = to_jsonable(
        models_budget_payee.meals_disliked,
        expected=[list, str],
        path='{}.mealsDisliked'.format(path))

    if models_budget_payee.meals_liked is not None:
        res['mealsLiked'] = to_jsonable(
        models_budget_payee.meals_liked,
        expected=[list, str],
        path='{}.mealsLiked'.format(path))

    if models_budget_payee.menu_link is not None:
        res['menuLink'] = models_budget_payee.menu_link

    if models_budget_payee.name is not None:
        res['name'] = models_budget_payee.name

    if models_budget_payee.phone_number is not None:
        res['phoneNumber'] = models_budget_payee.phone_number

    if models_budget_payee.price is not None:
        res['price'] = models_budget_payee.price

    if models_budget_payee.rating is not None:
        res['rating'] = models_budget_payee.rating

    if models_budget_payee.shop_store is not None:
        res['shopStore'] = models_budget_payee.shop_store

    if models_budget_payee.short_id is not None:
        res['shortID'] = models_budget_payee.short_id

    if models_budget_payee.travel_time is not None:
        res['travelTime'] = models_budget_payee.travel_time

    if models_budget_payee.updated is not None:
        res['updated'] = models_budget_payee.updated

    return res


class ModelsBudgetRecurrence:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            budget_account_id: Optional[str] = None,
            created: Optional[str] = None,
            id: Optional[str] = None,
            recurrence: Optional['TypesRecurrence'] = None,
            template: Optional['ModelsBudgetRecurrenceTemplate'] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.budget_account_id = budget_account_id

        self.created = created

        self.id = id

        self.recurrence = recurrence

        self.template = template

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_recurrence_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_recurrence_to_jsonable(self)


def new_models_budget_recurrence() -> ModelsBudgetRecurrence:
    """Generates an instance of ModelsBudgetRecurrence with default values."""
    return ModelsBudgetRecurrence()


def models_budget_recurrence_from_obj(obj: Any, path: str = "") -> ModelsBudgetRecurrence:
    """
    Generates an instance of ModelsBudgetRecurrence from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetRecurrence
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetRecurrence
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_account_id = obj.get('budgetAccountID', None)
    if obj_budget_account_id is not None:
        budget_account_id_from_obj = from_obj(
            obj_budget_account_id,
            expected=[str],
            path=path + '.budgetAccountID')  # type: Optional[str]
    else:
        budget_account_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_recurrence = obj.get('recurrence', None)
    if obj_recurrence is not None:
        recurrence_from_obj = from_obj(
            obj_recurrence,
            expected=[TypesRecurrence],
            path=path + '.recurrence')  # type: Optional['TypesRecurrence']
    else:
        recurrence_from_obj = None

    obj_template = obj.get('template', None)
    if obj_template is not None:
        template_from_obj = from_obj(
            obj_template,
            expected=[ModelsBudgetRecurrenceTemplate],
            path=path + '.template')  # type: Optional['ModelsBudgetRecurrenceTemplate']
    else:
        template_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsBudgetRecurrence(
        auth_household_id=auth_household_id_from_obj,
        budget_account_id=budget_account_id_from_obj,
        created=created_from_obj,
        id=id_from_obj,
        recurrence=recurrence_from_obj,
        template=template_from_obj,
        updated=updated_from_obj)


def models_budget_recurrence_to_jsonable(
        models_budget_recurrence: ModelsBudgetRecurrence,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetRecurrence.

    :param models_budget_recurrence: instance of ModelsBudgetRecurrence to be JSON-ized
    :param path: path to the models_budget_recurrence used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_recurrence.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_recurrence.auth_household_id

    if models_budget_recurrence.budget_account_id is not None:
        res['budgetAccountID'] = models_budget_recurrence.budget_account_id

    if models_budget_recurrence.created is not None:
        res['created'] = models_budget_recurrence.created

    if models_budget_recurrence.id is not None:
        res['id'] = models_budget_recurrence.id

    if models_budget_recurrence.recurrence is not None:
        res['recurrence'] = to_jsonable(
        models_budget_recurrence.recurrence,
        expected=[TypesRecurrence],
        path='{}.recurrence'.format(path))

    if models_budget_recurrence.template is not None:
        res['template'] = to_jsonable(
        models_budget_recurrence.template,
        expected=[ModelsBudgetRecurrenceTemplate],
        path='{}.template'.format(path))

    if models_budget_recurrence.updated is not None:
        res['updated'] = models_budget_recurrence.updated

    return res


class ModelsBudgetRecurrenceTemplate:
    def __init__(
            self,
            accounts: Optional[List['ModelsBudgetTransactionAccount']] = None,
            amount: Optional[int] = None,
            auth_household_id: Optional[str] = None,
            balance: Optional[int] = None,
            budget_payee_id: Optional[str] = None,
            budget_payee_name: Optional[str] = None,
            categories: Optional[List['ModelsBudgetTransactionCategory']] = None,
            created: Optional[str] = None,
            date: Optional[str] = None,
            id: Optional[str] = None,
            keep: Optional[bool] = None,
            note: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.accounts = accounts

        self.amount = amount

        self.auth_household_id = auth_household_id

        self.balance = balance

        self.budget_payee_id = budget_payee_id

        self.budget_payee_name = budget_payee_name

        self.categories = categories

        self.created = created

        self.date = date

        self.id = id

        self.keep = keep

        self.note = note

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_recurrence_template_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_recurrence_template_to_jsonable(self)


def new_models_budget_recurrence_template() -> ModelsBudgetRecurrenceTemplate:
    """Generates an instance of ModelsBudgetRecurrenceTemplate with default values."""
    return ModelsBudgetRecurrenceTemplate()


def models_budget_recurrence_template_from_obj(obj: Any, path: str = "") -> ModelsBudgetRecurrenceTemplate:
    """
    Generates an instance of ModelsBudgetRecurrenceTemplate from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetRecurrenceTemplate
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetRecurrenceTemplate
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_accounts = obj.get('accounts', None)
    if obj_accounts is not None:
        accounts_from_obj = from_obj(
            obj_accounts,
            expected=[list, ModelsBudgetTransactionAccount],
            path=path + '.accounts')  # type: Optional[List['ModelsBudgetTransactionAccount']]
    else:
        accounts_from_obj = None

    obj_amount = obj.get('amount', None)
    if obj_amount is not None:
        amount_from_obj = from_obj(
            obj_amount,
            expected=[int],
            path=path + '.amount')  # type: Optional[int]
    else:
        amount_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_balance = obj.get('balance', None)
    if obj_balance is not None:
        balance_from_obj = from_obj(
            obj_balance,
            expected=[int],
            path=path + '.balance')  # type: Optional[int]
    else:
        balance_from_obj = None

    obj_budget_payee_id = obj.get('budgetPayeeID', None)
    if obj_budget_payee_id is not None:
        budget_payee_id_from_obj = from_obj(
            obj_budget_payee_id,
            expected=[str],
            path=path + '.budgetPayeeID')  # type: Optional[str]
    else:
        budget_payee_id_from_obj = None

    obj_budget_payee_name = obj.get('budgetPayeeName', None)
    if obj_budget_payee_name is not None:
        budget_payee_name_from_obj = from_obj(
            obj_budget_payee_name,
            expected=[str],
            path=path + '.budgetPayeeName')  # type: Optional[str]
    else:
        budget_payee_name_from_obj = None

    obj_categories = obj.get('categories', None)
    if obj_categories is not None:
        categories_from_obj = from_obj(
            obj_categories,
            expected=[list, ModelsBudgetTransactionCategory],
            path=path + '.categories')  # type: Optional[List['ModelsBudgetTransactionCategory']]
    else:
        categories_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_date = obj.get('date', None)
    if obj_date is not None:
        date_from_obj = from_obj(
            obj_date,
            expected=[str],
            path=path + '.date')  # type: Optional[str]
    else:
        date_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_keep = obj.get('keep', None)
    if obj_keep is not None:
        keep_from_obj = from_obj(
            obj_keep,
            expected=[bool],
            path=path + '.keep')  # type: Optional[bool]
    else:
        keep_from_obj = None

    obj_note = obj.get('note', None)
    if obj_note is not None:
        note_from_obj = from_obj(
            obj_note,
            expected=[str],
            path=path + '.note')  # type: Optional[str]
    else:
        note_from_obj = None

    return ModelsBudgetRecurrenceTemplate(
        accounts=accounts_from_obj,
        amount=amount_from_obj,
        auth_household_id=auth_household_id_from_obj,
        balance=balance_from_obj,
        budget_payee_id=budget_payee_id_from_obj,
        budget_payee_name=budget_payee_name_from_obj,
        categories=categories_from_obj,
        created=created_from_obj,
        date=date_from_obj,
        id=id_from_obj,
        keep=keep_from_obj,
        note=note_from_obj)


def models_budget_recurrence_template_to_jsonable(
        models_budget_recurrence_template: ModelsBudgetRecurrenceTemplate,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetRecurrenceTemplate.

    :param models_budget_recurrence_template: instance of ModelsBudgetRecurrenceTemplate to be JSON-ized
    :param path: path to the models_budget_recurrence_template used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_recurrence_template.accounts is not None:
        res['accounts'] = to_jsonable(
        models_budget_recurrence_template.accounts,
        expected=[list, ModelsBudgetTransactionAccount],
        path='{}.accounts'.format(path))

    if models_budget_recurrence_template.amount is not None:
        res['amount'] = models_budget_recurrence_template.amount

    if models_budget_recurrence_template.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_recurrence_template.auth_household_id

    if models_budget_recurrence_template.balance is not None:
        res['balance'] = models_budget_recurrence_template.balance

    if models_budget_recurrence_template.budget_payee_id is not None:
        res['budgetPayeeID'] = models_budget_recurrence_template.budget_payee_id

    if models_budget_recurrence_template.budget_payee_name is not None:
        res['budgetPayeeName'] = models_budget_recurrence_template.budget_payee_name

    if models_budget_recurrence_template.categories is not None:
        res['categories'] = to_jsonable(
        models_budget_recurrence_template.categories,
        expected=[list, ModelsBudgetTransactionCategory],
        path='{}.categories'.format(path))

    if models_budget_recurrence_template.created is not None:
        res['created'] = models_budget_recurrence_template.created

    if models_budget_recurrence_template.date is not None:
        res['date'] = models_budget_recurrence_template.date

    if models_budget_recurrence_template.id is not None:
        res['id'] = models_budget_recurrence_template.id

    if models_budget_recurrence_template.keep is not None:
        res['keep'] = models_budget_recurrence_template.keep

    if models_budget_recurrence_template.note is not None:
        res['note'] = models_budget_recurrence_template.note

    return res


class ModelsBudgetTransaction:
    def __init__(
            self,
            accounts: Optional[List['ModelsBudgetTransactionAccount']] = None,
            amount: Optional[int] = None,
            auth_household_id: Optional[str] = None,
            balance: Optional[int] = None,
            budget_payee_id: Optional[str] = None,
            budget_payee_name: Optional[str] = None,
            categories: Optional[List['ModelsBudgetTransactionCategory']] = None,
            created: Optional[str] = None,
            date: Optional[str] = None,
            id: Optional[str] = None,
            keep: Optional[bool] = None,
            note: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.accounts = accounts

        self.amount = amount

        self.auth_household_id = auth_household_id

        self.balance = balance

        self.budget_payee_id = budget_payee_id

        self.budget_payee_name = budget_payee_name

        self.categories = categories

        self.created = created

        self.date = date

        self.id = id

        self.keep = keep

        self.note = note

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_transaction_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_transaction_to_jsonable(self)


def new_models_budget_transaction() -> ModelsBudgetTransaction:
    """Generates an instance of ModelsBudgetTransaction with default values."""
    return ModelsBudgetTransaction()


def models_budget_transaction_from_obj(obj: Any, path: str = "") -> ModelsBudgetTransaction:
    """
    Generates an instance of ModelsBudgetTransaction from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetTransaction
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetTransaction
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_accounts = obj.get('accounts', None)
    if obj_accounts is not None:
        accounts_from_obj = from_obj(
            obj_accounts,
            expected=[list, ModelsBudgetTransactionAccount],
            path=path + '.accounts')  # type: Optional[List['ModelsBudgetTransactionAccount']]
    else:
        accounts_from_obj = None

    obj_amount = obj.get('amount', None)
    if obj_amount is not None:
        amount_from_obj = from_obj(
            obj_amount,
            expected=[int],
            path=path + '.amount')  # type: Optional[int]
    else:
        amount_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_balance = obj.get('balance', None)
    if obj_balance is not None:
        balance_from_obj = from_obj(
            obj_balance,
            expected=[int],
            path=path + '.balance')  # type: Optional[int]
    else:
        balance_from_obj = None

    obj_budget_payee_id = obj.get('budgetPayeeID', None)
    if obj_budget_payee_id is not None:
        budget_payee_id_from_obj = from_obj(
            obj_budget_payee_id,
            expected=[str],
            path=path + '.budgetPayeeID')  # type: Optional[str]
    else:
        budget_payee_id_from_obj = None

    obj_budget_payee_name = obj.get('budgetPayeeName', None)
    if obj_budget_payee_name is not None:
        budget_payee_name_from_obj = from_obj(
            obj_budget_payee_name,
            expected=[str],
            path=path + '.budgetPayeeName')  # type: Optional[str]
    else:
        budget_payee_name_from_obj = None

    obj_categories = obj.get('categories', None)
    if obj_categories is not None:
        categories_from_obj = from_obj(
            obj_categories,
            expected=[list, ModelsBudgetTransactionCategory],
            path=path + '.categories')  # type: Optional[List['ModelsBudgetTransactionCategory']]
    else:
        categories_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_date = obj.get('date', None)
    if obj_date is not None:
        date_from_obj = from_obj(
            obj_date,
            expected=[str],
            path=path + '.date')  # type: Optional[str]
    else:
        date_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_keep = obj.get('keep', None)
    if obj_keep is not None:
        keep_from_obj = from_obj(
            obj_keep,
            expected=[bool],
            path=path + '.keep')  # type: Optional[bool]
    else:
        keep_from_obj = None

    obj_note = obj.get('note', None)
    if obj_note is not None:
        note_from_obj = from_obj(
            obj_note,
            expected=[str],
            path=path + '.note')  # type: Optional[str]
    else:
        note_from_obj = None

    return ModelsBudgetTransaction(
        accounts=accounts_from_obj,
        amount=amount_from_obj,
        auth_household_id=auth_household_id_from_obj,
        balance=balance_from_obj,
        budget_payee_id=budget_payee_id_from_obj,
        budget_payee_name=budget_payee_name_from_obj,
        categories=categories_from_obj,
        created=created_from_obj,
        date=date_from_obj,
        id=id_from_obj,
        keep=keep_from_obj,
        note=note_from_obj)


def models_budget_transaction_to_jsonable(
        models_budget_transaction: ModelsBudgetTransaction,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetTransaction.

    :param models_budget_transaction: instance of ModelsBudgetTransaction to be JSON-ized
    :param path: path to the models_budget_transaction used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_transaction.accounts is not None:
        res['accounts'] = to_jsonable(
        models_budget_transaction.accounts,
        expected=[list, ModelsBudgetTransactionAccount],
        path='{}.accounts'.format(path))

    if models_budget_transaction.amount is not None:
        res['amount'] = models_budget_transaction.amount

    if models_budget_transaction.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_transaction.auth_household_id

    if models_budget_transaction.balance is not None:
        res['balance'] = models_budget_transaction.balance

    if models_budget_transaction.budget_payee_id is not None:
        res['budgetPayeeID'] = models_budget_transaction.budget_payee_id

    if models_budget_transaction.budget_payee_name is not None:
        res['budgetPayeeName'] = models_budget_transaction.budget_payee_name

    if models_budget_transaction.categories is not None:
        res['categories'] = to_jsonable(
        models_budget_transaction.categories,
        expected=[list, ModelsBudgetTransactionCategory],
        path='{}.categories'.format(path))

    if models_budget_transaction.created is not None:
        res['created'] = models_budget_transaction.created

    if models_budget_transaction.date is not None:
        res['date'] = models_budget_transaction.date

    if models_budget_transaction.id is not None:
        res['id'] = models_budget_transaction.id

    if models_budget_transaction.keep is not None:
        res['keep'] = models_budget_transaction.keep

    if models_budget_transaction.note is not None:
        res['note'] = models_budget_transaction.note

    return res


class ModelsBudgetTransactionAccount:
    def __init__(
            self,
            amount: Optional[int] = None,
            auth_household_id: Optional[str] = None,
            budget_account_id: Optional[str] = None,
            budget_transaction_id: Optional[str] = None,
            id: Optional[str] = None,
            status: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.amount = amount

        self.auth_household_id = auth_household_id

        self.budget_account_id = budget_account_id

        self.budget_transaction_id = budget_transaction_id

        self.id = id

        self.status = status

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_transaction_account_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_transaction_account_to_jsonable(self)


def new_models_budget_transaction_account() -> ModelsBudgetTransactionAccount:
    """Generates an instance of ModelsBudgetTransactionAccount with default values."""
    return ModelsBudgetTransactionAccount()


def models_budget_transaction_account_from_obj(obj: Any, path: str = "") -> ModelsBudgetTransactionAccount:
    """
    Generates an instance of ModelsBudgetTransactionAccount from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetTransactionAccount
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetTransactionAccount
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_amount = obj.get('amount', None)
    if obj_amount is not None:
        amount_from_obj = from_obj(
            obj_amount,
            expected=[int],
            path=path + '.amount')  # type: Optional[int]
    else:
        amount_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_account_id = obj.get('budgetAccountID', None)
    if obj_budget_account_id is not None:
        budget_account_id_from_obj = from_obj(
            obj_budget_account_id,
            expected=[str],
            path=path + '.budgetAccountID')  # type: Optional[str]
    else:
        budget_account_id_from_obj = None

    obj_budget_transaction_id = obj.get('budgetTransactionID', None)
    if obj_budget_transaction_id is not None:
        budget_transaction_id_from_obj = from_obj(
            obj_budget_transaction_id,
            expected=[str],
            path=path + '.budgetTransactionID')  # type: Optional[str]
    else:
        budget_transaction_id_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_status = obj.get('status', None)
    if obj_status is not None:
        status_from_obj = from_obj(
            obj_status,
            expected=[int],
            path=path + '.status')  # type: Optional[int]
    else:
        status_from_obj = None

    return ModelsBudgetTransactionAccount(
        amount=amount_from_obj,
        auth_household_id=auth_household_id_from_obj,
        budget_account_id=budget_account_id_from_obj,
        budget_transaction_id=budget_transaction_id_from_obj,
        id=id_from_obj,
        status=status_from_obj)


def models_budget_transaction_account_to_jsonable(
        models_budget_transaction_account: ModelsBudgetTransactionAccount,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetTransactionAccount.

    :param models_budget_transaction_account: instance of ModelsBudgetTransactionAccount to be JSON-ized
    :param path: path to the models_budget_transaction_account used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_transaction_account.amount is not None:
        res['amount'] = models_budget_transaction_account.amount

    if models_budget_transaction_account.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_transaction_account.auth_household_id

    if models_budget_transaction_account.budget_account_id is not None:
        res['budgetAccountID'] = models_budget_transaction_account.budget_account_id

    if models_budget_transaction_account.budget_transaction_id is not None:
        res['budgetTransactionID'] = models_budget_transaction_account.budget_transaction_id

    if models_budget_transaction_account.id is not None:
        res['id'] = models_budget_transaction_account.id

    if models_budget_transaction_account.status is not None:
        res['status'] = models_budget_transaction_account.status

    return res


class ModelsBudgetTransactionCategory:
    def __init__(
            self,
            amount: Optional[int] = None,
            auth_household_id: Optional[str] = None,
            budget_category_id: Optional[str] = None,
            budget_transaction_id: Optional[str] = None,
            id: Optional[str] = None,
            year_month: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.amount = amount

        self.auth_household_id = auth_household_id

        self.budget_category_id = budget_category_id

        self.budget_transaction_id = budget_transaction_id

        self.id = id

        self.year_month = year_month

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_budget_transaction_category_to_jsonable.

        :return: JSON-able representation
        """
        return models_budget_transaction_category_to_jsonable(self)


def new_models_budget_transaction_category() -> ModelsBudgetTransactionCategory:
    """Generates an instance of ModelsBudgetTransactionCategory with default values."""
    return ModelsBudgetTransactionCategory()


def models_budget_transaction_category_from_obj(obj: Any, path: str = "") -> ModelsBudgetTransactionCategory:
    """
    Generates an instance of ModelsBudgetTransactionCategory from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsBudgetTransactionCategory
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsBudgetTransactionCategory
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_amount = obj.get('amount', None)
    if obj_amount is not None:
        amount_from_obj = from_obj(
            obj_amount,
            expected=[int],
            path=path + '.amount')  # type: Optional[int]
    else:
        amount_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_category_id = obj.get('budgetCategoryID', None)
    if obj_budget_category_id is not None:
        budget_category_id_from_obj = from_obj(
            obj_budget_category_id,
            expected=[str],
            path=path + '.budgetCategoryID')  # type: Optional[str]
    else:
        budget_category_id_from_obj = None

    obj_budget_transaction_id = obj.get('budgetTransactionID', None)
    if obj_budget_transaction_id is not None:
        budget_transaction_id_from_obj = from_obj(
            obj_budget_transaction_id,
            expected=[str],
            path=path + '.budgetTransactionID')  # type: Optional[str]
    else:
        budget_transaction_id_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_year_month = obj.get('yearMonth', None)
    if obj_year_month is not None:
        year_month_from_obj = from_obj(
            obj_year_month,
            expected=[int],
            path=path + '.yearMonth')  # type: Optional[int]
    else:
        year_month_from_obj = None

    return ModelsBudgetTransactionCategory(
        amount=amount_from_obj,
        auth_household_id=auth_household_id_from_obj,
        budget_category_id=budget_category_id_from_obj,
        budget_transaction_id=budget_transaction_id_from_obj,
        id=id_from_obj,
        year_month=year_month_from_obj)


def models_budget_transaction_category_to_jsonable(
        models_budget_transaction_category: ModelsBudgetTransactionCategory,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsBudgetTransactionCategory.

    :param models_budget_transaction_category: instance of ModelsBudgetTransactionCategory to be JSON-ized
    :param path: path to the models_budget_transaction_category used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_budget_transaction_category.amount is not None:
        res['amount'] = models_budget_transaction_category.amount

    if models_budget_transaction_category.auth_household_id is not None:
        res['authHouseholdID'] = models_budget_transaction_category.auth_household_id

    if models_budget_transaction_category.budget_category_id is not None:
        res['budgetCategoryID'] = models_budget_transaction_category.budget_category_id

    if models_budget_transaction_category.budget_transaction_id is not None:
        res['budgetTransactionID'] = models_budget_transaction_category.budget_transaction_id

    if models_budget_transaction_category.id is not None:
        res['id'] = models_budget_transaction_category.id

    if models_budget_transaction_category.year_month is not None:
        res['yearMonth'] = models_budget_transaction_category.year_month

    return res


class ModelsCalendarEvent:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            calendar_i_calendar_id: Optional[str] = None,
            color: Optional[str] = None,
            created: Optional[str] = None,
            date_end: Optional[str] = None,
            date_start: Optional[str] = None,
            details: Optional[str] = None,
            duration: Optional[int] = None,
            i_calendar_u_id: Optional[str] = None,
            id: Optional[str] = None,
            location: Optional[str] = None,
            name: Optional[str] = None,
            notify_offset: Optional[int] = None,
            participants: Optional[List[str]] = None,
            recurrence: Optional['TypesRecurrence'] = None,
            reminders_end: Optional[List[int]] = None,
            reminders_start: Optional[List[int]] = None,
            skip_days: Optional[List['TypesCivilDate']] = None,
            time_start: Optional[str] = None,
            time_zone: Optional[str] = None,
            timestamp_end: Optional[str] = None,
            timestamp_start: Optional[str] = None,
            travel_time: Optional[int] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.calendar_i_calendar_id = calendar_i_calendar_id

        self.color = color

        self.created = created

        # Deprecated: use Recurrence.End
        #
        # TODO remove 2026-05-06
        self.date_end = date_end

        # start of event or recurrence
        self.date_start = date_start

        self.details = details

        self.duration = duration

        self.i_calendar_u_id = i_calendar_u_id

        self.id = id

        self.location = location

        self.name = name

        # Deprecated: Use Reminders
        #
        # TODO remove 2026-05-06
        self.notify_offset = notify_offset

        self.participants = participants

        self.recurrence = recurrence

        self.reminders_end = reminders_end

        self.reminders_start = reminders_start

        self.skip_days = skip_days

        self.time_start = time_start

        self.time_zone = time_zone

        self.timestamp_end = timestamp_end

        self.timestamp_start = timestamp_start

        self.travel_time = travel_time

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_calendar_event_to_jsonable.

        :return: JSON-able representation
        """
        return models_calendar_event_to_jsonable(self)


def new_models_calendar_event() -> ModelsCalendarEvent:
    """Generates an instance of ModelsCalendarEvent with default values."""
    return ModelsCalendarEvent()


def models_calendar_event_from_obj(obj: Any, path: str = "") -> ModelsCalendarEvent:
    """
    Generates an instance of ModelsCalendarEvent from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsCalendarEvent
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsCalendarEvent
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_calendar_i_calendar_id = obj.get('calendarICalendarID', None)
    if obj_calendar_i_calendar_id is not None:
        calendar_i_calendar_id_from_obj = from_obj(
            obj_calendar_i_calendar_id,
            expected=[str],
            path=path + '.calendarICalendarID')  # type: Optional[str]
    else:
        calendar_i_calendar_id_from_obj = None

    obj_color = obj.get('color', None)
    if obj_color is not None:
        color_from_obj = from_obj(
            obj_color,
            expected=[str],
            path=path + '.color')  # type: Optional[str]
    else:
        color_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_date_end = obj.get('dateEnd', None)
    if obj_date_end is not None:
        date_end_from_obj = from_obj(
            obj_date_end,
            expected=[str],
            path=path + '.dateEnd')  # type: Optional[str]
    else:
        date_end_from_obj = None

    obj_date_start = obj.get('dateStart', None)
    if obj_date_start is not None:
        date_start_from_obj = from_obj(
            obj_date_start,
            expected=[str],
            path=path + '.dateStart')  # type: Optional[str]
    else:
        date_start_from_obj = None

    obj_details = obj.get('details', None)
    if obj_details is not None:
        details_from_obj = from_obj(
            obj_details,
            expected=[str],
            path=path + '.details')  # type: Optional[str]
    else:
        details_from_obj = None

    obj_duration = obj.get('duration', None)
    if obj_duration is not None:
        duration_from_obj = from_obj(
            obj_duration,
            expected=[int],
            path=path + '.duration')  # type: Optional[int]
    else:
        duration_from_obj = None

    obj_i_calendar_u_id = obj.get('iCalendarUID', None)
    if obj_i_calendar_u_id is not None:
        i_calendar_u_id_from_obj = from_obj(
            obj_i_calendar_u_id,
            expected=[str],
            path=path + '.iCalendarUID')  # type: Optional[str]
    else:
        i_calendar_u_id_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_location = obj.get('location', None)
    if obj_location is not None:
        location_from_obj = from_obj(
            obj_location,
            expected=[str],
            path=path + '.location')  # type: Optional[str]
    else:
        location_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_notify_offset = obj.get('notifyOffset', None)
    if obj_notify_offset is not None:
        notify_offset_from_obj = from_obj(
            obj_notify_offset,
            expected=[int],
            path=path + '.notifyOffset')  # type: Optional[int]
    else:
        notify_offset_from_obj = None

    obj_participants = obj.get('participants', None)
    if obj_participants is not None:
        participants_from_obj = from_obj(
            obj_participants,
            expected=[list, str],
            path=path + '.participants')  # type: Optional[List[str]]
    else:
        participants_from_obj = None

    obj_recurrence = obj.get('recurrence', None)
    if obj_recurrence is not None:
        recurrence_from_obj = from_obj(
            obj_recurrence,
            expected=[TypesRecurrence],
            path=path + '.recurrence')  # type: Optional['TypesRecurrence']
    else:
        recurrence_from_obj = None

    obj_reminders_end = obj.get('remindersEnd', None)
    if obj_reminders_end is not None:
        reminders_end_from_obj = from_obj(
            obj_reminders_end,
            expected=[list, int],
            path=path + '.remindersEnd')  # type: Optional[List[int]]
    else:
        reminders_end_from_obj = None

    obj_reminders_start = obj.get('remindersStart', None)
    if obj_reminders_start is not None:
        reminders_start_from_obj = from_obj(
            obj_reminders_start,
            expected=[list, int],
            path=path + '.remindersStart')  # type: Optional[List[int]]
    else:
        reminders_start_from_obj = None

    obj_skip_days = obj.get('skipDays', None)
    if obj_skip_days is not None:
        skip_days_from_obj = from_obj(
            obj_skip_days,
            expected=[list, TypesCivilDate],
            path=path + '.skipDays')  # type: Optional[List['TypesCivilDate']]
    else:
        skip_days_from_obj = None

    obj_time_start = obj.get('timeStart', None)
    if obj_time_start is not None:
        time_start_from_obj = from_obj(
            obj_time_start,
            expected=[str],
            path=path + '.timeStart')  # type: Optional[str]
    else:
        time_start_from_obj = None

    obj_time_zone = obj.get('timeZone', None)
    if obj_time_zone is not None:
        time_zone_from_obj = from_obj(
            obj_time_zone,
            expected=[str],
            path=path + '.timeZone')  # type: Optional[str]
    else:
        time_zone_from_obj = None

    obj_timestamp_end = obj.get('timestampEnd', None)
    if obj_timestamp_end is not None:
        timestamp_end_from_obj = from_obj(
            obj_timestamp_end,
            expected=[str],
            path=path + '.timestampEnd')  # type: Optional[str]
    else:
        timestamp_end_from_obj = None

    obj_timestamp_start = obj.get('timestampStart', None)
    if obj_timestamp_start is not None:
        timestamp_start_from_obj = from_obj(
            obj_timestamp_start,
            expected=[str],
            path=path + '.timestampStart')  # type: Optional[str]
    else:
        timestamp_start_from_obj = None

    obj_travel_time = obj.get('travelTime', None)
    if obj_travel_time is not None:
        travel_time_from_obj = from_obj(
            obj_travel_time,
            expected=[int],
            path=path + '.travelTime')  # type: Optional[int]
    else:
        travel_time_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsCalendarEvent(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        calendar_i_calendar_id=calendar_i_calendar_id_from_obj,
        color=color_from_obj,
        created=created_from_obj,
        date_end=date_end_from_obj,
        date_start=date_start_from_obj,
        details=details_from_obj,
        duration=duration_from_obj,
        i_calendar_u_id=i_calendar_u_id_from_obj,
        id=id_from_obj,
        location=location_from_obj,
        name=name_from_obj,
        notify_offset=notify_offset_from_obj,
        participants=participants_from_obj,
        recurrence=recurrence_from_obj,
        reminders_end=reminders_end_from_obj,
        reminders_start=reminders_start_from_obj,
        skip_days=skip_days_from_obj,
        time_start=time_start_from_obj,
        time_zone=time_zone_from_obj,
        timestamp_end=timestamp_end_from_obj,
        timestamp_start=timestamp_start_from_obj,
        travel_time=travel_time_from_obj,
        updated=updated_from_obj)


def models_calendar_event_to_jsonable(
        models_calendar_event: ModelsCalendarEvent,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsCalendarEvent.

    :param models_calendar_event: instance of ModelsCalendarEvent to be JSON-ized
    :param path: path to the models_calendar_event used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_calendar_event.auth_account_id is not None:
        res['authAccountID'] = models_calendar_event.auth_account_id

    if models_calendar_event.auth_household_id is not None:
        res['authHouseholdID'] = models_calendar_event.auth_household_id

    if models_calendar_event.calendar_i_calendar_id is not None:
        res['calendarICalendarID'] = models_calendar_event.calendar_i_calendar_id

    if models_calendar_event.color is not None:
        res['color'] = models_calendar_event.color

    if models_calendar_event.created is not None:
        res['created'] = models_calendar_event.created

    if models_calendar_event.date_end is not None:
        res['dateEnd'] = models_calendar_event.date_end

    if models_calendar_event.date_start is not None:
        res['dateStart'] = models_calendar_event.date_start

    if models_calendar_event.details is not None:
        res['details'] = models_calendar_event.details

    if models_calendar_event.duration is not None:
        res['duration'] = models_calendar_event.duration

    if models_calendar_event.i_calendar_u_id is not None:
        res['iCalendarUID'] = models_calendar_event.i_calendar_u_id

    if models_calendar_event.id is not None:
        res['id'] = models_calendar_event.id

    if models_calendar_event.location is not None:
        res['location'] = models_calendar_event.location

    if models_calendar_event.name is not None:
        res['name'] = models_calendar_event.name

    if models_calendar_event.notify_offset is not None:
        res['notifyOffset'] = models_calendar_event.notify_offset

    if models_calendar_event.participants is not None:
        res['participants'] = to_jsonable(
        models_calendar_event.participants,
        expected=[list, str],
        path='{}.participants'.format(path))

    if models_calendar_event.recurrence is not None:
        res['recurrence'] = to_jsonable(
        models_calendar_event.recurrence,
        expected=[TypesRecurrence],
        path='{}.recurrence'.format(path))

    if models_calendar_event.reminders_end is not None:
        res['remindersEnd'] = to_jsonable(
        models_calendar_event.reminders_end,
        expected=[list, int],
        path='{}.remindersEnd'.format(path))

    if models_calendar_event.reminders_start is not None:
        res['remindersStart'] = to_jsonable(
        models_calendar_event.reminders_start,
        expected=[list, int],
        path='{}.remindersStart'.format(path))

    if models_calendar_event.skip_days is not None:
        res['skipDays'] = to_jsonable(
        models_calendar_event.skip_days,
        expected=[list, TypesCivilDate],
        path='{}.skipDays'.format(path))

    if models_calendar_event.time_start is not None:
        res['timeStart'] = models_calendar_event.time_start

    if models_calendar_event.time_zone is not None:
        res['timeZone'] = models_calendar_event.time_zone

    if models_calendar_event.timestamp_end is not None:
        res['timestampEnd'] = models_calendar_event.timestamp_end

    if models_calendar_event.timestamp_start is not None:
        res['timestampStart'] = models_calendar_event.timestamp_start

    if models_calendar_event.travel_time is not None:
        res['travelTime'] = models_calendar_event.travel_time

    if models_calendar_event.updated is not None:
        res['updated'] = models_calendar_event.updated

    return res


class ModelsCalendarICalendar:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            color: Optional[str] = None,
            created: Optional[str] = None,
            ics: Optional[str] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            updated: Optional[str] = None,
            url: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.color = color

        self.created = created

        self.ics = ics

        self.id = id

        # If name is not specified, the ICS will be parsed, CalendarEvents created, but no CalendarICalendar will be created/associated with them.
        self.name = name

        self.updated = updated

        self.url = url

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_calendar_i_calendar_to_jsonable.

        :return: JSON-able representation
        """
        return models_calendar_i_calendar_to_jsonable(self)


def new_models_calendar_i_calendar() -> ModelsCalendarICalendar:
    """Generates an instance of ModelsCalendarICalendar with default values."""
    return ModelsCalendarICalendar()


def models_calendar_i_calendar_from_obj(obj: Any, path: str = "") -> ModelsCalendarICalendar:
    """
    Generates an instance of ModelsCalendarICalendar from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsCalendarICalendar
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsCalendarICalendar
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_color = obj.get('color', None)
    if obj_color is not None:
        color_from_obj = from_obj(
            obj_color,
            expected=[str],
            path=path + '.color')  # type: Optional[str]
    else:
        color_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_ics = obj.get('ics', None)
    if obj_ics is not None:
        ics_from_obj = from_obj(
            obj_ics,
            expected=[str],
            path=path + '.ics')  # type: Optional[str]
    else:
        ics_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    obj_url = obj.get('url', None)
    if obj_url is not None:
        url_from_obj = from_obj(
            obj_url,
            expected=[str],
            path=path + '.url')  # type: Optional[str]
    else:
        url_from_obj = None

    return ModelsCalendarICalendar(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        color=color_from_obj,
        created=created_from_obj,
        ics=ics_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        updated=updated_from_obj,
        url=url_from_obj)


def models_calendar_i_calendar_to_jsonable(
        models_calendar_i_calendar: ModelsCalendarICalendar,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsCalendarICalendar.

    :param models_calendar_i_calendar: instance of ModelsCalendarICalendar to be JSON-ized
    :param path: path to the models_calendar_i_calendar used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_calendar_i_calendar.auth_account_id is not None:
        res['authAccountID'] = models_calendar_i_calendar.auth_account_id

    if models_calendar_i_calendar.auth_household_id is not None:
        res['authHouseholdID'] = models_calendar_i_calendar.auth_household_id

    if models_calendar_i_calendar.color is not None:
        res['color'] = models_calendar_i_calendar.color

    if models_calendar_i_calendar.created is not None:
        res['created'] = models_calendar_i_calendar.created

    if models_calendar_i_calendar.ics is not None:
        res['ics'] = models_calendar_i_calendar.ics

    if models_calendar_i_calendar.id is not None:
        res['id'] = models_calendar_i_calendar.id

    if models_calendar_i_calendar.name is not None:
        res['name'] = models_calendar_i_calendar.name

    if models_calendar_i_calendar.updated is not None:
        res['updated'] = models_calendar_i_calendar.updated

    if models_calendar_i_calendar.url is not None:
        res['url'] = models_calendar_i_calendar.url

    return res


class ModelsChange:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            created: Optional[str] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            operation: Optional[int] = None,
            table_name: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.created = created

        self.id = id

        self.name = name

        self.operation = operation

        self.table_name = table_name

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_change_to_jsonable.

        :return: JSON-able representation
        """
        return models_change_to_jsonable(self)


def new_models_change() -> ModelsChange:
    """Generates an instance of ModelsChange with default values."""
    return ModelsChange()


def models_change_from_obj(obj: Any, path: str = "") -> ModelsChange:
    """
    Generates an instance of ModelsChange from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsChange
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsChange
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_operation = obj.get('operation', None)
    if obj_operation is not None:
        operation_from_obj = from_obj(
            obj_operation,
            expected=[int],
            path=path + '.operation')  # type: Optional[int]
    else:
        operation_from_obj = None

    obj_table_name = obj.get('tableName', None)
    if obj_table_name is not None:
        table_name_from_obj = from_obj(
            obj_table_name,
            expected=[str],
            path=path + '.tableName')  # type: Optional[str]
    else:
        table_name_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsChange(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        created=created_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        operation=operation_from_obj,
        table_name=table_name_from_obj,
        updated=updated_from_obj)


def models_change_to_jsonable(
        models_change: ModelsChange,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsChange.

    :param models_change: instance of ModelsChange to be JSON-ized
    :param path: path to the models_change used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_change.auth_account_id is not None:
        res['authAccountID'] = models_change.auth_account_id

    if models_change.auth_household_id is not None:
        res['authHouseholdID'] = models_change.auth_household_id

    if models_change.created is not None:
        res['created'] = models_change.created

    if models_change.id is not None:
        res['id'] = models_change.id

    if models_change.name is not None:
        res['name'] = models_change.name

    if models_change.operation is not None:
        res['operation'] = models_change.operation

    if models_change.table_name is not None:
        res['tableName'] = models_change.table_name

    if models_change.updated is not None:
        res['updated'] = models_change.updated

    return res


class ModelsColor:
    def __init__(
            self,
            hex_dark: Optional[str] = None,
            hex_light: Optional[str] = None,
            name: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.hex_dark = hex_dark

        self.hex_light = hex_light

        self.name = name

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_color_to_jsonable.

        :return: JSON-able representation
        """
        return models_color_to_jsonable(self)


def new_models_color() -> ModelsColor:
    """Generates an instance of ModelsColor with default values."""
    return ModelsColor()


def models_color_from_obj(obj: Any, path: str = "") -> ModelsColor:
    """
    Generates an instance of ModelsColor from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsColor
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsColor
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_hex_dark = obj.get('hexDark', None)
    if obj_hex_dark is not None:
        hex_dark_from_obj = from_obj(
            obj_hex_dark,
            expected=[str],
            path=path + '.hexDark')  # type: Optional[str]
    else:
        hex_dark_from_obj = None

    obj_hex_light = obj.get('hexLight', None)
    if obj_hex_light is not None:
        hex_light_from_obj = from_obj(
            obj_hex_light,
            expected=[str],
            path=path + '.hexLight')  # type: Optional[str]
    else:
        hex_light_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    return ModelsColor(
        hex_dark=hex_dark_from_obj,
        hex_light=hex_light_from_obj,
        name=name_from_obj)


def models_color_to_jsonable(
        models_color: ModelsColor,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsColor.

    :param models_color: instance of ModelsColor to be JSON-ized
    :param path: path to the models_color used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_color.hex_dark is not None:
        res['hexDark'] = models_color.hex_dark

    if models_color.hex_light is not None:
        res['hexLight'] = models_color.hex_light

    if models_color.name is not None:
        res['name'] = models_color.name

    return res


class ModelsConfigKey:
    def __init__(
            self,
            created: Optional[str] = None,
            key: Optional[str] = None,
            updated: Optional[str] = None,
            value: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.created = created

        self.key = key

        self.updated = updated

        self.value = value

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_config_key_to_jsonable.

        :return: JSON-able representation
        """
        return models_config_key_to_jsonable(self)


def new_models_config_key() -> ModelsConfigKey:
    """Generates an instance of ModelsConfigKey with default values."""
    return ModelsConfigKey()


def models_config_key_from_obj(obj: Any, path: str = "") -> ModelsConfigKey:
    """
    Generates an instance of ModelsConfigKey from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsConfigKey
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsConfigKey
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_key = obj.get('key', None)
    if obj_key is not None:
        key_from_obj = from_obj(
            obj_key,
            expected=[str],
            path=path + '.key')  # type: Optional[str]
    else:
        key_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    obj_value = obj.get('value', None)
    if obj_value is not None:
        value_from_obj = from_obj(
            obj_value,
            expected=[str],
            path=path + '.value')  # type: Optional[str]
    else:
        value_from_obj = None

    return ModelsConfigKey(
        created=created_from_obj,
        key=key_from_obj,
        updated=updated_from_obj,
        value=value_from_obj)


def models_config_key_to_jsonable(
        models_config_key: ModelsConfigKey,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsConfigKey.

    :param models_config_key: instance of ModelsConfigKey to be JSON-ized
    :param path: path to the models_config_key used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_config_key.created is not None:
        res['created'] = models_config_key.created

    if models_config_key.key is not None:
        res['key'] = models_config_key.key

    if models_config_key.updated is not None:
        res['updated'] = models_config_key.updated

    if models_config_key.value is not None:
        res['value'] = models_config_key.value

    return res


class ModelsCookMealPlan:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            budget_payee_id: Optional[str] = None,
            cook_meal_time_id: Optional[str] = None,
            cook_recipe_id: Optional[str] = None,
            cook_recipe_scale: Optional[str] = None,
            created: Optional[str] = None,
            custom_recipe: Optional[str] = None,
            date: Optional[str] = None,
            id: Optional[str] = None,
            notification_time_cook: Optional[str] = None,
            notification_time_leave: Optional[str] = None,
            notification_time_prep: Optional[str] = None,
            time: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.budget_payee_id = budget_payee_id

        self.cook_meal_time_id = cook_meal_time_id

        self.cook_recipe_id = cook_recipe_id

        self.cook_recipe_scale = cook_recipe_scale

        self.created = created

        self.custom_recipe = custom_recipe

        self.date = date

        self.id = id

        self.notification_time_cook = notification_time_cook

        self.notification_time_leave = notification_time_leave

        self.notification_time_prep = notification_time_prep

        self.time = time

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_cook_meal_plan_to_jsonable.

        :return: JSON-able representation
        """
        return models_cook_meal_plan_to_jsonable(self)


def new_models_cook_meal_plan() -> ModelsCookMealPlan:
    """Generates an instance of ModelsCookMealPlan with default values."""
    return ModelsCookMealPlan()


def models_cook_meal_plan_from_obj(obj: Any, path: str = "") -> ModelsCookMealPlan:
    """
    Generates an instance of ModelsCookMealPlan from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsCookMealPlan
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsCookMealPlan
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_payee_id = obj.get('budgetPayeeID', None)
    if obj_budget_payee_id is not None:
        budget_payee_id_from_obj = from_obj(
            obj_budget_payee_id,
            expected=[str],
            path=path + '.budgetPayeeID')  # type: Optional[str]
    else:
        budget_payee_id_from_obj = None

    obj_cook_meal_time_id = obj.get('cookMealTimeID', None)
    if obj_cook_meal_time_id is not None:
        cook_meal_time_id_from_obj = from_obj(
            obj_cook_meal_time_id,
            expected=[str],
            path=path + '.cookMealTimeID')  # type: Optional[str]
    else:
        cook_meal_time_id_from_obj = None

    obj_cook_recipe_id = obj.get('cookRecipeID', None)
    if obj_cook_recipe_id is not None:
        cook_recipe_id_from_obj = from_obj(
            obj_cook_recipe_id,
            expected=[str],
            path=path + '.cookRecipeID')  # type: Optional[str]
    else:
        cook_recipe_id_from_obj = None

    obj_cook_recipe_scale = obj.get('cookRecipeScale', None)
    if obj_cook_recipe_scale is not None:
        cook_recipe_scale_from_obj = from_obj(
            obj_cook_recipe_scale,
            expected=[str],
            path=path + '.cookRecipeScale')  # type: Optional[str]
    else:
        cook_recipe_scale_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_custom_recipe = obj.get('customRecipe', None)
    if obj_custom_recipe is not None:
        custom_recipe_from_obj = from_obj(
            obj_custom_recipe,
            expected=[str],
            path=path + '.customRecipe')  # type: Optional[str]
    else:
        custom_recipe_from_obj = None

    obj_date = obj.get('date', None)
    if obj_date is not None:
        date_from_obj = from_obj(
            obj_date,
            expected=[str],
            path=path + '.date')  # type: Optional[str]
    else:
        date_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_notification_time_cook = obj.get('notificationTimeCook', None)
    if obj_notification_time_cook is not None:
        notification_time_cook_from_obj = from_obj(
            obj_notification_time_cook,
            expected=[str],
            path=path + '.notificationTimeCook')  # type: Optional[str]
    else:
        notification_time_cook_from_obj = None

    obj_notification_time_leave = obj.get('notificationTimeLeave', None)
    if obj_notification_time_leave is not None:
        notification_time_leave_from_obj = from_obj(
            obj_notification_time_leave,
            expected=[str],
            path=path + '.notificationTimeLeave')  # type: Optional[str]
    else:
        notification_time_leave_from_obj = None

    obj_notification_time_prep = obj.get('notificationTimePrep', None)
    if obj_notification_time_prep is not None:
        notification_time_prep_from_obj = from_obj(
            obj_notification_time_prep,
            expected=[str],
            path=path + '.notificationTimePrep')  # type: Optional[str]
    else:
        notification_time_prep_from_obj = None

    obj_time = obj.get('time', None)
    if obj_time is not None:
        time_from_obj = from_obj(
            obj_time,
            expected=[str],
            path=path + '.time')  # type: Optional[str]
    else:
        time_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsCookMealPlan(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        budget_payee_id=budget_payee_id_from_obj,
        cook_meal_time_id=cook_meal_time_id_from_obj,
        cook_recipe_id=cook_recipe_id_from_obj,
        cook_recipe_scale=cook_recipe_scale_from_obj,
        created=created_from_obj,
        custom_recipe=custom_recipe_from_obj,
        date=date_from_obj,
        id=id_from_obj,
        notification_time_cook=notification_time_cook_from_obj,
        notification_time_leave=notification_time_leave_from_obj,
        notification_time_prep=notification_time_prep_from_obj,
        time=time_from_obj,
        updated=updated_from_obj)


def models_cook_meal_plan_to_jsonable(
        models_cook_meal_plan: ModelsCookMealPlan,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsCookMealPlan.

    :param models_cook_meal_plan: instance of ModelsCookMealPlan to be JSON-ized
    :param path: path to the models_cook_meal_plan used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_cook_meal_plan.auth_account_id is not None:
        res['authAccountID'] = models_cook_meal_plan.auth_account_id

    if models_cook_meal_plan.auth_household_id is not None:
        res['authHouseholdID'] = models_cook_meal_plan.auth_household_id

    if models_cook_meal_plan.budget_payee_id is not None:
        res['budgetPayeeID'] = models_cook_meal_plan.budget_payee_id

    if models_cook_meal_plan.cook_meal_time_id is not None:
        res['cookMealTimeID'] = models_cook_meal_plan.cook_meal_time_id

    if models_cook_meal_plan.cook_recipe_id is not None:
        res['cookRecipeID'] = models_cook_meal_plan.cook_recipe_id

    if models_cook_meal_plan.cook_recipe_scale is not None:
        res['cookRecipeScale'] = models_cook_meal_plan.cook_recipe_scale

    if models_cook_meal_plan.created is not None:
        res['created'] = models_cook_meal_plan.created

    if models_cook_meal_plan.custom_recipe is not None:
        res['customRecipe'] = models_cook_meal_plan.custom_recipe

    if models_cook_meal_plan.date is not None:
        res['date'] = models_cook_meal_plan.date

    if models_cook_meal_plan.id is not None:
        res['id'] = models_cook_meal_plan.id

    if models_cook_meal_plan.notification_time_cook is not None:
        res['notificationTimeCook'] = models_cook_meal_plan.notification_time_cook

    if models_cook_meal_plan.notification_time_leave is not None:
        res['notificationTimeLeave'] = models_cook_meal_plan.notification_time_leave

    if models_cook_meal_plan.notification_time_prep is not None:
        res['notificationTimePrep'] = models_cook_meal_plan.notification_time_prep

    if models_cook_meal_plan.time is not None:
        res['time'] = models_cook_meal_plan.time

    if models_cook_meal_plan.updated is not None:
        res['updated'] = models_cook_meal_plan.updated

    return res


class ModelsCookMealTime:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            created: Optional[str] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            time: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.created = created

        self.id = id

        self.name = name

        self.time = time

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_cook_meal_time_to_jsonable.

        :return: JSON-able representation
        """
        return models_cook_meal_time_to_jsonable(self)


def new_models_cook_meal_time() -> ModelsCookMealTime:
    """Generates an instance of ModelsCookMealTime with default values."""
    return ModelsCookMealTime()


def models_cook_meal_time_from_obj(obj: Any, path: str = "") -> ModelsCookMealTime:
    """
    Generates an instance of ModelsCookMealTime from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsCookMealTime
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsCookMealTime
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_time = obj.get('time', None)
    if obj_time is not None:
        time_from_obj = from_obj(
            obj_time,
            expected=[str],
            path=path + '.time')  # type: Optional[str]
    else:
        time_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsCookMealTime(
        auth_household_id=auth_household_id_from_obj,
        created=created_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        time=time_from_obj,
        updated=updated_from_obj)


def models_cook_meal_time_to_jsonable(
        models_cook_meal_time: ModelsCookMealTime,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsCookMealTime.

    :param models_cook_meal_time: instance of ModelsCookMealTime to be JSON-ized
    :param path: path to the models_cook_meal_time used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_cook_meal_time.auth_household_id is not None:
        res['authHouseholdID'] = models_cook_meal_time.auth_household_id

    if models_cook_meal_time.created is not None:
        res['created'] = models_cook_meal_time.created

    if models_cook_meal_time.id is not None:
        res['id'] = models_cook_meal_time.id

    if models_cook_meal_time.name is not None:
        res['name'] = models_cook_meal_time.name

    if models_cook_meal_time.time is not None:
        res['time'] = models_cook_meal_time.time

    if models_cook_meal_time.updated is not None:
        res['updated'] = models_cook_meal_time.updated

    return res


class ModelsCookRecipe:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            complexity: Optional[int] = None,
            cook_meal_plan_count: Optional[int] = None,
            cook_meal_plan_last: Optional[str] = None,
            created: Optional[str] = None,
            deleted: Optional[str] = None,
            directions: Optional[str] = None,
            id: Optional[str] = None,
            image: Optional[str] = None,
            ingredients: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            name: Optional[str] = None,
            notes: Optional[List['ModelsCookRecipeNote']] = None,
            public: Optional[bool] = None,
            rating: Optional[int] = None,
            servings: Optional[str] = None,
            short_id: Optional[str] = None,
            source: Optional[str] = None,
            tags: Optional[List[str]] = None,
            time_cook: Optional[int] = None,
            time_prep: Optional[int] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.complexity = complexity

        self.cook_meal_plan_count = cook_meal_plan_count

        self.cook_meal_plan_last = cook_meal_plan_last

        self.created = created

        self.deleted = deleted

        self.directions = directions

        self.id = id

        self.image = image

        self.ingredients = ingredients

        self.labels_values_ids = labels_values_ids

        self.name = name

        self.notes = notes

        self.public = public

        self.rating = rating

        self.servings = servings

        self.short_id = short_id

        self.source = source

        self.tags = tags

        self.time_cook = time_cook

        self.time_prep = time_prep

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_cook_recipe_to_jsonable.

        :return: JSON-able representation
        """
        return models_cook_recipe_to_jsonable(self)


def new_models_cook_recipe() -> ModelsCookRecipe:
    """Generates an instance of ModelsCookRecipe with default values."""
    return ModelsCookRecipe()


def models_cook_recipe_from_obj(obj: Any, path: str = "") -> ModelsCookRecipe:
    """
    Generates an instance of ModelsCookRecipe from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsCookRecipe
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsCookRecipe
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_complexity = obj.get('complexity', None)
    if obj_complexity is not None:
        complexity_from_obj = from_obj(
            obj_complexity,
            expected=[int],
            path=path + '.complexity')  # type: Optional[int]
    else:
        complexity_from_obj = None

    obj_cook_meal_plan_count = obj.get('cookMealPlanCount', None)
    if obj_cook_meal_plan_count is not None:
        cook_meal_plan_count_from_obj = from_obj(
            obj_cook_meal_plan_count,
            expected=[int],
            path=path + '.cookMealPlanCount')  # type: Optional[int]
    else:
        cook_meal_plan_count_from_obj = None

    obj_cook_meal_plan_last = obj.get('cookMealPlanLast', None)
    if obj_cook_meal_plan_last is not None:
        cook_meal_plan_last_from_obj = from_obj(
            obj_cook_meal_plan_last,
            expected=[str],
            path=path + '.cookMealPlanLast')  # type: Optional[str]
    else:
        cook_meal_plan_last_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_deleted = obj.get('deleted', None)
    if obj_deleted is not None:
        deleted_from_obj = from_obj(
            obj_deleted,
            expected=[str],
            path=path + '.deleted')  # type: Optional[str]
    else:
        deleted_from_obj = None

    obj_directions = obj.get('directions', None)
    if obj_directions is not None:
        directions_from_obj = from_obj(
            obj_directions,
            expected=[str],
            path=path + '.directions')  # type: Optional[str]
    else:
        directions_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_image = obj.get('image', None)
    if obj_image is not None:
        image_from_obj = from_obj(
            obj_image,
            expected=[str],
            path=path + '.image')  # type: Optional[str]
    else:
        image_from_obj = None

    obj_ingredients = obj.get('ingredients', None)
    if obj_ingredients is not None:
        ingredients_from_obj = from_obj(
            obj_ingredients,
            expected=[str],
            path=path + '.ingredients')  # type: Optional[str]
    else:
        ingredients_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_notes = obj.get('notes', None)
    if obj_notes is not None:
        notes_from_obj = from_obj(
            obj_notes,
            expected=[list, ModelsCookRecipeNote],
            path=path + '.notes')  # type: Optional[List['ModelsCookRecipeNote']]
    else:
        notes_from_obj = None

    obj_public = obj.get('public', None)
    if obj_public is not None:
        public_from_obj = from_obj(
            obj_public,
            expected=[bool],
            path=path + '.public')  # type: Optional[bool]
    else:
        public_from_obj = None

    obj_rating = obj.get('rating', None)
    if obj_rating is not None:
        rating_from_obj = from_obj(
            obj_rating,
            expected=[int],
            path=path + '.rating')  # type: Optional[int]
    else:
        rating_from_obj = None

    obj_servings = obj.get('servings', None)
    if obj_servings is not None:
        servings_from_obj = from_obj(
            obj_servings,
            expected=[str],
            path=path + '.servings')  # type: Optional[str]
    else:
        servings_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_source = obj.get('source', None)
    if obj_source is not None:
        source_from_obj = from_obj(
            obj_source,
            expected=[str],
            path=path + '.source')  # type: Optional[str]
    else:
        source_from_obj = None

    obj_tags = obj.get('tags', None)
    if obj_tags is not None:
        tags_from_obj = from_obj(
            obj_tags,
            expected=[list, str],
            path=path + '.tags')  # type: Optional[List[str]]
    else:
        tags_from_obj = None

    obj_time_cook = obj.get('timeCook', None)
    if obj_time_cook is not None:
        time_cook_from_obj = from_obj(
            obj_time_cook,
            expected=[int],
            path=path + '.timeCook')  # type: Optional[int]
    else:
        time_cook_from_obj = None

    obj_time_prep = obj.get('timePrep', None)
    if obj_time_prep is not None:
        time_prep_from_obj = from_obj(
            obj_time_prep,
            expected=[int],
            path=path + '.timePrep')  # type: Optional[int]
    else:
        time_prep_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsCookRecipe(
        auth_household_id=auth_household_id_from_obj,
        complexity=complexity_from_obj,
        cook_meal_plan_count=cook_meal_plan_count_from_obj,
        cook_meal_plan_last=cook_meal_plan_last_from_obj,
        created=created_from_obj,
        deleted=deleted_from_obj,
        directions=directions_from_obj,
        id=id_from_obj,
        image=image_from_obj,
        ingredients=ingredients_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        name=name_from_obj,
        notes=notes_from_obj,
        public=public_from_obj,
        rating=rating_from_obj,
        servings=servings_from_obj,
        short_id=short_id_from_obj,
        source=source_from_obj,
        tags=tags_from_obj,
        time_cook=time_cook_from_obj,
        time_prep=time_prep_from_obj,
        updated=updated_from_obj)


def models_cook_recipe_to_jsonable(
        models_cook_recipe: ModelsCookRecipe,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsCookRecipe.

    :param models_cook_recipe: instance of ModelsCookRecipe to be JSON-ized
    :param path: path to the models_cook_recipe used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_cook_recipe.auth_household_id is not None:
        res['authHouseholdID'] = models_cook_recipe.auth_household_id

    if models_cook_recipe.complexity is not None:
        res['complexity'] = models_cook_recipe.complexity

    if models_cook_recipe.cook_meal_plan_count is not None:
        res['cookMealPlanCount'] = models_cook_recipe.cook_meal_plan_count

    if models_cook_recipe.cook_meal_plan_last is not None:
        res['cookMealPlanLast'] = models_cook_recipe.cook_meal_plan_last

    if models_cook_recipe.created is not None:
        res['created'] = models_cook_recipe.created

    if models_cook_recipe.deleted is not None:
        res['deleted'] = models_cook_recipe.deleted

    if models_cook_recipe.directions is not None:
        res['directions'] = models_cook_recipe.directions

    if models_cook_recipe.id is not None:
        res['id'] = models_cook_recipe.id

    if models_cook_recipe.image is not None:
        res['image'] = models_cook_recipe.image

    if models_cook_recipe.ingredients is not None:
        res['ingredients'] = models_cook_recipe.ingredients

    if models_cook_recipe.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_cook_recipe.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_cook_recipe.name is not None:
        res['name'] = models_cook_recipe.name

    if models_cook_recipe.notes is not None:
        res['notes'] = to_jsonable(
        models_cook_recipe.notes,
        expected=[list, ModelsCookRecipeNote],
        path='{}.notes'.format(path))

    if models_cook_recipe.public is not None:
        res['public'] = models_cook_recipe.public

    if models_cook_recipe.rating is not None:
        res['rating'] = models_cook_recipe.rating

    if models_cook_recipe.servings is not None:
        res['servings'] = models_cook_recipe.servings

    if models_cook_recipe.short_id is not None:
        res['shortID'] = models_cook_recipe.short_id

    if models_cook_recipe.source is not None:
        res['source'] = models_cook_recipe.source

    if models_cook_recipe.tags is not None:
        res['tags'] = to_jsonable(
        models_cook_recipe.tags,
        expected=[list, str],
        path='{}.tags'.format(path))

    if models_cook_recipe.time_cook is not None:
        res['timeCook'] = models_cook_recipe.time_cook

    if models_cook_recipe.time_prep is not None:
        res['timePrep'] = models_cook_recipe.time_prep

    if models_cook_recipe.updated is not None:
        res['updated'] = models_cook_recipe.updated

    return res


class ModelsCookRecipeNote:
    def __init__(
            self,
            complexity: Optional[int] = None,
            date: Optional[Any] = None,
            note: Optional[str] = None,
            rating: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.complexity = complexity

        self.date = date

        self.note = note

        self.rating = rating

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_cook_recipe_note_to_jsonable.

        :return: JSON-able representation
        """
        return models_cook_recipe_note_to_jsonable(self)


def new_models_cook_recipe_note() -> ModelsCookRecipeNote:
    """Generates an instance of ModelsCookRecipeNote with default values."""
    return ModelsCookRecipeNote()


def models_cook_recipe_note_from_obj(obj: Any, path: str = "") -> ModelsCookRecipeNote:
    """
    Generates an instance of ModelsCookRecipeNote from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsCookRecipeNote
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsCookRecipeNote
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_complexity = obj.get('complexity', None)
    if obj_complexity is not None:
        complexity_from_obj = from_obj(
            obj_complexity,
            expected=[int],
            path=path + '.complexity')  # type: Optional[int]
    else:
        complexity_from_obj = None

    date_from_obj = obj.get('date', None)

    obj_note = obj.get('note', None)
    if obj_note is not None:
        note_from_obj = from_obj(
            obj_note,
            expected=[str],
            path=path + '.note')  # type: Optional[str]
    else:
        note_from_obj = None

    obj_rating = obj.get('rating', None)
    if obj_rating is not None:
        rating_from_obj = from_obj(
            obj_rating,
            expected=[int],
            path=path + '.rating')  # type: Optional[int]
    else:
        rating_from_obj = None

    return ModelsCookRecipeNote(
        complexity=complexity_from_obj,
        date=date_from_obj,
        note=note_from_obj,
        rating=rating_from_obj)


def models_cook_recipe_note_to_jsonable(
        models_cook_recipe_note: ModelsCookRecipeNote,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsCookRecipeNote.

    :param models_cook_recipe_note: instance of ModelsCookRecipeNote to be JSON-ized
    :param path: path to the models_cook_recipe_note used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_cook_recipe_note.complexity is not None:
        res['complexity'] = models_cook_recipe_note.complexity

    if models_cook_recipe_note.date is not None:
        res['date'] = models_cook_recipe_note.date

    if models_cook_recipe_note.note is not None:
        res['note'] = models_cook_recipe_note.note

    if models_cook_recipe_note.rating is not None:
        res['rating'] = models_cook_recipe_note.rating

    return res


class ModelsEvent:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            id: Optional[str] = None,
            operation: Optional[int] = None,
            table: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.id = id

        self.operation = operation

        self.table = table

        # Updated is the old timestamp when type EventTypeUpdate.
        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_event_to_jsonable.

        :return: JSON-able representation
        """
        return models_event_to_jsonable(self)


def new_models_event() -> ModelsEvent:
    """Generates an instance of ModelsEvent with default values."""
    return ModelsEvent()


def models_event_from_obj(obj: Any, path: str = "") -> ModelsEvent:
    """
    Generates an instance of ModelsEvent from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsEvent
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsEvent
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_operation = obj.get('operation', None)
    if obj_operation is not None:
        operation_from_obj = from_obj(
            obj_operation,
            expected=[int],
            path=path + '.operation')  # type: Optional[int]
    else:
        operation_from_obj = None

    obj_table = obj.get('table', None)
    if obj_table is not None:
        table_from_obj = from_obj(
            obj_table,
            expected=[str],
            path=path + '.table')  # type: Optional[str]
    else:
        table_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsEvent(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        id=id_from_obj,
        operation=operation_from_obj,
        table=table_from_obj,
        updated=updated_from_obj)


def models_event_to_jsonable(
        models_event: ModelsEvent,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsEvent.

    :param models_event: instance of ModelsEvent to be JSON-ized
    :param path: path to the models_event used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_event.auth_account_id is not None:
        res['authAccountID'] = models_event.auth_account_id

    if models_event.auth_household_id is not None:
        res['authHouseholdID'] = models_event.auth_household_id

    if models_event.id is not None:
        res['id'] = models_event.id

    if models_event.operation is not None:
        res['operation'] = models_event.operation

    if models_event.table is not None:
        res['table'] = models_event.table

    if models_event.updated is not None:
        res['updated'] = models_event.updated

    return res


class ModelsFeatureCandidate:
    def __init__(
            self,
            created: Optional[str] = None,
            feature_votes: Optional[List['ModelsFeatureVote']] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            updated: Optional[str] = None,
            wanted: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.created = created

        self.feature_votes = feature_votes

        self.id = id

        self.name = name

        self.updated = updated

        self.wanted = wanted

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_feature_candidate_to_jsonable.

        :return: JSON-able representation
        """
        return models_feature_candidate_to_jsonable(self)


def new_models_feature_candidate() -> ModelsFeatureCandidate:
    """Generates an instance of ModelsFeatureCandidate with default values."""
    return ModelsFeatureCandidate()


def models_feature_candidate_from_obj(obj: Any, path: str = "") -> ModelsFeatureCandidate:
    """
    Generates an instance of ModelsFeatureCandidate from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsFeatureCandidate
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsFeatureCandidate
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_feature_votes = obj.get('featureVotes', None)
    if obj_feature_votes is not None:
        feature_votes_from_obj = from_obj(
            obj_feature_votes,
            expected=[list, ModelsFeatureVote],
            path=path + '.featureVotes')  # type: Optional[List['ModelsFeatureVote']]
    else:
        feature_votes_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    obj_wanted = obj.get('wanted', None)
    if obj_wanted is not None:
        wanted_from_obj = from_obj(
            obj_wanted,
            expected=[int],
            path=path + '.wanted')  # type: Optional[int]
    else:
        wanted_from_obj = None

    return ModelsFeatureCandidate(
        created=created_from_obj,
        feature_votes=feature_votes_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        updated=updated_from_obj,
        wanted=wanted_from_obj)


def models_feature_candidate_to_jsonable(
        models_feature_candidate: ModelsFeatureCandidate,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsFeatureCandidate.

    :param models_feature_candidate: instance of ModelsFeatureCandidate to be JSON-ized
    :param path: path to the models_feature_candidate used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_feature_candidate.created is not None:
        res['created'] = models_feature_candidate.created

    if models_feature_candidate.feature_votes is not None:
        res['featureVotes'] = to_jsonable(
        models_feature_candidate.feature_votes,
        expected=[list, ModelsFeatureVote],
        path='{}.featureVotes'.format(path))

    if models_feature_candidate.id is not None:
        res['id'] = models_feature_candidate.id

    if models_feature_candidate.name is not None:
        res['name'] = models_feature_candidate.name

    if models_feature_candidate.updated is not None:
        res['updated'] = models_feature_candidate.updated

    if models_feature_candidate.wanted is not None:
        res['wanted'] = models_feature_candidate.wanted

    return res


class ModelsFeatureVote:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            comment: Optional[str] = None,
            created: Optional[str] = None,
            email_address: Optional[str] = None,
            feature_candidate_id: Optional[str] = None,
            id: Optional[str] = None,
            updated: Optional[str] = None,
            wanted: Optional[bool] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.comment = comment

        self.created = created

        self.email_address = email_address

        self.feature_candidate_id = feature_candidate_id

        self.id = id

        self.updated = updated

        self.wanted = wanted

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_feature_vote_to_jsonable.

        :return: JSON-able representation
        """
        return models_feature_vote_to_jsonable(self)


def new_models_feature_vote() -> ModelsFeatureVote:
    """Generates an instance of ModelsFeatureVote with default values."""
    return ModelsFeatureVote()


def models_feature_vote_from_obj(obj: Any, path: str = "") -> ModelsFeatureVote:
    """
    Generates an instance of ModelsFeatureVote from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsFeatureVote
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsFeatureVote
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_comment = obj.get('comment', None)
    if obj_comment is not None:
        comment_from_obj = from_obj(
            obj_comment,
            expected=[str],
            path=path + '.comment')  # type: Optional[str]
    else:
        comment_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_email_address = obj.get('emailAddress', None)
    if obj_email_address is not None:
        email_address_from_obj = from_obj(
            obj_email_address,
            expected=[str],
            path=path + '.emailAddress')  # type: Optional[str]
    else:
        email_address_from_obj = None

    obj_feature_candidate_id = obj.get('featureCandidateID', None)
    if obj_feature_candidate_id is not None:
        feature_candidate_id_from_obj = from_obj(
            obj_feature_candidate_id,
            expected=[str],
            path=path + '.featureCandidateID')  # type: Optional[str]
    else:
        feature_candidate_id_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    obj_wanted = obj.get('wanted', None)
    if obj_wanted is not None:
        wanted_from_obj = from_obj(
            obj_wanted,
            expected=[bool],
            path=path + '.wanted')  # type: Optional[bool]
    else:
        wanted_from_obj = None

    return ModelsFeatureVote(
        auth_household_id=auth_household_id_from_obj,
        comment=comment_from_obj,
        created=created_from_obj,
        email_address=email_address_from_obj,
        feature_candidate_id=feature_candidate_id_from_obj,
        id=id_from_obj,
        updated=updated_from_obj,
        wanted=wanted_from_obj)


def models_feature_vote_to_jsonable(
        models_feature_vote: ModelsFeatureVote,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsFeatureVote.

    :param models_feature_vote: instance of ModelsFeatureVote to be JSON-ized
    :param path: path to the models_feature_vote used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_feature_vote.auth_household_id is not None:
        res['authHouseholdID'] = models_feature_vote.auth_household_id

    if models_feature_vote.comment is not None:
        res['comment'] = models_feature_vote.comment

    if models_feature_vote.created is not None:
        res['created'] = models_feature_vote.created

    if models_feature_vote.email_address is not None:
        res['emailAddress'] = models_feature_vote.email_address

    if models_feature_vote.feature_candidate_id is not None:
        res['featureCandidateID'] = models_feature_vote.feature_candidate_id

    if models_feature_vote.id is not None:
        res['id'] = models_feature_vote.id

    if models_feature_vote.updated is not None:
        res['updated'] = models_feature_vote.updated

    if models_feature_vote.wanted is not None:
        res['wanted'] = models_feature_vote.wanted

    return res


class ModelsHealthItem:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            color: Optional[str] = None,
            correlations: Optional[Dict[str, int]] = None,
            created: Optional[str] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            output: Optional[bool] = None,
            total_correlations: Optional[int] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.color = color

        self.correlations = correlations

        self.created = created

        self.icon = icon

        self.id = id

        self.name = name

        self.output = output

        self.total_correlations = total_correlations

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_health_item_to_jsonable.

        :return: JSON-able representation
        """
        return models_health_item_to_jsonable(self)


def new_models_health_item() -> ModelsHealthItem:
    """Generates an instance of ModelsHealthItem with default values."""
    return ModelsHealthItem()


def models_health_item_from_obj(obj: Any, path: str = "") -> ModelsHealthItem:
    """
    Generates an instance of ModelsHealthItem from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsHealthItem
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsHealthItem
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_color = obj.get('color', None)
    if obj_color is not None:
        color_from_obj = from_obj(
            obj_color,
            expected=[str],
            path=path + '.color')  # type: Optional[str]
    else:
        color_from_obj = None

    obj_correlations = obj.get('correlations', None)
    if obj_correlations is not None:
        correlations_from_obj = from_obj(
            obj_correlations,
            expected=[dict, int],
            path=path + '.correlations')  # type: Optional[Dict[str, int]]
    else:
        correlations_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_output = obj.get('output', None)
    if obj_output is not None:
        output_from_obj = from_obj(
            obj_output,
            expected=[bool],
            path=path + '.output')  # type: Optional[bool]
    else:
        output_from_obj = None

    obj_total_correlations = obj.get('totalCorrelations', None)
    if obj_total_correlations is not None:
        total_correlations_from_obj = from_obj(
            obj_total_correlations,
            expected=[int],
            path=path + '.totalCorrelations')  # type: Optional[int]
    else:
        total_correlations_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsHealthItem(
        auth_account_id=auth_account_id_from_obj,
        color=color_from_obj,
        correlations=correlations_from_obj,
        created=created_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        output=output_from_obj,
        total_correlations=total_correlations_from_obj,
        updated=updated_from_obj)


def models_health_item_to_jsonable(
        models_health_item: ModelsHealthItem,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsHealthItem.

    :param models_health_item: instance of ModelsHealthItem to be JSON-ized
    :param path: path to the models_health_item used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_health_item.auth_account_id is not None:
        res['authAccountID'] = models_health_item.auth_account_id

    if models_health_item.color is not None:
        res['color'] = models_health_item.color

    if models_health_item.correlations is not None:
        res['correlations'] = to_jsonable(
        models_health_item.correlations,
        expected=[dict, int],
        path='{}.correlations'.format(path))

    if models_health_item.created is not None:
        res['created'] = models_health_item.created

    if models_health_item.icon is not None:
        res['icon'] = models_health_item.icon

    if models_health_item.id is not None:
        res['id'] = models_health_item.id

    if models_health_item.name is not None:
        res['name'] = models_health_item.name

    if models_health_item.output is not None:
        res['output'] = models_health_item.output

    if models_health_item.total_correlations is not None:
        res['totalCorrelations'] = models_health_item.total_correlations

    if models_health_item.updated is not None:
        res['updated'] = models_health_item.updated

    return res


class ModelsHealthLogItem:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            created: Optional[str] = None,
            date: Optional[str] = None,
            health_item_id: Optional[str] = None,
            id: Optional[str] = None,
            timestamp: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.created = created

        # Deprecated: use Timestamp
        #
        # TODO remove 2026-02-21
        self.date = date

        self.health_item_id = health_item_id

        self.id = id

        self.timestamp = timestamp

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_health_log_item_to_jsonable.

        :return: JSON-able representation
        """
        return models_health_log_item_to_jsonable(self)


def new_models_health_log_item() -> ModelsHealthLogItem:
    """Generates an instance of ModelsHealthLogItem with default values."""
    return ModelsHealthLogItem()


def models_health_log_item_from_obj(obj: Any, path: str = "") -> ModelsHealthLogItem:
    """
    Generates an instance of ModelsHealthLogItem from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsHealthLogItem
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsHealthLogItem
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_date = obj.get('date', None)
    if obj_date is not None:
        date_from_obj = from_obj(
            obj_date,
            expected=[str],
            path=path + '.date')  # type: Optional[str]
    else:
        date_from_obj = None

    obj_health_item_id = obj.get('healthItemID', None)
    if obj_health_item_id is not None:
        health_item_id_from_obj = from_obj(
            obj_health_item_id,
            expected=[str],
            path=path + '.healthItemID')  # type: Optional[str]
    else:
        health_item_id_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_timestamp = obj.get('timestamp', None)
    if obj_timestamp is not None:
        timestamp_from_obj = from_obj(
            obj_timestamp,
            expected=[str],
            path=path + '.timestamp')  # type: Optional[str]
    else:
        timestamp_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsHealthLogItem(
        auth_account_id=auth_account_id_from_obj,
        created=created_from_obj,
        date=date_from_obj,
        health_item_id=health_item_id_from_obj,
        id=id_from_obj,
        timestamp=timestamp_from_obj,
        updated=updated_from_obj)


def models_health_log_item_to_jsonable(
        models_health_log_item: ModelsHealthLogItem,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsHealthLogItem.

    :param models_health_log_item: instance of ModelsHealthLogItem to be JSON-ized
    :param path: path to the models_health_log_item used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_health_log_item.auth_account_id is not None:
        res['authAccountID'] = models_health_log_item.auth_account_id

    if models_health_log_item.created is not None:
        res['created'] = models_health_log_item.created

    if models_health_log_item.date is not None:
        res['date'] = models_health_log_item.date

    if models_health_log_item.health_item_id is not None:
        res['healthItemID'] = models_health_log_item.health_item_id

    if models_health_log_item.id is not None:
        res['id'] = models_health_log_item.id

    if models_health_log_item.timestamp is not None:
        res['timestamp'] = models_health_log_item.timestamp

    if models_health_log_item.updated is not None:
        res['updated'] = models_health_log_item.updated

    return res


class ModelsInventoryCollection:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            columns: Optional[Dict[str, str]] = None,
            created: Optional[str] = None,
            grouping: Optional[str] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            name: Optional[str] = None,
            short_id: Optional[str] = None,
            sort: Optional['ModelsInventoryCollectionSort'] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.columns = columns

        self.created = created

        self.grouping = grouping

        self.icon = icon

        self.id = id

        self.labels_values_ids = labels_values_ids

        self.name = name

        self.short_id = short_id

        self.sort = sort

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_inventory_collection_to_jsonable.

        :return: JSON-able representation
        """
        return models_inventory_collection_to_jsonable(self)


def new_models_inventory_collection() -> ModelsInventoryCollection:
    """Generates an instance of ModelsInventoryCollection with default values."""
    return ModelsInventoryCollection()


def models_inventory_collection_from_obj(obj: Any, path: str = "") -> ModelsInventoryCollection:
    """
    Generates an instance of ModelsInventoryCollection from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsInventoryCollection
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsInventoryCollection
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_columns = obj.get('columns', None)
    if obj_columns is not None:
        columns_from_obj = from_obj(
            obj_columns,
            expected=[dict, str],
            path=path + '.columns')  # type: Optional[Dict[str, str]]
    else:
        columns_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_grouping = obj.get('grouping', None)
    if obj_grouping is not None:
        grouping_from_obj = from_obj(
            obj_grouping,
            expected=[str],
            path=path + '.grouping')  # type: Optional[str]
    else:
        grouping_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_sort = obj.get('sort', None)
    if obj_sort is not None:
        sort_from_obj = from_obj(
            obj_sort,
            expected=[ModelsInventoryCollectionSort],
            path=path + '.sort')  # type: Optional['ModelsInventoryCollectionSort']
    else:
        sort_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsInventoryCollection(
        auth_household_id=auth_household_id_from_obj,
        columns=columns_from_obj,
        created=created_from_obj,
        grouping=grouping_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        name=name_from_obj,
        short_id=short_id_from_obj,
        sort=sort_from_obj,
        updated=updated_from_obj)


def models_inventory_collection_to_jsonable(
        models_inventory_collection: ModelsInventoryCollection,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsInventoryCollection.

    :param models_inventory_collection: instance of ModelsInventoryCollection to be JSON-ized
    :param path: path to the models_inventory_collection used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_inventory_collection.auth_household_id is not None:
        res['authHouseholdID'] = models_inventory_collection.auth_household_id

    if models_inventory_collection.columns is not None:
        res['columns'] = to_jsonable(
        models_inventory_collection.columns,
        expected=[dict, str],
        path='{}.columns'.format(path))

    if models_inventory_collection.created is not None:
        res['created'] = models_inventory_collection.created

    if models_inventory_collection.grouping is not None:
        res['grouping'] = models_inventory_collection.grouping

    if models_inventory_collection.icon is not None:
        res['icon'] = models_inventory_collection.icon

    if models_inventory_collection.id is not None:
        res['id'] = models_inventory_collection.id

    if models_inventory_collection.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_inventory_collection.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_inventory_collection.name is not None:
        res['name'] = models_inventory_collection.name

    if models_inventory_collection.short_id is not None:
        res['shortID'] = models_inventory_collection.short_id

    if models_inventory_collection.sort is not None:
        res['sort'] = to_jsonable(
        models_inventory_collection.sort,
        expected=[ModelsInventoryCollectionSort],
        path='{}.sort'.format(path))

    if models_inventory_collection.updated is not None:
        res['updated'] = models_inventory_collection.updated

    return res


class ModelsInventoryCollectionSort:
    def __init__(
            self,
            invert: Optional[bool] = None,
            property: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.invert = invert

        self.property = property

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_inventory_collection_sort_to_jsonable.

        :return: JSON-able representation
        """
        return models_inventory_collection_sort_to_jsonable(self)


def new_models_inventory_collection_sort() -> ModelsInventoryCollectionSort:
    """Generates an instance of ModelsInventoryCollectionSort with default values."""
    return ModelsInventoryCollectionSort()


def models_inventory_collection_sort_from_obj(obj: Any, path: str = "") -> ModelsInventoryCollectionSort:
    """
    Generates an instance of ModelsInventoryCollectionSort from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsInventoryCollectionSort
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsInventoryCollectionSort
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_invert = obj.get('invert', None)
    if obj_invert is not None:
        invert_from_obj = from_obj(
            obj_invert,
            expected=[bool],
            path=path + '.invert')  # type: Optional[bool]
    else:
        invert_from_obj = None

    obj_property = obj.get('property', None)
    if obj_property is not None:
        property_from_obj = from_obj(
            obj_property,
            expected=[str],
            path=path + '.property')  # type: Optional[str]
    else:
        property_from_obj = None

    return ModelsInventoryCollectionSort(
        invert=invert_from_obj,
        property=property_from_obj)


def models_inventory_collection_sort_to_jsonable(
        models_inventory_collection_sort: ModelsInventoryCollectionSort,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsInventoryCollectionSort.

    :param models_inventory_collection_sort: instance of ModelsInventoryCollectionSort to be JSON-ized
    :param path: path to the models_inventory_collection_sort used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_inventory_collection_sort.invert is not None:
        res['invert'] = models_inventory_collection_sort.invert

    if models_inventory_collection_sort.property is not None:
        res['property'] = models_inventory_collection_sort.property

    return res


class ModelsInventoryItem:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            created: Optional[str] = None,
            expiration: Optional[str] = None,
            id: Optional[str] = None,
            image: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            last_purchased: Optional[str] = None,
            name: Optional[str] = None,
            properties: Optional[Dict[str, str]] = None,
            quantity: Optional[int] = None,
            short_id: Optional[str] = None,
            upc: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.created = created

        self.expiration = expiration

        self.id = id

        self.image = image

        self.labels_values_ids = labels_values_ids

        self.last_purchased = last_purchased

        self.name = name

        self.properties = properties

        self.quantity = quantity

        self.short_id = short_id

        self.upc = upc

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_inventory_item_to_jsonable.

        :return: JSON-able representation
        """
        return models_inventory_item_to_jsonable(self)


def new_models_inventory_item() -> ModelsInventoryItem:
    """Generates an instance of ModelsInventoryItem with default values."""
    return ModelsInventoryItem()


def models_inventory_item_from_obj(obj: Any, path: str = "") -> ModelsInventoryItem:
    """
    Generates an instance of ModelsInventoryItem from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsInventoryItem
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsInventoryItem
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_expiration = obj.get('expiration', None)
    if obj_expiration is not None:
        expiration_from_obj = from_obj(
            obj_expiration,
            expected=[str],
            path=path + '.expiration')  # type: Optional[str]
    else:
        expiration_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_image = obj.get('image', None)
    if obj_image is not None:
        image_from_obj = from_obj(
            obj_image,
            expected=[str],
            path=path + '.image')  # type: Optional[str]
    else:
        image_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_last_purchased = obj.get('lastPurchased', None)
    if obj_last_purchased is not None:
        last_purchased_from_obj = from_obj(
            obj_last_purchased,
            expected=[str],
            path=path + '.lastPurchased')  # type: Optional[str]
    else:
        last_purchased_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_properties = obj.get('properties', None)
    if obj_properties is not None:
        properties_from_obj = from_obj(
            obj_properties,
            expected=[dict, str],
            path=path + '.properties')  # type: Optional[Dict[str, str]]
    else:
        properties_from_obj = None

    obj_quantity = obj.get('quantity', None)
    if obj_quantity is not None:
        quantity_from_obj = from_obj(
            obj_quantity,
            expected=[int],
            path=path + '.quantity')  # type: Optional[int]
    else:
        quantity_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_upc = obj.get('upc', None)
    if obj_upc is not None:
        upc_from_obj = from_obj(
            obj_upc,
            expected=[str],
            path=path + '.upc')  # type: Optional[str]
    else:
        upc_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsInventoryItem(
        auth_household_id=auth_household_id_from_obj,
        created=created_from_obj,
        expiration=expiration_from_obj,
        id=id_from_obj,
        image=image_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        last_purchased=last_purchased_from_obj,
        name=name_from_obj,
        properties=properties_from_obj,
        quantity=quantity_from_obj,
        short_id=short_id_from_obj,
        upc=upc_from_obj,
        updated=updated_from_obj)


def models_inventory_item_to_jsonable(
        models_inventory_item: ModelsInventoryItem,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsInventoryItem.

    :param models_inventory_item: instance of ModelsInventoryItem to be JSON-ized
    :param path: path to the models_inventory_item used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_inventory_item.auth_household_id is not None:
        res['authHouseholdID'] = models_inventory_item.auth_household_id

    if models_inventory_item.created is not None:
        res['created'] = models_inventory_item.created

    if models_inventory_item.expiration is not None:
        res['expiration'] = models_inventory_item.expiration

    if models_inventory_item.id is not None:
        res['id'] = models_inventory_item.id

    if models_inventory_item.image is not None:
        res['image'] = models_inventory_item.image

    if models_inventory_item.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_inventory_item.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_inventory_item.last_purchased is not None:
        res['lastPurchased'] = models_inventory_item.last_purchased

    if models_inventory_item.name is not None:
        res['name'] = models_inventory_item.name

    if models_inventory_item.properties is not None:
        res['properties'] = to_jsonable(
        models_inventory_item.properties,
        expected=[dict, str],
        path='{}.properties'.format(path))

    if models_inventory_item.quantity is not None:
        res['quantity'] = models_inventory_item.quantity

    if models_inventory_item.short_id is not None:
        res['shortID'] = models_inventory_item.short_id

    if models_inventory_item.upc is not None:
        res['upc'] = models_inventory_item.upc

    if models_inventory_item.updated is not None:
        res['updated'] = models_inventory_item.updated

    return res


class ModelsLabelsValue:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            color: Optional[str] = None,
            created: Optional[str] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.color = color

        self.created = created

        self.id = id

        self.name = name

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_labels_value_to_jsonable.

        :return: JSON-able representation
        """
        return models_labels_value_to_jsonable(self)


def new_models_labels_value() -> ModelsLabelsValue:
    """Generates an instance of ModelsLabelsValue with default values."""
    return ModelsLabelsValue()


def models_labels_value_from_obj(obj: Any, path: str = "") -> ModelsLabelsValue:
    """
    Generates an instance of ModelsLabelsValue from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsLabelsValue
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsLabelsValue
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_color = obj.get('color', None)
    if obj_color is not None:
        color_from_obj = from_obj(
            obj_color,
            expected=[str],
            path=path + '.color')  # type: Optional[str]
    else:
        color_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsLabelsValue(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        color=color_from_obj,
        created=created_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        updated=updated_from_obj)


def models_labels_value_to_jsonable(
        models_labels_value: ModelsLabelsValue,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsLabelsValue.

    :param models_labels_value: instance of ModelsLabelsValue to be JSON-ized
    :param path: path to the models_labels_value used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_labels_value.auth_account_id is not None:
        res['authAccountID'] = models_labels_value.auth_account_id

    if models_labels_value.auth_household_id is not None:
        res['authHouseholdID'] = models_labels_value.auth_household_id

    if models_labels_value.color is not None:
        res['color'] = models_labels_value.color

    if models_labels_value.created is not None:
        res['created'] = models_labels_value.created

    if models_labels_value.id is not None:
        res['id'] = models_labels_value.id

    if models_labels_value.name is not None:
        res['name'] = models_labels_value.name

    if models_labels_value.updated is not None:
        res['updated'] = models_labels_value.updated

    return res


class ModelsNotesPage:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            color: Optional[str] = None,
            created: Optional[str] = None,
            deleted: Optional[str] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            name: Optional[str] = None,
            parent_id: Optional[str] = None,
            short_id: Optional[str] = None,
            tags: Optional[List[str]] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.color = color

        self.created = created

        self.deleted = deleted

        self.icon = icon

        self.id = id

        self.labels_values_ids = labels_values_ids

        self.name = name

        self.parent_id = parent_id

        self.short_id = short_id

        self.tags = tags

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_notes_page_to_jsonable.

        :return: JSON-able representation
        """
        return models_notes_page_to_jsonable(self)


def new_models_notes_page() -> ModelsNotesPage:
    """Generates an instance of ModelsNotesPage with default values."""
    return ModelsNotesPage()


def models_notes_page_from_obj(obj: Any, path: str = "") -> ModelsNotesPage:
    """
    Generates an instance of ModelsNotesPage from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsNotesPage
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsNotesPage
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_color = obj.get('color', None)
    if obj_color is not None:
        color_from_obj = from_obj(
            obj_color,
            expected=[str],
            path=path + '.color')  # type: Optional[str]
    else:
        color_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_deleted = obj.get('deleted', None)
    if obj_deleted is not None:
        deleted_from_obj = from_obj(
            obj_deleted,
            expected=[str],
            path=path + '.deleted')  # type: Optional[str]
    else:
        deleted_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_parent_id = obj.get('parentID', None)
    if obj_parent_id is not None:
        parent_id_from_obj = from_obj(
            obj_parent_id,
            expected=[str],
            path=path + '.parentID')  # type: Optional[str]
    else:
        parent_id_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_tags = obj.get('tags', None)
    if obj_tags is not None:
        tags_from_obj = from_obj(
            obj_tags,
            expected=[list, str],
            path=path + '.tags')  # type: Optional[List[str]]
    else:
        tags_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsNotesPage(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        color=color_from_obj,
        created=created_from_obj,
        deleted=deleted_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        name=name_from_obj,
        parent_id=parent_id_from_obj,
        short_id=short_id_from_obj,
        tags=tags_from_obj,
        updated=updated_from_obj)


def models_notes_page_to_jsonable(
        models_notes_page: ModelsNotesPage,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsNotesPage.

    :param models_notes_page: instance of ModelsNotesPage to be JSON-ized
    :param path: path to the models_notes_page used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_notes_page.auth_account_id is not None:
        res['authAccountID'] = models_notes_page.auth_account_id

    if models_notes_page.auth_household_id is not None:
        res['authHouseholdID'] = models_notes_page.auth_household_id

    if models_notes_page.color is not None:
        res['color'] = models_notes_page.color

    if models_notes_page.created is not None:
        res['created'] = models_notes_page.created

    if models_notes_page.deleted is not None:
        res['deleted'] = models_notes_page.deleted

    if models_notes_page.icon is not None:
        res['icon'] = models_notes_page.icon

    if models_notes_page.id is not None:
        res['id'] = models_notes_page.id

    if models_notes_page.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_notes_page.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_notes_page.name is not None:
        res['name'] = models_notes_page.name

    if models_notes_page.parent_id is not None:
        res['parentID'] = models_notes_page.parent_id

    if models_notes_page.short_id is not None:
        res['shortID'] = models_notes_page.short_id

    if models_notes_page.tags is not None:
        res['tags'] = to_jsonable(
        models_notes_page.tags,
        expected=[list, str],
        path='{}.tags'.format(path))

    if models_notes_page.updated is not None:
        res['updated'] = models_notes_page.updated

    return res


class ModelsNotesPageVersion:
    def __init__(
            self,
            body: Optional[str] = None,
            created_by: Optional[str] = None,
            id: Optional[str] = None,
            notes_page_id: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.body = body

        # Updated is technically the created field, but the existing merge and query code uses updated and it's hard to justify duplicating all that code for a semantic change.  Alternatively, having a created and updated field seems very redundant as they will always be equal.
        self.created_by = created_by

        self.id = id

        self.notes_page_id = notes_page_id

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_notes_page_version_to_jsonable.

        :return: JSON-able representation
        """
        return models_notes_page_version_to_jsonable(self)


def new_models_notes_page_version() -> ModelsNotesPageVersion:
    """Generates an instance of ModelsNotesPageVersion with default values."""
    return ModelsNotesPageVersion()


def models_notes_page_version_from_obj(obj: Any, path: str = "") -> ModelsNotesPageVersion:
    """
    Generates an instance of ModelsNotesPageVersion from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsNotesPageVersion
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsNotesPageVersion
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_body = obj.get('body', None)
    if obj_body is not None:
        body_from_obj = from_obj(
            obj_body,
            expected=[str],
            path=path + '.body')  # type: Optional[str]
    else:
        body_from_obj = None

    obj_created_by = obj.get('createdBy', None)
    if obj_created_by is not None:
        created_by_from_obj = from_obj(
            obj_created_by,
            expected=[str],
            path=path + '.createdBy')  # type: Optional[str]
    else:
        created_by_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_notes_page_id = obj.get('notesPageID', None)
    if obj_notes_page_id is not None:
        notes_page_id_from_obj = from_obj(
            obj_notes_page_id,
            expected=[str],
            path=path + '.notesPageID')  # type: Optional[str]
    else:
        notes_page_id_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsNotesPageVersion(
        body=body_from_obj,
        created_by=created_by_from_obj,
        id=id_from_obj,
        notes_page_id=notes_page_id_from_obj,
        updated=updated_from_obj)


def models_notes_page_version_to_jsonable(
        models_notes_page_version: ModelsNotesPageVersion,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsNotesPageVersion.

    :param models_notes_page_version: instance of ModelsNotesPageVersion to be JSON-ized
    :param path: path to the models_notes_page_version used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_notes_page_version.body is not None:
        res['body'] = models_notes_page_version.body

    if models_notes_page_version.created_by is not None:
        res['createdBy'] = models_notes_page_version.created_by

    if models_notes_page_version.id is not None:
        res['id'] = models_notes_page_version.id

    if models_notes_page_version.notes_page_id is not None:
        res['notesPageID'] = models_notes_page_version.notes_page_id

    if models_notes_page_version.updated is not None:
        res['updated'] = models_notes_page_version.updated

    return res


class ModelsPermissions:
    def __init__(
            self,
            auth: Optional[int] = None,
            bookmarks: Optional[int] = None,
            budget: Optional[int] = None,
            calendar: Optional[int] = None,
            cook: Optional[int] = None,
            health: Optional[int] = None,
            inventory: Optional[int] = None,
            notes: Optional[int] = None,
            plan: Optional[int] = None,
            reward: Optional[int] = None,
            secrets: Optional[int] = None,
            shop: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.auth = auth

        self.bookmarks = bookmarks

        self.budget = budget

        self.calendar = calendar

        self.cook = cook

        self.health = health

        self.inventory = inventory

        self.notes = notes

        self.plan = plan

        self.reward = reward

        self.secrets = secrets

        self.shop = shop

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_permissions_to_jsonable.

        :return: JSON-able representation
        """
        return models_permissions_to_jsonable(self)


def new_models_permissions() -> ModelsPermissions:
    """Generates an instance of ModelsPermissions with default values."""
    return ModelsPermissions()


def models_permissions_from_obj(obj: Any, path: str = "") -> ModelsPermissions:
    """
    Generates an instance of ModelsPermissions from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsPermissions
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsPermissions
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth = obj.get('auth', None)
    if obj_auth is not None:
        auth_from_obj = from_obj(
            obj_auth,
            expected=[int],
            path=path + '.auth')  # type: Optional[int]
    else:
        auth_from_obj = None

    obj_bookmarks = obj.get('bookmarks', None)
    if obj_bookmarks is not None:
        bookmarks_from_obj = from_obj(
            obj_bookmarks,
            expected=[int],
            path=path + '.bookmarks')  # type: Optional[int]
    else:
        bookmarks_from_obj = None

    obj_budget = obj.get('budget', None)
    if obj_budget is not None:
        budget_from_obj = from_obj(
            obj_budget,
            expected=[int],
            path=path + '.budget')  # type: Optional[int]
    else:
        budget_from_obj = None

    obj_calendar = obj.get('calendar', None)
    if obj_calendar is not None:
        calendar_from_obj = from_obj(
            obj_calendar,
            expected=[int],
            path=path + '.calendar')  # type: Optional[int]
    else:
        calendar_from_obj = None

    obj_cook = obj.get('cook', None)
    if obj_cook is not None:
        cook_from_obj = from_obj(
            obj_cook,
            expected=[int],
            path=path + '.cook')  # type: Optional[int]
    else:
        cook_from_obj = None

    obj_health = obj.get('health', None)
    if obj_health is not None:
        health_from_obj = from_obj(
            obj_health,
            expected=[int],
            path=path + '.health')  # type: Optional[int]
    else:
        health_from_obj = None

    obj_inventory = obj.get('inventory', None)
    if obj_inventory is not None:
        inventory_from_obj = from_obj(
            obj_inventory,
            expected=[int],
            path=path + '.inventory')  # type: Optional[int]
    else:
        inventory_from_obj = None

    obj_notes = obj.get('notes', None)
    if obj_notes is not None:
        notes_from_obj = from_obj(
            obj_notes,
            expected=[int],
            path=path + '.notes')  # type: Optional[int]
    else:
        notes_from_obj = None

    obj_plan = obj.get('plan', None)
    if obj_plan is not None:
        plan_from_obj = from_obj(
            obj_plan,
            expected=[int],
            path=path + '.plan')  # type: Optional[int]
    else:
        plan_from_obj = None

    obj_reward = obj.get('reward', None)
    if obj_reward is not None:
        reward_from_obj = from_obj(
            obj_reward,
            expected=[int],
            path=path + '.reward')  # type: Optional[int]
    else:
        reward_from_obj = None

    obj_secrets = obj.get('secrets', None)
    if obj_secrets is not None:
        secrets_from_obj = from_obj(
            obj_secrets,
            expected=[int],
            path=path + '.secrets')  # type: Optional[int]
    else:
        secrets_from_obj = None

    obj_shop = obj.get('shop', None)
    if obj_shop is not None:
        shop_from_obj = from_obj(
            obj_shop,
            expected=[int],
            path=path + '.shop')  # type: Optional[int]
    else:
        shop_from_obj = None

    return ModelsPermissions(
        auth=auth_from_obj,
        bookmarks=bookmarks_from_obj,
        budget=budget_from_obj,
        calendar=calendar_from_obj,
        cook=cook_from_obj,
        health=health_from_obj,
        inventory=inventory_from_obj,
        notes=notes_from_obj,
        plan=plan_from_obj,
        reward=reward_from_obj,
        secrets=secrets_from_obj,
        shop=shop_from_obj)


def models_permissions_to_jsonable(
        models_permissions: ModelsPermissions,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsPermissions.

    :param models_permissions: instance of ModelsPermissions to be JSON-ized
    :param path: path to the models_permissions used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_permissions.auth is not None:
        res['auth'] = models_permissions.auth

    if models_permissions.bookmarks is not None:
        res['bookmarks'] = models_permissions.bookmarks

    if models_permissions.budget is not None:
        res['budget'] = models_permissions.budget

    if models_permissions.calendar is not None:
        res['calendar'] = models_permissions.calendar

    if models_permissions.cook is not None:
        res['cook'] = models_permissions.cook

    if models_permissions.health is not None:
        res['health'] = models_permissions.health

    if models_permissions.inventory is not None:
        res['inventory'] = models_permissions.inventory

    if models_permissions.notes is not None:
        res['notes'] = models_permissions.notes

    if models_permissions.plan is not None:
        res['plan'] = models_permissions.plan

    if models_permissions.reward is not None:
        res['reward'] = models_permissions.reward

    if models_permissions.secrets is not None:
        res['secrets'] = models_permissions.secrets

    if models_permissions.shop is not None:
        res['shop'] = models_permissions.shop

    return res


class ModelsPlanProject:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            budget_category_id: Optional[str] = None,
            color: Optional[str] = None,
            created: Optional[str] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            name: Optional[str] = None,
            parent_id: Optional[str] = None,
            plan_task_count: Optional[int] = None,
            plan_task_sort: Optional[str] = None,
            position: Optional[str] = None,
            shop_item_count: Optional[int] = None,
            short_id: Optional[str] = None,
            tags: Optional[List[str]] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.budget_category_id = budget_category_id

        self.color = color

        self.created = created

        self.icon = icon

        self.id = id

        self.labels_values_ids = labels_values_ids

        self.name = name

        self.parent_id = parent_id

        self.plan_task_count = plan_task_count

        self.plan_task_sort = plan_task_sort

        self.position = position

        self.shop_item_count = shop_item_count

        self.short_id = short_id

        self.tags = tags

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_plan_project_to_jsonable.

        :return: JSON-able representation
        """
        return models_plan_project_to_jsonable(self)


def new_models_plan_project() -> ModelsPlanProject:
    """Generates an instance of ModelsPlanProject with default values."""
    return ModelsPlanProject()


def models_plan_project_from_obj(obj: Any, path: str = "") -> ModelsPlanProject:
    """
    Generates an instance of ModelsPlanProject from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsPlanProject
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsPlanProject
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_category_id = obj.get('budgetCategoryID', None)
    if obj_budget_category_id is not None:
        budget_category_id_from_obj = from_obj(
            obj_budget_category_id,
            expected=[str],
            path=path + '.budgetCategoryID')  # type: Optional[str]
    else:
        budget_category_id_from_obj = None

    obj_color = obj.get('color', None)
    if obj_color is not None:
        color_from_obj = from_obj(
            obj_color,
            expected=[str],
            path=path + '.color')  # type: Optional[str]
    else:
        color_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_parent_id = obj.get('parentID', None)
    if obj_parent_id is not None:
        parent_id_from_obj = from_obj(
            obj_parent_id,
            expected=[str],
            path=path + '.parentID')  # type: Optional[str]
    else:
        parent_id_from_obj = None

    obj_plan_task_count = obj.get('planTaskCount', None)
    if obj_plan_task_count is not None:
        plan_task_count_from_obj = from_obj(
            obj_plan_task_count,
            expected=[int],
            path=path + '.planTaskCount')  # type: Optional[int]
    else:
        plan_task_count_from_obj = None

    obj_plan_task_sort = obj.get('planTaskSort', None)
    if obj_plan_task_sort is not None:
        plan_task_sort_from_obj = from_obj(
            obj_plan_task_sort,
            expected=[str],
            path=path + '.planTaskSort')  # type: Optional[str]
    else:
        plan_task_sort_from_obj = None

    obj_position = obj.get('position', None)
    if obj_position is not None:
        position_from_obj = from_obj(
            obj_position,
            expected=[str],
            path=path + '.position')  # type: Optional[str]
    else:
        position_from_obj = None

    obj_shop_item_count = obj.get('shopItemCount', None)
    if obj_shop_item_count is not None:
        shop_item_count_from_obj = from_obj(
            obj_shop_item_count,
            expected=[int],
            path=path + '.shopItemCount')  # type: Optional[int]
    else:
        shop_item_count_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_tags = obj.get('tags', None)
    if obj_tags is not None:
        tags_from_obj = from_obj(
            obj_tags,
            expected=[list, str],
            path=path + '.tags')  # type: Optional[List[str]]
    else:
        tags_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsPlanProject(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        budget_category_id=budget_category_id_from_obj,
        color=color_from_obj,
        created=created_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        name=name_from_obj,
        parent_id=parent_id_from_obj,
        plan_task_count=plan_task_count_from_obj,
        plan_task_sort=plan_task_sort_from_obj,
        position=position_from_obj,
        shop_item_count=shop_item_count_from_obj,
        short_id=short_id_from_obj,
        tags=tags_from_obj,
        updated=updated_from_obj)


def models_plan_project_to_jsonable(
        models_plan_project: ModelsPlanProject,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsPlanProject.

    :param models_plan_project: instance of ModelsPlanProject to be JSON-ized
    :param path: path to the models_plan_project used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_plan_project.auth_account_id is not None:
        res['authAccountID'] = models_plan_project.auth_account_id

    if models_plan_project.auth_household_id is not None:
        res['authHouseholdID'] = models_plan_project.auth_household_id

    if models_plan_project.budget_category_id is not None:
        res['budgetCategoryID'] = models_plan_project.budget_category_id

    if models_plan_project.color is not None:
        res['color'] = models_plan_project.color

    if models_plan_project.created is not None:
        res['created'] = models_plan_project.created

    if models_plan_project.icon is not None:
        res['icon'] = models_plan_project.icon

    if models_plan_project.id is not None:
        res['id'] = models_plan_project.id

    if models_plan_project.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_plan_project.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_plan_project.name is not None:
        res['name'] = models_plan_project.name

    if models_plan_project.parent_id is not None:
        res['parentID'] = models_plan_project.parent_id

    if models_plan_project.plan_task_count is not None:
        res['planTaskCount'] = models_plan_project.plan_task_count

    if models_plan_project.plan_task_sort is not None:
        res['planTaskSort'] = models_plan_project.plan_task_sort

    if models_plan_project.position is not None:
        res['position'] = models_plan_project.position

    if models_plan_project.shop_item_count is not None:
        res['shopItemCount'] = models_plan_project.shop_item_count

    if models_plan_project.short_id is not None:
        res['shortID'] = models_plan_project.short_id

    if models_plan_project.tags is not None:
        res['tags'] = to_jsonable(
        models_plan_project.tags,
        expected=[list, str],
        path='{}.tags'.format(path))

    if models_plan_project.updated is not None:
        res['updated'] = models_plan_project.updated

    return res


class ModelsPlanTask:
    def __init__(
            self,
            assignees: Optional[List[str]] = None,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            color: Optional[str] = None,
            created: Optional[str] = None,
            date_end: Optional[str] = None,
            details: Optional[str] = None,
            done: Optional[bool] = None,
            due_date: Optional[str] = None,
            duration: Optional[int] = None,
            id: Optional[str] = None,
            inventory_item_id: Optional[str] = None,
            last_done_by: Optional[str] = None,
            last_done_date: Optional['TypesCivilDate'] = None,
            name: Optional[str] = None,
            notify: Optional[bool] = None,
            parent_id: Optional[str] = None,
            plan_project_id: Optional[str] = None,
            position: Optional[str] = None,
            recur_on_done: Optional[bool] = None,
            recurrence: Optional['TypesRecurrence'] = None,
            short_id: Optional[str] = None,
            tags: Optional[List[str]] = None,
            template: Optional[bool] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.assignees = assignees

        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.color = color

        self.created = created

        # Deprecated: use Recurrence.End
        #
        # TODO remove 2026-05-06
        self.date_end = date_end

        self.details = details

        self.done = done

        self.due_date = due_date

        self.duration = duration

        self.id = id

        self.inventory_item_id = inventory_item_id

        self.last_done_by = last_done_by

        self.last_done_date = last_done_date

        self.name = name

        self.notify = notify

        self.parent_id = parent_id

        self.plan_project_id = plan_project_id

        self.position = position

        self.recur_on_done = recur_on_done

        self.recurrence = recurrence

        self.short_id = short_id

        self.tags = tags

        self.template = template

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_plan_task_to_jsonable.

        :return: JSON-able representation
        """
        return models_plan_task_to_jsonable(self)


def new_models_plan_task() -> ModelsPlanTask:
    """Generates an instance of ModelsPlanTask with default values."""
    return ModelsPlanTask()


def models_plan_task_from_obj(obj: Any, path: str = "") -> ModelsPlanTask:
    """
    Generates an instance of ModelsPlanTask from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsPlanTask
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsPlanTask
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_assignees = obj.get('assignees', None)
    if obj_assignees is not None:
        assignees_from_obj = from_obj(
            obj_assignees,
            expected=[list, str],
            path=path + '.assignees')  # type: Optional[List[str]]
    else:
        assignees_from_obj = None

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_color = obj.get('color', None)
    if obj_color is not None:
        color_from_obj = from_obj(
            obj_color,
            expected=[str],
            path=path + '.color')  # type: Optional[str]
    else:
        color_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_date_end = obj.get('dateEnd', None)
    if obj_date_end is not None:
        date_end_from_obj = from_obj(
            obj_date_end,
            expected=[str],
            path=path + '.dateEnd')  # type: Optional[str]
    else:
        date_end_from_obj = None

    obj_details = obj.get('details', None)
    if obj_details is not None:
        details_from_obj = from_obj(
            obj_details,
            expected=[str],
            path=path + '.details')  # type: Optional[str]
    else:
        details_from_obj = None

    obj_done = obj.get('done', None)
    if obj_done is not None:
        done_from_obj = from_obj(
            obj_done,
            expected=[bool],
            path=path + '.done')  # type: Optional[bool]
    else:
        done_from_obj = None

    obj_due_date = obj.get('dueDate', None)
    if obj_due_date is not None:
        due_date_from_obj = from_obj(
            obj_due_date,
            expected=[str],
            path=path + '.dueDate')  # type: Optional[str]
    else:
        due_date_from_obj = None

    obj_duration = obj.get('duration', None)
    if obj_duration is not None:
        duration_from_obj = from_obj(
            obj_duration,
            expected=[int],
            path=path + '.duration')  # type: Optional[int]
    else:
        duration_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_inventory_item_id = obj.get('inventoryItemID', None)
    if obj_inventory_item_id is not None:
        inventory_item_id_from_obj = from_obj(
            obj_inventory_item_id,
            expected=[str],
            path=path + '.inventoryItemID')  # type: Optional[str]
    else:
        inventory_item_id_from_obj = None

    obj_last_done_by = obj.get('lastDoneBy', None)
    if obj_last_done_by is not None:
        last_done_by_from_obj = from_obj(
            obj_last_done_by,
            expected=[str],
            path=path + '.lastDoneBy')  # type: Optional[str]
    else:
        last_done_by_from_obj = None

    obj_last_done_date = obj.get('lastDoneDate', None)
    if obj_last_done_date is not None:
        last_done_date_from_obj = from_obj(
            obj_last_done_date,
            expected=[TypesCivilDate],
            path=path + '.lastDoneDate')  # type: Optional['TypesCivilDate']
    else:
        last_done_date_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_notify = obj.get('notify', None)
    if obj_notify is not None:
        notify_from_obj = from_obj(
            obj_notify,
            expected=[bool],
            path=path + '.notify')  # type: Optional[bool]
    else:
        notify_from_obj = None

    obj_parent_id = obj.get('parentID', None)
    if obj_parent_id is not None:
        parent_id_from_obj = from_obj(
            obj_parent_id,
            expected=[str],
            path=path + '.parentID')  # type: Optional[str]
    else:
        parent_id_from_obj = None

    obj_plan_project_id = obj.get('planProjectID', None)
    if obj_plan_project_id is not None:
        plan_project_id_from_obj = from_obj(
            obj_plan_project_id,
            expected=[str],
            path=path + '.planProjectID')  # type: Optional[str]
    else:
        plan_project_id_from_obj = None

    obj_position = obj.get('position', None)
    if obj_position is not None:
        position_from_obj = from_obj(
            obj_position,
            expected=[str],
            path=path + '.position')  # type: Optional[str]
    else:
        position_from_obj = None

    obj_recur_on_done = obj.get('recurOnDone', None)
    if obj_recur_on_done is not None:
        recur_on_done_from_obj = from_obj(
            obj_recur_on_done,
            expected=[bool],
            path=path + '.recurOnDone')  # type: Optional[bool]
    else:
        recur_on_done_from_obj = None

    obj_recurrence = obj.get('recurrence', None)
    if obj_recurrence is not None:
        recurrence_from_obj = from_obj(
            obj_recurrence,
            expected=[TypesRecurrence],
            path=path + '.recurrence')  # type: Optional['TypesRecurrence']
    else:
        recurrence_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_tags = obj.get('tags', None)
    if obj_tags is not None:
        tags_from_obj = from_obj(
            obj_tags,
            expected=[list, str],
            path=path + '.tags')  # type: Optional[List[str]]
    else:
        tags_from_obj = None

    obj_template = obj.get('template', None)
    if obj_template is not None:
        template_from_obj = from_obj(
            obj_template,
            expected=[bool],
            path=path + '.template')  # type: Optional[bool]
    else:
        template_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsPlanTask(
        assignees=assignees_from_obj,
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        color=color_from_obj,
        created=created_from_obj,
        date_end=date_end_from_obj,
        details=details_from_obj,
        done=done_from_obj,
        due_date=due_date_from_obj,
        duration=duration_from_obj,
        id=id_from_obj,
        inventory_item_id=inventory_item_id_from_obj,
        last_done_by=last_done_by_from_obj,
        last_done_date=last_done_date_from_obj,
        name=name_from_obj,
        notify=notify_from_obj,
        parent_id=parent_id_from_obj,
        plan_project_id=plan_project_id_from_obj,
        position=position_from_obj,
        recur_on_done=recur_on_done_from_obj,
        recurrence=recurrence_from_obj,
        short_id=short_id_from_obj,
        tags=tags_from_obj,
        template=template_from_obj,
        updated=updated_from_obj)


def models_plan_task_to_jsonable(
        models_plan_task: ModelsPlanTask,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsPlanTask.

    :param models_plan_task: instance of ModelsPlanTask to be JSON-ized
    :param path: path to the models_plan_task used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_plan_task.assignees is not None:
        res['assignees'] = to_jsonable(
        models_plan_task.assignees,
        expected=[list, str],
        path='{}.assignees'.format(path))

    if models_plan_task.auth_account_id is not None:
        res['authAccountID'] = models_plan_task.auth_account_id

    if models_plan_task.auth_household_id is not None:
        res['authHouseholdID'] = models_plan_task.auth_household_id

    if models_plan_task.color is not None:
        res['color'] = models_plan_task.color

    if models_plan_task.created is not None:
        res['created'] = models_plan_task.created

    if models_plan_task.date_end is not None:
        res['dateEnd'] = models_plan_task.date_end

    if models_plan_task.details is not None:
        res['details'] = models_plan_task.details

    if models_plan_task.done is not None:
        res['done'] = models_plan_task.done

    if models_plan_task.due_date is not None:
        res['dueDate'] = models_plan_task.due_date

    if models_plan_task.duration is not None:
        res['duration'] = models_plan_task.duration

    if models_plan_task.id is not None:
        res['id'] = models_plan_task.id

    if models_plan_task.inventory_item_id is not None:
        res['inventoryItemID'] = models_plan_task.inventory_item_id

    if models_plan_task.last_done_by is not None:
        res['lastDoneBy'] = models_plan_task.last_done_by

    if models_plan_task.last_done_date is not None:
        res['lastDoneDate'] = to_jsonable(
        models_plan_task.last_done_date,
        expected=[TypesCivilDate],
        path='{}.lastDoneDate'.format(path))

    if models_plan_task.name is not None:
        res['name'] = models_plan_task.name

    if models_plan_task.notify is not None:
        res['notify'] = models_plan_task.notify

    if models_plan_task.parent_id is not None:
        res['parentID'] = models_plan_task.parent_id

    if models_plan_task.plan_project_id is not None:
        res['planProjectID'] = models_plan_task.plan_project_id

    if models_plan_task.position is not None:
        res['position'] = models_plan_task.position

    if models_plan_task.recur_on_done is not None:
        res['recurOnDone'] = models_plan_task.recur_on_done

    if models_plan_task.recurrence is not None:
        res['recurrence'] = to_jsonable(
        models_plan_task.recurrence,
        expected=[TypesRecurrence],
        path='{}.recurrence'.format(path))

    if models_plan_task.short_id is not None:
        res['shortID'] = models_plan_task.short_id

    if models_plan_task.tags is not None:
        res['tags'] = to_jsonable(
        models_plan_task.tags,
        expected=[list, str],
        path='{}.tags'.format(path))

    if models_plan_task.template is not None:
        res['template'] = models_plan_task.template

    if models_plan_task.updated is not None:
        res['updated'] = models_plan_task.updated

    return res


class ModelsRewardCard:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            created: Optional[str] = None,
            details: Optional[str] = None,
            id: Optional[str] = None,
            invert: Optional[bool] = None,
            name: Optional[str] = None,
            recipients: Optional[List[str]] = None,
            reward: Optional[str] = None,
            senders: Optional[List[str]] = None,
            short_id: Optional[str] = None,
            stamp_count: Optional[int] = None,
            stamp_goal: Optional[int] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.created = created

        self.details = details

        self.id = id

        self.invert = invert

        self.name = name

        self.recipients = recipients

        self.reward = reward

        self.senders = senders

        self.short_id = short_id

        self.stamp_count = stamp_count

        self.stamp_goal = stamp_goal

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_reward_card_to_jsonable.

        :return: JSON-able representation
        """
        return models_reward_card_to_jsonable(self)


def new_models_reward_card() -> ModelsRewardCard:
    """Generates an instance of ModelsRewardCard with default values."""
    return ModelsRewardCard()


def models_reward_card_from_obj(obj: Any, path: str = "") -> ModelsRewardCard:
    """
    Generates an instance of ModelsRewardCard from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsRewardCard
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsRewardCard
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_details = obj.get('details', None)
    if obj_details is not None:
        details_from_obj = from_obj(
            obj_details,
            expected=[str],
            path=path + '.details')  # type: Optional[str]
    else:
        details_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_invert = obj.get('invert', None)
    if obj_invert is not None:
        invert_from_obj = from_obj(
            obj_invert,
            expected=[bool],
            path=path + '.invert')  # type: Optional[bool]
    else:
        invert_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_recipients = obj.get('recipients', None)
    if obj_recipients is not None:
        recipients_from_obj = from_obj(
            obj_recipients,
            expected=[list, str],
            path=path + '.recipients')  # type: Optional[List[str]]
    else:
        recipients_from_obj = None

    obj_reward = obj.get('reward', None)
    if obj_reward is not None:
        reward_from_obj = from_obj(
            obj_reward,
            expected=[str],
            path=path + '.reward')  # type: Optional[str]
    else:
        reward_from_obj = None

    obj_senders = obj.get('senders', None)
    if obj_senders is not None:
        senders_from_obj = from_obj(
            obj_senders,
            expected=[list, str],
            path=path + '.senders')  # type: Optional[List[str]]
    else:
        senders_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_stamp_count = obj.get('stampCount', None)
    if obj_stamp_count is not None:
        stamp_count_from_obj = from_obj(
            obj_stamp_count,
            expected=[int],
            path=path + '.stampCount')  # type: Optional[int]
    else:
        stamp_count_from_obj = None

    obj_stamp_goal = obj.get('stampGoal', None)
    if obj_stamp_goal is not None:
        stamp_goal_from_obj = from_obj(
            obj_stamp_goal,
            expected=[int],
            path=path + '.stampGoal')  # type: Optional[int]
    else:
        stamp_goal_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsRewardCard(
        auth_household_id=auth_household_id_from_obj,
        created=created_from_obj,
        details=details_from_obj,
        id=id_from_obj,
        invert=invert_from_obj,
        name=name_from_obj,
        recipients=recipients_from_obj,
        reward=reward_from_obj,
        senders=senders_from_obj,
        short_id=short_id_from_obj,
        stamp_count=stamp_count_from_obj,
        stamp_goal=stamp_goal_from_obj,
        updated=updated_from_obj)


def models_reward_card_to_jsonable(
        models_reward_card: ModelsRewardCard,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsRewardCard.

    :param models_reward_card: instance of ModelsRewardCard to be JSON-ized
    :param path: path to the models_reward_card used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_reward_card.auth_household_id is not None:
        res['authHouseholdID'] = models_reward_card.auth_household_id

    if models_reward_card.created is not None:
        res['created'] = models_reward_card.created

    if models_reward_card.details is not None:
        res['details'] = models_reward_card.details

    if models_reward_card.id is not None:
        res['id'] = models_reward_card.id

    if models_reward_card.invert is not None:
        res['invert'] = models_reward_card.invert

    if models_reward_card.name is not None:
        res['name'] = models_reward_card.name

    if models_reward_card.recipients is not None:
        res['recipients'] = to_jsonable(
        models_reward_card.recipients,
        expected=[list, str],
        path='{}.recipients'.format(path))

    if models_reward_card.reward is not None:
        res['reward'] = models_reward_card.reward

    if models_reward_card.senders is not None:
        res['senders'] = to_jsonable(
        models_reward_card.senders,
        expected=[list, str],
        path='{}.senders'.format(path))

    if models_reward_card.short_id is not None:
        res['shortID'] = models_reward_card.short_id

    if models_reward_card.stamp_count is not None:
        res['stampCount'] = models_reward_card.stamp_count

    if models_reward_card.stamp_goal is not None:
        res['stampGoal'] = models_reward_card.stamp_goal

    if models_reward_card.updated is not None:
        res['updated'] = models_reward_card.updated

    return res


class ModelsSecretsValue:
    def __init__(
            self,
            data_encrypted: Optional[List['CryptolibEncryptedValue']] = None,
            deleted: Optional[str] = None,
            id: Optional[str] = None,
            name_encrypted: Optional['CryptolibEncryptedValue'] = None,
            secrets_vault_id: Optional[str] = None,
            short_id: Optional[str] = None,
            tags_encrypted: Optional['CryptolibEncryptedValue'] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.data_encrypted = data_encrypted

        self.deleted = deleted

        self.id = id

        self.name_encrypted = name_encrypted

        self.secrets_vault_id = secrets_vault_id

        self.short_id = short_id

        self.tags_encrypted = tags_encrypted

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_secrets_value_to_jsonable.

        :return: JSON-able representation
        """
        return models_secrets_value_to_jsonable(self)


def new_models_secrets_value() -> ModelsSecretsValue:
    """Generates an instance of ModelsSecretsValue with default values."""
    return ModelsSecretsValue()


def models_secrets_value_from_obj(obj: Any, path: str = "") -> ModelsSecretsValue:
    """
    Generates an instance of ModelsSecretsValue from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsSecretsValue
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsSecretsValue
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_data_encrypted = obj.get('dataEncrypted', None)
    if obj_data_encrypted is not None:
        data_encrypted_from_obj = from_obj(
            obj_data_encrypted,
            expected=[list, CryptolibEncryptedValue],
            path=path + '.dataEncrypted')  # type: Optional[List['CryptolibEncryptedValue']]
    else:
        data_encrypted_from_obj = None

    obj_deleted = obj.get('deleted', None)
    if obj_deleted is not None:
        deleted_from_obj = from_obj(
            obj_deleted,
            expected=[str],
            path=path + '.deleted')  # type: Optional[str]
    else:
        deleted_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name_encrypted = obj.get('nameEncrypted', None)
    if obj_name_encrypted is not None:
        name_encrypted_from_obj = from_obj(
            obj_name_encrypted,
            expected=[CryptolibEncryptedValue],
            path=path + '.nameEncrypted')  # type: Optional['CryptolibEncryptedValue']
    else:
        name_encrypted_from_obj = None

    obj_secrets_vault_id = obj.get('secretsVaultID', None)
    if obj_secrets_vault_id is not None:
        secrets_vault_id_from_obj = from_obj(
            obj_secrets_vault_id,
            expected=[str],
            path=path + '.secretsVaultID')  # type: Optional[str]
    else:
        secrets_vault_id_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_tags_encrypted = obj.get('tagsEncrypted', None)
    if obj_tags_encrypted is not None:
        tags_encrypted_from_obj = from_obj(
            obj_tags_encrypted,
            expected=[CryptolibEncryptedValue],
            path=path + '.tagsEncrypted')  # type: Optional['CryptolibEncryptedValue']
    else:
        tags_encrypted_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsSecretsValue(
        data_encrypted=data_encrypted_from_obj,
        deleted=deleted_from_obj,
        id=id_from_obj,
        name_encrypted=name_encrypted_from_obj,
        secrets_vault_id=secrets_vault_id_from_obj,
        short_id=short_id_from_obj,
        tags_encrypted=tags_encrypted_from_obj,
        updated=updated_from_obj)


def models_secrets_value_to_jsonable(
        models_secrets_value: ModelsSecretsValue,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsSecretsValue.

    :param models_secrets_value: instance of ModelsSecretsValue to be JSON-ized
    :param path: path to the models_secrets_value used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_secrets_value.data_encrypted is not None:
        res['dataEncrypted'] = to_jsonable(
        models_secrets_value.data_encrypted,
        expected=[list, CryptolibEncryptedValue],
        path='{}.dataEncrypted'.format(path))

    if models_secrets_value.deleted is not None:
        res['deleted'] = models_secrets_value.deleted

    if models_secrets_value.id is not None:
        res['id'] = models_secrets_value.id

    if models_secrets_value.name_encrypted is not None:
        res['nameEncrypted'] = to_jsonable(
        models_secrets_value.name_encrypted,
        expected=[CryptolibEncryptedValue],
        path='{}.nameEncrypted'.format(path))

    if models_secrets_value.secrets_vault_id is not None:
        res['secretsVaultID'] = models_secrets_value.secrets_vault_id

    if models_secrets_value.short_id is not None:
        res['shortID'] = models_secrets_value.short_id

    if models_secrets_value.tags_encrypted is not None:
        res['tagsEncrypted'] = to_jsonable(
        models_secrets_value.tags_encrypted,
        expected=[CryptolibEncryptedValue],
        path='{}.tagsEncrypted'.format(path))

    if models_secrets_value.updated is not None:
        res['updated'] = models_secrets_value.updated

    return res


class ModelsSecretsVault:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            created: Optional[str] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            keys: Optional[List['ModelsSecretsVaultKey']] = None,
            name: Optional[str] = None,
            short_id: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.created = created

        self.icon = icon

        self.id = id

        self.keys = keys

        self.name = name

        self.short_id = short_id

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_secrets_vault_to_jsonable.

        :return: JSON-able representation
        """
        return models_secrets_vault_to_jsonable(self)


def new_models_secrets_vault() -> ModelsSecretsVault:
    """Generates an instance of ModelsSecretsVault with default values."""
    return ModelsSecretsVault()


def models_secrets_vault_from_obj(obj: Any, path: str = "") -> ModelsSecretsVault:
    """
    Generates an instance of ModelsSecretsVault from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsSecretsVault
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsSecretsVault
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_keys = obj.get('keys', None)
    if obj_keys is not None:
        keys_from_obj = from_obj(
            obj_keys,
            expected=[list, ModelsSecretsVaultKey],
            path=path + '.keys')  # type: Optional[List['ModelsSecretsVaultKey']]
    else:
        keys_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsSecretsVault(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        created=created_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        keys=keys_from_obj,
        name=name_from_obj,
        short_id=short_id_from_obj,
        updated=updated_from_obj)


def models_secrets_vault_to_jsonable(
        models_secrets_vault: ModelsSecretsVault,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsSecretsVault.

    :param models_secrets_vault: instance of ModelsSecretsVault to be JSON-ized
    :param path: path to the models_secrets_vault used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_secrets_vault.auth_account_id is not None:
        res['authAccountID'] = models_secrets_vault.auth_account_id

    if models_secrets_vault.auth_household_id is not None:
        res['authHouseholdID'] = models_secrets_vault.auth_household_id

    if models_secrets_vault.created is not None:
        res['created'] = models_secrets_vault.created

    if models_secrets_vault.icon is not None:
        res['icon'] = models_secrets_vault.icon

    if models_secrets_vault.id is not None:
        res['id'] = models_secrets_vault.id

    if models_secrets_vault.keys is not None:
        res['keys'] = to_jsonable(
        models_secrets_vault.keys,
        expected=[list, ModelsSecretsVaultKey],
        path='{}.keys'.format(path))

    if models_secrets_vault.name is not None:
        res['name'] = models_secrets_vault.name

    if models_secrets_vault.short_id is not None:
        res['shortID'] = models_secrets_vault.short_id

    if models_secrets_vault.updated is not None:
        res['updated'] = models_secrets_vault.updated

    return res


class ModelsSecretsVaultKey:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            key: Optional['CryptolibEncryptedValue'] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.key = key

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_secrets_vault_key_to_jsonable.

        :return: JSON-able representation
        """
        return models_secrets_vault_key_to_jsonable(self)


def new_models_secrets_vault_key() -> ModelsSecretsVaultKey:
    """Generates an instance of ModelsSecretsVaultKey with default values."""
    return ModelsSecretsVaultKey()


def models_secrets_vault_key_from_obj(obj: Any, path: str = "") -> ModelsSecretsVaultKey:
    """
    Generates an instance of ModelsSecretsVaultKey from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsSecretsVaultKey
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsSecretsVaultKey
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_key = obj.get('key', None)
    if obj_key is not None:
        key_from_obj = from_obj(
            obj_key,
            expected=[CryptolibEncryptedValue],
            path=path + '.key')  # type: Optional['CryptolibEncryptedValue']
    else:
        key_from_obj = None

    return ModelsSecretsVaultKey(
        auth_account_id=auth_account_id_from_obj,
        key=key_from_obj)


def models_secrets_vault_key_to_jsonable(
        models_secrets_vault_key: ModelsSecretsVaultKey,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsSecretsVaultKey.

    :param models_secrets_vault_key: instance of ModelsSecretsVaultKey to be JSON-ized
    :param path: path to the models_secrets_vault_key used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_secrets_vault_key.auth_account_id is not None:
        res['authAccountID'] = models_secrets_vault_key.auth_account_id

    if models_secrets_vault_key.key is not None:
        res['key'] = to_jsonable(
        models_secrets_vault_key.key,
        expected=[CryptolibEncryptedValue],
        path='{}.key'.format(path))

    return res


class ModelsShopCategory:
    def __init__(
            self,
            auth_household_id: Optional[str] = None,
            budget_payee_id: Optional[str] = None,
            created: Optional[str] = None,
            id: Optional[str] = None,
            match: Optional[str] = None,
            name: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_household_id = auth_household_id

        self.budget_payee_id = budget_payee_id

        self.created = created

        self.id = id

        self.match = match

        self.name = name

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_shop_category_to_jsonable.

        :return: JSON-able representation
        """
        return models_shop_category_to_jsonable(self)


def new_models_shop_category() -> ModelsShopCategory:
    """Generates an instance of ModelsShopCategory with default values."""
    return ModelsShopCategory()


def models_shop_category_from_obj(obj: Any, path: str = "") -> ModelsShopCategory:
    """
    Generates an instance of ModelsShopCategory from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsShopCategory
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsShopCategory
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_payee_id = obj.get('budgetPayeeID', None)
    if obj_budget_payee_id is not None:
        budget_payee_id_from_obj = from_obj(
            obj_budget_payee_id,
            expected=[str],
            path=path + '.budgetPayeeID')  # type: Optional[str]
    else:
        budget_payee_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_match = obj.get('match', None)
    if obj_match is not None:
        match_from_obj = from_obj(
            obj_match,
            expected=[str],
            path=path + '.match')  # type: Optional[str]
    else:
        match_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsShopCategory(
        auth_household_id=auth_household_id_from_obj,
        budget_payee_id=budget_payee_id_from_obj,
        created=created_from_obj,
        id=id_from_obj,
        match=match_from_obj,
        name=name_from_obj,
        updated=updated_from_obj)


def models_shop_category_to_jsonable(
        models_shop_category: ModelsShopCategory,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsShopCategory.

    :param models_shop_category: instance of ModelsShopCategory to be JSON-ized
    :param path: path to the models_shop_category used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_shop_category.auth_household_id is not None:
        res['authHouseholdID'] = models_shop_category.auth_household_id

    if models_shop_category.budget_payee_id is not None:
        res['budgetPayeeID'] = models_shop_category.budget_payee_id

    if models_shop_category.created is not None:
        res['created'] = models_shop_category.created

    if models_shop_category.id is not None:
        res['id'] = models_shop_category.id

    if models_shop_category.match is not None:
        res['match'] = models_shop_category.match

    if models_shop_category.name is not None:
        res['name'] = models_shop_category.name

    if models_shop_category.updated is not None:
        res['updated'] = models_shop_category.updated

    return res


class ModelsShopItem:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            budget_payee_id: Optional[str] = None,
            cook_meal_plan_id: Optional[str] = None,
            cook_recipe_id: Optional[str] = None,
            created: Optional[str] = None,
            id: Optional[str] = None,
            in_cart: Optional[bool] = None,
            name: Optional[str] = None,
            next_date: Optional[str] = None,
            plan_project_id: Optional[str] = None,
            position: Optional[str] = None,
            price: Optional[int] = None,
            recurrence: Optional['TypesRecurrence'] = None,
            shop_category_id: Optional[str] = None,
            shop_list_id: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.budget_payee_id = budget_payee_id

        self.cook_meal_plan_id = cook_meal_plan_id

        self.cook_recipe_id = cook_recipe_id

        self.created = created

        self.id = id

        self.in_cart = in_cart

        self.name = name

        self.next_date = next_date

        self.plan_project_id = plan_project_id

        self.position = position

        self.price = price

        self.recurrence = recurrence

        self.shop_category_id = shop_category_id

        self.shop_list_id = shop_list_id

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_shop_item_to_jsonable.

        :return: JSON-able representation
        """
        return models_shop_item_to_jsonable(self)


def new_models_shop_item() -> ModelsShopItem:
    """Generates an instance of ModelsShopItem with default values."""
    return ModelsShopItem()


def models_shop_item_from_obj(obj: Any, path: str = "") -> ModelsShopItem:
    """
    Generates an instance of ModelsShopItem from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsShopItem
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsShopItem
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_payee_id = obj.get('budgetPayeeID', None)
    if obj_budget_payee_id is not None:
        budget_payee_id_from_obj = from_obj(
            obj_budget_payee_id,
            expected=[str],
            path=path + '.budgetPayeeID')  # type: Optional[str]
    else:
        budget_payee_id_from_obj = None

    obj_cook_meal_plan_id = obj.get('cookMealPlanID', None)
    if obj_cook_meal_plan_id is not None:
        cook_meal_plan_id_from_obj = from_obj(
            obj_cook_meal_plan_id,
            expected=[str],
            path=path + '.cookMealPlanID')  # type: Optional[str]
    else:
        cook_meal_plan_id_from_obj = None

    obj_cook_recipe_id = obj.get('cookRecipeID', None)
    if obj_cook_recipe_id is not None:
        cook_recipe_id_from_obj = from_obj(
            obj_cook_recipe_id,
            expected=[str],
            path=path + '.cookRecipeID')  # type: Optional[str]
    else:
        cook_recipe_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_in_cart = obj.get('inCart', None)
    if obj_in_cart is not None:
        in_cart_from_obj = from_obj(
            obj_in_cart,
            expected=[bool],
            path=path + '.inCart')  # type: Optional[bool]
    else:
        in_cart_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_next_date = obj.get('nextDate', None)
    if obj_next_date is not None:
        next_date_from_obj = from_obj(
            obj_next_date,
            expected=[str],
            path=path + '.nextDate')  # type: Optional[str]
    else:
        next_date_from_obj = None

    obj_plan_project_id = obj.get('planProjectID', None)
    if obj_plan_project_id is not None:
        plan_project_id_from_obj = from_obj(
            obj_plan_project_id,
            expected=[str],
            path=path + '.planProjectID')  # type: Optional[str]
    else:
        plan_project_id_from_obj = None

    obj_position = obj.get('position', None)
    if obj_position is not None:
        position_from_obj = from_obj(
            obj_position,
            expected=[str],
            path=path + '.position')  # type: Optional[str]
    else:
        position_from_obj = None

    obj_price = obj.get('price', None)
    if obj_price is not None:
        price_from_obj = from_obj(
            obj_price,
            expected=[int],
            path=path + '.price')  # type: Optional[int]
    else:
        price_from_obj = None

    obj_recurrence = obj.get('recurrence', None)
    if obj_recurrence is not None:
        recurrence_from_obj = from_obj(
            obj_recurrence,
            expected=[TypesRecurrence],
            path=path + '.recurrence')  # type: Optional['TypesRecurrence']
    else:
        recurrence_from_obj = None

    obj_shop_category_id = obj.get('shopCategoryID', None)
    if obj_shop_category_id is not None:
        shop_category_id_from_obj = from_obj(
            obj_shop_category_id,
            expected=[str],
            path=path + '.shopCategoryID')  # type: Optional[str]
    else:
        shop_category_id_from_obj = None

    obj_shop_list_id = obj.get('shopListID', None)
    if obj_shop_list_id is not None:
        shop_list_id_from_obj = from_obj(
            obj_shop_list_id,
            expected=[str],
            path=path + '.shopListID')  # type: Optional[str]
    else:
        shop_list_id_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsShopItem(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        budget_payee_id=budget_payee_id_from_obj,
        cook_meal_plan_id=cook_meal_plan_id_from_obj,
        cook_recipe_id=cook_recipe_id_from_obj,
        created=created_from_obj,
        id=id_from_obj,
        in_cart=in_cart_from_obj,
        name=name_from_obj,
        next_date=next_date_from_obj,
        plan_project_id=plan_project_id_from_obj,
        position=position_from_obj,
        price=price_from_obj,
        recurrence=recurrence_from_obj,
        shop_category_id=shop_category_id_from_obj,
        shop_list_id=shop_list_id_from_obj,
        updated=updated_from_obj)


def models_shop_item_to_jsonable(
        models_shop_item: ModelsShopItem,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsShopItem.

    :param models_shop_item: instance of ModelsShopItem to be JSON-ized
    :param path: path to the models_shop_item used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_shop_item.auth_account_id is not None:
        res['authAccountID'] = models_shop_item.auth_account_id

    if models_shop_item.auth_household_id is not None:
        res['authHouseholdID'] = models_shop_item.auth_household_id

    if models_shop_item.budget_payee_id is not None:
        res['budgetPayeeID'] = models_shop_item.budget_payee_id

    if models_shop_item.cook_meal_plan_id is not None:
        res['cookMealPlanID'] = models_shop_item.cook_meal_plan_id

    if models_shop_item.cook_recipe_id is not None:
        res['cookRecipeID'] = models_shop_item.cook_recipe_id

    if models_shop_item.created is not None:
        res['created'] = models_shop_item.created

    if models_shop_item.id is not None:
        res['id'] = models_shop_item.id

    if models_shop_item.in_cart is not None:
        res['inCart'] = models_shop_item.in_cart

    if models_shop_item.name is not None:
        res['name'] = models_shop_item.name

    if models_shop_item.next_date is not None:
        res['nextDate'] = models_shop_item.next_date

    if models_shop_item.plan_project_id is not None:
        res['planProjectID'] = models_shop_item.plan_project_id

    if models_shop_item.position is not None:
        res['position'] = models_shop_item.position

    if models_shop_item.price is not None:
        res['price'] = models_shop_item.price

    if models_shop_item.recurrence is not None:
        res['recurrence'] = to_jsonable(
        models_shop_item.recurrence,
        expected=[TypesRecurrence],
        path='{}.recurrence'.format(path))

    if models_shop_item.shop_category_id is not None:
        res['shopCategoryID'] = models_shop_item.shop_category_id

    if models_shop_item.shop_list_id is not None:
        res['shopListID'] = models_shop_item.shop_list_id

    if models_shop_item.updated is not None:
        res['updated'] = models_shop_item.updated

    return res


class ModelsShopList:
    def __init__(
            self,
            auth_account_id: Optional[str] = None,
            auth_household_id: Optional[str] = None,
            budget_category_id: Optional[str] = None,
            created: Optional[str] = None,
            icon: Optional[str] = None,
            id: Optional[str] = None,
            labels_values_ids: Optional[List[str]] = None,
            name: Optional[str] = None,
            shop_item_count: Optional[int] = None,
            short_id: Optional[str] = None,
            updated: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth_account_id = auth_account_id

        self.auth_household_id = auth_household_id

        self.budget_category_id = budget_category_id

        self.created = created

        self.icon = icon

        self.id = id

        self.labels_values_ids = labels_values_ids

        self.name = name

        self.shop_item_count = shop_item_count

        self.short_id = short_id

        self.updated = updated

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to models_shop_list_to_jsonable.

        :return: JSON-able representation
        """
        return models_shop_list_to_jsonable(self)


def new_models_shop_list() -> ModelsShopList:
    """Generates an instance of ModelsShopList with default values."""
    return ModelsShopList()


def models_shop_list_from_obj(obj: Any, path: str = "") -> ModelsShopList:
    """
    Generates an instance of ModelsShopList from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of ModelsShopList
    :param path: path to the object used for debugging
    :return: parsed instance of ModelsShopList
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_account_id = obj.get('authAccountID', None)
    if obj_auth_account_id is not None:
        auth_account_id_from_obj = from_obj(
            obj_auth_account_id,
            expected=[str],
            path=path + '.authAccountID')  # type: Optional[str]
    else:
        auth_account_id_from_obj = None

    obj_auth_household_id = obj.get('authHouseholdID', None)
    if obj_auth_household_id is not None:
        auth_household_id_from_obj = from_obj(
            obj_auth_household_id,
            expected=[str],
            path=path + '.authHouseholdID')  # type: Optional[str]
    else:
        auth_household_id_from_obj = None

    obj_budget_category_id = obj.get('budgetCategoryID', None)
    if obj_budget_category_id is not None:
        budget_category_id_from_obj = from_obj(
            obj_budget_category_id,
            expected=[str],
            path=path + '.budgetCategoryID')  # type: Optional[str]
    else:
        budget_category_id_from_obj = None

    obj_created = obj.get('created', None)
    if obj_created is not None:
        created_from_obj = from_obj(
            obj_created,
            expected=[str],
            path=path + '.created')  # type: Optional[str]
    else:
        created_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_labels_values_ids = obj.get('labelsValuesIDs', None)
    if obj_labels_values_ids is not None:
        labels_values_ids_from_obj = from_obj(
            obj_labels_values_ids,
            expected=[list, str],
            path=path + '.labelsValuesIDs')  # type: Optional[List[str]]
    else:
        labels_values_ids_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_shop_item_count = obj.get('shopItemCount', None)
    if obj_shop_item_count is not None:
        shop_item_count_from_obj = from_obj(
            obj_shop_item_count,
            expected=[int],
            path=path + '.shopItemCount')  # type: Optional[int]
    else:
        shop_item_count_from_obj = None

    obj_short_id = obj.get('shortID', None)
    if obj_short_id is not None:
        short_id_from_obj = from_obj(
            obj_short_id,
            expected=[str],
            path=path + '.shortID')  # type: Optional[str]
    else:
        short_id_from_obj = None

    obj_updated = obj.get('updated', None)
    if obj_updated is not None:
        updated_from_obj = from_obj(
            obj_updated,
            expected=[str],
            path=path + '.updated')  # type: Optional[str]
    else:
        updated_from_obj = None

    return ModelsShopList(
        auth_account_id=auth_account_id_from_obj,
        auth_household_id=auth_household_id_from_obj,
        budget_category_id=budget_category_id_from_obj,
        created=created_from_obj,
        icon=icon_from_obj,
        id=id_from_obj,
        labels_values_ids=labels_values_ids_from_obj,
        name=name_from_obj,
        shop_item_count=shop_item_count_from_obj,
        short_id=short_id_from_obj,
        updated=updated_from_obj)


def models_shop_list_to_jsonable(
        models_shop_list: ModelsShopList,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of ModelsShopList.

    :param models_shop_list: instance of ModelsShopList to be JSON-ized
    :param path: path to the models_shop_list used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if models_shop_list.auth_account_id is not None:
        res['authAccountID'] = models_shop_list.auth_account_id

    if models_shop_list.auth_household_id is not None:
        res['authHouseholdID'] = models_shop_list.auth_household_id

    if models_shop_list.budget_category_id is not None:
        res['budgetCategoryID'] = models_shop_list.budget_category_id

    if models_shop_list.created is not None:
        res['created'] = models_shop_list.created

    if models_shop_list.icon is not None:
        res['icon'] = models_shop_list.icon

    if models_shop_list.id is not None:
        res['id'] = models_shop_list.id

    if models_shop_list.labels_values_ids is not None:
        res['labelsValuesIDs'] = to_jsonable(
        models_shop_list.labels_values_ids,
        expected=[list, str],
        path='{}.labelsValuesIDs'.format(path))

    if models_shop_list.name is not None:
        res['name'] = models_shop_list.name

    if models_shop_list.shop_item_count is not None:
        res['shopItemCount'] = models_shop_list.shop_item_count

    if models_shop_list.short_id is not None:
        res['shortID'] = models_shop_list.short_id

    if models_shop_list.updated is not None:
        res['updated'] = models_shop_list.updated

    return res


class NotifyAPN:
    def __init__(
            self,
            app_id: Optional[str] = None,
            jwt_key: Optional['CryptolibKeyCryptolibKeyProviderPrivate'] = None,
            sandbox: Optional[bool] = None,
            team_id: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.app_id = app_id

        self.jwt_key = jwt_key

        self.sandbox = sandbox

        self.team_id = team_id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to notify_a_p_n_to_jsonable.

        :return: JSON-able representation
        """
        return notify_a_p_n_to_jsonable(self)


def new_notify_a_p_n() -> NotifyAPN:
    """Generates an instance of NotifyAPN with default values."""
    return NotifyAPN()


def notify_a_p_n_from_obj(obj: Any, path: str = "") -> NotifyAPN:
    """
    Generates an instance of NotifyAPN from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of NotifyAPN
    :param path: path to the object used for debugging
    :return: parsed instance of NotifyAPN
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_app_id = obj.get('appID', None)
    if obj_app_id is not None:
        app_id_from_obj = from_obj(
            obj_app_id,
            expected=[str],
            path=path + '.appID')  # type: Optional[str]
    else:
        app_id_from_obj = None

    obj_jwt_key = obj.get('jwtKey', None)
    if obj_jwt_key is not None:
        jwt_key_from_obj = from_obj(
            obj_jwt_key,
            expected=[CryptolibKeyCryptolibKeyProviderPrivate],
            path=path + '.jwtKey')  # type: Optional['CryptolibKeyCryptolibKeyProviderPrivate']
    else:
        jwt_key_from_obj = None

    obj_sandbox = obj.get('sandbox', None)
    if obj_sandbox is not None:
        sandbox_from_obj = from_obj(
            obj_sandbox,
            expected=[bool],
            path=path + '.sandbox')  # type: Optional[bool]
    else:
        sandbox_from_obj = None

    obj_team_id = obj.get('teamID', None)
    if obj_team_id is not None:
        team_id_from_obj = from_obj(
            obj_team_id,
            expected=[str],
            path=path + '.teamID')  # type: Optional[str]
    else:
        team_id_from_obj = None

    return NotifyAPN(
        app_id=app_id_from_obj,
        jwt_key=jwt_key_from_obj,
        sandbox=sandbox_from_obj,
        team_id=team_id_from_obj)


def notify_a_p_n_to_jsonable(
        notify_a_p_n: NotifyAPN,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of NotifyAPN.

    :param notify_a_p_n: instance of NotifyAPN to be JSON-ized
    :param path: path to the notify_a_p_n used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if notify_a_p_n.app_id is not None:
        res['appID'] = notify_a_p_n.app_id

    if notify_a_p_n.jwt_key is not None:
        res['jwtKey'] = to_jsonable(
        notify_a_p_n.jwt_key,
        expected=[CryptolibKeyCryptolibKeyProviderPrivate],
        path='{}.jwtKey'.format(path))

    if notify_a_p_n.sandbox is not None:
        res['sandbox'] = notify_a_p_n.sandbox

    if notify_a_p_n.team_id is not None:
        res['teamID'] = notify_a_p_n.team_id

    return res


class NotifySMTP:
    def __init__(
            self,
            from_address: Optional[str] = None,
            helo: Optional[str] = None,
            hostname: Optional[str] = None,
            password: Optional[str] = None,
            port: Optional[int] = None,
            reply_to: Optional[str] = None,
            require_t_l_s: Optional[bool] = None,
            username: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.from_address = from_address

        self.helo = helo

        self.hostname = hostname

        self.password = password

        self.port = port

        self.reply_to = reply_to

        self.require_t_l_s = require_t_l_s

        self.username = username

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to notify_s_m_t_p_to_jsonable.

        :return: JSON-able representation
        """
        return notify_s_m_t_p_to_jsonable(self)


def new_notify_s_m_t_p() -> NotifySMTP:
    """Generates an instance of NotifySMTP with default values."""
    return NotifySMTP()


def notify_s_m_t_p_from_obj(obj: Any, path: str = "") -> NotifySMTP:
    """
    Generates an instance of NotifySMTP from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of NotifySMTP
    :param path: path to the object used for debugging
    :return: parsed instance of NotifySMTP
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_from_address = obj.get('fromAddress', None)
    if obj_from_address is not None:
        from_address_from_obj = from_obj(
            obj_from_address,
            expected=[str],
            path=path + '.fromAddress')  # type: Optional[str]
    else:
        from_address_from_obj = None

    obj_helo = obj.get('helo', None)
    if obj_helo is not None:
        helo_from_obj = from_obj(
            obj_helo,
            expected=[str],
            path=path + '.helo')  # type: Optional[str]
    else:
        helo_from_obj = None

    obj_hostname = obj.get('hostname', None)
    if obj_hostname is not None:
        hostname_from_obj = from_obj(
            obj_hostname,
            expected=[str],
            path=path + '.hostname')  # type: Optional[str]
    else:
        hostname_from_obj = None

    obj_password = obj.get('password', None)
    if obj_password is not None:
        password_from_obj = from_obj(
            obj_password,
            expected=[str],
            path=path + '.password')  # type: Optional[str]
    else:
        password_from_obj = None

    obj_port = obj.get('port', None)
    if obj_port is not None:
        port_from_obj = from_obj(
            obj_port,
            expected=[int],
            path=path + '.port')  # type: Optional[int]
    else:
        port_from_obj = None

    obj_reply_to = obj.get('replyTo', None)
    if obj_reply_to is not None:
        reply_to_from_obj = from_obj(
            obj_reply_to,
            expected=[str],
            path=path + '.replyTo')  # type: Optional[str]
    else:
        reply_to_from_obj = None

    obj_require_t_l_s = obj.get('requireTLS', None)
    if obj_require_t_l_s is not None:
        require_t_l_s_from_obj = from_obj(
            obj_require_t_l_s,
            expected=[bool],
            path=path + '.requireTLS')  # type: Optional[bool]
    else:
        require_t_l_s_from_obj = None

    obj_username = obj.get('username', None)
    if obj_username is not None:
        username_from_obj = from_obj(
            obj_username,
            expected=[str],
            path=path + '.username')  # type: Optional[str]
    else:
        username_from_obj = None

    return NotifySMTP(
        from_address=from_address_from_obj,
        helo=helo_from_obj,
        hostname=hostname_from_obj,
        password=password_from_obj,
        port=port_from_obj,
        reply_to=reply_to_from_obj,
        require_t_l_s=require_t_l_s_from_obj,
        username=username_from_obj)


def notify_s_m_t_p_to_jsonable(
        notify_s_m_t_p: NotifySMTP,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of NotifySMTP.

    :param notify_s_m_t_p: instance of NotifySMTP to be JSON-ized
    :param path: path to the notify_s_m_t_p used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if notify_s_m_t_p.from_address is not None:
        res['fromAddress'] = notify_s_m_t_p.from_address

    if notify_s_m_t_p.helo is not None:
        res['helo'] = notify_s_m_t_p.helo

    if notify_s_m_t_p.hostname is not None:
        res['hostname'] = notify_s_m_t_p.hostname

    if notify_s_m_t_p.password is not None:
        res['password'] = notify_s_m_t_p.password

    if notify_s_m_t_p.port is not None:
        res['port'] = notify_s_m_t_p.port

    if notify_s_m_t_p.reply_to is not None:
        res['replyTo'] = notify_s_m_t_p.reply_to

    if notify_s_m_t_p.require_t_l_s is not None:
        res['requireTLS'] = notify_s_m_t_p.require_t_l_s

    if notify_s_m_t_p.username is not None:
        res['username'] = notify_s_m_t_p.username

    return res


class NotifyWebPush:
    def __init__(
            self,
            vapid_private_key: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.vapid_private_key = vapid_private_key

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to notify_web_push_to_jsonable.

        :return: JSON-able representation
        """
        return notify_web_push_to_jsonable(self)


def new_notify_web_push() -> NotifyWebPush:
    """Generates an instance of NotifyWebPush with default values."""
    return NotifyWebPush()


def notify_web_push_from_obj(obj: Any, path: str = "") -> NotifyWebPush:
    """
    Generates an instance of NotifyWebPush from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of NotifyWebPush
    :param path: path to the object used for debugging
    :return: parsed instance of NotifyWebPush
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_vapid_private_key = obj.get('vapidPrivateKey', None)
    if obj_vapid_private_key is not None:
        vapid_private_key_from_obj = from_obj(
            obj_vapid_private_key,
            expected=[str],
            path=path + '.vapidPrivateKey')  # type: Optional[str]
    else:
        vapid_private_key_from_obj = None

    return NotifyWebPush(
        vapid_private_key=vapid_private_key_from_obj)


def notify_web_push_to_jsonable(
        notify_web_push: NotifyWebPush,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of NotifyWebPush.

    :param notify_web_push: instance of NotifyWebPush to be JSON-ized
    :param path: path to the notify_web_push used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if notify_web_push.vapid_private_key is not None:
        res['vapidPrivateKey'] = notify_web_push.vapid_private_key

    return res


class NotifyWebPushClient:
    def __init__(
            self,
            auth: Optional[str] = None,
            endpoint: Optional[str] = None,
            p256: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.auth = auth

        self.endpoint = endpoint

        self.p256 = p256

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to notify_web_push_client_to_jsonable.

        :return: JSON-able representation
        """
        return notify_web_push_client_to_jsonable(self)


def new_notify_web_push_client() -> NotifyWebPushClient:
    """Generates an instance of NotifyWebPushClient with default values."""
    return NotifyWebPushClient()


def notify_web_push_client_from_obj(obj: Any, path: str = "") -> NotifyWebPushClient:
    """
    Generates an instance of NotifyWebPushClient from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of NotifyWebPushClient
    :param path: path to the object used for debugging
    :return: parsed instance of NotifyWebPushClient
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth = obj.get('auth', None)
    if obj_auth is not None:
        auth_from_obj = from_obj(
            obj_auth,
            expected=[str],
            path=path + '.auth')  # type: Optional[str]
    else:
        auth_from_obj = None

    obj_endpoint = obj.get('endpoint', None)
    if obj_endpoint is not None:
        endpoint_from_obj = from_obj(
            obj_endpoint,
            expected=[str],
            path=path + '.endpoint')  # type: Optional[str]
    else:
        endpoint_from_obj = None

    obj_p256 = obj.get('p256', None)
    if obj_p256 is not None:
        p256_from_obj = from_obj(
            obj_p256,
            expected=[str],
            path=path + '.p256')  # type: Optional[str]
    else:
        p256_from_obj = None

    return NotifyWebPushClient(
        auth=auth_from_obj,
        endpoint=endpoint_from_obj,
        p256=p256_from_obj)


def notify_web_push_client_to_jsonable(
        notify_web_push_client: NotifyWebPushClient,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of NotifyWebPushClient.

    :param notify_web_push_client: instance of NotifyWebPushClient to be JSON-ized
    :param path: path to the notify_web_push_client used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if notify_web_push_client.auth is not None:
        res['auth'] = notify_web_push_client.auth

    if notify_web_push_client.endpoint is not None:
        res['endpoint'] = notify_web_push_client.endpoint

    if notify_web_push_client.p256 is not None:
        res['p256'] = notify_web_push_client.p256

    return res


class OidcClientIssuer:
    def __init__(
            self,
            auth_url: Optional[str] = None,
            auth_url_params: Optional[Dict[str, str]] = None,
            ca_certificate_base64: Optional[str] = None,
            client_id: Optional[str] = None,
            client_secret: Optional[str] = None,
            client_secret_j_w_t_claims_custom: Optional[Dict[str, Any]] = None,
            client_secret_j_w_t_claims_reg: Optional[Any] = None,
            client_secret_j_w_t_key: Optional[Any] = None,
            code_challenge_methods_supported: Optional[List[str]] = None,
            display_name: Optional[str] = None,
            filters: Optional[List['TypesFilter']] = None,
            icon: Optional[str] = None,
            issuer_url: Optional[str] = None,
            jwks_keys: Optional[List['CryptolibKeyCryptolibKeyProviderPublic']] = None,
            jwks_u_r_i: Optional[str] = None,
            oidc_issuer_url: Optional[str] = None,
            scopes: Optional[List[str]] = None,
            token_url: Optional[str] = None,
            user_info_endpoint: Optional[str] = None) -> None:
        """Initializes with the given values."""
        # OPTIONAL AuthURL is the endpoint for OAuth.  Can be discovered from OIDCIssuerURL.
        self.auth_url = auth_url

        # OPTIONAL AuthURLParams to send with OAuth.
        self.auth_url_params = auth_url_params

        # OPTIONAL CA certificate to use with requests.
        self.ca_certificate_base64 = ca_certificate_base64

        # REQUIRED ClientID is the ID shared with clients for OAuth requests.
        self.client_id = client_id

        # REQUIRED ClientSecret is used to retrieve tokens from OAuth responses.
        self.client_secret = client_secret

        # OPTIONAL Custom claims to be added to JWT.
        self.client_secret_j_w_t_claims_custom = client_secret_j_w_t_claims_custom

        # OPTIONAL Registered claims to be added to JWT.
        self.client_secret_j_w_t_claims_reg = client_secret_j_w_t_claims_reg

        # OPTIONAL Key that can be used to generate a JWT for the clientSecret.
        self.client_secret_j_w_t_key = client_secret_j_w_t_key

        # OPTIONAL CodeChallengeMethodsSupported is an optional list of supported.  Can be discovered from OIDCIssuerURL
        self.code_challenge_methods_supported = code_challenge_methods_supported

        # OPTIONAL Display name of the ClientIssuer.
        self.display_name = display_name

        # A list of filters to test the returned token with.
        self.filters = filters

        # OPTIONAL Icon of the ClientIssuer.
        self.icon = icon

        # OPTIONAL Issuer URL of the Issuer.  Must match aud for token.  Can be discovered from OIDCIssuerURL.
        self.issuer_url = issuer_url

        # OPTIONAL List of public keys for the Issuer.  Can be discovered from JWKSURI
        self.jwks_keys = jwks_keys

        # OPTIONAL URL to retrieve JWKSKeys.  Can be discovered from OIDCIssuerURL
        self.jwks_u_r_i = jwks_u_r_i

        # OPTIONAL URL to retrieve issuer configurations.
        self.oidc_issuer_url = oidc_issuer_url

        # OPTIONAL List of scopes to request.  Should include openid for OIDC issuers.
        self.scopes = scopes

        # OPTIONAL URL to retrieve token from.  Can be discovered from OIDCIssuerURL.
        self.token_url = token_url

        # OPTIONAL URL to retrieve user info.  Can be discovered from OIDCIssuerURL.
        self.user_info_endpoint = user_info_endpoint

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to oidc_client_issuer_to_jsonable.

        :return: JSON-able representation
        """
        return oidc_client_issuer_to_jsonable(self)


def new_oidc_client_issuer() -> OidcClientIssuer:
    """Generates an instance of OidcClientIssuer with default values."""
    return OidcClientIssuer()


def oidc_client_issuer_from_obj(obj: Any, path: str = "") -> OidcClientIssuer:
    """
    Generates an instance of OidcClientIssuer from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of OidcClientIssuer
    :param path: path to the object used for debugging
    :return: parsed instance of OidcClientIssuer
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_auth_url = obj.get('authURL', None)
    if obj_auth_url is not None:
        auth_url_from_obj = from_obj(
            obj_auth_url,
            expected=[str],
            path=path + '.authURL')  # type: Optional[str]
    else:
        auth_url_from_obj = None

    obj_auth_url_params = obj.get('authURLParams', None)
    if obj_auth_url_params is not None:
        auth_url_params_from_obj = from_obj(
            obj_auth_url_params,
            expected=[dict, str],
            path=path + '.authURLParams')  # type: Optional[Dict[str, str]]
    else:
        auth_url_params_from_obj = None

    obj_ca_certificate_base64 = obj.get('caCertificateBase64', None)
    if obj_ca_certificate_base64 is not None:
        ca_certificate_base64_from_obj = from_obj(
            obj_ca_certificate_base64,
            expected=[str],
            path=path + '.caCertificateBase64')  # type: Optional[str]
    else:
        ca_certificate_base64_from_obj = None

    obj_client_id = obj.get('clientID', None)
    if obj_client_id is not None:
        client_id_from_obj = from_obj(
            obj_client_id,
            expected=[str],
            path=path + '.clientID')  # type: Optional[str]
    else:
        client_id_from_obj = None

    obj_client_secret = obj.get('clientSecret', None)
    if obj_client_secret is not None:
        client_secret_from_obj = from_obj(
            obj_client_secret,
            expected=[str],
            path=path + '.clientSecret')  # type: Optional[str]
    else:
        client_secret_from_obj = None

    obj_client_secret_j_w_t_claims_custom = obj.get('clientSecretJWTClaimsCustom', None)
    if obj_client_secret_j_w_t_claims_custom is not None:
        client_secret_j_w_t_claims_custom_from_obj = from_obj(
            obj_client_secret_j_w_t_claims_custom,
            expected=[dict, Any],
            path=path + '.clientSecretJWTClaimsCustom')  # type: Optional[Dict[str, Any]]
    else:
        client_secret_j_w_t_claims_custom_from_obj = None

    client_secret_j_w_t_claims_reg_from_obj = obj.get('clientSecretJWTClaimsReg', None)

    client_secret_j_w_t_key_from_obj = obj.get('clientSecretJWTKey', None)

    obj_code_challenge_methods_supported = obj.get('codeChallengeMethodsSupported', None)
    if obj_code_challenge_methods_supported is not None:
        code_challenge_methods_supported_from_obj = from_obj(
            obj_code_challenge_methods_supported,
            expected=[list, str],
            path=path + '.codeChallengeMethodsSupported')  # type: Optional[List[str]]
    else:
        code_challenge_methods_supported_from_obj = None

    obj_display_name = obj.get('displayName', None)
    if obj_display_name is not None:
        display_name_from_obj = from_obj(
            obj_display_name,
            expected=[str],
            path=path + '.displayName')  # type: Optional[str]
    else:
        display_name_from_obj = None

    obj_filters = obj.get('filters', None)
    if obj_filters is not None:
        filters_from_obj = from_obj(
            obj_filters,
            expected=[list, TypesFilter],
            path=path + '.filters')  # type: Optional[List['TypesFilter']]
    else:
        filters_from_obj = None

    obj_icon = obj.get('icon', None)
    if obj_icon is not None:
        icon_from_obj = from_obj(
            obj_icon,
            expected=[str],
            path=path + '.icon')  # type: Optional[str]
    else:
        icon_from_obj = None

    obj_issuer_url = obj.get('issuerURL', None)
    if obj_issuer_url is not None:
        issuer_url_from_obj = from_obj(
            obj_issuer_url,
            expected=[str],
            path=path + '.issuerURL')  # type: Optional[str]
    else:
        issuer_url_from_obj = None

    obj_jwks_keys = obj.get('jwksKeys', None)
    if obj_jwks_keys is not None:
        jwks_keys_from_obj = from_obj(
            obj_jwks_keys,
            expected=[list, CryptolibKeyCryptolibKeyProviderPublic],
            path=path + '.jwksKeys')  # type: Optional[List['CryptolibKeyCryptolibKeyProviderPublic']]
    else:
        jwks_keys_from_obj = None

    obj_jwks_u_r_i = obj.get('jwksURI', None)
    if obj_jwks_u_r_i is not None:
        jwks_u_r_i_from_obj = from_obj(
            obj_jwks_u_r_i,
            expected=[str],
            path=path + '.jwksURI')  # type: Optional[str]
    else:
        jwks_u_r_i_from_obj = None

    obj_oidc_issuer_url = obj.get('oidcIssuerURL', None)
    if obj_oidc_issuer_url is not None:
        oidc_issuer_url_from_obj = from_obj(
            obj_oidc_issuer_url,
            expected=[str],
            path=path + '.oidcIssuerURL')  # type: Optional[str]
    else:
        oidc_issuer_url_from_obj = None

    obj_scopes = obj.get('scopes', None)
    if obj_scopes is not None:
        scopes_from_obj = from_obj(
            obj_scopes,
            expected=[list, str],
            path=path + '.scopes')  # type: Optional[List[str]]
    else:
        scopes_from_obj = None

    obj_token_url = obj.get('tokenURL', None)
    if obj_token_url is not None:
        token_url_from_obj = from_obj(
            obj_token_url,
            expected=[str],
            path=path + '.tokenURL')  # type: Optional[str]
    else:
        token_url_from_obj = None

    obj_user_info_endpoint = obj.get('userInfoEndpoint', None)
    if obj_user_info_endpoint is not None:
        user_info_endpoint_from_obj = from_obj(
            obj_user_info_endpoint,
            expected=[str],
            path=path + '.userInfoEndpoint')  # type: Optional[str]
    else:
        user_info_endpoint_from_obj = None

    return OidcClientIssuer(
        auth_url=auth_url_from_obj,
        auth_url_params=auth_url_params_from_obj,
        ca_certificate_base64=ca_certificate_base64_from_obj,
        client_id=client_id_from_obj,
        client_secret=client_secret_from_obj,
        client_secret_j_w_t_claims_custom=client_secret_j_w_t_claims_custom_from_obj,
        client_secret_j_w_t_claims_reg=client_secret_j_w_t_claims_reg_from_obj,
        client_secret_j_w_t_key=client_secret_j_w_t_key_from_obj,
        code_challenge_methods_supported=code_challenge_methods_supported_from_obj,
        display_name=display_name_from_obj,
        filters=filters_from_obj,
        icon=icon_from_obj,
        issuer_url=issuer_url_from_obj,
        jwks_keys=jwks_keys_from_obj,
        jwks_u_r_i=jwks_u_r_i_from_obj,
        oidc_issuer_url=oidc_issuer_url_from_obj,
        scopes=scopes_from_obj,
        token_url=token_url_from_obj,
        user_info_endpoint=user_info_endpoint_from_obj)


def oidc_client_issuer_to_jsonable(
        oidc_client_issuer: OidcClientIssuer,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of OidcClientIssuer.

    :param oidc_client_issuer: instance of OidcClientIssuer to be JSON-ized
    :param path: path to the oidc_client_issuer used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if oidc_client_issuer.auth_url is not None:
        res['authURL'] = oidc_client_issuer.auth_url

    if oidc_client_issuer.auth_url_params is not None:
        res['authURLParams'] = to_jsonable(
        oidc_client_issuer.auth_url_params,
        expected=[dict, str],
        path='{}.authURLParams'.format(path))

    if oidc_client_issuer.ca_certificate_base64 is not None:
        res['caCertificateBase64'] = oidc_client_issuer.ca_certificate_base64

    if oidc_client_issuer.client_id is not None:
        res['clientID'] = oidc_client_issuer.client_id

    if oidc_client_issuer.client_secret is not None:
        res['clientSecret'] = oidc_client_issuer.client_secret

    if oidc_client_issuer.client_secret_j_w_t_claims_custom is not None:
        res['clientSecretJWTClaimsCustom'] = to_jsonable(
        oidc_client_issuer.client_secret_j_w_t_claims_custom,
        expected=[dict, Any],
        path='{}.clientSecretJWTClaimsCustom'.format(path))

    if oidc_client_issuer.client_secret_j_w_t_claims_reg is not None:
        res['clientSecretJWTClaimsReg'] = oidc_client_issuer.client_secret_j_w_t_claims_reg

    if oidc_client_issuer.client_secret_j_w_t_key is not None:
        res['clientSecretJWTKey'] = oidc_client_issuer.client_secret_j_w_t_key

    if oidc_client_issuer.code_challenge_methods_supported is not None:
        res['codeChallengeMethodsSupported'] = to_jsonable(
        oidc_client_issuer.code_challenge_methods_supported,
        expected=[list, str],
        path='{}.codeChallengeMethodsSupported'.format(path))

    if oidc_client_issuer.display_name is not None:
        res['displayName'] = oidc_client_issuer.display_name

    if oidc_client_issuer.filters is not None:
        res['filters'] = to_jsonable(
        oidc_client_issuer.filters,
        expected=[list, TypesFilter],
        path='{}.filters'.format(path))

    if oidc_client_issuer.icon is not None:
        res['icon'] = oidc_client_issuer.icon

    if oidc_client_issuer.issuer_url is not None:
        res['issuerURL'] = oidc_client_issuer.issuer_url

    if oidc_client_issuer.jwks_keys is not None:
        res['jwksKeys'] = to_jsonable(
        oidc_client_issuer.jwks_keys,
        expected=[list, CryptolibKeyCryptolibKeyProviderPublic],
        path='{}.jwksKeys'.format(path))

    if oidc_client_issuer.jwks_u_r_i is not None:
        res['jwksURI'] = oidc_client_issuer.jwks_u_r_i

    if oidc_client_issuer.oidc_issuer_url is not None:
        res['oidcIssuerURL'] = oidc_client_issuer.oidc_issuer_url

    if oidc_client_issuer.scopes is not None:
        res['scopes'] = to_jsonable(
        oidc_client_issuer.scopes,
        expected=[list, str],
        path='{}.scopes'.format(path))

    if oidc_client_issuer.token_url is not None:
        res['tokenURL'] = oidc_client_issuer.token_url

    if oidc_client_issuer.user_info_endpoint is not None:
        res['userInfoEndpoint'] = oidc_client_issuer.user_info_endpoint

    return res


class PaymentsApple:
    def __init__(
            self,
            sandbox: Optional[bool] = None,
            subscriptions: Optional[Dict[str, str]] = None) -> None:
        """Initializes with the given values."""
        self.sandbox = sandbox

        self.subscriptions = subscriptions

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to payments_apple_to_jsonable.

        :return: JSON-able representation
        """
        return payments_apple_to_jsonable(self)


def new_payments_apple() -> PaymentsApple:
    """Generates an instance of PaymentsApple with default values."""
    return PaymentsApple()


def payments_apple_from_obj(obj: Any, path: str = "") -> PaymentsApple:
    """
    Generates an instance of PaymentsApple from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of PaymentsApple
    :param path: path to the object used for debugging
    :return: parsed instance of PaymentsApple
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_sandbox = obj.get('sandbox', None)
    if obj_sandbox is not None:
        sandbox_from_obj = from_obj(
            obj_sandbox,
            expected=[bool],
            path=path + '.sandbox')  # type: Optional[bool]
    else:
        sandbox_from_obj = None

    obj_subscriptions = obj.get('subscriptions', None)
    if obj_subscriptions is not None:
        subscriptions_from_obj = from_obj(
            obj_subscriptions,
            expected=[dict, str],
            path=path + '.subscriptions')  # type: Optional[Dict[str, str]]
    else:
        subscriptions_from_obj = None

    return PaymentsApple(
        sandbox=sandbox_from_obj,
        subscriptions=subscriptions_from_obj)


def payments_apple_to_jsonable(
        payments_apple: PaymentsApple,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of PaymentsApple.

    :param payments_apple: instance of PaymentsApple to be JSON-ized
    :param path: path to the payments_apple used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if payments_apple.sandbox is not None:
        res['sandbox'] = payments_apple.sandbox

    if payments_apple.subscriptions is not None:
        res['subscriptions'] = to_jsonable(
        payments_apple.subscriptions,
        expected=[dict, str],
        path='{}.subscriptions'.format(path))

    return res


class PaymentsGoogle:
    def __init__(
            self,
            email_address: Optional[str] = None,
            package_name: Optional[str] = None,
            private_key: Optional['CryptolibKeyCryptolibKeyProviderPrivate'] = None,
            products: Optional[List[str]] = None) -> None:
        """Initializes with the given values."""
        self.email_address = email_address

        self.package_name = package_name

        self.private_key = private_key

        self.products = products

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to payments_google_to_jsonable.

        :return: JSON-able representation
        """
        return payments_google_to_jsonable(self)


def new_payments_google() -> PaymentsGoogle:
    """Generates an instance of PaymentsGoogle with default values."""
    return PaymentsGoogle()


def payments_google_from_obj(obj: Any, path: str = "") -> PaymentsGoogle:
    """
    Generates an instance of PaymentsGoogle from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of PaymentsGoogle
    :param path: path to the object used for debugging
    :return: parsed instance of PaymentsGoogle
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_email_address = obj.get('emailAddress', None)
    if obj_email_address is not None:
        email_address_from_obj = from_obj(
            obj_email_address,
            expected=[str],
            path=path + '.emailAddress')  # type: Optional[str]
    else:
        email_address_from_obj = None

    obj_package_name = obj.get('packageName', None)
    if obj_package_name is not None:
        package_name_from_obj = from_obj(
            obj_package_name,
            expected=[str],
            path=path + '.packageName')  # type: Optional[str]
    else:
        package_name_from_obj = None

    obj_private_key = obj.get('privateKey', None)
    if obj_private_key is not None:
        private_key_from_obj = from_obj(
            obj_private_key,
            expected=[CryptolibKeyCryptolibKeyProviderPrivate],
            path=path + '.privateKey')  # type: Optional['CryptolibKeyCryptolibKeyProviderPrivate']
    else:
        private_key_from_obj = None

    obj_products = obj.get('products', None)
    if obj_products is not None:
        products_from_obj = from_obj(
            obj_products,
            expected=[list, str],
            path=path + '.products')  # type: Optional[List[str]]
    else:
        products_from_obj = None

    return PaymentsGoogle(
        email_address=email_address_from_obj,
        package_name=package_name_from_obj,
        private_key=private_key_from_obj,
        products=products_from_obj)


def payments_google_to_jsonable(
        payments_google: PaymentsGoogle,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of PaymentsGoogle.

    :param payments_google: instance of PaymentsGoogle to be JSON-ized
    :param path: path to the payments_google used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if payments_google.email_address is not None:
        res['emailAddress'] = payments_google.email_address

    if payments_google.package_name is not None:
        res['packageName'] = payments_google.package_name

    if payments_google.private_key is not None:
        res['privateKey'] = to_jsonable(
        payments_google.private_key,
        expected=[CryptolibKeyCryptolibKeyProviderPrivate],
        path='{}.privateKey'.format(path))

    if payments_google.products is not None:
        res['products'] = to_jsonable(
        payments_google.products,
        expected=[list, str],
        path='{}.products'.format(path))

    return res


class PaymentsPaddle:
    def __init__(
            self,
            plans: Optional[Dict[str, int]] = None,
            products: Optional[Dict[str, int]] = None,
            public_key: Optional['CryptolibKeyCryptolibRSA2048PublicKey'] = None,
            sandbox: Optional[bool] = None,
            vendor_auth_code: Optional[str] = None,
            vendor_id: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.plans = plans

        self.products = products

        self.public_key = public_key

        self.sandbox = sandbox

        self.vendor_auth_code = vendor_auth_code

        self.vendor_id = vendor_id

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to payments_paddle_to_jsonable.

        :return: JSON-able representation
        """
        return payments_paddle_to_jsonable(self)


def new_payments_paddle() -> PaymentsPaddle:
    """Generates an instance of PaymentsPaddle with default values."""
    return PaymentsPaddle()


def payments_paddle_from_obj(obj: Any, path: str = "") -> PaymentsPaddle:
    """
    Generates an instance of PaymentsPaddle from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of PaymentsPaddle
    :param path: path to the object used for debugging
    :return: parsed instance of PaymentsPaddle
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_plans = obj.get('plans', None)
    if obj_plans is not None:
        plans_from_obj = from_obj(
            obj_plans,
            expected=[dict, int],
            path=path + '.plans')  # type: Optional[Dict[str, int]]
    else:
        plans_from_obj = None

    obj_products = obj.get('products', None)
    if obj_products is not None:
        products_from_obj = from_obj(
            obj_products,
            expected=[dict, int],
            path=path + '.products')  # type: Optional[Dict[str, int]]
    else:
        products_from_obj = None

    obj_public_key = obj.get('publicKey', None)
    if obj_public_key is not None:
        public_key_from_obj = from_obj(
            obj_public_key,
            expected=[CryptolibKeyCryptolibRSA2048PublicKey],
            path=path + '.publicKey')  # type: Optional['CryptolibKeyCryptolibRSA2048PublicKey']
    else:
        public_key_from_obj = None

    obj_sandbox = obj.get('sandbox', None)
    if obj_sandbox is not None:
        sandbox_from_obj = from_obj(
            obj_sandbox,
            expected=[bool],
            path=path + '.sandbox')  # type: Optional[bool]
    else:
        sandbox_from_obj = None

    obj_vendor_auth_code = obj.get('vendorAuthCode', None)
    if obj_vendor_auth_code is not None:
        vendor_auth_code_from_obj = from_obj(
            obj_vendor_auth_code,
            expected=[str],
            path=path + '.vendorAuthCode')  # type: Optional[str]
    else:
        vendor_auth_code_from_obj = None

    obj_vendor_id = obj.get('vendorID', None)
    if obj_vendor_id is not None:
        vendor_id_from_obj = from_obj(
            obj_vendor_id,
            expected=[int],
            path=path + '.vendorID')  # type: Optional[int]
    else:
        vendor_id_from_obj = None

    return PaymentsPaddle(
        plans=plans_from_obj,
        products=products_from_obj,
        public_key=public_key_from_obj,
        sandbox=sandbox_from_obj,
        vendor_auth_code=vendor_auth_code_from_obj,
        vendor_id=vendor_id_from_obj)


def payments_paddle_to_jsonable(
        payments_paddle: PaymentsPaddle,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of PaymentsPaddle.

    :param payments_paddle: instance of PaymentsPaddle to be JSON-ized
    :param path: path to the payments_paddle used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if payments_paddle.plans is not None:
        res['plans'] = to_jsonable(
        payments_paddle.plans,
        expected=[dict, int],
        path='{}.plans'.format(path))

    if payments_paddle.products is not None:
        res['products'] = to_jsonable(
        payments_paddle.products,
        expected=[dict, int],
        path='{}.products'.format(path))

    if payments_paddle.public_key is not None:
        res['publicKey'] = to_jsonable(
        payments_paddle.public_key,
        expected=[CryptolibKeyCryptolibRSA2048PublicKey],
        path='{}.publicKey'.format(path))

    if payments_paddle.sandbox is not None:
        res['sandbox'] = payments_paddle.sandbox

    if payments_paddle.vendor_auth_code is not None:
        res['vendorAuthCode'] = payments_paddle.vendor_auth_code

    if payments_paddle.vendor_id is not None:
        res['vendorID'] = payments_paddle.vendor_id

    return res


class RegexpRegexp:
    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to regexp_regexp_to_jsonable.

        :return: a JSON-able representation
        """
        return regexp_regexp_to_jsonable(self)


def new_regexp_regexp() -> RegexpRegexp:
    """Generates an instance of RegexpRegexp with default values."""
    return RegexpRegexp()


def regexp_regexp_from_obj(obj: Any, path: str = "") -> RegexpRegexp:
    """
    Generates an instance of RegexpRegexp from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of RegexpRegexp
    :param path: path to the object used for debugging
    :return: parsed instance of RegexpRegexp
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    return RegexpRegexp()


def regexp_regexp_to_jsonable(
        regexp_regexp: RegexpRegexp,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of RegexpRegexp.

    :param regexp_regexp: instance of RegexpRegexp to be JSON-ized
    :param path: path to the regexp_regexp used for debugging
    :return: a JSON-able representation
    """
    return dict()


class TypesCivilDate:
    def __init__(
            self,
            day: Optional[int] = None,
            month: Optional[int] = None,
            year: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.day = day

        self.month = month

        self.year = year

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to types_civil_date_to_jsonable.

        :return: JSON-able representation
        """
        return types_civil_date_to_jsonable(self)


def new_types_civil_date() -> TypesCivilDate:
    """Generates an instance of TypesCivilDate with default values."""
    return TypesCivilDate()


def types_civil_date_from_obj(obj: Any, path: str = "") -> TypesCivilDate:
    """
    Generates an instance of TypesCivilDate from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of TypesCivilDate
    :param path: path to the object used for debugging
    :return: parsed instance of TypesCivilDate
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_day = obj.get('day', None)
    if obj_day is not None:
        day_from_obj = from_obj(
            obj_day,
            expected=[int],
            path=path + '.day')  # type: Optional[int]
    else:
        day_from_obj = None

    obj_month = obj.get('month', None)
    if obj_month is not None:
        month_from_obj = from_obj(
            obj_month,
            expected=[int],
            path=path + '.month')  # type: Optional[int]
    else:
        month_from_obj = None

    obj_year = obj.get('year', None)
    if obj_year is not None:
        year_from_obj = from_obj(
            obj_year,
            expected=[int],
            path=path + '.year')  # type: Optional[int]
    else:
        year_from_obj = None

    return TypesCivilDate(
        day=day_from_obj,
        month=month_from_obj,
        year=year_from_obj)


def types_civil_date_to_jsonable(
        types_civil_date: TypesCivilDate,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of TypesCivilDate.

    :param types_civil_date: instance of TypesCivilDate to be JSON-ized
    :param path: path to the types_civil_date used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if types_civil_date.day is not None:
        res['day'] = types_civil_date.day

    if types_civil_date.month is not None:
        res['month'] = types_civil_date.month

    if types_civil_date.year is not None:
        res['year'] = types_civil_date.year

    return res


class TypesFilter:
    def __init__(
            self,
            filters: Optional[List['TypesFilter']] = None,
            invert: Optional[bool] = None,
            or: Optional[bool] = None,
            property: Optional[str] = None,
            regexp: Optional['RegexpRegexp'] = None) -> None:
        """Initializes with the given values."""
        self.filters = filters

        self.invert = invert

        self.or = or

        self.property = property

        self.regexp = regexp

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to types_filter_to_jsonable.

        :return: JSON-able representation
        """
        return types_filter_to_jsonable(self)


def new_types_filter() -> TypesFilter:
    """Generates an instance of TypesFilter with default values."""
    return TypesFilter()


def types_filter_from_obj(obj: Any, path: str = "") -> TypesFilter:
    """
    Generates an instance of TypesFilter from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of TypesFilter
    :param path: path to the object used for debugging
    :return: parsed instance of TypesFilter
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_filters = obj.get('filters', None)
    if obj_filters is not None:
        filters_from_obj = from_obj(
            obj_filters,
            expected=[list, TypesFilter],
            path=path + '.filters')  # type: Optional[List['TypesFilter']]
    else:
        filters_from_obj = None

    obj_invert = obj.get('invert', None)
    if obj_invert is not None:
        invert_from_obj = from_obj(
            obj_invert,
            expected=[bool],
            path=path + '.invert')  # type: Optional[bool]
    else:
        invert_from_obj = None

    obj_or = obj.get('or', None)
    if obj_or is not None:
        or_from_obj = from_obj(
            obj_or,
            expected=[bool],
            path=path + '.or')  # type: Optional[bool]
    else:
        or_from_obj = None

    obj_property = obj.get('property', None)
    if obj_property is not None:
        property_from_obj = from_obj(
            obj_property,
            expected=[str],
            path=path + '.property')  # type: Optional[str]
    else:
        property_from_obj = None

    obj_regexp = obj.get('regexp', None)
    if obj_regexp is not None:
        regexp_from_obj = from_obj(
            obj_regexp,
            expected=[RegexpRegexp],
            path=path + '.regexp')  # type: Optional['RegexpRegexp']
    else:
        regexp_from_obj = None

    return TypesFilter(
        filters=filters_from_obj,
        invert=invert_from_obj,
        or=or_from_obj,
        property=property_from_obj,
        regexp=regexp_from_obj)


def types_filter_to_jsonable(
        types_filter: TypesFilter,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of TypesFilter.

    :param types_filter: instance of TypesFilter to be JSON-ized
    :param path: path to the types_filter used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if types_filter.filters is not None:
        res['filters'] = to_jsonable(
        types_filter.filters,
        expected=[list, TypesFilter],
        path='{}.filters'.format(path))

    if types_filter.invert is not None:
        res['invert'] = types_filter.invert

    if types_filter.or is not None:
        res['or'] = types_filter.or

    if types_filter.property is not None:
        res['property'] = types_filter.property

    if types_filter.regexp is not None:
        res['regexp'] = to_jsonable(
        types_filter.regexp,
        expected=[RegexpRegexp],
        path='{}.regexp'.format(path))

    return res


class TypesRecurrence:
    def __init__(
            self,
            day: Optional[int] = None,
            end: Optional['TypesCivilDate'] = None,
            month: Optional[int] = None,
            month_week: Optional[int] = None,
            separation: Optional[int] = None,
            weekday: Optional[int] = None,
            weekdays: Optional[List[int]] = None) -> None:
        """Initializes with the given values."""
        self.day = day

        self.end = end

        self.month = month

        self.month_week = month_week

        self.separation = separation

        self.weekday = weekday

        self.weekdays = weekdays

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to types_recurrence_to_jsonable.

        :return: JSON-able representation
        """
        return types_recurrence_to_jsonable(self)


def new_types_recurrence() -> TypesRecurrence:
    """Generates an instance of TypesRecurrence with default values."""
    return TypesRecurrence()


def types_recurrence_from_obj(obj: Any, path: str = "") -> TypesRecurrence:
    """
    Generates an instance of TypesRecurrence from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of TypesRecurrence
    :param path: path to the object used for debugging
    :return: parsed instance of TypesRecurrence
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_day = obj.get('day', None)
    if obj_day is not None:
        day_from_obj = from_obj(
            obj_day,
            expected=[int],
            path=path + '.day')  # type: Optional[int]
    else:
        day_from_obj = None

    obj_end = obj.get('end', None)
    if obj_end is not None:
        end_from_obj = from_obj(
            obj_end,
            expected=[TypesCivilDate],
            path=path + '.end')  # type: Optional['TypesCivilDate']
    else:
        end_from_obj = None

    obj_month = obj.get('month', None)
    if obj_month is not None:
        month_from_obj = from_obj(
            obj_month,
            expected=[int],
            path=path + '.month')  # type: Optional[int]
    else:
        month_from_obj = None

    obj_month_week = obj.get('monthWeek', None)
    if obj_month_week is not None:
        month_week_from_obj = from_obj(
            obj_month_week,
            expected=[int],
            path=path + '.monthWeek')  # type: Optional[int]
    else:
        month_week_from_obj = None

    obj_separation = obj.get('separation', None)
    if obj_separation is not None:
        separation_from_obj = from_obj(
            obj_separation,
            expected=[int],
            path=path + '.separation')  # type: Optional[int]
    else:
        separation_from_obj = None

    obj_weekday = obj.get('weekday', None)
    if obj_weekday is not None:
        weekday_from_obj = from_obj(
            obj_weekday,
            expected=[int],
            path=path + '.weekday')  # type: Optional[int]
    else:
        weekday_from_obj = None

    obj_weekdays = obj.get('weekdays', None)
    if obj_weekdays is not None:
        weekdays_from_obj = from_obj(
            obj_weekdays,
            expected=[list, int],
            path=path + '.weekdays')  # type: Optional[List[int]]
    else:
        weekdays_from_obj = None

    return TypesRecurrence(
        day=day_from_obj,
        end=end_from_obj,
        month=month_from_obj,
        month_week=month_week_from_obj,
        separation=separation_from_obj,
        weekday=weekday_from_obj,
        weekdays=weekdays_from_obj)


def types_recurrence_to_jsonable(
        types_recurrence: TypesRecurrence,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of TypesRecurrence.

    :param types_recurrence: instance of TypesRecurrence to be JSON-ized
    :param path: path to the types_recurrence used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if types_recurrence.day is not None:
        res['day'] = types_recurrence.day

    if types_recurrence.end is not None:
        res['end'] = to_jsonable(
        types_recurrence.end,
        expected=[TypesCivilDate],
        path='{}.end'.format(path))

    if types_recurrence.month is not None:
        res['month'] = types_recurrence.month

    if types_recurrence.month_week is not None:
        res['monthWeek'] = types_recurrence.month_week

    if types_recurrence.separation is not None:
        res['separation'] = types_recurrence.separation

    if types_recurrence.weekday is not None:
        res['weekday'] = types_recurrence.weekday

    if types_recurrence.weekdays is not None:
        res['weekdays'] = to_jsonable(
        types_recurrence.weekdays,
        expected=[list, int],
        path='{}.weekdays'.format(path))

    return res


class WebauthnCredential:
    def __init__(
            self,
            id: Optional[str] = None,
            name: Optional[str] = None,
            public_key: Optional['CryptolibKeyCryptolibKeyProviderPublic'] = None,
            transports: Optional[List[str]] = None) -> None:
        """Initializes with the given values."""
        self.id = id

        self.name = name

        self.public_key = public_key

        self.transports = transports

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to webauthn_credential_to_jsonable.

        :return: JSON-able representation
        """
        return webauthn_credential_to_jsonable(self)


def new_webauthn_credential() -> WebauthnCredential:
    """Generates an instance of WebauthnCredential with default values."""
    return WebauthnCredential()


def webauthn_credential_from_obj(obj: Any, path: str = "") -> WebauthnCredential:
    """
    Generates an instance of WebauthnCredential from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of WebauthnCredential
    :param path: path to the object used for debugging
    :return: parsed instance of WebauthnCredential
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_public_key = obj.get('publicKey', None)
    if obj_public_key is not None:
        public_key_from_obj = from_obj(
            obj_public_key,
            expected=[CryptolibKeyCryptolibKeyProviderPublic],
            path=path + '.publicKey')  # type: Optional['CryptolibKeyCryptolibKeyProviderPublic']
    else:
        public_key_from_obj = None

    obj_transports = obj.get('transports', None)
    if obj_transports is not None:
        transports_from_obj = from_obj(
            obj_transports,
            expected=[list, str],
            path=path + '.transports')  # type: Optional[List[str]]
    else:
        transports_from_obj = None

    return WebauthnCredential(
        id=id_from_obj,
        name=name_from_obj,
        public_key=public_key_from_obj,
        transports=transports_from_obj)


def webauthn_credential_to_jsonable(
        webauthn_credential: WebauthnCredential,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of WebauthnCredential.

    :param webauthn_credential: instance of WebauthnCredential to be JSON-ized
    :param path: path to the webauthn_credential used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if webauthn_credential.id is not None:
        res['id'] = webauthn_credential.id

    if webauthn_credential.name is not None:
        res['name'] = webauthn_credential.name

    if webauthn_credential.public_key is not None:
        res['publicKey'] = to_jsonable(
        webauthn_credential.public_key,
        expected=[CryptolibKeyCryptolibKeyProviderPublic],
        path='{}.publicKey'.format(path))

    if webauthn_credential.transports is not None:
        res['transports'] = to_jsonable(
        webauthn_credential.transports,
        expected=[list, str],
        path='{}.transports'.format(path))

    return res


class WebauthnCredentialCreation:
    def __init__(
            self,
            challenge: Optional[str] = None,
            credential_transports: Optional[List[str]] = None,
            id: Optional[str] = None,
            name: Optional[str] = None,
            public_key: Optional[str] = None,
            public_key_algorithm: Optional[int] = None) -> None:
        """Initializes with the given values."""
        self.challenge = challenge

        self.credential_transports = credential_transports

        self.id = id

        self.name = name

        self.public_key = public_key

        self.public_key_algorithm = public_key_algorithm

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to webauthn_credential_creation_to_jsonable.

        :return: JSON-able representation
        """
        return webauthn_credential_creation_to_jsonable(self)


def new_webauthn_credential_creation() -> WebauthnCredentialCreation:
    """Generates an instance of WebauthnCredentialCreation with default values."""
    return WebauthnCredentialCreation()


def webauthn_credential_creation_from_obj(obj: Any, path: str = "") -> WebauthnCredentialCreation:
    """
    Generates an instance of WebauthnCredentialCreation from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of WebauthnCredentialCreation
    :param path: path to the object used for debugging
    :return: parsed instance of WebauthnCredentialCreation
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_challenge = obj.get('challenge', None)
    if obj_challenge is not None:
        challenge_from_obj = from_obj(
            obj_challenge,
            expected=[str],
            path=path + '.challenge')  # type: Optional[str]
    else:
        challenge_from_obj = None

    obj_credential_transports = obj.get('credentialTransports', None)
    if obj_credential_transports is not None:
        credential_transports_from_obj = from_obj(
            obj_credential_transports,
            expected=[list, str],
            path=path + '.credentialTransports')  # type: Optional[List[str]]
    else:
        credential_transports_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    obj_public_key = obj.get('publicKey', None)
    if obj_public_key is not None:
        public_key_from_obj = from_obj(
            obj_public_key,
            expected=[str],
            path=path + '.publicKey')  # type: Optional[str]
    else:
        public_key_from_obj = None

    obj_public_key_algorithm = obj.get('publicKeyAlgorithm', None)
    if obj_public_key_algorithm is not None:
        public_key_algorithm_from_obj = from_obj(
            obj_public_key_algorithm,
            expected=[int],
            path=path + '.publicKeyAlgorithm')  # type: Optional[int]
    else:
        public_key_algorithm_from_obj = None

    return WebauthnCredentialCreation(
        challenge=challenge_from_obj,
        credential_transports=credential_transports_from_obj,
        id=id_from_obj,
        name=name_from_obj,
        public_key=public_key_from_obj,
        public_key_algorithm=public_key_algorithm_from_obj)


def webauthn_credential_creation_to_jsonable(
        webauthn_credential_creation: WebauthnCredentialCreation,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of WebauthnCredentialCreation.

    :param webauthn_credential_creation: instance of WebauthnCredentialCreation to be JSON-ized
    :param path: path to the webauthn_credential_creation used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if webauthn_credential_creation.challenge is not None:
        res['challenge'] = webauthn_credential_creation.challenge

    if webauthn_credential_creation.credential_transports is not None:
        res['credentialTransports'] = to_jsonable(
        webauthn_credential_creation.credential_transports,
        expected=[list, str],
        path='{}.credentialTransports'.format(path))

    if webauthn_credential_creation.id is not None:
        res['id'] = webauthn_credential_creation.id

    if webauthn_credential_creation.name is not None:
        res['name'] = webauthn_credential_creation.name

    if webauthn_credential_creation.public_key is not None:
        res['publicKey'] = webauthn_credential_creation.public_key

    if webauthn_credential_creation.public_key_algorithm is not None:
        res['publicKeyAlgorithm'] = webauthn_credential_creation.public_key_algorithm

    return res


class WebauthnCredentialCreationOpts:
    def __init__(
            self,
            challenge: Optional[str] = None,
            pub_key_cred_params: Optional[List['WebauthnCredentialCreationOptsParameter']] = None,
            rp: Optional['WebauthnCredentialCreationOptsRelyingParty'] = None,
            timeout: Optional[int] = None,
            user: Optional['WebauthnCredentialCreationOptsUser'] = None) -> None:
        """Initializes with the given values."""
        self.challenge = challenge

        self.pub_key_cred_params = pub_key_cred_params

        self.rp = rp

        # Timeout, in milliseconds.
        self.timeout = timeout

        self.user = user

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to webauthn_credential_creation_opts_to_jsonable.

        :return: JSON-able representation
        """
        return webauthn_credential_creation_opts_to_jsonable(self)


def new_webauthn_credential_creation_opts() -> WebauthnCredentialCreationOpts:
    """Generates an instance of WebauthnCredentialCreationOpts with default values."""
    return WebauthnCredentialCreationOpts()


def webauthn_credential_creation_opts_from_obj(obj: Any, path: str = "") -> WebauthnCredentialCreationOpts:
    """
    Generates an instance of WebauthnCredentialCreationOpts from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of WebauthnCredentialCreationOpts
    :param path: path to the object used for debugging
    :return: parsed instance of WebauthnCredentialCreationOpts
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_challenge = obj.get('challenge', None)
    if obj_challenge is not None:
        challenge_from_obj = from_obj(
            obj_challenge,
            expected=[str],
            path=path + '.challenge')  # type: Optional[str]
    else:
        challenge_from_obj = None

    obj_pub_key_cred_params = obj.get('pubKeyCredParams', None)
    if obj_pub_key_cred_params is not None:
        pub_key_cred_params_from_obj = from_obj(
            obj_pub_key_cred_params,
            expected=[list, WebauthnCredentialCreationOptsParameter],
            path=path + '.pubKeyCredParams')  # type: Optional[List['WebauthnCredentialCreationOptsParameter']]
    else:
        pub_key_cred_params_from_obj = None

    obj_rp = obj.get('rp', None)
    if obj_rp is not None:
        rp_from_obj = from_obj(
            obj_rp,
            expected=[WebauthnCredentialCreationOptsRelyingParty],
            path=path + '.rp')  # type: Optional['WebauthnCredentialCreationOptsRelyingParty']
    else:
        rp_from_obj = None

    obj_timeout = obj.get('timeout', None)
    if obj_timeout is not None:
        timeout_from_obj = from_obj(
            obj_timeout,
            expected=[int],
            path=path + '.timeout')  # type: Optional[int]
    else:
        timeout_from_obj = None

    obj_user = obj.get('user', None)
    if obj_user is not None:
        user_from_obj = from_obj(
            obj_user,
            expected=[WebauthnCredentialCreationOptsUser],
            path=path + '.user')  # type: Optional['WebauthnCredentialCreationOptsUser']
    else:
        user_from_obj = None

    return WebauthnCredentialCreationOpts(
        challenge=challenge_from_obj,
        pub_key_cred_params=pub_key_cred_params_from_obj,
        rp=rp_from_obj,
        timeout=timeout_from_obj,
        user=user_from_obj)


def webauthn_credential_creation_opts_to_jsonable(
        webauthn_credential_creation_opts: WebauthnCredentialCreationOpts,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of WebauthnCredentialCreationOpts.

    :param webauthn_credential_creation_opts: instance of WebauthnCredentialCreationOpts to be JSON-ized
    :param path: path to the webauthn_credential_creation_opts used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if webauthn_credential_creation_opts.challenge is not None:
        res['challenge'] = webauthn_credential_creation_opts.challenge

    if webauthn_credential_creation_opts.pub_key_cred_params is not None:
        res['pubKeyCredParams'] = to_jsonable(
        webauthn_credential_creation_opts.pub_key_cred_params,
        expected=[list, WebauthnCredentialCreationOptsParameter],
        path='{}.pubKeyCredParams'.format(path))

    if webauthn_credential_creation_opts.rp is not None:
        res['rp'] = to_jsonable(
        webauthn_credential_creation_opts.rp,
        expected=[WebauthnCredentialCreationOptsRelyingParty],
        path='{}.rp'.format(path))

    if webauthn_credential_creation_opts.timeout is not None:
        res['timeout'] = webauthn_credential_creation_opts.timeout

    if webauthn_credential_creation_opts.user is not None:
        res['user'] = to_jsonable(
        webauthn_credential_creation_opts.user,
        expected=[WebauthnCredentialCreationOptsUser],
        path='{}.user'.format(path))

    return res


class WebauthnCredentialCreationOptsParameter:
    def __init__(
            self,
            alg: Optional[int] = None,
            type: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.alg = alg

        self.type = type

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to webauthn_credential_creation_opts_parameter_to_jsonable.

        :return: JSON-able representation
        """
        return webauthn_credential_creation_opts_parameter_to_jsonable(self)


def new_webauthn_credential_creation_opts_parameter() -> WebauthnCredentialCreationOptsParameter:
    """Generates an instance of WebauthnCredentialCreationOptsParameter with default values."""
    return WebauthnCredentialCreationOptsParameter()


def webauthn_credential_creation_opts_parameter_from_obj(obj: Any, path: str = "") -> WebauthnCredentialCreationOptsParameter:
    """
    Generates an instance of WebauthnCredentialCreationOptsParameter from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of WebauthnCredentialCreationOptsParameter
    :param path: path to the object used for debugging
    :return: parsed instance of WebauthnCredentialCreationOptsParameter
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_alg = obj.get('alg', None)
    if obj_alg is not None:
        alg_from_obj = from_obj(
            obj_alg,
            expected=[int],
            path=path + '.alg')  # type: Optional[int]
    else:
        alg_from_obj = None

    obj_type = obj.get('type', None)
    if obj_type is not None:
        type_from_obj = from_obj(
            obj_type,
            expected=[str],
            path=path + '.type')  # type: Optional[str]
    else:
        type_from_obj = None

    return WebauthnCredentialCreationOptsParameter(
        alg=alg_from_obj,
        type=type_from_obj)


def webauthn_credential_creation_opts_parameter_to_jsonable(
        webauthn_credential_creation_opts_parameter: WebauthnCredentialCreationOptsParameter,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of WebauthnCredentialCreationOptsParameter.

    :param webauthn_credential_creation_opts_parameter: instance of WebauthnCredentialCreationOptsParameter to be JSON-ized
    :param path: path to the webauthn_credential_creation_opts_parameter used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if webauthn_credential_creation_opts_parameter.alg is not None:
        res['alg'] = webauthn_credential_creation_opts_parameter.alg

    if webauthn_credential_creation_opts_parameter.type is not None:
        res['type'] = webauthn_credential_creation_opts_parameter.type

    return res


class WebauthnCredentialCreationOptsRelyingParty:
    def __init__(
            self,
            id: Optional[str] = None,
            name: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.id = id

        self.name = name

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to webauthn_credential_creation_opts_relying_party_to_jsonable.

        :return: JSON-able representation
        """
        return webauthn_credential_creation_opts_relying_party_to_jsonable(self)


def new_webauthn_credential_creation_opts_relying_party() -> WebauthnCredentialCreationOptsRelyingParty:
    """Generates an instance of WebauthnCredentialCreationOptsRelyingParty with default values."""
    return WebauthnCredentialCreationOptsRelyingParty()


def webauthn_credential_creation_opts_relying_party_from_obj(obj: Any, path: str = "") -> WebauthnCredentialCreationOptsRelyingParty:
    """
    Generates an instance of WebauthnCredentialCreationOptsRelyingParty from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of WebauthnCredentialCreationOptsRelyingParty
    :param path: path to the object used for debugging
    :return: parsed instance of WebauthnCredentialCreationOptsRelyingParty
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    return WebauthnCredentialCreationOptsRelyingParty(
        id=id_from_obj,
        name=name_from_obj)


def webauthn_credential_creation_opts_relying_party_to_jsonable(
        webauthn_credential_creation_opts_relying_party: WebauthnCredentialCreationOptsRelyingParty,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of WebauthnCredentialCreationOptsRelyingParty.

    :param webauthn_credential_creation_opts_relying_party: instance of WebauthnCredentialCreationOptsRelyingParty to be JSON-ized
    :param path: path to the webauthn_credential_creation_opts_relying_party used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if webauthn_credential_creation_opts_relying_party.id is not None:
        res['id'] = webauthn_credential_creation_opts_relying_party.id

    if webauthn_credential_creation_opts_relying_party.name is not None:
        res['name'] = webauthn_credential_creation_opts_relying_party.name

    return res


class WebauthnCredentialCreationOptsUser:
    def __init__(
            self,
            display_name: Optional[str] = None,
            id: Optional[str] = None,
            name: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.display_name = display_name

        self.id = id

        self.name = name

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to webauthn_credential_creation_opts_user_to_jsonable.

        :return: JSON-able representation
        """
        return webauthn_credential_creation_opts_user_to_jsonable(self)


def new_webauthn_credential_creation_opts_user() -> WebauthnCredentialCreationOptsUser:
    """Generates an instance of WebauthnCredentialCreationOptsUser with default values."""
    return WebauthnCredentialCreationOptsUser()


def webauthn_credential_creation_opts_user_from_obj(obj: Any, path: str = "") -> WebauthnCredentialCreationOptsUser:
    """
    Generates an instance of WebauthnCredentialCreationOptsUser from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of WebauthnCredentialCreationOptsUser
    :param path: path to the object used for debugging
    :return: parsed instance of WebauthnCredentialCreationOptsUser
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_display_name = obj.get('displayName', None)
    if obj_display_name is not None:
        display_name_from_obj = from_obj(
            obj_display_name,
            expected=[str],
            path=path + '.displayName')  # type: Optional[str]
    else:
        display_name_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_name = obj.get('name', None)
    if obj_name is not None:
        name_from_obj = from_obj(
            obj_name,
            expected=[str],
            path=path + '.name')  # type: Optional[str]
    else:
        name_from_obj = None

    return WebauthnCredentialCreationOptsUser(
        display_name=display_name_from_obj,
        id=id_from_obj,
        name=name_from_obj)


def webauthn_credential_creation_opts_user_to_jsonable(
        webauthn_credential_creation_opts_user: WebauthnCredentialCreationOptsUser,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of WebauthnCredentialCreationOptsUser.

    :param webauthn_credential_creation_opts_user: instance of WebauthnCredentialCreationOptsUser to be JSON-ized
    :param path: path to the webauthn_credential_creation_opts_user used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if webauthn_credential_creation_opts_user.display_name is not None:
        res['displayName'] = webauthn_credential_creation_opts_user.display_name

    if webauthn_credential_creation_opts_user.id is not None:
        res['id'] = webauthn_credential_creation_opts_user.id

    if webauthn_credential_creation_opts_user.name is not None:
        res['name'] = webauthn_credential_creation_opts_user.name

    return res


class WebauthnCredentialRequest:
    def __init__(
            self,
            authenticator_data: Optional[str] = None,
            challenge: Optional[str] = None,
            client_data_json: Optional[str] = None,
            id: Optional[str] = None,
            signature: Optional[str] = None) -> None:
        """Initializes with the given values."""
        self.authenticator_data = authenticator_data

        self.challenge = challenge

        self.client_data_json = client_data_json

        self.id = id

        self.signature = signature

    def to_jsonable(self) -> MutableMapping[str, Any]:
        """
        Dispatches the conversion to webauthn_credential_request_to_jsonable.

        :return: JSON-able representation
        """
        return webauthn_credential_request_to_jsonable(self)


def new_webauthn_credential_request() -> WebauthnCredentialRequest:
    """Generates an instance of WebauthnCredentialRequest with default values."""
    return WebauthnCredentialRequest()


def webauthn_credential_request_from_obj(obj: Any, path: str = "") -> WebauthnCredentialRequest:
    """
    Generates an instance of WebauthnCredentialRequest from a dictionary object.

    :param obj: a JSON-ed dictionary object representing an instance of WebauthnCredentialRequest
    :param path: path to the object used for debugging
    :return: parsed instance of WebauthnCredentialRequest
    """
    if not isinstance(obj, dict):
        raise ValueError('Expected a dict at path {}, but got: {}'.format(path, type(obj)))

    for key in obj:
        if not isinstance(key, str):
            raise ValueError(
                'Expected a key of type str at path {}, but got: {}'.format(path, type(key)))

    obj_authenticator_data = obj.get('authenticatorData', None)
    if obj_authenticator_data is not None:
        authenticator_data_from_obj = from_obj(
            obj_authenticator_data,
            expected=[str],
            path=path + '.authenticatorData')  # type: Optional[str]
    else:
        authenticator_data_from_obj = None

    obj_challenge = obj.get('challenge', None)
    if obj_challenge is not None:
        challenge_from_obj = from_obj(
            obj_challenge,
            expected=[str],
            path=path + '.challenge')  # type: Optional[str]
    else:
        challenge_from_obj = None

    obj_client_data_json = obj.get('clientDataJSON', None)
    if obj_client_data_json is not None:
        client_data_json_from_obj = from_obj(
            obj_client_data_json,
            expected=[str],
            path=path + '.clientDataJSON')  # type: Optional[str]
    else:
        client_data_json_from_obj = None

    obj_id = obj.get('id', None)
    if obj_id is not None:
        id_from_obj = from_obj(
            obj_id,
            expected=[str],
            path=path + '.id')  # type: Optional[str]
    else:
        id_from_obj = None

    obj_signature = obj.get('signature', None)
    if obj_signature is not None:
        signature_from_obj = from_obj(
            obj_signature,
            expected=[str],
            path=path + '.signature')  # type: Optional[str]
    else:
        signature_from_obj = None

    return WebauthnCredentialRequest(
        authenticator_data=authenticator_data_from_obj,
        challenge=challenge_from_obj,
        client_data_json=client_data_json_from_obj,
        id=id_from_obj,
        signature=signature_from_obj)


def webauthn_credential_request_to_jsonable(
        webauthn_credential_request: WebauthnCredentialRequest,
        path: str = "") -> MutableMapping[str, Any]:
    """
    Generates a JSON-able mapping from an instance of WebauthnCredentialRequest.

    :param webauthn_credential_request: instance of WebauthnCredentialRequest to be JSON-ized
    :param path: path to the webauthn_credential_request used for debugging
    :return: a JSON-able representation
    """
    res = dict()  # type: Dict[str, Any]

    if webauthn_credential_request.authenticator_data is not None:
        res['authenticatorData'] = webauthn_credential_request.authenticator_data

    if webauthn_credential_request.challenge is not None:
        res['challenge'] = webauthn_credential_request.challenge

    if webauthn_credential_request.client_data_json is not None:
        res['clientDataJSON'] = webauthn_credential_request.client_data_json

    if webauthn_credential_request.id is not None:
        res['id'] = webauthn_credential_request.id

    if webauthn_credential_request.signature is not None:
        res['signature'] = webauthn_credential_request.signature

    return res


class RemoteCaller:
    """Executes the remote calls to the server."""

    def __init__(
        self,
        url_prefix: str,
        auth: Optional[requests.auth.AuthBase] = None,
        session: Optional[requests.Session] = None) -> None:
        self.url_prefix = url_prefix
        self.auth = auth
        self.session = session

        if not self.session:
            self.session = requests.Session()
            self.session.auth = self.auth

    def auth_accounts_read(self) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a get request to /api/v1/auth/accounts.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/accounts'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_create(
            self,
            body: 'ModelsAuthAccount') -> 'HttplibJsonResponseModelsAuthSessions':
        """
        Send a post request to /api/v1/auth/accounts.

        :param body: AuthAccount

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/accounts'

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthSessions])

    def auth_account_delegation_create(
            self,
            body: 'ModelsAuthAccountDelegation',
            auth_account_id: str) -> 'HttplibJsonResponseModelsAuthAccountDelegations':
        """
        Send a post request to /api/v1/auth/accounts/{authAccountID}/delegation.

        :param body: AuthAccountDelegation
        :param auth_account_id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(auth_account_id),
            '/delegation'])

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccountDelegation])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccountDelegations])

    def auth_account_delegation_delete(
            self,
            auth_account_id: str,
            id: str) -> 'HttplibJsonResponseModelsAuthAccountDelegations':
        """
        Send a delete request to /api/v1/auth/accounts/{authAccountID}/delegation/{id}.

        :param auth_account_id: ID
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(auth_account_id),
            '/delegation/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccountDelegations])

    def auth_account_delegation_update(
            self,
            body: 'ModelsAuthAccountDelegation',
            auth_account_id: str,
            id: str) -> 'HttplibJsonResponseModelsAuthAccountDelegations':
        """
        Send a put request to /api/v1/auth/accounts/{authAccountID}/delegation/{id}.

        :param body: AuthAccountDelegation
        :param auth_account_id: ID
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(auth_account_id),
            '/delegation/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccountDelegation])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccountDelegations])

    def auth_account_delete(
            self,
            id: str) -> MutableMapping[str, Any]:
        """
        Send a delete request to /api/v1/auth/accounts/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return resp.json()

    def auth_account_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a get request to /api/v1/auth/accounts/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_update(
            self,
            body: 'ModelsAuthAccount',
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a put request to /api/v1/auth/accounts/{id}.

        :param body: AuthAccount
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_keys_update(
            self,
            body: 'ModelsAuthAccount',
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a put request to /api/v1/auth/accounts/{id}/keys.

        :param body: AuthAccount
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id),
            '/keys'])

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_o_id_c_update(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a put request to /api/v1/auth/accounts/{id}/oidc.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id),
            '/oidc'])

        resp = self.session.request(
            method='put',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_password_update(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a put request to /api/v1/auth/accounts/{id}/password.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id),
            '/password'])

        resp = self.session.request(
            method='put',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_t_o_t_p_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a get request to /api/v1/auth/accounts/{id}/totp.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id),
            '/totp'])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_t_o_t_p_create(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a post request to /api/v1/auth/accounts/{id}/totp.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id),
            '/totp'])

        resp = self.session.request(
            method='post',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_t_o_t_p_update(
            self,
            body: 'ModelsAuthAccount',
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a put request to /api/v1/auth/accounts/{id}/totp.

        :param body: AuthAccount
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id),
            '/totp'])

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_web_authn_read(
            self,
            id: str) -> 'HttplibJsonResponseWebauthnCredentialCreationOpts':
        """
        Send a get request to /api/v1/auth/accounts/{id}/webauthn.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id),
            '/webauthn'])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseWebauthnCredentialCreationOpts])

    def auth_account_web_authn_update(
            self,
            body: 'ModelsAuthAccount',
            id: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a put request to /api/v1/auth/accounts/{id}/webauthn.

        :param body: AuthAccount
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/accounts/',
            str(id),
            '/webauthn'])

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_households_read(self) -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a get request to /api/v1/auth/households.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/households'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_create(
            self,
            body: 'ModelsAuthHousehold') -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a post request to /api/v1/auth/households.

        :param body: AuthHousehold

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/households'

        data = to_jsonable(
            body,
            expected=[ModelsAuthHousehold])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_member_delete(
            self,
            auth_account_id: str,
            auth_household_id: str) -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a delete request to /api/v1/auth/households/{auth_household_id}/members/{auth_account_id}.

        :param auth_account_id: AuthAccountID
        :param auth_household_id: AuthHouseholdID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/households/',
            str(auth_household_id),
            '/members/',
            str(auth_account_id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_member_update(
            self,
            auth_account_id: str,
            auth_household_id: str,
            body: 'ModelsAuthAccount') -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a put request to /api/v1/auth/households/{auth_household_id}/members/{auth_account_id}.

        :param auth_account_id: AuthAccountID
        :param auth_household_id: AuthHouseholdID
        :param body: AuthAccount

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/households/',
            str(auth_household_id),
            '/members/',
            str(auth_account_id)])

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a delete request to /api/v1/auth/households/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/households/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a get request to /api/v1/auth/households/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/households/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_update(
            self,
            body: 'ModelsAuthHousehold',
            id: str) -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a put request to /api/v1/auth/households/{id}.

        :param body: AuthHousehold
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/households/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsAuthHousehold])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_invite_create(
            self,
            body: 'ModelsAuthAccount',
            id: str) -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a post request to /api/v1/auth/households/{id}/invites.

        :param body: AuthAccountAuthHousehold
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/households/',
            str(id),
            '/invites'])

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_invite_delete(
            self,
            id: str,
            token: str) -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a delete request to /api/v1/auth/households/{id}/invites/{token}.

        :param id: ID
        :param token: Token

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/households/',
            str(id),
            '/invites/',
            str(token)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_household_invite_accept(
            self,
            id: str,
            token: str) -> 'HttplibJsonResponseModelsAuthHouseholds':
        """
        Send a get request to /api/v1/auth/households/{id}/invites/{token}.

        :param id: ID
        :param token: Token

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/households/',
            str(id),
            '/invites/',
            str(token)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthHouseholds])

    def auth_methods_create(
            self,
            body: 'ModelsAuthAccount') -> 'HttplibJsonResponseModelsAuthSessions':
        """
        Requires emailAddress

        :param body: AuthAccount

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/methods'

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthSessions])

    def auth_o_id_c_clients_read(self) -> 'HttplibJsonResponseModelsAuthOIDCClients':
        """
        Send a get request to /api/v1/auth/oidc/clients.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/oidc/clients'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthOIDCClients])

    def auth_o_id_c_client_create(
            self,
            body: 'ModelsAuthOIDCClient') -> 'HttplibJsonResponseModelsAuthOIDCClients':
        """
        Send a post request to /api/v1/auth/oidc/clients.

        :param body: AuthOIDCClient

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/oidc/clients'

        data = to_jsonable(
            body,
            expected=[ModelsAuthOIDCClient])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthOIDCClients])

    def auth_o_id_c_client_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthOIDCClients':
        """
        Send a delete request to /api/v1/auth/oidc/clients/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/oidc/clients/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthOIDCClients])

    def auth_o_id_c_client_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsAuthOIDCClients':
        """
        Send a get request to /api/v1/auth/oidc/clients/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/oidc/clients/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthOIDCClients])

    def auth_o_id_c_client_update(
            self,
            body: 'ModelsAuthOIDCClient',
            id: str) -> 'HttplibJsonResponseModelsAuthOIDCClients':
        """
        Send a put request to /api/v1/auth/oidc/clients/{id}.

        :param body: AuthOIDCClient
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/oidc/clients/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsAuthOIDCClient])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthOIDCClients])

    def auth_o_id_c_code_read(
            self,
            body: 'ModelsAuthOIDCCode') -> 'HttplibJsonResponseModelsAuthOIDCCodes':
        """
        Send a post request to /api/v1/auth/oidc/codes.

        :param body: AuthOIDCCode

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/oidc/codes'

        data = to_jsonable(
            body,
            expected=[ModelsAuthOIDCCode])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthOIDCCodes])

    def auth_session_delete_all(self) -> MutableMapping[str, Any]:
        """
        Send a delete request to /api/v1/auth/sessions.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/sessions'

        resp = self.session.request(method='delete', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return resp.json()

    def auth_session_read(self) -> 'HttplibJsonResponseModelsAuthSessions':
        """
        Send a get request to /api/v1/auth/sessions.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/sessions'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthSessions])

    def auth_session_create(
            self,
            body: 'ModelsAuthSession') -> 'HttplibJsonResponseModelsAuthSessions':
        """
        Send a post request to /api/v1/auth/sessions.

        :param body: AuthSession

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/sessions'

        data = to_jsonable(
            body,
            expected=[ModelsAuthSession])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthSessions])

    def auth_session_delete(
            self,
            id: str) -> MutableMapping[str, Any]:
        """
        Send a delete request to /api/v1/auth/sessions/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/sessions/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return resp.json()

    def auth_session_update(
            self,
            body: 'ModelsAuthSession',
            id: str) -> 'HttplibJsonResponseModelsAuthSessions':
        """
        Send a put request to /api/v1/auth/sessions/{id}.

        :param body: AuthSession
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/sessions/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsAuthSession])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthSessions])

    def auth_sign_in_read(self) -> 'HttplibJsonResponseModelsAuthSessions':
        """
        Send a get request to /api/v1/auth/signin.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/signin'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthSessions])

    def auth_sign_in_create(
            self,
            body: 'ModelsAuthAccount') -> 'HttplibJsonResponseModelsAuthSessions':
        """
        Requires emailAddress and password

        :param body: AuthAccount

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/signin'

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthSessions])

    def auth_account_verify_read(
            self,
            body: 'ModelsAuthAccount') -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a get request to /api/v1/auth/verify.

        :param body: AuthAccount

        :return: OK
        """
        url = self.url_prefix + '/api/v1/auth/verify'

        data = to_jsonable(
            body,
            expected=[ModelsAuthAccount])


        resp = self.session.request(
            method='get',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def auth_account_verify_update(
            self,
            id: str,
            token: str) -> 'HttplibJsonResponseModelsAuthAccounts':
        """
        Send a put request to /api/v1/auth/verify/{id}/{token}.

        :param id: ID
        :param token: Verification token

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/auth/verify/',
            str(id),
            '/',
            str(token)])

        resp = self.session.request(
            method='put',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsAuthAccounts])

    def bookmarks_read(self) -> 'HttplibJsonResponseModelsBookmarks':
        """
        Send a get request to /api/v1/bookmarks.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/bookmarks'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBookmarks])

    def bookmark_create(
            self,
            body: 'ModelsBookmark') -> 'HttplibJsonResponseModelsBookmarks':
        """
        Send a post request to /api/v1/bookmarks.

        :param body: Bookmark

        :return: OK
        """
        url = self.url_prefix + '/api/v1/bookmarks'

        data = to_jsonable(
            body,
            expected=[ModelsBookmark])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBookmarks])

    def bookmark_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsBookmarks':
        """
        Send a delete request to /api/v1/bookmarks/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/bookmarks/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBookmarks])

    def bookmark_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsBookmarks':
        """
        Send a get request to /api/v1/bookmarks/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/bookmarks/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBookmarks])

    def bookmark_update(
            self,
            body: 'ModelsBookmark',
            id: str) -> 'HttplibJsonResponseModelsBookmarks':
        """
        Send a put request to /api/v1/bookmarks/{id}.

        :param body: Bookmark
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/bookmarks/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsBookmark])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBookmarks])

    def budget_accounts_read(self) -> 'HttplibJsonResponseModelsBudgetAccounts':
        """
        Send a get request to /api/v1/budget/accounts.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/accounts'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetAccounts])

    def budget_account_create(
            self,
            body: 'ModelsBudgetAccount') -> 'HttplibJsonResponseModelsBudgetAccounts':
        """
        Send a post request to /api/v1/budget/accounts.

        :param body: BudgetAccount

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/accounts'

        data = to_jsonable(
            body,
            expected=[ModelsBudgetAccount])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetAccounts])

    def budget_account_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetAccounts':
        """
        Send a delete request to /api/v1/budget/accounts/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/accounts/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetAccounts])

    def budget_account_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetAccounts':
        """
        Send a get request to /api/v1/budget/accounts/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/accounts/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetAccounts])

    def budget_account_update(
            self,
            body: 'ModelsBudgetAccount',
            id: str) -> 'HttplibJsonResponseModelsBudgetAccounts':
        """
        Send a put request to /api/v1/budget/accounts/{id}.

        :param body: BudgetAccount
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/accounts/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsBudgetAccount])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetAccounts])

    def budget_account_reconcile(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetAccounts':
        """
        Send a post request to /api/v1/budget/accounts/{id}/reconcile.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/accounts/',
            str(id),
            '/reconcile'])

        resp = self.session.request(
            method='post',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetAccounts])

    def budget_account_rollup_balance(
            self,
            id: str,
            yearmonth: int) -> 'HttplibJsonResponseModelsBudgetAccounts':
        """
        Send a post request to /api/v1/budget/accounts/{id}/rollup/{yearmonth}/balance.

        :param id: ID
        :param yearmonth: YearMonth

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/accounts/',
            str(id),
            '/rollup/',
            str(yearmonth),
            '/balance'])

        resp = self.session.request(
            method='post',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetAccounts])

    def budget_account_rollup_summary(
            self,
            id: str,
            yearmonth: int) -> 'HttplibJsonResponseModelsBudgetAccounts':
        """
        Send a post request to /api/v1/budget/accounts/{id}/rollup/{yearmonth}/summary.

        :param id: ID
        :param yearmonth: YearMonth

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/accounts/',
            str(id),
            '/rollup/',
            str(yearmonth),
            '/summary'])

        resp = self.session.request(
            method='post',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetAccounts])

    def budget_transactions_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetTransactions':
        """
        Send a get request to /api/v1/budget/accounts/{id}/transactions.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/accounts/',
            str(id),
            '/transactions'])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetTransactions])

    def budget_categories_read(self) -> 'HttplibJsonResponseModelsBudgetCategories':
        """
        Send a get request to /api/v1/budget/categories.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/categories'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetCategories])

    def budget_category_create(
            self,
            body: 'ModelsBudgetCategory') -> 'HttplibJsonResponseModelsBudgetCategories':
        """
        Send a post request to /api/v1/budget/categories.

        :param body: BudgetCategory

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/categories'

        data = to_jsonable(
            body,
            expected=[ModelsBudgetCategory])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetCategories])

    def budget_category_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetCategories':
        """
        Send a delete request to /api/v1/budget/categories/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/categories/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetCategories])

    def budget_category_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetCategories':
        """
        Send a get request to /api/v1/budget/categories/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/categories/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetCategories])

    def budget_category_update(
            self,
            body: 'ModelsBudgetCategory',
            id: str) -> 'HttplibJsonResponseModelsBudgetCategories':
        """
        Send a put request to /api/v1/budget/categories/{id}.

        :param body: BudgetCategory
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/categories/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsBudgetCategory])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetCategories])

    def budget_transactions_read_category(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetTransactions':
        """
        Send a get request to /api/v1/budget/categories/{id}/transactions.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/categories/',
            str(id),
            '/transactions'])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetTransactions])

    def budget_month_category_create(
            self,
            body: 'ModelsBudgetMonthCategory') -> 'HttplibJsonResponseModelsBudgetMonthCategories':
        """
        Send a post request to /api/v1/budget/month-categories.

        :param body: BudgetMonthCategory

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/month-categories'

        data = to_jsonable(
            body,
            expected=[ModelsBudgetMonthCategory])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetMonthCategories])

    def budget_month_category_update(
            self,
            body: 'ModelsBudgetMonthCategory') -> 'HttplibJsonResponseModelsBudgetMonthCategories':
        """
        Send a put request to /api/v1/budget/month-categories.

        :param body: BudgetMonthCategory

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/month-categories'

        data = to_jsonable(
            body,
            expected=[ModelsBudgetMonthCategory])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetMonthCategories])

    def budget_month_read(
            self,
            auth_household_id: str,
            year_month: str) -> 'HttplibJsonResponseModelsBudgetMonths':
        """
        Send a get request to /api/v1/budget/months/{authHouseholdID}/{yearMonth}.

        :param auth_household_id: authHouseholdID
        :param year_month: yearMonth

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/months/',
            str(auth_household_id),
            '/',
            str(year_month)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetMonths])

    def budget_month_category_rollup(
            self,
            auth_household_id: str,
            year_month: str) -> 'HttplibJsonResponseModelsBudgetMonthCategories':
        """
        Send a post request to /api/v1/budget/months/{authHouseholdID}/{yearMonth}/rollup.

        :param auth_household_id: authHouseholdID
        :param year_month: yearMonth

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/months/',
            str(auth_household_id),
            '/',
            str(year_month),
            '/rollup'])

        resp = self.session.request(
            method='post',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetMonthCategories])

    def budget_payees_read(self) -> 'HttplibJsonResponseModelsBudgetPayees':
        """
        Send a get request to /api/v1/budget/payees.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/payees'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetPayees])

    def budget_payee_create(
            self,
            body: 'ModelsBudgetPayee') -> 'HttplibJsonResponseModelsBudgetPayees':
        """
        Send a post request to /api/v1/budget/payees.

        :param body: BudgetPayee

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/payees'

        data = to_jsonable(
            body,
            expected=[ModelsBudgetPayee])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetPayees])

    def budget_payee_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetPayees':
        """
        Send a delete request to /api/v1/budget/payees/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/payees/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetPayees])

    def budget_payee_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetPayees':
        """
        Send a get request to /api/v1/budget/payees/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/payees/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetPayees])

    def budget_payee_update(
            self,
            body: 'ModelsBudgetPayee',
            id: str) -> 'HttplibJsonResponseModelsBudgetPayees':
        """
        Send a put request to /api/v1/budget/payees/{id}.

        :param body: BudgetPayee
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/payees/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsBudgetPayee])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetPayees])

    def budget_transactions_read_payee(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetTransactions':
        """
        Send a get request to /api/v1/budget/payees/{id}/transactions.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/payees/',
            str(id),
            '/transactions'])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetTransactions])

    def budget_recurrences_read(self) -> 'HttplibJsonResponseModelsBudgetRecurrences':
        """
        Send a get request to /api/v1/budget/recurrences.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/recurrences'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetRecurrences])

    def budget_recurrence_create(
            self,
            body: 'ModelsBudgetRecurrence') -> 'HttplibJsonResponseModelsBudgetRecurrences':
        """
        Send a post request to /api/v1/budget/recurrences.

        :param body: BudgetRecurrence

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/recurrences'

        data = to_jsonable(
            body,
            expected=[ModelsBudgetRecurrence])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetRecurrences])

    def budget_recurrence_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetRecurrences':
        """
        Send a delete request to /api/v1/budget/recurrences/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/recurrences/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetRecurrences])

    def budget_recurrence_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetRecurrences':
        """
        Send a get request to /api/v1/budget/recurrences/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/recurrences/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetRecurrences])

    def budget_recurrence_update(
            self,
            body: 'ModelsBudgetRecurrence',
            id: str) -> 'HttplibJsonResponseModelsBudgetRecurrences':
        """
        Send a put request to /api/v1/budget/recurrences/{id}.

        :param body: BudgetRecurrence
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/recurrences/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsBudgetRecurrence])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetRecurrences])

    def budget_transaction_create(
            self,
            body: 'ModelsBudgetTransaction') -> 'HttplibJsonResponseModelsBudgetTransactions':
        """
        Send a post request to /api/v1/budget/transactions.

        :param body: BudgetTransaction

        :return: OK
        """
        url = self.url_prefix + '/api/v1/budget/transactions'

        data = to_jsonable(
            body,
            expected=[ModelsBudgetTransaction])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetTransactions])

    def budget_transaction_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsBudgetTransactions':
        """
        Send a delete request to /api/v1/budget/transactions/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/transactions/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetTransactions])

    def budget_transaction_update(
            self,
            body: 'ModelsBudgetTransaction',
            id: str) -> 'HttplibJsonResponseModelsBudgetTransactions':
        """
        Send a put request to /api/v1/budget/transactions/{id}.

        :param body: BudgetTransaction
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/budget/transactions/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsBudgetTransaction])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsBudgetTransactions])

    def calendar_events_read(self) -> 'HttplibJsonResponseModelsCalendarEvents':
        """
        Send a get request to /api/v1/calendar/events.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/calendar/events'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarEvents])

    def calendar_event_create(
            self,
            body: 'ModelsCalendarEvent') -> 'HttplibJsonResponseModelsCalendarEvents':
        """
        Send a post request to /api/v1/calendar/events.

        :param body: CalendarEvent

        :return: OK
        """
        url = self.url_prefix + '/api/v1/calendar/events'

        data = to_jsonable(
            body,
            expected=[ModelsCalendarEvent])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarEvents])

    def calendar_event_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsCalendarEvents':
        """
        Send a delete request to /api/v1/calendar/events/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/calendar/events/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarEvents])

    def calendar_event_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsCalendarEvents':
        """
        Send a get request to /api/v1/calendar/events/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/calendar/events/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarEvents])

    def calendar_event_update(
            self,
            body: 'ModelsCalendarEvent',
            id: str) -> 'HttplibJsonResponseModelsCalendarEvents':
        """
        Send a put request to /api/v1/calendar/events/{id}.

        :param body: CalendarEvent
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/calendar/events/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsCalendarEvent])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarEvents])

    def calendar_i_calendars_read(self) -> 'HttplibJsonResponseModelsCalendarICalendars':
        """
        Send a get request to /api/v1/calendar/icalendars.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/calendar/icalendars'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarICalendars])

    def calendar_i_calendar_create(
            self,
            body: 'ModelsCalendarICalendar') -> 'HttplibJsonResponseModelsCalendarICalendars':
        """
        Send a post request to /api/v1/calendar/icalendars.

        :param body: CalendarICalendar

        :return: OK
        """
        url = self.url_prefix + '/api/v1/calendar/icalendars'

        data = to_jsonable(
            body,
            expected=[ModelsCalendarICalendar])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarICalendars])

    def calendar_i_calendar_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsCalendarICalendars':
        """
        Send a delete request to /api/v1/calendar/icalendars/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/calendar/icalendars/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarICalendars])

    def calendar_i_calendar_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsCalendarICalendars':
        """
        Send a get request to /api/v1/calendar/icalendars/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/calendar/icalendars/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarICalendars])

    def calendar_i_calendar_update(
            self,
            body: 'ModelsCalendarICalendar',
            id: str) -> 'HttplibJsonResponseModelsCalendarICalendars':
        """
        Send a put request to /api/v1/calendar/icalendars/{id}.

        :param body: CalendarICalendar
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/calendar/icalendars/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsCalendarICalendar])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCalendarICalendars])

    def changes_read(self) -> 'HttplibJsonResponseModelsChanges':
        """
        Send a get request to /api/v1/changes.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/changes'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsChanges])

    def change_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsChanges':
        """
        Send a get request to /api/v1/changes/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/changes/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsChanges])

    def config_read(self) -> 'HttplibJsonResponseConfigConfig':
        """
        Send a get request to /api/v1/config.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/config'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseConfigConfig])

    def config_apply(self) -> 'ControllersResponse':
        """
        Send a post request to /api/v1/config/apply.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/config/apply'

        resp = self.session.request(method='post', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[ControllersResponse])

    def config_keys_read(self) -> 'HttplibJsonResponseModelsCookMealPlans':
        """
        Send a get request to /api/v1/config/keys.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/config/keys'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealPlans])

    def config_key_set(
            self,
            body: 'ModelsConfigKey',
            key: str) -> 'HttplibJsonResponseModelsConfigKeys':
        """
        Send a get request to /api/v1/config/keys/{key}.

        :param body: ConfigKey
        :param key: Key

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/config/keys/',
            str(key)])

        data = to_jsonable(
            body,
            expected=[ModelsConfigKey])


        resp = self.session.request(
            method='get',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsConfigKeys])

    def cook_meal_plans_read(self) -> 'HttplibJsonResponseModelsCookMealPlans':
        """
        Send a get request to /api/v1/cook/meal-plans.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/cook/meal-plans'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealPlans])

    def cook_meal_plan_create(
            self,
            body: 'ModelsCookMealPlan') -> 'HttplibJsonResponseModelsCookMealPlans':
        """
        Send a post request to /api/v1/cook/meal-plans.

        :param body: CookMealPlan

        :return: OK
        """
        url = self.url_prefix + '/api/v1/cook/meal-plans'

        data = to_jsonable(
            body,
            expected=[ModelsCookMealPlan])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealPlans])

    def cook_meal_plan_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsCookMealPlans':
        """
        Send a delete request to /api/v1/cook/meal-plans/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/meal-plans/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealPlans])

    def cook_meal_plan_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsCookMealPlans':
        """
        Send a get request to /api/v1/cook/meal-plans/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/meal-plans/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealPlans])

    def cook_meal_plan_update(
            self,
            body: 'ModelsCookMealPlan',
            id: str) -> 'HttplibJsonResponseModelsCookMealPlans':
        """
        Send a put request to /api/v1/cook/meal-plans/{id}.

        :param body: CookMealPlan
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/meal-plans/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsCookMealPlan])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealPlans])

    def cook_meal_times_read(self) -> 'HttplibJsonResponseModelsCookMealTimes':
        """
        Send a get request to /api/v1/cook/meal-times.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/cook/meal-times'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealTimes])

    def cook_meal_time_create(
            self,
            body: 'ModelsCookMealTime') -> 'HttplibJsonResponseModelsCookMealTimes':
        """
        Send a post request to /api/v1/cook/meal-times.

        :param body: CookMealTime

        :return: OK
        """
        url = self.url_prefix + '/api/v1/cook/meal-times'

        data = to_jsonable(
            body,
            expected=[ModelsCookMealTime])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealTimes])

    def cook_meal_time_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsCookMealTimes':
        """
        Send a delete request to /api/v1/cook/meal-times/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/meal-times/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealTimes])

    def cook_meal_time_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsCookMealTimes':
        """
        Send a get request to /api/v1/cook/meal-times/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/meal-times/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealTimes])

    def cook_meal_time_update(
            self,
            body: 'ModelsCookMealTime',
            id: str) -> 'HttplibJsonResponseModelsCookMealTimes':
        """
        Send a put request to /api/v1/cook/meal-times/{id}.

        :param body: CookMealTime
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/meal-times/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsCookMealTime])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookMealTimes])

    def cook_recipes_read(self) -> 'HttplibJsonResponseModelsCookRecipes':
        """
        Send a get request to /api/v1/cook/recipes.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/cook/recipes'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookRecipes])

    def cook_recipe_create(
            self,
            body: 'ModelsCookRecipe') -> 'HttplibJsonResponseModelsCookRecipes':
        """
        Send a post request to /api/v1/cook/recipes.

        :param body: CookRecipe

        :return: OK
        """
        url = self.url_prefix + '/api/v1/cook/recipes'

        data = to_jsonable(
            body,
            expected=[ModelsCookRecipe])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookRecipes])

    def cook_recipe_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsCookRecipes':
        """
        Send a delete request to /api/v1/cook/recipes/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/recipes/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookRecipes])

    def cook_recipe_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsCookRecipes':
        """
        Can read recipes marked public unauthenticated

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/recipes/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookRecipes])

    def cook_recipe_update(
            self,
            body: 'ModelsCookRecipe',
            id: str) -> 'HttplibJsonResponseModelsCookRecipes':
        """
        Send a put request to /api/v1/cook/recipes/{id}.

        :param body: CookRecipe
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/cook/recipes/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsCookRecipe])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsCookRecipes])

    def feature_candidates_read(self) -> 'HttplibJsonResponseModelsFeatureCandidates':
        """
        Send a get request to /api/v1/feature/candidates.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/feature/candidates'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureCandidates])

    def feature_candidate_create(
            self,
            body: 'ModelsFeatureCandidate') -> 'HttplibJsonResponseModelsFeatureCandidates':
        """
        Send a post request to /api/v1/feature/candidates.

        :param body: FeatureCandidate

        :return: OK
        """
        url = self.url_prefix + '/api/v1/feature/candidates'

        data = to_jsonable(
            body,
            expected=[ModelsFeatureCandidate])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureCandidates])

    def feature_candidate_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsFeatureCandidates':
        """
        Send a get request to /api/v1/feature/candidates/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/feature/candidates/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureCandidates])

    def feature_votes_read(self) -> 'HttplibJsonResponseModelsFeatureVotes':
        """
        Send a get request to /api/v1/feature/votes.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/feature/votes'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureVotes])

    def feature_vote_create(
            self,
            body: 'ModelsFeatureVote') -> 'HttplibJsonResponseModelsFeatureVotes':
        """
        Send a post request to /api/v1/feature/votes.

        :param body: FeatureVote

        :return: OK
        """
        url = self.url_prefix + '/api/v1/feature/votes'

        data = to_jsonable(
            body,
            expected=[ModelsFeatureVote])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureVotes])

    def feature_vote_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsFeatureVotes':
        """
        Send a delete request to /api/v1/feature/votes/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/feature/votes/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureVotes])

    def feature_vote_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsFeatureVotes':
        """
        Send a get request to /api/v1/feature/votes/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/feature/votes/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureVotes])

    def feature_vote_update(
            self,
            body: 'ModelsFeatureVote',
            id: str) -> 'HttplibJsonResponseModelsFeatureVotes':
        """
        Send a put request to /api/v1/feature/votes/{id}.

        :param body: FeatureVote
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/feature/votes/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsFeatureVote])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureVotes])

    def feature_candidate_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsFeatureCandidates':
        """
        Send a delete request to /api/v1/features/candidates/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/features/candidates/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureCandidates])

    def feature_candidate_update(
            self,
            body: 'ModelsFeatureCandidate',
            id: str) -> 'HttplibJsonResponseModelsFeatureCandidates':
        """
        Send a put request to /api/v1/features/candidates/{id}.

        :param body: FeatureCandidate
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/features/candidates/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsFeatureCandidate])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsFeatureCandidates])

    def health_items_read(self) -> 'HttplibJsonResponseModelsHealthItems':
        """
        Send a get request to /api/v1/health/items.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/health/items'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthItems])

    def health_item_create(
            self,
            body: 'ModelsHealthItem') -> 'HttplibJsonResponseModelsHealthItems':
        """
        Send a post request to /api/v1/health/items.

        :param body: HealthItem

        :return: OK
        """
        url = self.url_prefix + '/api/v1/health/items'

        data = to_jsonable(
            body,
            expected=[ModelsHealthItem])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthItems])

    def health_items_init(self) -> 'HttplibJsonResponseModelsHealthItems':
        """
        Send a put request to /api/v1/health/items.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/health/items'

        resp = self.session.request(method='put', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthItems])

    def health_item_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsHealthItems':
        """
        Send a delete request to /api/v1/health/items/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/health/items/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthItems])

    def health_item_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsHealthItems':
        """
        Send a get request to /api/v1/health/items/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/health/items/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthItems])

    def health_item_update(
            self,
            body: 'ModelsHealthItem',
            id: str) -> 'HttplibJsonResponseModelsHealthItems':
        """
        Send a put request to /api/v1/health/items/{id}.

        :param body: HealthItem
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/health/items/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsHealthItem])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthItems])

    def health_log_items_read(self) -> 'HttplibJsonResponseModelsHealthLogItems':
        """
        Send a get request to /api/v1/health/log-items.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/health/log-items'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthLogItems])

    def health_log_item_create(
            self,
            body: 'ModelsHealthLogItem') -> 'HttplibJsonResponseModelsHealthLogItems':
        """
        Send a post request to /api/v1/health/log-items.

        :param body: HealthLogItem

        :return: OK
        """
        url = self.url_prefix + '/api/v1/health/log-items'

        data = to_jsonable(
            body,
            expected=[ModelsHealthLogItem])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthLogItems])

    def health_log_item_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsHealthLogItems':
        """
        Send a delete request to /api/v1/health/log-items/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/health/log-items/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthLogItems])

    def health_log_item_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsHealthLogItems':
        """
        Send a get request to /api/v1/health/log-items/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/health/log-items/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthLogItems])

    def health_log_item_update(
            self,
            body: 'ModelsHealthLogItem',
            id: str) -> 'HttplibJsonResponseModelsHealthLogItems':
        """
        Send a put request to /api/v1/health/log-items/{id}.

        :param body: HealthLogItem
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/health/log-items/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsHealthLogItem])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsHealthLogItems])

    def inventory_collections_read(self) -> 'HttplibJsonResponseModelsInventoryCollections':
        """
        Send a get request to /api/v1/inventory/collections.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/inventory/collections'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryCollections])

    def inventory_collection_create(
            self,
            body: 'ModelsInventoryCollection') -> 'HttplibJsonResponseModelsInventoryCollections':
        """
        Send a post request to /api/v1/inventory/collections.

        :param body: InventoryCollection

        :return: OK
        """
        url = self.url_prefix + '/api/v1/inventory/collections'

        data = to_jsonable(
            body,
            expected=[ModelsInventoryCollection])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryCollections])

    def inventory_collection_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsInventoryCollections':
        """
        Send a delete request to /api/v1/inventory/collections/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/inventory/collections/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryCollections])

    def inventory_collection_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsInventoryCollections':
        """
        Send a get request to /api/v1/inventory/collections/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/inventory/collections/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryCollections])

    def inventory_collection_update(
            self,
            body: 'ModelsInventoryCollection',
            id: str) -> 'HttplibJsonResponseModelsInventoryCollections':
        """
        Send a put request to /api/v1/inventory/collections/{id}.

        :param body: InventoryCollection
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/inventory/collections/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsInventoryCollection])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryCollections])

    def inventory_items_read(self) -> 'HttplibJsonResponseModelsInventoryItems':
        """
        Send a get request to /api/v1/inventory/items.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/inventory/items'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryItems])

    def inventory_item_create(
            self,
            body: 'ModelsInventoryItem') -> 'HttplibJsonResponseModelsInventoryItems':
        """
        Send a post request to /api/v1/inventory/items.

        :param body: InventoryItem

        :return: OK
        """
        url = self.url_prefix + '/api/v1/inventory/items'

        data = to_jsonable(
            body,
            expected=[ModelsInventoryItem])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryItems])

    def inventory_item_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsInventoryItems':
        """
        Send a delete request to /api/v1/inventory/items/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/inventory/items/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryItems])

    def inventory_item_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsInventoryItems':
        """
        Send a get request to /api/v1/inventory/items/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/inventory/items/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryItems])

    def inventory_item_update(
            self,
            body: 'ModelsInventoryItem',
            id: str) -> 'HttplibJsonResponseModelsInventoryItems':
        """
        Send a put request to /api/v1/inventory/items/{id}.

        :param body: InventoryItem
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/inventory/items/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsInventoryItem])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsInventoryItems])

    def labels_values_read(self) -> 'HttplibJsonResponseModelsLabelsValues':
        """
        Send a get request to /api/v1/label/values.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/label/values'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsLabelsValues])

    def labels_value_create(
            self,
            body: 'ModelsLabelsValue') -> 'HttplibJsonResponseModelsLabelsValues':
        """
        Send a post request to /api/v1/label/values.

        :param body: LabelsValue

        :return: OK
        """
        url = self.url_prefix + '/api/v1/label/values'

        data = to_jsonable(
            body,
            expected=[ModelsLabelsValue])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsLabelsValues])

    def labels_value_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsLabelsValues':
        """
        Send a delete request to /api/v1/label/values/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/label/values/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsLabelsValues])

    def labels_value_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsLabelsValues':
        """
        Send a get request to /api/v1/label/values/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/label/values/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsLabelsValues])

    def labels_value_update(
            self,
            body: 'ModelsLabelsValue',
            id: str) -> 'HttplibJsonResponseModelsLabelsValues':
        """
        Send a put request to /api/v1/label/values/{id}.

        :param body: LabelsValue
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/label/values/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsLabelsValue])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsLabelsValues])

    def notes_page_versions_read(self) -> 'HttplibJsonResponseModelsNotesPageVersions':
        """
        Send a get request to /api/v1/notes/page-versions.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/notes/page-versions'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsNotesPageVersions])

    def notes_page_version_create(
            self,
            body: 'ModelsNotesPageVersion') -> 'HttplibJsonResponseModelsNotesPageVersions':
        """
        Send a post request to /api/v1/notes/page-versions.

        :param body: NotesPageVersion

        :return: OK
        """
        url = self.url_prefix + '/api/v1/notes/page-versions'

        data = to_jsonable(
            body,
            expected=[ModelsNotesPageVersion])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsNotesPageVersions])

    def notes_page_version_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsNotesPageVersions':
        """
        Send a get request to /api/v1/notes/page-versions/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/notes/page-versions/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsNotesPageVersions])

    def notes_pages_read(self) -> 'HttplibJsonResponseModelsNotesPageVersions':
        """
        Send a get request to /api/v1/notes/pages.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/notes/pages'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsNotesPageVersions])

    def notes_page_create(
            self,
            body: 'ModelsNotesPage') -> 'HttplibJsonResponseModelsNotesPages':
        """
        Send a post request to /api/v1/notes/pages.

        :param body: NotesPage

        :return: OK
        """
        url = self.url_prefix + '/api/v1/notes/pages'

        data = to_jsonable(
            body,
            expected=[ModelsNotesPage])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsNotesPages])

    def notes_page_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsNotesPageVersions':
        """
        Send a delete request to /api/v1/notes/pages/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/notes/pages/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsNotesPageVersions])

    def notes_page_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsNotesPageVersions':
        """
        Send a get request to /api/v1/notes/pages/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/notes/pages/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsNotesPageVersions])

    def notes_page_update(
            self,
            body: 'ModelsNotesPage',
            id: str) -> 'HttplibJsonResponseModelsNotesPageVersions':
        """
        Send a put request to /api/v1/notes/pages/{id}.

        :param body: NotesPage
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/notes/pages/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsNotesPage])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsNotesPageVersions])

    def plan_projects_read(self) -> 'HttplibJsonResponseModelsPlanProjects':
        """
        Send a get request to /api/v1/plan/projects.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/plan/projects'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanProjects])

    def plan_project_create(
            self,
            body: 'ModelsPlanProject') -> 'HttplibJsonResponseModelsPlanProjects':
        """
        Send a post request to /api/v1/plan/projects.

        :param body: PlanProject

        :return: OK
        """
        url = self.url_prefix + '/api/v1/plan/projects'

        data = to_jsonable(
            body,
            expected=[ModelsPlanProject])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanProjects])

    def plan_project_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsPlanProjects':
        """
        Send a get request to /api/v1/plan/projects/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/plan/projects/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanProjects])

    def plan_project_update(
            self,
            body: 'ModelsPlanProject',
            id: str) -> 'HttplibJsonResponseModelsPlanProjects':
        """
        Send a put request to /api/v1/plan/projects/{id}.

        :param body: PlanProject
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/plan/projects/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsPlanProject])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanProjects])

    def plan_tasks_read(self) -> 'HttplibJsonResponseModelsPlanTasks':
        """
        Send a get request to /api/v1/plan/tasks.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/plan/tasks'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanTasks])

    def plan_task_create(
            self,
            body: 'ModelsPlanTask') -> 'HttplibJsonResponseModelsPlanTasks':
        """
        Send a post request to /api/v1/plan/tasks.

        :param body: PlanTask

        :return: OK
        """
        url = self.url_prefix + '/api/v1/plan/tasks'

        data = to_jsonable(
            body,
            expected=[ModelsPlanTask])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanTasks])

    def plan_task_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsPlanTasks':
        """
        Send a delete request to /api/v1/plan/tasks/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/plan/tasks/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanTasks])

    def plan_task_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsPlanTasks':
        """
        Send a get request to /api/v1/plan/tasks/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/plan/tasks/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanTasks])

    def plan_task_update(
            self,
            body: 'ModelsPlanTask',
            id: str) -> 'HttplibJsonResponseModelsPlanTasks':
        """
        Send a put request to /api/v1/plan/tasks/{id}.

        :param body: PlanTask
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/plan/tasks/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsPlanTask])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsPlanTasks])

    def reward_cards_read(self) -> 'HttplibJsonResponseModelsRewardCards':
        """
        Send a get request to /api/v1/reward/cards.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/reward/cards'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsRewardCards])

    def reward_card_create(
            self,
            body: 'ModelsRewardCard') -> 'HttplibJsonResponseModelsRewardCards':
        """
        Send a post request to /api/v1/reward/cards.

        :param body: RewardCard

        :return: OK
        """
        url = self.url_prefix + '/api/v1/reward/cards'

        data = to_jsonable(
            body,
            expected=[ModelsRewardCard])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsRewardCards])

    def reward_card_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsRewardCards':
        """
        Send a delete request to /api/v1/reward/cards/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/reward/cards/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsRewardCards])

    def reward_card_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsRewardCards':
        """
        Send a get request to /api/v1/reward/cards/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/reward/cards/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsRewardCards])

    def reward_card_update(
            self,
            body: 'ModelsRewardCard',
            id: str) -> 'HttplibJsonResponseModelsRewardCards':
        """
        Send a put request to /api/v1/reward/cards/{id}.

        :param body: RewardCard
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/reward/cards/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsRewardCard])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsRewardCards])

    def secrets_values_read(self) -> 'HttplibJsonResponseModelsSecretsValues':
        """
        Send a get request to /api/v1/secrets/values.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/secrets/values'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsValues])

    def secrets_value_create(
            self,
            body: 'ModelsSecretsValue') -> 'HttplibJsonResponseModelsSecretsValues':
        """
        Send a post request to /api/v1/secrets/values.

        :param body: SecretsValue

        :return: OK
        """
        url = self.url_prefix + '/api/v1/secrets/values'

        data = to_jsonable(
            body,
            expected=[ModelsSecretsValue])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsValues])

    def secrets_value_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsSecretsValues':
        """
        Send a delete request to /api/v1/secrets/values/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/secrets/values/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsValues])

    def secrets_value_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsSecretsValues':
        """
        Send a get request to /api/v1/secrets/values/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/secrets/values/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsValues])

    def secrets_value_update(
            self,
            body: 'ModelsSecretsValue',
            id: str) -> 'HttplibJsonResponseModelsSecretsValues':
        """
        Send a put request to /api/v1/secrets/values/{id}.

        :param body: SecretsValue
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/secrets/values/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsSecretsValue])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsValues])

    def secrets_vaults_read(self) -> 'HttplibJsonResponseModelsSecretsVaults':
        """
        Send a get request to /api/v1/secrets/vaults.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/secrets/vaults'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsVaults])

    def secrets_vault_create(
            self,
            body: 'ModelsSecretsVault') -> 'HttplibJsonResponseModelsSecretsVaults':
        """
        Send a post request to /api/v1/secrets/vaults.

        :param body: SecretsVault

        :return: OK
        """
        url = self.url_prefix + '/api/v1/secrets/vaults'

        data = to_jsonable(
            body,
            expected=[ModelsSecretsVault])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsVaults])

    def secrets_vault_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsSecretsVaults':
        """
        Send a delete request to /api/v1/secrets/vaults/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/secrets/vaults/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsVaults])

    def secrets_vault_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsSecretsVaults':
        """
        Send a get request to /api/v1/secrets/vaults/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/secrets/vaults/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsVaults])

    def secrets_vault_update(
            self,
            body: 'ModelsSecretsVault',
            id: str) -> 'HttplibJsonResponseModelsSecretsVaults':
        """
        Send a put request to /api/v1/secrets/vaults/{id}.

        :param body: SecretsVault
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/secrets/vaults/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsSecretsVault])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsSecretsVaults])

    def shop_categories_read(self) -> 'HttplibJsonResponseModelsShopCategories':
        """
        Send a get request to /api/v1/shop/categories.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/shop/categories'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopCategories])

    def shop_category_create(
            self,
            body: 'ModelsShopCategory') -> 'HttplibJsonResponseModelsShopCategories':
        """
        Send a post request to /api/v1/shop/categories.

        :param body: ShopCategory

        :return: OK
        """
        url = self.url_prefix + '/api/v1/shop/categories'

        data = to_jsonable(
            body,
            expected=[ModelsShopCategory])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopCategories])

    def shop_category_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsShopCategories':
        """
        Send a delete request to /api/v1/shop/categories/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/categories/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopCategories])

    def shop_category_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsShopCategories':
        """
        Send a get request to /api/v1/shop/categories/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/categories/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopCategories])

    def shop_category_update(
            self,
            body: 'ModelsShopCategory',
            id: str) -> 'HttplibJsonResponseModelsShopCategories':
        """
        Send a put request to /api/v1/shop/categories/{id}.

        :param body: ShopCategory
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/categories/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsShopCategory])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopCategories])

    def shop_items_read(self) -> 'HttplibJsonResponseModelsShopItems':
        """
        Send a get request to /api/v1/shop/items.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/shop/items'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopItems])

    def shop_item_create(
            self,
            body: 'ModelsShopItem') -> 'HttplibJsonResponseModelsShopItems':
        """
        Send a post request to /api/v1/shop/items.

        :param body: ShopItem

        :return: OK
        """
        url = self.url_prefix + '/api/v1/shop/items'

        data = to_jsonable(
            body,
            expected=[ModelsShopItem])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopItems])

    def shop_item_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsShopItems':
        """
        Send a delete request to /api/v1/shop/items/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/items/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopItems])

    def shop_item_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsShopItems':
        """
        Send a get request to /api/v1/shop/items/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/items/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopItems])

    def shop_item_update(
            self,
            body: 'ModelsShopItem',
            id: str) -> 'HttplibJsonResponseModelsShopItems':
        """
        Send a put request to /api/v1/shop/items/{id}.

        :param body: ShopItem
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/items/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsShopItem])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopItems])

    def shop_lists_read(self) -> 'HttplibJsonResponseModelsShopLists':
        """
        Send a get request to /api/v1/shop/lists.

        :return: OK
        """
        url = self.url_prefix + '/api/v1/shop/lists'

        resp = self.session.request(method='get', url=url)

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopLists])

    def shop_list_create(
            self,
            body: 'ModelsShopList') -> 'HttplibJsonResponseModelsShopLists':
        """
        Send a post request to /api/v1/shop/lists.

        :param body: ShopList

        :return: OK
        """
        url = self.url_prefix + '/api/v1/shop/lists'

        data = to_jsonable(
            body,
            expected=[ModelsShopList])


        resp = self.session.request(
            method='post',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopLists])

    def shop_list_delete(
            self,
            id: str) -> 'HttplibJsonResponseModelsShopLists':
        """
        Send a delete request to /api/v1/shop/lists/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/lists/',
            str(id)])

        resp = self.session.request(
            method='delete',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopLists])

    def shop_list_read(
            self,
            id: str) -> 'HttplibJsonResponseModelsShopLists':
        """
        Send a get request to /api/v1/shop/lists/{id}.

        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/lists/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopLists])

    def shop_list_update(
            self,
            body: 'ModelsShopList',
            id: str) -> 'HttplibJsonResponseModelsShopLists':
        """
        Send a put request to /api/v1/shop/lists/{id}.

        :param body: ShopList
        :param id: ID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/shop/lists/',
            str(id)])

        data = to_jsonable(
            body,
            expected=[ModelsShopList])


        resp = self.session.request(
            method='put',
            url=url,
            json=data,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[HttplibJsonResponseModelsShopLists])

    def s_s_e_read(
            self,
            id: str) -> 'ModelsEvent':
        """
        Send a get request to /api/v1/sse/{id}.

        :param id: AuthSessionID

        :return: OK
        """
        url = "".join([
            self.url_prefix,
            '/api/v1/sse/',
            str(id)])

        resp = self.session.request(
            method='get',
            url=url,
        )

        with contextlib.closing(resp):
            resp.raise_for_status()
            return from_obj(
                obj=resp.json(),
                expected=[ModelsEvent])


# Automatically generated file by swagger_to. DO NOT EDIT OR APPEND ANYTHING!

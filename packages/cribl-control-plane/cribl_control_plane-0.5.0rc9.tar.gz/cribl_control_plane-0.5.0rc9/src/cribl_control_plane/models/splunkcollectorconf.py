"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class SplunkAuthenticationLoginSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationLoginSecretOutputMode(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class SplunkAuthenticationLoginSecretCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationLoginSecretCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationLoginSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationLoginSecretCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationLoginSecretRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class SplunkAuthenticationLoginSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[SplunkAuthenticationLoginSecretRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class SplunkAuthenticationLoginSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[SplunkAuthenticationLoginSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationLoginSecretRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationLoginSecretRetryType(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationLoginSecretTypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[SplunkAuthenticationLoginSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[SplunkAuthenticationLoginSecretOutputMode]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationLoginSecretCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationLoginSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationLoginSecretRetryRulesTypedDict]


class SplunkAuthenticationLoginSecret(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[SplunkAuthenticationLoginSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationLoginSecretAuthentication.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[SplunkAuthenticationLoginSecretOutputMode],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = SplunkAuthenticationLoginSecretOutputMode.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationLoginSecretCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationLoginSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationLoginSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationLoginSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationLoginSecretOutputMode(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationLoginAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationLoginOutputMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class SplunkAuthenticationLoginCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationLoginCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationLoginCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationLoginCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationLoginRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class SplunkAuthenticationLoginRetryRulesTypedDict(TypedDict):
    type: NotRequired[SplunkAuthenticationLoginRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class SplunkAuthenticationLoginRetryRules(BaseModel):
    type: Annotated[
        Optional[SplunkAuthenticationLoginRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationLoginRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationLoginRetryType(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationLoginTypedDict(TypedDict):
    username: str
    password: str
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[SplunkAuthenticationLoginAuthentication]
    r"""Authentication method for Discover and Collect REST calls"""
    login_url: NotRequired[str]
    r"""URL to use for login API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[SplunkAuthenticationLoginOutputMode]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationLoginCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationLoginCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationLoginRetryRulesTypedDict]


class SplunkAuthenticationLogin(BaseModel):
    username: str

    password: str

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[SplunkAuthenticationLoginAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationLoginAuthentication.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[SplunkAuthenticationLoginOutputMode],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = SplunkAuthenticationLoginOutputMode.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationLoginCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationLoginCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationLoginRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationLoginAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationLoginOutputMode(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationTokenSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationTokenSecretOutputMode(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class SplunkAuthenticationTokenSecretCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSecretCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSecretCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenSecretRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class SplunkAuthenticationTokenSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[SplunkAuthenticationTokenSecretRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class SplunkAuthenticationTokenSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[SplunkAuthenticationTokenSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationTokenSecretRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationTokenSecretRetryType(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationTokenSecretTypedDict(TypedDict):
    token_secret: str
    r"""Select or create a stored secret that references your Bearer token"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[SplunkAuthenticationTokenSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[SplunkAuthenticationTokenSecretOutputMode]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationTokenSecretCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationTokenSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationTokenSecretRetryRulesTypedDict]


class SplunkAuthenticationTokenSecret(BaseModel):
    token_secret: Annotated[str, pydantic.Field(alias="tokenSecret")]
    r"""Select or create a stored secret that references your Bearer token"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[SplunkAuthenticationTokenSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationTokenSecretAuthentication.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[SplunkAuthenticationTokenSecretOutputMode],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = SplunkAuthenticationTokenSecretOutputMode.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationTokenSecretCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationTokenSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationTokenSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationTokenSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationTokenSecretOutputMode(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationTokenAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationTokenOutputMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class SplunkAuthenticationTokenCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationTokenRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class SplunkAuthenticationTokenRetryRulesTypedDict(TypedDict):
    type: NotRequired[SplunkAuthenticationTokenRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class SplunkAuthenticationTokenRetryRules(BaseModel):
    type: Annotated[
        Optional[SplunkAuthenticationTokenRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationTokenRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationTokenRetryType(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationTokenTypedDict(TypedDict):
    token: str
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[SplunkAuthenticationTokenAuthentication]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[SplunkAuthenticationTokenOutputMode]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationTokenCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationTokenCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationTokenRetryRulesTypedDict]


class SplunkAuthenticationToken(BaseModel):
    token: str

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[SplunkAuthenticationTokenAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationTokenAuthentication.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[SplunkAuthenticationTokenOutputMode],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = SplunkAuthenticationTokenOutputMode.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationTokenCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationTokenCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationTokenRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationTokenAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationTokenOutputMode(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationBasicSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationBasicSecretOutputMode(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class SplunkAuthenticationBasicSecretCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSecretCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSecretCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicSecretRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class SplunkAuthenticationBasicSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[SplunkAuthenticationBasicSecretRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class SplunkAuthenticationBasicSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[SplunkAuthenticationBasicSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationBasicSecretRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationBasicSecretRetryType(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationBasicSecretTypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your credentials"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[SplunkAuthenticationBasicSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[SplunkAuthenticationBasicSecretOutputMode]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationBasicSecretCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationBasicSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationBasicSecretRetryRulesTypedDict]


class SplunkAuthenticationBasicSecret(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your credentials"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[SplunkAuthenticationBasicSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationBasicSecretAuthentication.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[SplunkAuthenticationBasicSecretOutputMode],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = SplunkAuthenticationBasicSecretOutputMode.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationBasicSecretCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationBasicSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationBasicSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationBasicSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationBasicSecretOutputMode(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationBasicAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationBasicOutputMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class SplunkAuthenticationBasicCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationBasicRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class SplunkAuthenticationBasicRetryRulesTypedDict(TypedDict):
    type: NotRequired[SplunkAuthenticationBasicRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class SplunkAuthenticationBasicRetryRules(BaseModel):
    type: Annotated[
        Optional[SplunkAuthenticationBasicRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationBasicRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationBasicRetryType(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationBasicTypedDict(TypedDict):
    username: str
    r"""Basic authentication username"""
    password: str
    r"""Basic authentication password"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[SplunkAuthenticationBasicAuthentication]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[SplunkAuthenticationBasicOutputMode]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationBasicCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationBasicCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationBasicRetryRulesTypedDict]


class SplunkAuthenticationBasic(BaseModel):
    username: str
    r"""Basic authentication username"""

    password: str
    r"""Basic authentication password"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[SplunkAuthenticationBasicAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationBasicAuthentication.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[SplunkAuthenticationBasicOutputMode],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = SplunkAuthenticationBasicOutputMode.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationBasicCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationBasicCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationBasicRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationBasicAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationBasicOutputMode(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationNoneAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class SplunkAuthenticationNoneOutputMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class SplunkAuthenticationNoneCollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationNoneCollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationNoneCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationNoneCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class SplunkAuthenticationNoneRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class SplunkAuthenticationNoneRetryRulesTypedDict(TypedDict):
    type: NotRequired[SplunkAuthenticationNoneRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class SplunkAuthenticationNoneRetryRules(BaseModel):
    type: Annotated[
        Optional[SplunkAuthenticationNoneRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationNoneRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationNoneRetryType(value)
            except ValueError:
                return value
        return value


class SplunkAuthenticationNoneTypedDict(TypedDict):
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[SplunkAuthenticationNoneAuthentication]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[SplunkAuthenticationNoneOutputMode]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[SplunkAuthenticationNoneCollectRequestParamTypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[SplunkAuthenticationNoneCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[SplunkAuthenticationNoneRetryRulesTypedDict]


class SplunkAuthenticationNone(BaseModel):
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[SplunkAuthenticationNoneAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = SplunkAuthenticationNoneAuthentication.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[SplunkAuthenticationNoneOutputMode],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = SplunkAuthenticationNoneOutputMode.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[SplunkAuthenticationNoneCollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[SplunkAuthenticationNoneCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[SplunkAuthenticationNoneRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationNoneAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.SplunkAuthenticationNoneOutputMode(value)
            except ValueError:
                return value
        return value


SplunkCollectorConfTypedDict = TypeAliasType(
    "SplunkCollectorConfTypedDict",
    Union[
        SplunkAuthenticationNoneTypedDict,
        SplunkAuthenticationBasicSecretTypedDict,
        SplunkAuthenticationTokenTypedDict,
        SplunkAuthenticationTokenSecretTypedDict,
        SplunkAuthenticationBasicTypedDict,
        SplunkAuthenticationLoginSecretTypedDict,
        SplunkAuthenticationLoginTypedDict,
    ],
)


SplunkCollectorConf = TypeAliasType(
    "SplunkCollectorConf",
    Union[
        SplunkAuthenticationNone,
        SplunkAuthenticationBasicSecret,
        SplunkAuthenticationToken,
        SplunkAuthenticationTokenSecret,
        SplunkAuthenticationBasic,
        SplunkAuthenticationLoginSecret,
        SplunkAuthenticationLogin,
    ],
)

"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import get_discriminator, validate_open_enum
from enum import Enum
import pydantic
from pydantic import Discriminator, Tag, field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class RestAuthenticationHmacAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationHmacDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestAuthenticationHmacDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationHmacDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationHmacDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationHmacDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacDiscoverType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationHmacCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationHmacCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationHmacPaginationEnum(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationHmacPaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationHmacPaginationEnum]


class RestAuthenticationHmacPagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationHmacPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationHmacPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationHmacRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationHmacRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationHmacRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationHmacRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationHmacRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRetryType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationHmacStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationHmacStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationHmacSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationHmacStateTrackingTypedDict]


class RestAuthenticationHmacScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationHmacStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationHmacTypedDict(TypedDict):
    hmac_function_id: str
    r"""Select or create an HMAC Function to use with authentication"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[RestAuthenticationHmacAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[RestAuthenticationHmacDiscoveryTypedDict]
    collect_method: NotRequired[RestAuthenticationHmacCollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestAuthenticationHmacCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationHmacPaginationTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationHmacRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationHmacSchedulingTypedDict]


class RestAuthenticationHmac(BaseModel):
    hmac_function_id: Annotated[str, pydantic.Field(alias="hmacFunctionId")]
    r"""Select or create an HMAC Function to use with authentication"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[RestAuthenticationHmacAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationHmacAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[RestAuthenticationHmacDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationHmacCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationHmacCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestAuthenticationHmacCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationHmacPagination] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationHmacRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationHmacScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacCollectMethod(value)
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationGoogleOauthSecretDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestAuthenticationGoogleOauthSecretDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationGoogleOauthSecretDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationGoogleOauthSecretDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationGoogleOauthSecretDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretDiscoverType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationGoogleOauthSecretCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationGoogleOauthSecretPaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationGoogleOauthSecretPaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationGoogleOauthSecretPaginationEnum]


class RestAuthenticationGoogleOauthSecretPagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationGoogleOauthSecretPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationGoogleOauthSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationGoogleOauthSecretRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationGoogleOauthSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationGoogleOauthSecretRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRetryType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationGoogleOauthSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationGoogleOauthSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[
        RestAuthenticationGoogleOauthSecretStateTrackingTypedDict
    ]


class RestAuthenticationGoogleOauthSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationGoogleOauthSecretTypedDict(TypedDict):
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    text_secret: str
    r"""Select or create a text secret that contains the Google service account credentials value"""
    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[RestAuthenticationGoogleOauthSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[RestAuthenticationGoogleOauthSecretDiscoveryTypedDict]
    collect_method: NotRequired[RestAuthenticationGoogleOauthSecretCollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestAuthenticationGoogleOauthSecretCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationGoogleOauthSecretPaginationTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationGoogleOauthSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationGoogleOauthSecretSchedulingTypedDict]


class RestAuthenticationGoogleOauthSecret(BaseModel):
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the Google service account credentials value"""

    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationGoogleOauthSecretAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[RestAuthenticationGoogleOauthSecretDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationGoogleOauthSecretCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationGoogleOauthSecretCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestAuthenticationGoogleOauthSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationGoogleOauthSecretPagination] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretCollectMethod(value)
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationGoogleOauthDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestAuthenticationGoogleOauthDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationGoogleOauthDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationGoogleOauthDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationGoogleOauthDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthDiscoverType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationGoogleOauthCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationGoogleOauthPaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationGoogleOauthPaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationGoogleOauthPaginationEnum]


class RestAuthenticationGoogleOauthPagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationGoogleOauthPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationGoogleOauthPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationGoogleOauthRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationGoogleOauthRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationGoogleOauthRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationGoogleOauthRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationGoogleOauthRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRetryType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationGoogleOauthStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationGoogleOauthSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationGoogleOauthStateTrackingTypedDict]


class RestAuthenticationGoogleOauthScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationGoogleOauthStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationGoogleOauthTypedDict(TypedDict):
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: str
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[RestAuthenticationGoogleOauthAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[RestAuthenticationGoogleOauthDiscoveryTypedDict]
    collect_method: NotRequired[RestAuthenticationGoogleOauthCollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestAuthenticationGoogleOauthCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationGoogleOauthPaginationTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationGoogleOauthRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationGoogleOauthSchedulingTypedDict]


class RestAuthenticationGoogleOauth(BaseModel):
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        str, pydantic.Field(alias="serviceAccountCredentials")
    ]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[RestAuthenticationGoogleOauthAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationGoogleOauthAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[RestAuthenticationGoogleOauthDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationGoogleOauthCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationGoogleOauthCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestAuthenticationGoogleOauthCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationGoogleOauthPagination] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationGoogleOauthRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationGoogleOauthScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthCollectMethod(value)
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationOauthSecretAuthRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthSecretAuthRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthSecretAuthRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthSecretAuthRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthSecretDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthSecretDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestAuthenticationOauthSecretDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationOauthSecretDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationOauthSecretDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationOauthSecretDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretDiscoverType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthSecretCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthSecretPaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationOauthSecretPaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationOauthSecretPaginationEnum]


class RestAuthenticationOauthSecretPagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationOauthSecretPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationOauthSecretPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationOauthSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationOauthSecretRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationOauthSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationOauthSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationOauthSecretRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRetryType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationOauthSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationOauthSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationOauthSecretStateTrackingTypedDict]


class RestAuthenticationOauthSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationOauthSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationOauthSecretTypedDict(TypedDict):
    text_secret: str
    r"""Select or create a text secret that contains the client secret's value"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[RestAuthenticationOauthSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    auth_request_params: NotRequired[
        List[RestAuthenticationOauthSecretAuthRequestParamTypedDict]
    ]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[
        List[RestAuthenticationOauthSecretAuthRequestHeaderTypedDict]
    ]
    discovery: NotRequired[RestAuthenticationOauthSecretDiscoveryTypedDict]
    collect_method: NotRequired[RestAuthenticationOauthSecretCollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestAuthenticationOauthSecretCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationOauthSecretPaginationTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationOauthSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationOauthSecretSchedulingTypedDict]


class RestAuthenticationOauthSecret(BaseModel):
    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the client secret's value"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[RestAuthenticationOauthSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationOauthSecretAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    auth_request_params: Annotated[
        Optional[List[RestAuthenticationOauthSecretAuthRequestParam]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[RestAuthenticationOauthSecretAuthRequestHeader]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationOauthSecretDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationOauthSecretCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationOauthSecretCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestAuthenticationOauthSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationOauthSecretPagination] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationOauthSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationOauthSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretCollectMethod(value)
            except ValueError:
                return value
        return value


class RestAuthenticationOauthAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationOauthAuthRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthAuthRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthAuthRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthAuthRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestAuthenticationOauthDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationOauthDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationOauthDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationOauthDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthDiscoverType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationOauthCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationOauthPaginationEnum(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationOauthPaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationOauthPaginationEnum]


class RestAuthenticationOauthPagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationOauthPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationOauthPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestAuthenticationOauthRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationOauthRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationOauthRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationOauthRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationOauthRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationOauthRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRetryType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationOauthStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationOauthStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationOauthSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationOauthStateTrackingTypedDict]


class RestAuthenticationOauthScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationOauthStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationOauthTypedDict(TypedDict):
    client_secret_param_value: str
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[RestAuthenticationOauthAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    auth_request_params: NotRequired[
        List[RestAuthenticationOauthAuthRequestParamTypedDict]
    ]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[
        List[RestAuthenticationOauthAuthRequestHeaderTypedDict]
    ]
    discovery: NotRequired[RestAuthenticationOauthDiscoveryTypedDict]
    collect_method: NotRequired[RestAuthenticationOauthCollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestAuthenticationOauthCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationOauthPaginationTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationOauthRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationOauthSchedulingTypedDict]


class RestAuthenticationOauth(BaseModel):
    client_secret_param_value: Annotated[
        str, pydantic.Field(alias="clientSecretParamValue")
    ]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[RestAuthenticationOauthAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationOauthAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    auth_request_params: Annotated[
        Optional[List[RestAuthenticationOauthAuthRequestParam]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[RestAuthenticationOauthAuthRequestHeader]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationOauthDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationOauthCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationOauthCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestAuthenticationOauthCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationOauthPagination] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationOauthRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationOauthScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthCollectMethod(value)
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthRequestHeaderTypedDict(
    TypedDict
):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthRequestHeader(
    BaseModel
):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoveryTypedDict(
    TypedDict
):
    discover_type: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[
                RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType
            ],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectRequestHeaderTypedDict(
    TypedDict
):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectRequestHeader(
    BaseModel
):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationTypedDict(
    TypedDict
):
    type: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum
    ]


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationEnum(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRulesTypedDict(
    TypedDict
):
    type: NotRequired[RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTrackingTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueSchedulingTypedDict(
    TypedDict
):
    state_tracking: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTrackingTypedDict
    ]


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueTypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    authentication: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication
    ]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for login API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[
        List[
            RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthRequestHeaderTypedDict
        ]
    ]
    discovery: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscoveryTypedDict
    ]
    collect_method: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod
    ]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[
            RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectRequestHeaderTypedDict
        ]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationTypedDict
    ]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRulesTypedDict
    ]
    scheduling: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueSchedulingTypedDict
    ]


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    authentication: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[
            List[
                RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthRequestHeader
            ]
        ],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery
    ] = None

    collect_method: Annotated[
        Annotated[
            Optional[
                RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod
            ],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[
            List[
                RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectRequestHeader
            ]
        ],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePagination
    ] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthRequestHeaderTypedDict(
    TypedDict
):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthRequestHeader(
    BaseModel
):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoveryTypedDict(
    TypedDict
):
    discover_type: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[
                RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType
            ],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectRequestHeaderTypedDict(
    TypedDict
):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectRequestHeader(
    BaseModel
):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationTypedDict(
    TypedDict
):
    type: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum
    ]


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination(BaseModel):
    type: Annotated[
        Optional[
            RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum
        ],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationEnum(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRulesTypedDict(
    TypedDict
):
    type: NotRequired[RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTrackingTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseSchedulingTypedDict(
    TypedDict
):
    state_tracking: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTrackingTypedDict
    ]


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseTypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    authentication: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication
    ]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for login API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[
        List[
            RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthRequestHeaderTypedDict
        ]
    ]
    discovery: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoveryTypedDict
    ]
    collect_method: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod
    ]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[
            RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectRequestHeaderTypedDict
        ]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationTypedDict
    ]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRulesTypedDict
    ]
    scheduling: NotRequired[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseSchedulingTypedDict
    ]


class RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    authentication: Annotated[
        Optional[
            RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication
        ],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[
            List[
                RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthRequestHeader
            ]
        ],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery
    ] = None

    collect_method: Annotated[
        Annotated[
            Optional[
                RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod
            ],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[
            List[
                RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectRequestHeader
            ]
        ],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePagination
    ] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationLoginSecretTypedDict = TypeAliasType(
    "RestAuthenticationLoginSecretTypedDict",
    Union[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueTypedDict,
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseTypedDict,
    ],
)


RestAuthenticationLoginSecret = TypeAliasType(
    "RestAuthenticationLoginSecret",
    Union[
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
    ],
)


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthRequestHeaderTypedDict(
    TypedDict
):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectRequestHeaderTypedDict(
    TypedDict
):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum]


class RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationEnum(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return (
                    models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryType(
                        value
                    )
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingTypedDict
    ]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationLoginGetAuthTokenFromHeaderTrueTypedDict(TypedDict):
    username: str
    password: str
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    authentication: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
    ]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for login API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[
        List[
            RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthRequestHeaderTypedDict
        ]
    ]
    discovery: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryTypedDict
    ]
    collect_method: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod
    ]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[
            RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectRequestHeaderTypedDict
        ]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationTypedDict
    ]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesTypedDict
    ]
    scheduling: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingTypedDict
    ]


class RestAuthenticationLoginGetAuthTokenFromHeaderTrue(BaseModel):
    username: str

    password: str

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    authentication: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[
            List[RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthRequestHeader]
        ],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery] = (
        None
    )

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[
            List[RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectRequestHeader]
        ],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderTruePagination
    ] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthRequestHeaderTypedDict(
    TypedDict
):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectRequestHeaderTypedDict(
    TypedDict
):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationEnum(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return (
                    models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryType(
                        value
                    )
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTrackingTypedDict(
    TypedDict
):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTrackingTypedDict
    ]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationLoginGetAuthTokenFromHeaderFalseTypedDict(TypedDict):
    username: str
    password: str
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    authentication: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
    ]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for login API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[
        List[
            RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthRequestHeaderTypedDict
        ]
    ]
    discovery: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscoveryTypedDict
    ]
    collect_method: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod
    ]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[
            RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectRequestHeaderTypedDict
        ]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalsePaginationTypedDict
    ]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRulesTypedDict
    ]
    scheduling: NotRequired[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseSchedulingTypedDict
    ]


class RestAuthenticationLoginGetAuthTokenFromHeaderFalse(BaseModel):
    username: str

    password: str

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    authentication: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[
            List[RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthRequestHeader]
        ],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseDiscovery] = (
        None
    )

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[
            List[RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectRequestHeader]
        ],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginGetAuthTokenFromHeaderFalsePagination
    ] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationLoginGetAuthTokenFromHeaderFalseScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginGetAuthTokenFromHeaderFalseCollectMethod(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationLoginTypedDict = TypeAliasType(
    "RestAuthenticationLoginTypedDict",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueTypedDict,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseTypedDict,
    ],
)


RestAuthenticationLogin = TypeAliasType(
    "RestAuthenticationLogin",
    Union[
        RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
        RestAuthenticationLoginGetAuthTokenFromHeaderFalse,
    ],
)


class RestAuthenticationBasicSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationBasicSecretDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestAuthenticationBasicSecretDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationBasicSecretDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationBasicSecretDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationBasicSecretDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretDiscoverType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationBasicSecretCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationBasicSecretPaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationBasicSecretPaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationBasicSecretPaginationEnum]


class RestAuthenticationBasicSecretPagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationBasicSecretPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationBasicSecretPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationBasicSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationBasicSecretRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationBasicSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationBasicSecretRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRetryType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationBasicSecretStateTrackingTypedDict]


class RestAuthenticationBasicSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationBasicSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationBasicSecretTypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your credentials"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[RestAuthenticationBasicSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[RestAuthenticationBasicSecretDiscoveryTypedDict]
    collect_method: NotRequired[RestAuthenticationBasicSecretCollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestAuthenticationBasicSecretCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationBasicSecretPaginationTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationBasicSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationBasicSecretSchedulingTypedDict]


class RestAuthenticationBasicSecret(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your credentials"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[RestAuthenticationBasicSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationBasicSecretAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[RestAuthenticationBasicSecretDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationBasicSecretCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationBasicSecretCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestAuthenticationBasicSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationBasicSecretPagination] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationBasicSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationBasicSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretCollectMethod(value)
            except ValueError:
                return value
        return value


class RestAuthenticationBasicAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationBasicDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestAuthenticationBasicDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationBasicDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationBasicDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationBasicDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicDiscoverType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationBasicCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationBasicCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationBasicPaginationEnum(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationBasicPaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationBasicPaginationEnum]


class RestAuthenticationBasicPagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationBasicPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationBasicPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationBasicRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationBasicRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationBasicRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationBasicRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRetryType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationBasicStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationBasicStateTrackingTypedDict]


class RestAuthenticationBasicScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationBasicStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationBasicTypedDict(TypedDict):
    username: str
    password: str
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[RestAuthenticationBasicAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[RestAuthenticationBasicDiscoveryTypedDict]
    collect_method: NotRequired[RestAuthenticationBasicCollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestAuthenticationBasicCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationBasicPaginationTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationBasicRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationBasicSchedulingTypedDict]


class RestAuthenticationBasic(BaseModel):
    username: str

    password: str

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[RestAuthenticationBasicAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationBasicAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[RestAuthenticationBasicDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationBasicCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationBasicCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestAuthenticationBasicCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationBasicPagination] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationBasicRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationBasicScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicCollectMethod(value)
            except ValueError:
                return value
        return value


class RestAuthenticationNoneAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationNoneDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestAuthenticationNoneDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationNoneDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestAuthenticationNoneDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestAuthenticationNoneDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneDiscoverType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationNoneCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationNoneCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestAuthenticationNonePaginationEnum(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestAuthenticationNonePaginationTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationNonePaginationEnum]


class RestAuthenticationNonePagination(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationNonePaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationNonePaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNonePaginationEnum(value)
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestAuthenticationNoneRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestAuthenticationNoneRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationNoneRetryRules(BaseModel):
    type: Annotated[
        Optional[RestAuthenticationNoneRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationNoneRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRetryType(value)
            except ValueError:
                return value
        return value


class RestAuthenticationNoneStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationNoneStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationNoneSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationNoneStateTrackingTypedDict]


class RestAuthenticationNoneScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationNoneStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestAuthenticationNoneTypedDict(TypedDict):
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[RestAuthenticationNoneAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[RestAuthenticationNoneDiscoveryTypedDict]
    collect_method: NotRequired[RestAuthenticationNoneCollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestAuthenticationNoneCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationNonePaginationTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationNoneRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationNoneSchedulingTypedDict]


class RestAuthenticationNone(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[RestAuthenticationNoneAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestAuthenticationNoneAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[RestAuthenticationNoneDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[RestAuthenticationNoneCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestAuthenticationNoneCollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestAuthenticationNoneCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationNonePagination] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationNoneRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationNoneScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneCollectMethod(value)
            except ValueError:
                return value
        return value


class RestCollectMethodOtherCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestCollectMethodOtherDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodOtherDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestCollectMethodOtherDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestCollectMethodOtherDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherDiscoverType(value)
            except ValueError:
                return value
        return value


class RestCollectMethodOtherCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectMethodOtherCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectMethodOtherPaginationEnum(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestCollectMethodOtherPaginationTypedDict(TypedDict):
    type: NotRequired[RestCollectMethodOtherPaginationEnum]


class RestCollectMethodOtherPagination(BaseModel):
    type: Annotated[
        Optional[RestCollectMethodOtherPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodOtherPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestCollectMethodOtherAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodOtherRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestCollectMethodOtherRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestCollectMethodOtherRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodOtherRetryRules(BaseModel):
    type: Annotated[
        Optional[RestCollectMethodOtherRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodOtherRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRetryType(value)
            except ValueError:
                return value
        return value


class RestCollectMethodOtherStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodOtherStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodOtherSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodOtherStateTrackingTypedDict]


class RestCollectMethodOtherScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodOtherStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestCollectMethodOtherTypedDict(TypedDict):
    collect_verb: Any
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: NotRequired[RestCollectMethodOtherCollectMethod]
    collect_body: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[RestCollectMethodOtherDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[RestCollectMethodOtherCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodOtherPaginationTypedDict]
    authentication: NotRequired[RestCollectMethodOtherAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodOtherRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodOtherSchedulingTypedDict]


class RestCollectMethodOther(BaseModel):
    collect_verb: Annotated[Any, pydantic.Field(alias="collectVerb")]

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        Annotated[
            Optional[RestCollectMethodOtherCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestCollectMethodOtherCollectMethod.GET

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[RestCollectMethodOtherDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[RestCollectMethodOtherCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodOtherPagination] = None

    authentication: Annotated[
        Optional[RestCollectMethodOtherAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodOtherAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodOtherRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodOtherScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherAuthentication(value)
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestCollectMethodPostWithBodyDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodPostWithBodyDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestCollectMethodPostWithBodyDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestCollectMethodPostWithBodyDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyDiscoverType(value)
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectMethodPostWithBodyCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectMethodPostWithBodyPaginationEnum(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestCollectMethodPostWithBodyPaginationTypedDict(TypedDict):
    type: NotRequired[RestCollectMethodPostWithBodyPaginationEnum]


class RestCollectMethodPostWithBodyPagination(BaseModel):
    type: Annotated[
        Optional[RestCollectMethodPostWithBodyPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodPostWithBodyPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodPostWithBodyRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestCollectMethodPostWithBodyRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestCollectMethodPostWithBodyRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodPostWithBodyRetryRules(BaseModel):
    type: Annotated[
        Optional[RestCollectMethodPostWithBodyRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodPostWithBodyRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRetryType(value)
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodPostWithBodyStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodPostWithBodySchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodPostWithBodyStateTrackingTypedDict]


class RestCollectMethodPostWithBodyScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodPostWithBodyStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestCollectMethodPostWithBodyTypedDict(TypedDict):
    collect_body: Any
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: NotRequired[RestCollectMethodPostWithBodyCollectMethod]
    discovery: NotRequired[RestCollectMethodPostWithBodyDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestCollectMethodPostWithBodyCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodPostWithBodyPaginationTypedDict]
    authentication: NotRequired[RestCollectMethodPostWithBodyAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodPostWithBodyRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodPostWithBodySchedulingTypedDict]


class RestCollectMethodPostWithBody(BaseModel):
    collect_body: Annotated[Any, pydantic.Field(alias="collectBody")]

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        Annotated[
            Optional[RestCollectMethodPostWithBodyCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestCollectMethodPostWithBodyCollectMethod.GET

    discovery: Optional[RestCollectMethodPostWithBodyDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_request_headers: Annotated[
        Optional[List[RestCollectMethodPostWithBodyCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodPostWithBodyPagination] = None

    authentication: Annotated[
        Optional[RestCollectMethodPostWithBodyAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodPostWithBodyAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodPostWithBodyRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodPostWithBodyScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyAuthentication(value)
            except ValueError:
                return value
        return value


class RestCollectMethodPostCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestCollectMethodPostDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodPostDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestCollectMethodPostDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestCollectMethodPostDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostDiscoverType(value)
            except ValueError:
                return value
        return value


class RestCollectMethodPostCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectMethodPostCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectMethodPostPaginationEnum(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestCollectMethodPostPaginationTypedDict(TypedDict):
    type: NotRequired[RestCollectMethodPostPaginationEnum]


class RestCollectMethodPostPagination(BaseModel):
    type: Annotated[
        Optional[RestCollectMethodPostPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodPostPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestCollectMethodPostAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodPostRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestCollectMethodPostRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestCollectMethodPostRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodPostRetryRules(BaseModel):
    type: Annotated[
        Optional[RestCollectMethodPostRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodPostRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRetryType(value)
            except ValueError:
                return value
        return value


class RestCollectMethodPostStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodPostStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodPostSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodPostStateTrackingTypedDict]


class RestCollectMethodPostScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodPostStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestCollectMethodPostTypedDict(TypedDict):
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: NotRequired[RestCollectMethodPostCollectMethod]
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[RestCollectMethodPostDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestCollectMethodPostCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodPostPaginationTypedDict]
    authentication: NotRequired[RestCollectMethodPostAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodPostRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodPostSchedulingTypedDict]


class RestCollectMethodPost(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        Annotated[
            Optional[RestCollectMethodPostCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestCollectMethodPostCollectMethod.GET

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[RestCollectMethodPostDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestCollectMethodPostCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodPostPagination] = None

    authentication: Annotated[
        Optional[RestCollectMethodPostAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodPostAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodPostRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodPostScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostAuthentication(value)
            except ValueError:
                return value
        return value


class RestCollectMethodGetCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodGetDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodGetDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestCollectMethodGetDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodGetDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestCollectMethodGetDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestCollectMethodGetDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetDiscoverType(value)
            except ValueError:
                return value
        return value


class RestCollectMethodGetCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectMethodGetCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectMethodGetPaginationEnum(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class RestCollectMethodGetPaginationTypedDict(TypedDict):
    type: NotRequired[RestCollectMethodGetPaginationEnum]


class RestCollectMethodGetPagination(BaseModel):
    type: Annotated[
        Optional[RestCollectMethodGetPaginationEnum],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodGetPaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetPaginationEnum(value)
            except ValueError:
                return value
        return value


class RestCollectMethodGetAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodGetRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestCollectMethodGetRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestCollectMethodGetRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodGetRetryRules(BaseModel):
    type: Annotated[
        Optional[RestCollectMethodGetRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodGetRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRetryType(value)
            except ValueError:
                return value
        return value


class RestCollectMethodGetStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodGetStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodGetSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodGetStateTrackingTypedDict]


class RestCollectMethodGetScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodGetStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None


class RestCollectMethodGetTypedDict(TypedDict):
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: NotRequired[RestCollectMethodGetCollectMethod]
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[RestCollectMethodGetDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestCollectMethodGetCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodGetPaginationTypedDict]
    authentication: NotRequired[RestCollectMethodGetAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodGetRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodGetSchedulingTypedDict]


class RestCollectMethodGet(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        Annotated[
            Optional[RestCollectMethodGetCollectMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = RestCollectMethodGetCollectMethod.GET

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[RestCollectMethodGetDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestCollectMethodGetCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodGetPagination] = None

    authentication: Annotated[
        Optional[RestCollectMethodGetAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectMethodGetAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodGetRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodGetScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetAuthentication(value)
            except ValueError:
                return value
        return value


RestCollectorConfTypedDict = TypeAliasType(
    "RestCollectorConfTypedDict",
    Union[
        RestCollectMethodGetTypedDict,
        RestCollectMethodPostTypedDict,
        RestCollectMethodPostWithBodyTypedDict,
        RestCollectMethodOtherTypedDict,
        RestAuthenticationNoneTypedDict,
        RestAuthenticationBasicSecretTypedDict,
        RestAuthenticationHmacTypedDict,
        RestAuthenticationBasicTypedDict,
        RestAuthenticationGoogleOauthTypedDict,
        RestAuthenticationGoogleOauthSecretTypedDict,
        RestAuthenticationOauthTypedDict,
        RestAuthenticationOauthSecretTypedDict,
        RestAuthenticationLoginTypedDict,
        RestAuthenticationLoginSecretTypedDict,
    ],
)


RestCollectorConf = Annotated[
    Union[
        Annotated[RestAuthenticationNone, Tag("none")],
        Annotated[RestAuthenticationBasic, Tag("basic")],
        Annotated[RestAuthenticationBasicSecret, Tag("basicSecret")],
        Annotated[RestAuthenticationLogin, Tag("login")],
        Annotated[RestAuthenticationLoginSecret, Tag("loginSecret")],
        Annotated[RestAuthenticationOauth, Tag("oauth")],
        Annotated[RestAuthenticationOauthSecret, Tag("oauthSecret")],
        Annotated[RestAuthenticationGoogleOauth, Tag("google_oauth")],
        Annotated[RestAuthenticationGoogleOauthSecret, Tag("google_oauthSecret")],
        Annotated[RestAuthenticationHmac, Tag("hmac")],
    ],
    Discriminator(lambda m: get_discriminator(m, "authentication", "authentication")),
]

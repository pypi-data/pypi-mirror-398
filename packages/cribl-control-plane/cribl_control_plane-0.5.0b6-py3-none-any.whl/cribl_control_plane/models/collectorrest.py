"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class CollectorRestAuthentication14(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestType14(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType14(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery14TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType14]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery14(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType14],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType14.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType14(value)
            except ValueError:
                return value
        return value


class CollectMethod14(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam14TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam14(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader14TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader14(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum14(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination14TypedDict(TypedDict):
    type: NotRequired[PaginationEnum14]


class Pagination14(BaseModel):
    type: Annotated[
        Optional[PaginationEnum14], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum14.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum14(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType14(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules14TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType14]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules14(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType14], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType14.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType14(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking14TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking14(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling14TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking14TypedDict]


class CollectorRestScheduling14(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking14], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader14TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader14(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam14TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam14(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest14TypedDict(TypedDict):
    hmac_function_id: str
    r"""Select or create an HMAC Function to use with authentication"""
    type: CollectorRestType14
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication14]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[CollectorRestDiscovery14TypedDict]
    collect_method: NotRequired[CollectMethod14]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam14TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader14TypedDict]
    ]
    pagination: NotRequired[Pagination14TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules14TypedDict]
    scheduling: NotRequired[CollectorRestScheduling14TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader14TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam14TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""


class CollectorRestRest14(BaseModel):
    hmac_function_id: Annotated[str, pydantic.Field(alias="hmacFunctionId")]
    r"""Select or create an HMAC Function to use with authentication"""

    type: CollectorRestType14
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication14],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication14.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[CollectorRestDiscovery14] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod14], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod14.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam14]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader14]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination14] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules14], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling14], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader14]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam14]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication14(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod14(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication13(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestType13(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType13(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery13TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType13]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery13(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType13],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType13.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType13(value)
            except ValueError:
                return value
        return value


class CollectMethod13(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam13TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam13(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader13TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader13(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum13(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination13TypedDict(TypedDict):
    type: NotRequired[PaginationEnum13]


class Pagination13(BaseModel):
    type: Annotated[
        Optional[PaginationEnum13], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum13.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum13(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType13(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules13TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType13]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules13(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType13], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType13.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType13(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking13TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking13(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling13TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking13TypedDict]


class CollectorRestScheduling13(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking13], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader13TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader13(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam13TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam13(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest13TypedDict(TypedDict):
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    text_secret: str
    r"""Select or create a text secret that contains the Google service account credentials value"""
    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    type: CollectorRestType13
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication13]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[CollectorRestDiscovery13TypedDict]
    collect_method: NotRequired[CollectMethod13]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam13TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader13TypedDict]
    ]
    pagination: NotRequired[Pagination13TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules13TypedDict]
    scheduling: NotRequired[CollectorRestScheduling13TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader13TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam13TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest13(BaseModel):
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the Google service account credentials value"""

    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    type: CollectorRestType13
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication13],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication13.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[CollectorRestDiscovery13] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod13], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod13.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam13]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader13]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination13] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules13], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling13], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader13]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam13]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication13(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod13(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication12(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestType12(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType12(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery12TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType12]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery12(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType12],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType12.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType12(value)
            except ValueError:
                return value
        return value


class CollectMethod12(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam12TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam12(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader12TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader12(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum12(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination12TypedDict(TypedDict):
    type: NotRequired[PaginationEnum12]


class Pagination12(BaseModel):
    type: Annotated[
        Optional[PaginationEnum12], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum12.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum12(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType12(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules12TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType12]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules12(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType12], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType12.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType12(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking12TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking12(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling12TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking12TypedDict]


class CollectorRestScheduling12(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking12], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader12TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader12(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam12TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam12(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest12TypedDict(TypedDict):
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: str
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    type: CollectorRestType12
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication12]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[CollectorRestDiscovery12TypedDict]
    collect_method: NotRequired[CollectMethod12]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam12TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader12TypedDict]
    ]
    pagination: NotRequired[Pagination12TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules12TypedDict]
    scheduling: NotRequired[CollectorRestScheduling12TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader12TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam12TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest12(BaseModel):
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        str, pydantic.Field(alias="serviceAccountCredentials")
    ]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    type: CollectorRestType12
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication12],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication12.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[CollectorRestDiscovery12] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod12], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod12.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam12]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader12]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination12] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules12], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling12], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader12]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam12]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication12(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod12(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication11(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestAuthRequestParam11TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam11(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader11TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader11(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestType11(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType11(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery11TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType11]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery11(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType11],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType11.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType11(value)
            except ValueError:
                return value
        return value


class CollectMethod11(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam11TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam11(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader11TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader11(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum11(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination11TypedDict(TypedDict):
    type: NotRequired[PaginationEnum11]


class Pagination11(BaseModel):
    type: Annotated[
        Optional[PaginationEnum11], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum11.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum11(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType11(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules11TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType11]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules11(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType11], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType11.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType11(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking11TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking11(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling11TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking11TypedDict]


class CollectorRestScheduling11(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking11], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestRest11TypedDict(TypedDict):
    text_secret: str
    r"""Select or create a text secret that contains the Google service account credentials value"""
    type: CollectorRestType11
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication11]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam11TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader11TypedDict]]
    discovery: NotRequired[CollectorRestDiscovery11TypedDict]
    collect_method: NotRequired[CollectMethod11]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam11TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader11TypedDict]
    ]
    pagination: NotRequired[Pagination11TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules11TypedDict]
    scheduling: NotRequired[CollectorRestScheduling11TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest11(BaseModel):
    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the Google service account credentials value"""

    type: CollectorRestType11
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication11],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication11.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam11]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader11]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[CollectorRestDiscovery11] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod11], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod11.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam11]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader11]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination11] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules11], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling11], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication11(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod11(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication10(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestAuthRequestParam10TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam10(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader10TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader10(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestType10(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType10(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery10TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType10]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery10(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType10],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType10.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType10(value)
            except ValueError:
                return value
        return value


class CollectMethod10(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam10TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam10(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader10TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader10(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum10(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination10TypedDict(TypedDict):
    type: NotRequired[PaginationEnum10]


class Pagination10(BaseModel):
    type: Annotated[
        Optional[PaginationEnum10], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum10.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum10(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType10(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules10TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType10]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules10(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType10], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType10.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType10(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking10TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking10(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling10TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking10TypedDict]


class CollectorRestScheduling10(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking10], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestRest10TypedDict(TypedDict):
    client_secret_param_value: str
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    type: CollectorRestType10
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication10]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam10TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader10TypedDict]]
    discovery: NotRequired[CollectorRestDiscovery10TypedDict]
    collect_method: NotRequired[CollectMethod10]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam10TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader10TypedDict]
    ]
    pagination: NotRequired[Pagination10TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules10TypedDict]
    scheduling: NotRequired[CollectorRestScheduling10TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest10(BaseModel):
    client_secret_param_value: Annotated[
        str, pydantic.Field(alias="clientSecretParamValue")
    ]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    type: CollectorRestType10
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication10],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication10.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam10]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader10]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[CollectorRestDiscovery10] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod10], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod10.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam10]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader10]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination10] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules10], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling10], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication10(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod10(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication9(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestAuthRequestHeader9TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader9(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestType9(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType9(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery9TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType9]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery9(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType9],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType9.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType9(value)
            except ValueError:
                return value
        return value


class CollectMethod9(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam9TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam9(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader9TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader9(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum9(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination9TypedDict(TypedDict):
    type: NotRequired[PaginationEnum9]


class Pagination9(BaseModel):
    type: Annotated[
        Optional[PaginationEnum9], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum9.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum9(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType9(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules9TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType9]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules9(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType9], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType9.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType9(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking9TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking9(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling9TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking9TypedDict]


class CollectorRestScheduling9(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking9], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestParam9TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam9(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest9TypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    type: CollectorRestType9
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication9]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader9TypedDict]]
    discovery: NotRequired[CollectorRestDiscovery9TypedDict]
    collect_method: NotRequired[CollectMethod9]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam9TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader9TypedDict]
    ]
    pagination: NotRequired[Pagination9TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules9TypedDict]
    scheduling: NotRequired[CollectorRestScheduling9TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam9TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest9(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    type: CollectorRestType9
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication9],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication9.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader9]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[CollectorRestDiscovery9] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod9], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod9.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam9]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader9]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination9] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules9], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling9], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam9]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication9(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod9(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication8(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestAuthRequestHeader8TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader8(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestType8(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType8(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery8TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType8]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery8(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType8],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType8.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType8(value)
            except ValueError:
                return value
        return value


class CollectMethod8(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam8TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam8(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader8TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader8(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum8(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination8TypedDict(TypedDict):
    type: NotRequired[PaginationEnum8]


class Pagination8(BaseModel):
    type: Annotated[
        Optional[PaginationEnum8], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum8.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum8(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType8(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules8TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType8]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules8(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType8], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType8.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType8(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking8TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking8(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling8TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking8TypedDict]


class CollectorRestScheduling8(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking8], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestParam8TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam8(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest8TypedDict(TypedDict):
    username: str
    password: str
    type: CollectorRestType8
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication8]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader8TypedDict]]
    discovery: NotRequired[CollectorRestDiscovery8TypedDict]
    collect_method: NotRequired[CollectMethod8]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam8TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader8TypedDict]
    ]
    pagination: NotRequired[Pagination8TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules8TypedDict]
    scheduling: NotRequired[CollectorRestScheduling8TypedDict]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam8TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest8(BaseModel):
    username: str

    password: str

    type: CollectorRestType8
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication8],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication8.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader8]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[CollectorRestDiscovery8] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod8], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod8.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam8]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader8]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination8] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules8], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling8], pydantic.Field(alias="__scheduling")
    ] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam8]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication8(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod8(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestType7(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery7TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType7]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery7(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType7],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType7.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType7(value)
            except ValueError:
                return value
        return value


class CollectMethod7(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam7TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam7(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader7TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader7(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum7(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination7TypedDict(TypedDict):
    type: NotRequired[PaginationEnum7]


class Pagination7(BaseModel):
    type: Annotated[
        Optional[PaginationEnum7], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum7.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum7(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules7TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType7]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules7(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType7], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType7.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType7(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking7TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking7(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling7TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking7TypedDict]


class CollectorRestScheduling7(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking7], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader7TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader7(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam7TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam7(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest7TypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    type: CollectorRestType7
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication7]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[CollectorRestDiscovery7TypedDict]
    collect_method: NotRequired[CollectMethod7]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam7TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader7TypedDict]
    ]
    pagination: NotRequired[Pagination7TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules7TypedDict]
    scheduling: NotRequired[CollectorRestScheduling7TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader7TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam7TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest7(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    type: CollectorRestType7
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication7],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication7.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[CollectorRestDiscovery7] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod7], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod7.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam7]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader7]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination7] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules7], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling7], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader7]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam7]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication7(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod7(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestType6(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery6TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType6]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery6(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType6],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType6.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType6(value)
            except ValueError:
                return value
        return value


class CollectMethod6(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam6TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam6(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader6TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader6(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum6(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination6TypedDict(TypedDict):
    type: NotRequired[PaginationEnum6]


class Pagination6(BaseModel):
    type: Annotated[
        Optional[PaginationEnum6], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum6.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum6(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules6TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType6]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules6(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType6], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType6.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType6(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking6TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking6(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling6TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking6TypedDict]


class CollectorRestScheduling6(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking6], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader6TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader6(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam6TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam6(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest6TypedDict(TypedDict):
    username: str
    password: str
    type: CollectorRestType6
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication6]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[CollectorRestDiscovery6TypedDict]
    collect_method: NotRequired[CollectMethod6]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam6TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader6TypedDict]
    ]
    pagination: NotRequired[Pagination6TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules6TypedDict]
    scheduling: NotRequired[CollectorRestScheduling6TypedDict]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader6TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam6TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest6(BaseModel):
    username: str

    password: str

    type: CollectorRestType6
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication6],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication6.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[CollectorRestDiscovery6] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod6], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod6.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam6]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader6]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination6] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules6], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling6], pydantic.Field(alias="__scheduling")
    ] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader6]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam6]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication6(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod6(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestType5(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery5TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType5]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery5(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType5],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType5.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType5(value)
            except ValueError:
                return value
        return value


class CollectMethod5(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam5TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam5(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader5TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader5(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum5(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination5TypedDict(TypedDict):
    type: NotRequired[PaginationEnum5]


class Pagination5(BaseModel):
    type: Annotated[
        Optional[PaginationEnum5], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum5.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum5(value)
            except ValueError:
                return value
        return value


class CollectorRestRetryType5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules5TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType5]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules5(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType5], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType5.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType5(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking5TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking5(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling5TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking5TypedDict]


class CollectorRestScheduling5(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking5], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader5TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader5(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam5TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam5(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest5TypedDict(TypedDict):
    type: CollectorRestType5
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: NotRequired[CollectorRestAuthentication5]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[CollectorRestDiscovery5TypedDict]
    collect_method: NotRequired[CollectMethod5]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam5TypedDict]
    ]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader5TypedDict]
    ]
    pagination: NotRequired[Pagination5TypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules5TypedDict]
    scheduling: NotRequired[CollectorRestScheduling5TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader5TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam5TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest5(BaseModel):
    type: CollectorRestType5
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: Annotated[
        Optional[CollectorRestAuthentication5],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication5.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[CollectorRestDiscovery5] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod5], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod5.GET

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam5]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader5]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination5] = None

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules5], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling5], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader5]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam5]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication5(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod5(value)
            except ValueError:
                return value
        return value


class CollectMethod4(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam4TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam4(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestType4(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery4TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType4]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery4(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType4],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType4.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType4(value)
            except ValueError:
                return value
        return value


class CollectorRestCollectRequestHeader4TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader4(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum4(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination4TypedDict(TypedDict):
    type: NotRequired[PaginationEnum4]


class Pagination4(BaseModel):
    type: Annotated[
        Optional[PaginationEnum4], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum4.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum4(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestRetryType4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules4TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType4]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules4(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType4], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType4.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType4(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking4TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking4(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling4TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking4TypedDict]


class CollectorRestScheduling4(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking4], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader4TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader4(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam4TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam4(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest4TypedDict(TypedDict):
    collect_verb: str
    r"""Custom HTTP method to use for the Collect operation"""
    type: CollectorRestType4
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: NotRequired[CollectMethod4]
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam4TypedDict]
    ]
    discovery: NotRequired[CollectorRestDiscovery4TypedDict]
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader4TypedDict]
    ]
    pagination: NotRequired[Pagination4TypedDict]
    authentication: NotRequired[CollectorRestAuthentication4]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules4TypedDict]
    scheduling: NotRequired[CollectorRestScheduling4TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader4TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam4TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest4(BaseModel):
    collect_verb: Annotated[str, pydantic.Field(alias="collectVerb")]
    r"""Custom HTTP method to use for the Collect operation"""

    type: CollectorRestType4
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        Annotated[Optional[CollectMethod4], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod4.GET

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam4]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    discovery: Optional[CollectorRestDiscovery4] = None

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader4]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination4] = None

    authentication: Annotated[
        Optional[CollectorRestAuthentication4],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication4.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules4], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling4], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader4]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam4]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod4(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication4(value)
            except ValueError:
                return value
        return value


class CollectMethod3(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestType3(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery3TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType3]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery3(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType3],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType3.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType3(value)
            except ValueError:
                return value
        return value


class CollectorRestCollectRequestParam3TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam3(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader3TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader3(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum3(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination3TypedDict(TypedDict):
    type: NotRequired[PaginationEnum3]


class Pagination3(BaseModel):
    type: Annotated[
        Optional[PaginationEnum3], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum3.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum3(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestRetryType3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules3TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType3]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules3(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType3], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType3.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType3(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking3TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking3(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling3TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking3TypedDict]


class CollectorRestScheduling3(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking3], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader3TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader3(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam3TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam3(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest3TypedDict(TypedDict):
    collect_body: str
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    type: CollectorRestType3
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: NotRequired[CollectMethod3]
    discovery: NotRequired[CollectorRestDiscovery3TypedDict]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam3TypedDict]
    ]
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader3TypedDict]
    ]
    pagination: NotRequired[Pagination3TypedDict]
    authentication: NotRequired[CollectorRestAuthentication3]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules3TypedDict]
    scheduling: NotRequired[CollectorRestScheduling3TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader3TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam3TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest3(BaseModel):
    collect_body: Annotated[str, pydantic.Field(alias="collectBody")]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    type: CollectorRestType3
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        Annotated[Optional[CollectMethod3], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod3.GET

    discovery: Optional[CollectorRestDiscovery3] = None

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam3]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader3]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination3] = None

    authentication: Annotated[
        Optional[CollectorRestAuthentication3],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication3.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules3], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling3], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader3]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam3]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod3(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication3(value)
            except ValueError:
                return value
        return value


class CollectMethod2(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam2TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam2(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestType2(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery2TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType2]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery2(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType2],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType2.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType2(value)
            except ValueError:
                return value
        return value


class CollectorRestCollectRequestHeader2TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader2(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum2(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination2TypedDict(TypedDict):
    type: NotRequired[PaginationEnum2]


class Pagination2(BaseModel):
    type: Annotated[
        Optional[PaginationEnum2], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum2.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum2(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestRetryType2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules2TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType2]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules2(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType2], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType2.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType2(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking2TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking2(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling2TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking2TypedDict]


class CollectorRestScheduling2(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking2], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader2TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader2(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam2TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam2(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest2TypedDict(TypedDict):
    type: CollectorRestType2
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: NotRequired[CollectMethod2]
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam2TypedDict]
    ]
    discovery: NotRequired[CollectorRestDiscovery2TypedDict]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader2TypedDict]
    ]
    pagination: NotRequired[Pagination2TypedDict]
    authentication: NotRequired[CollectorRestAuthentication2]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules2TypedDict]
    scheduling: NotRequired[CollectorRestScheduling2TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader2TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam2TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest2(BaseModel):
    type: CollectorRestType2
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        Annotated[Optional[CollectMethod2], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod2.GET

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam2]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    discovery: Optional[CollectorRestDiscovery2] = None

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader2]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination2] = None

    authentication: Annotated[
        Optional[CollectorRestAuthentication2],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication2.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules2], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling2], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader2]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam2]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod2(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication2(value)
            except ValueError:
                return value
        return value


class CollectMethod1(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class CollectorRestCollectRequestParam1TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestParam1(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestType1(str, Enum):
    r"""Collector type: rest"""

    REST = "rest"


class CollectorRestDiscoverType1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class CollectorRestDiscovery1TypedDict(TypedDict):
    discover_type: NotRequired[CollectorRestDiscoverType1]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class CollectorRestDiscovery1(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[CollectorRestDiscoverType1],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = CollectorRestDiscoverType1.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestDiscoverType1(value)
            except ValueError:
                return value
        return value


class CollectorRestCollectRequestHeader1TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestCollectRequestHeader1(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum1(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class Pagination1TypedDict(TypedDict):
    type: NotRequired[PaginationEnum1]


class Pagination1(BaseModel):
    type: Annotated[
        Optional[PaginationEnum1], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum1.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum1(value)
            except ValueError:
                return value
        return value


class CollectorRestAuthentication1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class CollectorRestRetryType1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorRestRetryRules1TypedDict(TypedDict):
    type: NotRequired[CollectorRestRetryType1]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorRestRetryRules1(BaseModel):
    type: Annotated[
        Optional[CollectorRestRetryType1], PlainValidator(validate_open_enum(False))
    ] = CollectorRestRetryType1.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestRetryType1(value)
            except ValueError:
                return value
        return value


class CollectorRestStateTracking1TypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestStateTracking1(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class CollectorRestScheduling1TypedDict(TypedDict):
    state_tracking: NotRequired[CollectorRestStateTracking1TypedDict]


class CollectorRestScheduling1(BaseModel):
    state_tracking: Annotated[
        Optional[CollectorRestStateTracking1], pydantic.Field(alias="stateTracking")
    ] = None


class CollectorRestAuthRequestHeader1TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestHeader1(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam1TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestAuthRequestParam1(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class CollectorRestRest1TypedDict(TypedDict):
    type: CollectorRestType1
    r"""Collector type: rest"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: NotRequired[CollectMethod1]
    collect_request_params: NotRequired[
        List[CollectorRestCollectRequestParam1TypedDict]
    ]
    discovery: NotRequired[CollectorRestDiscovery1TypedDict]
    collect_verb: NotRequired[str]
    r"""Custom HTTP method to use for the Collect operation"""
    collect_body: NotRequired[str]
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""
    collect_request_headers: NotRequired[
        List[CollectorRestCollectRequestHeader1TypedDict]
    ]
    pagination: NotRequired[Pagination1TypedDict]
    authentication: NotRequired[CollectorRestAuthentication1]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[CollectorRestRetryRules1TypedDict]
    scheduling: NotRequired[CollectorRestScheduling1TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[List[CollectorRestAuthRequestHeader1TypedDict]]
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    client_secret_param_name: NotRequired[str]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: NotRequired[str]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    auth_request_params: NotRequired[List[CollectorRestAuthRequestParam1TypedDict]]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    text_secret: NotRequired[str]
    r"""Select or create a text secret that contains the Google service account credentials value"""
    scopes: NotRequired[List[str]]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: NotRequired[str]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: NotRequired[str]
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    hmac_function_id: NotRequired[str]
    r"""Select or create an HMAC Function to use with authentication"""


class CollectorRestRest1(BaseModel):
    type: CollectorRestType1
    r"""Collector type: rest"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        Annotated[Optional[CollectMethod1], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod1.GET

    collect_request_params: Annotated[
        Optional[List[CollectorRestCollectRequestParam1]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None

    discovery: Optional[CollectorRestDiscovery1] = None

    collect_verb: Annotated[Optional[str], pydantic.Field(alias="collectVerb")] = None
    r"""Custom HTTP method to use for the Collect operation"""

    collect_body: Annotated[Optional[str], pydantic.Field(alias="collectBody")] = None
    r"""Template for body to send with the Collect request. Reference global variables, functions, or parameters from the Discover response using template parameters: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`"""

    collect_request_headers: Annotated[
        Optional[List[CollectorRestCollectRequestHeader1]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination1] = None

    authentication: Annotated[
        Optional[CollectorRestAuthentication1],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorRestAuthentication1.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[CollectorRestRetryRules1], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[CollectorRestScheduling1], pydantic.Field(alias="__scheduling")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = False
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        "Authorization"
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[CollectorRestAuthRequestHeader1]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamValue")
    ] = None
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[CollectorRestAuthRequestParam1]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a text secret that contains the Google service account credentials value"""

    scopes: Optional[List[str]] = None
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        Optional[str], pydantic.Field(alias="serviceAccountCredentials")
    ] = None
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: Optional[str] = None
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    hmac_function_id: Annotated[
        Optional[str], pydantic.Field(alias="hmacFunctionId")
    ] = None
    r"""Select or create an HMAC Function to use with authentication"""

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod1(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorRestAuthentication1(value)
            except ValueError:
                return value
        return value


CollectorRestTypedDict = TypeAliasType(
    "CollectorRestTypedDict",
    Union[
        CollectorRestRest1TypedDict,
        CollectorRestRest2TypedDict,
        CollectorRestRest3TypedDict,
        CollectorRestRest4TypedDict,
        CollectorRestRest5TypedDict,
        CollectorRestRest6TypedDict,
        CollectorRestRest7TypedDict,
        CollectorRestRest8TypedDict,
        CollectorRestRest9TypedDict,
        CollectorRestRest10TypedDict,
        CollectorRestRest11TypedDict,
        CollectorRestRest12TypedDict,
        CollectorRestRest13TypedDict,
        CollectorRestRest14TypedDict,
    ],
)


CollectorRest = TypeAliasType(
    "CollectorRest",
    Union[
        CollectorRestRest1,
        CollectorRestRest2,
        CollectorRestRest3,
        CollectorRestRest4,
        CollectorRestRest5,
        CollectorRestRest6,
        CollectorRestRest7,
        CollectorRestRest8,
        CollectorRestRest9,
        CollectorRestRest10,
        CollectorRestRest11,
        CollectorRestRest12,
        CollectorRestRest13,
        CollectorRestRest14,
    ],
)

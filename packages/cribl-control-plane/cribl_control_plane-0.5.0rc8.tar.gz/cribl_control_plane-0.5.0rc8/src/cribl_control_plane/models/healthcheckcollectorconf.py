"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class HealthCheckCollectorConfDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectorConfDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckCollectorConfDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectorConfDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckCollectorConfDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckCollectorConfDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectorConfDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectorConfCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectorConfCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectorConfAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectorConfHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckCollectorConfRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckCollectorConfRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckCollectorConfRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectorConfRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckCollectorConfRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckCollectorConfRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectorConfRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectorConfTypedDict(TypedDict):
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    discovery: NotRequired[HealthCheckCollectorConfDiscoveryTypedDict]
    collect_method: NotRequired[HealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectorConfCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    authentication: NotRequired[HealthCheckCollectorConfAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HealthCheckCollectorConfHiddenDefaultBreakers]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectorConfRetryRulesTypedDict]


class HealthCheckCollectorConf(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    discovery: Optional[HealthCheckCollectorConfDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckMethod], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectorConfCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    authentication: Annotated[
        Optional[HealthCheckCollectorConfAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckCollectorConfAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckCollectorConfHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectorConfRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectorConfAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectorConfHiddenDefaultBreakers(value)
            except ValueError:
                return value
        return value

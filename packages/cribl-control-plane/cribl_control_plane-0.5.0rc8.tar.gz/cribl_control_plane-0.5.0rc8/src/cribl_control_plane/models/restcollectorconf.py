"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class RestCollectorConfDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectorConfDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[RestCollectorConfDiscoverType]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectorConfDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[RestCollectorConfDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = RestCollectorConfDiscoverType.NONE
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectorConfDiscoverType(value)
            except ValueError:
                return value
        return value


class CollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectorConfCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class RestCollectorConfCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute parameter value, usually enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values that aren't successfully evaluated as JavaScript expressions will be treated as string constants."""


class PaginationEnum(str, Enum, metaclass=utils.OpenEnumMeta):
    # None
    NONE = "none"
    # Response Body Attribute
    RESPONSE_BODY = "response_body"
    # Response Header Attribute
    RESPONSE_HEADER = "response_header"
    # RFC 5988 - Web Linking
    RESPONSE_HEADER_LINK = "response_header_link"
    # Offset/Limit
    REQUEST_OFFSET = "request_offset"
    # Page/Size
    REQUEST_PAGE = "request_page"


class PaginationTypedDict(TypedDict):
    type: NotRequired[PaginationEnum]


class Pagination(BaseModel):
    type: Annotated[
        Optional[PaginationEnum], PlainValidator(validate_open_enum(False))
    ] = PaginationEnum.NONE

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationEnum(value)
            except ValueError:
                return value
        return value


class RestCollectorConfAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectorConfRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class RestCollectorConfRetryRulesTypedDict(TypedDict):
    type: NotRequired[RestCollectorConfRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectorConfRetryRules(BaseModel):
    type: Annotated[
        Optional[RestCollectorConfRetryType], PlainValidator(validate_open_enum(False))
    ] = RestCollectorConfRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectorConfRetryType(value)
            except ValueError:
                return value
        return value


class RestCollectorConfStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectorConfStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectorConfSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectorConfStateTrackingTypedDict]


class RestCollectorConfScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectorConfStateTracking], pydantic.Field(alias="stateTracking")
    ] = None


class RestCollectorConfTypedDict(TypedDict):
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    discovery: NotRequired[RestCollectorConfDiscoveryTypedDict]
    collect_method: NotRequired[CollectMethod]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[RestCollectorConfCollectRequestHeaderTypedDict]
    ]
    pagination: NotRequired[PaginationTypedDict]
    authentication: NotRequired[RestCollectorConfAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectorConfRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectorConfSchedulingTypedDict]


class RestCollectorConf(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    discovery: Optional[RestCollectorConfDiscovery] = None

    collect_method: Annotated[
        Annotated[Optional[CollectMethod], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="collectMethod"),
    ] = CollectMethod.GET

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[RestCollectorConfCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[Pagination] = None

    authentication: Annotated[
        Optional[RestCollectorConfAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = RestCollectorConfAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = False
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = True
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = False
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = False
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectorConfRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestCollectorConfScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.CollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectorConfAuthentication(value)
            except ValueError:
                return value
        return value

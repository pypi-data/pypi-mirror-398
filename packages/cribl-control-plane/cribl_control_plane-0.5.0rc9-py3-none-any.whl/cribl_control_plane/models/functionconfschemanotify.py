"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class FunctionConfSchemaNotifyTriggerType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Type of the trigger condition. custom applies a kusto expression over the results, and results count applies a comparison over results count"""

    # Where
    CUSTOM = "custom"
    # Count of Results
    RESULTS_COUNT = "resultsCount"


class FunctionConfSchemaNotifyCountComparator(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Operation to be applied over the results count"""

    # greater than
    GREATER_THAN_ = ">"
    # less than
    LESS_THAN_ = "<"
    # equals
    EQUAL_EQUAL_EQUAL_ = "==="
    # not equal to
    NOT_EQUAL_EQUAL_ = "!=="
    # greater than or equal to
    GREATER_THAN_EQUAL_ = ">="
    # less than or equal to
    LESS_THAN_EQUAL_ = "<="


class FunctionConfSchemaNotifyTypedDict(TypedDict):
    group: NotRequired[str]
    r"""Group the notification belongs to"""
    notification_id: NotRequired[str]
    r"""Workspace within the deployment to send the search results to."""
    search_id: NotRequired[str]
    r"""Id of the search this function is running on."""
    saved_query_id: NotRequired[str]
    r"""Id of the saved query"""
    trigger: NotRequired[str]
    r"""Js expression that filters events, a greater than 'Trigger Count' events will trigger the notification"""
    trigger_type: NotRequired[FunctionConfSchemaNotifyTriggerType]
    r"""Type of the trigger condition. custom applies a kusto expression over the results, and results count applies a comparison over results count"""
    trigger_comparator: NotRequired[FunctionConfSchemaNotifyCountComparator]
    r"""Operation to be applied over the results count"""
    trigger_count: NotRequired[float]
    r"""How many results that match trigger the condition"""
    results_limit: NotRequired[float]
    r"""Number of results to include in the notification event"""
    search_url: NotRequired[str]
    r"""Url of the search results"""
    message: NotRequired[str]
    r"""Message content template, available fields: searchId, resultSet, savedQueryId, notificationId, searchResultsUrl"""
    auth_token: NotRequired[str]
    r"""Auth token for sending notification messages"""
    messages_endpoint: NotRequired[str]
    r"""System messages api endpoint"""
    tenant_id: NotRequired[str]
    r"""Current tenant id"""


class FunctionConfSchemaNotify(BaseModel):
    group: Optional[str] = "default"
    r"""Group the notification belongs to"""

    notification_id: Annotated[
        Optional[str], pydantic.Field(alias="notificationId")
    ] = "main"
    r"""Workspace within the deployment to send the search results to."""

    search_id: Annotated[Optional[str], pydantic.Field(alias="searchId")] = None
    r"""Id of the search this function is running on."""

    saved_query_id: Annotated[Optional[str], pydantic.Field(alias="savedQueryId")] = (
        None
    )
    r"""Id of the saved query"""

    trigger: Optional[str] = None
    r"""Js expression that filters events, a greater than 'Trigger Count' events will trigger the notification"""

    trigger_type: Annotated[
        Annotated[
            Optional[FunctionConfSchemaNotifyTriggerType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="triggerType"),
    ] = None
    r"""Type of the trigger condition. custom applies a kusto expression over the results, and results count applies a comparison over results count"""

    trigger_comparator: Annotated[
        Annotated[
            Optional[FunctionConfSchemaNotifyCountComparator],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="triggerComparator"),
    ] = None
    r"""Operation to be applied over the results count"""

    trigger_count: Annotated[Optional[float], pydantic.Field(alias="triggerCount")] = 0
    r"""How many results that match trigger the condition"""

    results_limit: Annotated[Optional[float], pydantic.Field(alias="resultsLimit")] = 50
    r"""Number of results to include in the notification event"""

    search_url: Annotated[Optional[str], pydantic.Field(alias="searchUrl")] = None
    r"""Url of the search results"""

    message: Optional[str] = None
    r"""Message content template, available fields: searchId, resultSet, savedQueryId, notificationId, searchResultsUrl"""

    auth_token: Annotated[Optional[str], pydantic.Field(alias="authToken")] = None
    r"""Auth token for sending notification messages"""

    messages_endpoint: Annotated[
        Optional[str], pydantic.Field(alias="messagesEndpoint")
    ] = None
    r"""System messages api endpoint"""

    tenant_id: Annotated[Optional[str], pydantic.Field(alias="tenantId")] = None
    r"""Current tenant id"""

    @field_serializer("trigger_type")
    def serialize_trigger_type(self, value):
        if isinstance(value, str):
            try:
                return models.FunctionConfSchemaNotifyTriggerType(value)
            except ValueError:
                return value
        return value

    @field_serializer("trigger_comparator")
    def serialize_trigger_comparator(self, value):
        if isinstance(value, str):
            try:
                return models.FunctionConfSchemaNotifyCountComparator(value)
            except ValueError:
                return value
        return value

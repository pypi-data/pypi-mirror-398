"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import get_discriminator, validate_open_enum
from enum import Enum
import pydantic
from pydantic import Discriminator, Tag, field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class HealthCheckAuthenticationOauthSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationOauthSecretAuthRequestParamTypedDict(TypedDict):
    name: str
    r"""Parameter name."""
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings."""


class HealthCheckAuthenticationOauthSecretAuthRequestParam(BaseModel):
    name: str
    r"""Parameter name."""

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings."""


class HealthCheckAuthenticationOauthSecretAuthRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header name."""
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings."""


class HealthCheckAuthenticationOauthSecretAuthRequestHeader(BaseModel):
    name: str
    r"""Header name."""

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings."""


class HealthCheckAuthenticationOauthSecretDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthSecretDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckAuthenticationOauthSecretDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationOauthSecretDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationOauthSecretDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckAuthenticationOauthSecretDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthSecretHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationOauthSecretCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationOauthSecretHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckAuthenticationOauthSecretRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckAuthenticationOauthSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckAuthenticationOauthSecretRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationOauthSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckAuthenticationOauthSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationOauthSecretRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthSecretTypedDict(TypedDict):
    text_secret: str
    r"""Select or create a text secret that contains the client secret's value."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: NotRequired[HealthCheckAuthenticationOauthSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: NotRequired[str]
    r"""Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters."""
    auth_request_params: NotRequired[
        List[HealthCheckAuthenticationOauthSecretAuthRequestParamTypedDict]
    ]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[
        List[HealthCheckAuthenticationOauthSecretAuthRequestHeaderTypedDict]
    ]
    r"""Optional authentication request headers."""
    discovery: NotRequired[HealthCheckAuthenticationOauthSecretDiscoveryTypedDict]
    collect_method: NotRequired[HealthCheckAuthenticationOauthSecretHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationOauthSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[
        HealthCheckAuthenticationOauthSecretHiddenDefaultBreakers
    ]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationOauthSecretRetryRulesTypedDict]


class HealthCheckAuthenticationOauthSecret(BaseModel):
    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the client secret's value."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: Annotated[
        Optional[HealthCheckAuthenticationOauthSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationOauthSecretAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[HealthCheckAuthenticationOauthSecretAuthRequestParam]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationOauthSecretAuthRequestHeader]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None
    r"""Optional authentication request headers."""

    discovery: Optional[HealthCheckAuthenticationOauthSecretDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationOauthSecretHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckAuthenticationOauthSecretHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationOauthSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationOauthSecretHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationOauthSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHiddenDefaultBreakers(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationOauthAuthRequestParamTypedDict(TypedDict):
    name: str
    r"""Parameter name."""
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings."""


class HealthCheckAuthenticationOauthAuthRequestParam(BaseModel):
    name: str
    r"""Parameter name."""

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings."""


class HealthCheckAuthenticationOauthAuthRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header name."""
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings."""


class HealthCheckAuthenticationOauthAuthRequestHeader(BaseModel):
    name: str
    r"""Header name."""

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings."""


class HealthCheckAuthenticationOauthDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckAuthenticationOauthDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationOauthDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationOauthDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckAuthenticationOauthDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationOauthCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationOauthHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckAuthenticationOauthRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckAuthenticationOauthRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckAuthenticationOauthRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationOauthRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckAuthenticationOauthRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationOauthRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthTypedDict(TypedDict):
    client_secret_param_value: str
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters"""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: NotRequired[HealthCheckAuthenticationOauthAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: NotRequired[str]
    r"""Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters."""
    auth_request_params: NotRequired[
        List[HealthCheckAuthenticationOauthAuthRequestParamTypedDict]
    ]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[
        List[HealthCheckAuthenticationOauthAuthRequestHeaderTypedDict]
    ]
    r"""Optional authentication request headers."""
    discovery: NotRequired[HealthCheckAuthenticationOauthDiscoveryTypedDict]
    collect_method: NotRequired[HealthCheckAuthenticationOauthHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationOauthCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HealthCheckAuthenticationOauthHiddenDefaultBreakers]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationOauthRetryRulesTypedDict]


class HealthCheckAuthenticationOauth(BaseModel):
    client_secret_param_value: Annotated[
        str, pydantic.Field(alias="clientSecretParamValue")
    ]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: Annotated[
        Optional[HealthCheckAuthenticationOauthAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationOauthAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = ""
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        Optional[str], pydantic.Field(alias="clientSecretParamName")
    ] = "client_secret"
    r"""Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters."""

    auth_request_params: Annotated[
        Optional[List[HealthCheckAuthenticationOauthAuthRequestParam]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationOauthAuthRequestHeader]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None
    r"""Optional authentication request headers."""

    discovery: Optional[HealthCheckAuthenticationOauthDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationOauthHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckAuthenticationOauthHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationOauthCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationOauthHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationOauthRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHiddenDefaultBreakers(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationLoginSecretAuthRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header name."""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginSecretAuthRequestHeader(BaseModel):
    name: str
    r"""Header name."""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginSecretDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginSecretDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckAuthenticationLoginSecretDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationLoginSecretDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationLoginSecretDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckAuthenticationLoginSecretDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginSecretHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginSecretCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginSecretHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckAuthenticationLoginSecretRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckAuthenticationLoginSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckAuthenticationLoginSecretRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationLoginSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckAuthenticationLoginSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationLoginSecretRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginSecretTypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: NotRequired[HealthCheckAuthenticationLoginSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. If left blank, the entire response body will be used to derive the authorization header."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[
        List[HealthCheckAuthenticationLoginSecretAuthRequestHeaderTypedDict]
    ]
    r"""Optional authentication request headers."""
    discovery: NotRequired[HealthCheckAuthenticationLoginSecretDiscoveryTypedDict]
    collect_method: NotRequired[HealthCheckAuthenticationLoginSecretHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationLoginSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[
        HealthCheckAuthenticationLoginSecretHiddenDefaultBreakers
    ]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationLoginSecretRetryRulesTypedDict]


class HealthCheckAuthenticationLoginSecret(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: Annotated[
        Optional[HealthCheckAuthenticationLoginSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationLoginSecretAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. If left blank, the entire response body will be used to derive the authorization header."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationLoginSecretAuthRequestHeader]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None
    r"""Optional authentication request headers."""

    discovery: Optional[HealthCheckAuthenticationLoginSecretDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationLoginSecretHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckAuthenticationLoginSecretHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationLoginSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationLoginSecretHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationLoginSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHiddenDefaultBreakers(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationLoginAuthRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header name."""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginAuthRequestHeader(BaseModel):
    name: str
    r"""Header name."""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckAuthenticationLoginDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationLoginDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationLoginDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckAuthenticationLoginDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckAuthenticationLoginRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckAuthenticationLoginRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckAuthenticationLoginRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationLoginRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckAuthenticationLoginRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationLoginRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginTypedDict(TypedDict):
    username: str
    r"""Login username"""
    password: str
    r"""Login password"""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: NotRequired[HealthCheckAuthenticationLoginAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    login_url: NotRequired[str]
    r"""URL to use for login API call. This call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    auth_request_headers: NotRequired[
        List[HealthCheckAuthenticationLoginAuthRequestHeaderTypedDict]
    ]
    r"""Optional authentication request headers."""
    discovery: NotRequired[HealthCheckAuthenticationLoginDiscoveryTypedDict]
    collect_method: NotRequired[HealthCheckAuthenticationLoginHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationLoginCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HealthCheckAuthenticationLoginHiddenDefaultBreakers]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationLoginRetryRulesTypedDict]


class HealthCheckAuthenticationLogin(BaseModel):
    username: str
    r"""Login username"""

    password: str
    r"""Login password"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: Annotated[
        Optional[HealthCheckAuthenticationLoginAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationLoginAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call. This call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    auth_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationLoginAuthRequestHeader]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None
    r"""Optional authentication request headers."""

    discovery: Optional[HealthCheckAuthenticationLoginDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationLoginHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckAuthenticationLoginHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationLoginCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationLoginHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationLoginRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHiddenDefaultBreakers(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationBasicSecretDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicSecretDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckAuthenticationBasicSecretDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationBasicSecretDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationBasicSecretDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckAuthenticationBasicSecretDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicSecretHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationBasicSecretCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationBasicSecretHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckAuthenticationBasicSecretRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckAuthenticationBasicSecretRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckAuthenticationBasicSecretRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationBasicSecretRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckAuthenticationBasicSecretRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationBasicSecretRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicSecretTypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your credentials"""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: NotRequired[HealthCheckAuthenticationBasicSecretAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[HealthCheckAuthenticationBasicSecretDiscoveryTypedDict]
    collect_method: NotRequired[HealthCheckAuthenticationBasicSecretHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationBasicSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[
        HealthCheckAuthenticationBasicSecretHiddenDefaultBreakers
    ]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationBasicSecretRetryRulesTypedDict]


class HealthCheckAuthenticationBasicSecret(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your credentials"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: Annotated[
        Optional[HealthCheckAuthenticationBasicSecretAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationBasicSecretAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[HealthCheckAuthenticationBasicSecretDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationBasicSecretHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckAuthenticationBasicSecretHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationBasicSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationBasicSecretHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationBasicSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHiddenDefaultBreakers(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationBasicDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckAuthenticationBasicDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationBasicDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationBasicDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckAuthenticationBasicDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationBasicCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationBasicHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckAuthenticationBasicRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckAuthenticationBasicRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckAuthenticationBasicRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationBasicRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckAuthenticationBasicRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationBasicRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicTypedDict(TypedDict):
    username: str
    r"""Basic authentication username"""
    password: str
    r"""Basic authentication password"""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: NotRequired[HealthCheckAuthenticationBasicAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[HealthCheckAuthenticationBasicDiscoveryTypedDict]
    collect_method: NotRequired[HealthCheckAuthenticationBasicHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationBasicCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HealthCheckAuthenticationBasicHiddenDefaultBreakers]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationBasicRetryRulesTypedDict]


class HealthCheckAuthenticationBasic(BaseModel):
    username: str
    r"""Basic authentication username"""

    password: str
    r"""Basic authentication password"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: Annotated[
        Optional[HealthCheckAuthenticationBasicAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationBasicAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[HealthCheckAuthenticationBasicDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationBasicHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckAuthenticationBasicHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationBasicCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationBasicHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationBasicRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHiddenDefaultBreakers(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationNoneAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckAuthenticationNoneDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationNoneDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationNoneDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckAuthenticationNoneDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationNoneHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationNoneCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationNoneHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckAuthenticationNoneRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckAuthenticationNoneRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckAuthenticationNoneRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationNoneRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckAuthenticationNoneRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationNoneRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationNoneTypedDict(TypedDict):
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: NotRequired[HealthCheckAuthenticationNoneAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[HealthCheckAuthenticationNoneDiscoveryTypedDict]
    collect_method: NotRequired[HealthCheckAuthenticationNoneHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationNoneCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HealthCheckAuthenticationNoneHiddenDefaultBreakers]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationNoneRetryRulesTypedDict]


class HealthCheckAuthenticationNone(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: Annotated[
        Optional[HealthCheckAuthenticationNoneAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckAuthenticationNoneAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[HealthCheckAuthenticationNoneDiscovery] = None

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationNoneHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckAuthenticationNoneHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationNoneCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckAuthenticationNoneHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationNoneRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHiddenDefaultBreakers(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostWithBodyHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckCollectMethodPostWithBodyDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodPostWithBodyDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodPostWithBodyDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckCollectMethodPostWithBodyDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostWithBodyCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostWithBodyCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostWithBodyAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodPostWithBodyHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckCollectMethodPostWithBodyRetryType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckCollectMethodPostWithBodyRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckCollectMethodPostWithBodyRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodPostWithBodyRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckCollectMethodPostWithBodyRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckCollectMethodPostWithBodyRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostWithBodyTypedDict(TypedDict):
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: NotRequired[HealthCheckCollectMethodPostWithBodyHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_body: NotRequired[Any]
    discovery: NotRequired[HealthCheckCollectMethodPostWithBodyDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodPostWithBodyCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    authentication: NotRequired[HealthCheckCollectMethodPostWithBodyAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[
        HealthCheckCollectMethodPostWithBodyHiddenDefaultBreakers
    ]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodPostWithBodyRetryRulesTypedDict]


class HealthCheckCollectMethodPostWithBody(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodPostWithBodyHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckCollectMethodPostWithBodyHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    discovery: Optional[HealthCheckCollectMethodPostWithBodyDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodPostWithBodyCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    authentication: Annotated[
        Optional[HealthCheckCollectMethodPostWithBodyAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckCollectMethodPostWithBodyAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodPostWithBodyHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodPostWithBodyRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHiddenDefaultBreakers(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckCollectMethodPostDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodPostDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodPostDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckCollectMethodPostDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodPostHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckCollectMethodPostRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckCollectMethodPostRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckCollectMethodPostRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodPostRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckCollectMethodPostRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckCollectMethodPostRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostTypedDict(TypedDict):
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: NotRequired[HealthCheckCollectMethodPostHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[HealthCheckCollectMethodPostDiscoveryTypedDict]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodPostCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    authentication: NotRequired[HealthCheckCollectMethodPostAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HealthCheckCollectMethodPostHiddenDefaultBreakers]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodPostRetryRulesTypedDict]


class HealthCheckCollectMethodPost(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodPostHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckCollectMethodPostHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[HealthCheckCollectMethodPostDiscovery] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodPostCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    authentication: Annotated[
        Optional[HealthCheckCollectMethodPostAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckCollectMethodPostAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodPostHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodPostRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHiddenDefaultBreakers(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodGetHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetDiscoverType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetDiscoveryTypedDict(TypedDict):
    discover_type: NotRequired[HealthCheckCollectMethodGetDiscoverType]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodGetDiscovery(BaseModel):
    discover_type: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodGetDiscoverType],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="discoverType"),
    ] = HealthCheckCollectMethodGetDiscoverType.NONE
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetDiscoverType(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodGetCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodGetCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodGetAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodGetHiddenDefaultBreakers(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    CRIBL = "Cribl"


class HealthCheckCollectMethodGetRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class HealthCheckCollectMethodGetRetryRulesTypedDict(TypedDict):
    type: NotRequired[HealthCheckCollectMethodGetRetryType]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodGetRetryRules(BaseModel):
    type: Annotated[
        Optional[HealthCheckCollectMethodGetRetryType],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckCollectMethodGetRetryType.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetRetryType(value)
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodGetTypedDict(TypedDict):
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: NotRequired[HealthCheckCollectMethodGetHealthCheckMethod]
    r"""Health check HTTP method."""
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[HealthCheckCollectMethodGetDiscoveryTypedDict]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodGetCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    authentication: NotRequired[HealthCheckCollectMethodGetAuthentication]
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HealthCheckCollectMethodGetHiddenDefaultBreakers]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodGetRetryRulesTypedDict]


class HealthCheckCollectMethodGet(BaseModel):
    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodGetHealthCheckMethod],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="collectMethod"),
    ] = HealthCheckCollectMethodGetHealthCheckMethod.GET
    r"""Health check HTTP method."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[HealthCheckCollectMethodGetDiscovery] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodGetCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = False
    r"""Enable to make auth health check call."""

    authentication: Annotated[
        Optional[HealthCheckCollectMethodGetAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = HealthCheckCollectMethodGetAuthentication.NONE
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    timeout: Optional[float] = 30
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Annotated[
            Optional[HealthCheckCollectMethodGetHiddenDefaultBreakers],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodGetRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHiddenDefaultBreakers(value)
            except ValueError:
                return value
        return value


HealthCheckCollectorConfTypedDict = TypeAliasType(
    "HealthCheckCollectorConfTypedDict",
    Union[
        HealthCheckCollectMethodGetTypedDict,
        HealthCheckCollectMethodPostTypedDict,
        HealthCheckCollectMethodPostWithBodyTypedDict,
        HealthCheckAuthenticationNoneTypedDict,
        HealthCheckAuthenticationBasicSecretTypedDict,
        HealthCheckAuthenticationBasicTypedDict,
        HealthCheckAuthenticationLoginSecretTypedDict,
        HealthCheckAuthenticationLoginTypedDict,
        HealthCheckAuthenticationOauthTypedDict,
        HealthCheckAuthenticationOauthSecretTypedDict,
    ],
)


HealthCheckCollectorConf = Annotated[
    Union[
        Annotated[HealthCheckAuthenticationNone, Tag("none")],
        Annotated[HealthCheckAuthenticationBasic, Tag("basic")],
        Annotated[HealthCheckAuthenticationBasicSecret, Tag("basicSecret")],
        Annotated[HealthCheckAuthenticationLogin, Tag("login")],
        Annotated[HealthCheckAuthenticationLoginSecret, Tag("loginSecret")],
        Annotated[HealthCheckAuthenticationOauth, Tag("oauth")],
        Annotated[HealthCheckAuthenticationOauthSecret, Tag("oauthSecret")],
    ],
    Discriminator(lambda m: get_discriminator(m, "authentication", "authentication")),
]

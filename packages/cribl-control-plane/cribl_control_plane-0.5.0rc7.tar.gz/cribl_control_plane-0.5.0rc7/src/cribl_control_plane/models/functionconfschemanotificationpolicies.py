"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class Operator(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Comparison operator"""

    EQUAL = "="
    NOT_EQUAL = "!="
    REGEX_MATCH = "=~"
    REGEX_NOT_MATCH = "!~"


ValueTypedDict = TypeAliasType("ValueTypedDict", Union[str, float, bool])
r"""Value to compare against (string, number, boolean)"""


Value = TypeAliasType("Value", Union[str, float, bool])
r"""Value to compare against (string, number, boolean)"""


class ConditionTypedDict(TypedDict):
    key: str
    r"""Event field name to match against"""
    operator: Operator
    r"""Comparison operator"""
    value: ValueTypedDict
    r"""Value to compare against (string, number, boolean)"""


class Condition(BaseModel):
    key: str
    r"""Event field name to match against"""

    operator: Annotated[Operator, PlainValidator(validate_open_enum(False))]
    r"""Comparison operator"""

    value: Value
    r"""Value to compare against (string, number, boolean)"""

    @field_serializer("operator")
    def serialize_operator(self, value):
        if isinstance(value, str):
            try:
                return models.Operator(value)
            except ValueError:
                return value
        return value


class TemplateTargetPairTypedDict(TypedDict):
    template_id: str
    r"""ID of the notification template to use"""
    target_id: str
    r"""ID of the notification target (output)"""


class TemplateTargetPair(BaseModel):
    template_id: Annotated[str, pydantic.Field(alias="templateId")]
    r"""ID of the notification template to use"""

    target_id: Annotated[str, pydantic.Field(alias="targetId")]
    r"""ID of the notification target (output)"""


class PolicyTypedDict(TypedDict):
    id: str
    r"""Unique identifier for this policy"""
    template_target_pairs: List[TemplateTargetPairTypedDict]
    r"""List of targets to route to and the templates to use"""
    order: float
    r"""Evaluation order of this policy (lower numbers evaluated first)"""
    disabled: NotRequired[bool]
    r"""If true, this policy will be skipped during evaluation"""
    wait_to_group: NotRequired[float]
    r"""Time to wait (in minutes) to group similar alerts before sending"""
    group_by_labels: NotRequired[List[str]]
    r"""Event fields to use for grouping"""
    conditions: NotRequired[List[List[ConditionTypedDict]]]
    r"""List of conditions. If ANY condition matches (OR), the policy applies. Each condition is a list of tags that must ALL match (AND)."""
    final: NotRequired[bool]
    r"""If true, stop evaluating further policies after this one matches"""


class Policy(BaseModel):
    id: str
    r"""Unique identifier for this policy"""

    template_target_pairs: Annotated[
        List[TemplateTargetPair], pydantic.Field(alias="templateTargetPairs")
    ]
    r"""List of targets to route to and the templates to use"""

    order: float
    r"""Evaluation order of this policy (lower numbers evaluated first)"""

    disabled: Optional[bool] = False
    r"""If true, this policy will be skipped during evaluation"""

    wait_to_group: Annotated[Optional[float], pydantic.Field(alias="waitToGroup")] = (
        None
    )
    r"""Time to wait (in minutes) to group similar alerts before sending"""

    group_by_labels: Annotated[
        Optional[List[str]], pydantic.Field(alias="groupByLabels")
    ] = None
    r"""Event fields to use for grouping"""

    conditions: Optional[List[List[Condition]]] = None
    r"""List of conditions. If ANY condition matches (OR), the policy applies. Each condition is a list of tags that must ALL match (AND)."""

    final: Optional[bool] = False
    r"""If true, stop evaluating further policies after this one matches"""


class FunctionConfSchemaNotificationPoliciesTypedDict(TypedDict):
    policies: NotRequired[List[PolicyTypedDict]]
    r"""List of notification routing policies evaluated in order"""


class FunctionConfSchemaNotificationPolicies(BaseModel):
    policies: Optional[List[Policy]] = None
    r"""List of notification routing policies evaluated in order"""

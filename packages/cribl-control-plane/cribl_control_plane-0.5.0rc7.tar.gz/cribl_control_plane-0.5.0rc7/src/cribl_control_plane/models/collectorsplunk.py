"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .outputmodeoptions import OutputModeOptions
from .retrytypeoptionsretryrules import RetryTypeOptionsRetryRules
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class CollectorSplunkAuthentication4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType5(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectRequestParam4TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectRequestParam4(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader4TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader4(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryRules4TypedDict(TypedDict):
    type: NotRequired[RetryTypeOptionsRetryRules]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules4(BaseModel):
    type: Annotated[
        Optional[RetryTypeOptionsRetryRules], PlainValidator(validate_open_enum(False))
    ] = RetryTypeOptionsRetryRules.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsRetryRules(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk4TypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    type: CollectorSplunkType5
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication4]
    r"""Authentication method for Discover and Collect REST calls"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[OutputModeOptions]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[List[CollectRequestParam4TypedDict]]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader4TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules4TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""


class CollectorSplunkSplunk4(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    type: CollectorSplunkType5
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication4],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication4.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[OutputModeOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="outputMode"),
    ] = OutputModeOptions.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectRequestParam4]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader4]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules4], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication4(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptions(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType4(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectRequestParam3TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectRequestParam3(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader3TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader3(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryRules3TypedDict(TypedDict):
    type: NotRequired[RetryTypeOptionsRetryRules]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules3(BaseModel):
    type: Annotated[
        Optional[RetryTypeOptionsRetryRules], PlainValidator(validate_open_enum(False))
    ] = RetryTypeOptionsRetryRules.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsRetryRules(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk3TypedDict(TypedDict):
    username: str
    password: str
    type: CollectorSplunkType4
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication3]
    r"""Authentication method for Discover and Collect REST calls"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[OutputModeOptions]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[List[CollectRequestParam3TypedDict]]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader3TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules3TypedDict]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""


class CollectorSplunkSplunk3(BaseModel):
    username: str

    password: str

    type: CollectorSplunkType4
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication3],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication3.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[OutputModeOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="outputMode"),
    ] = OutputModeOptions.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectRequestParam3]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader3]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules3], pydantic.Field(alias="retryRules")
    ] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication3(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptions(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType3(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectRequestParam2TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectRequestParam2(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader2TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader2(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryRules2TypedDict(TypedDict):
    type: NotRequired[RetryTypeOptionsRetryRules]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules2(BaseModel):
    type: Annotated[
        Optional[RetryTypeOptionsRetryRules], PlainValidator(validate_open_enum(False))
    ] = RetryTypeOptionsRetryRules.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsRetryRules(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk2TypedDict(TypedDict):
    token_secret: str
    r"""Select or create a stored secret that references your Bearer token"""
    type: CollectorSplunkType3
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication2]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[OutputModeOptions]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[List[CollectRequestParam2TypedDict]]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader2TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules2TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token: NotRequired[str]
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkSplunk2(BaseModel):
    token_secret: Annotated[str, pydantic.Field(alias="tokenSecret")]
    r"""Select or create a stored secret that references your Bearer token"""

    type: CollectorSplunkType3
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication2],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication2.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[OutputModeOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="outputMode"),
    ] = OutputModeOptions.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectRequestParam2]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader2]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules2], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token: Optional[str] = None

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication2(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptions(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType2(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectRequestParam1TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectRequestParam1(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader1TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader1(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryRules1TypedDict(TypedDict):
    type: NotRequired[RetryTypeOptionsRetryRules]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules1(BaseModel):
    type: Annotated[
        Optional[RetryTypeOptionsRetryRules], PlainValidator(validate_open_enum(False))
    ] = RetryTypeOptionsRetryRules.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsRetryRules(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk1TypedDict(TypedDict):
    token: str
    type: CollectorSplunkType2
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication1]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[OutputModeOptions]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[List[CollectRequestParam1TypedDict]]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader1TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules1TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkSplunk1(BaseModel):
    token: str

    type: CollectorSplunkType2
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication1],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication1.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[OutputModeOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="outputMode"),
    ] = OutputModeOptions.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectRequestParam1]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader1]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules1], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication1(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptions(value)
            except ValueError:
                return value
        return value


class AuthenticationSplunk(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType1(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectRequestParamSplunkTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectRequestParamSplunk(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectRequestHeaderSplunkTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectRequestHeaderSplunk(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class RetryRulesSplunkTypedDict(TypedDict):
    type: NotRequired[RetryTypeOptionsRetryRules]
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RetryRulesSplunk(BaseModel):
    type: Annotated[
        Optional[RetryTypeOptionsRetryRules], PlainValidator(validate_open_enum(False))
    ] = RetryTypeOptionsRetryRules.BACKOFF
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsRetryRules(value)
            except ValueError:
                return value
        return value


class CollectorSplunkCollectorHealthCheckPart2TypeTypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    type: CollectorSplunkType1
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[AuthenticationSplunk]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[OutputModeOptions]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[List[CollectRequestParamSplunkTypedDict]]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[List[CollectRequestHeaderSplunkTypedDict]]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[RetryRulesSplunkTypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkCollectorHealthCheckPart2Type(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    type: CollectorSplunkType1
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[AuthenticationSplunk], PlainValidator(validate_open_enum(False))
    ] = AuthenticationSplunk.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[OutputModeOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="outputMode"),
    ] = OutputModeOptions.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectRequestParamSplunk]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectRequestHeaderSplunk]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[RetryRulesSplunk], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationSplunk(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptions(value)
            except ValueError:
                return value
        return value


class CollectorSplunkCollectorHealthCheckPart1TypeTypedDict(TypedDict):
    username: str
    password: str
    type: CollectorSplunkType1
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[AuthenticationSplunk]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[OutputModeOptions]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[List[CollectRequestParamSplunkTypedDict]]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[List[CollectRequestHeaderSplunkTypedDict]]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[RetryRulesSplunkTypedDict]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkCollectorHealthCheckPart1Type(BaseModel):
    username: str

    password: str

    type: CollectorSplunkType1
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[AuthenticationSplunk], PlainValidator(validate_open_enum(False))
    ] = AuthenticationSplunk.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[OutputModeOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="outputMode"),
    ] = OutputModeOptions.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectRequestParamSplunk]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectRequestHeaderSplunk]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[RetryRulesSplunk], pydantic.Field(alias="retryRules")
    ] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationSplunk(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptions(value)
            except ValueError:
                return value
        return value


class CollectorSplunkCollectorHealthCheckPart0TypeTypedDict(TypedDict):
    type: CollectorSplunkType1
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[AuthenticationSplunk]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[OutputModeOptions]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[List[CollectRequestParamSplunkTypedDict]]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[List[CollectRequestHeaderSplunkTypedDict]]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[RetryRulesSplunkTypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkCollectorHealthCheckPart0Type(BaseModel):
    type: CollectorSplunkType1
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[AuthenticationSplunk], PlainValidator(validate_open_enum(False))
    ] = AuthenticationSplunk.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[OutputModeOptions], PlainValidator(validate_open_enum(False))
        ],
        pydantic.Field(alias="outputMode"),
    ] = OutputModeOptions.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectRequestParamSplunk]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectRequestHeaderSplunk]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[RetryRulesSplunk], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationSplunk(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.OutputModeOptions(value)
            except ValueError:
                return value
        return value


CollectorSplunkTypedDict = TypeAliasType(
    "CollectorSplunkTypedDict",
    Union[
        CollectorSplunkCollectorHealthCheckPart0TypeTypedDict,
        CollectorSplunkCollectorHealthCheckPart1TypeTypedDict,
        CollectorSplunkCollectorHealthCheckPart2TypeTypedDict,
        CollectorSplunkSplunk1TypedDict,
        CollectorSplunkSplunk2TypedDict,
        CollectorSplunkSplunk3TypedDict,
        CollectorSplunkSplunk4TypedDict,
    ],
)


CollectorSplunk = TypeAliasType(
    "CollectorSplunk",
    Union[
        CollectorSplunkCollectorHealthCheckPart0Type,
        CollectorSplunkCollectorHealthCheckPart1Type,
        CollectorSplunkCollectorHealthCheckPart2Type,
        CollectorSplunkSplunk1,
        CollectorSplunkSplunk2,
        CollectorSplunkSplunk3,
        CollectorSplunkSplunk4,
    ],
)

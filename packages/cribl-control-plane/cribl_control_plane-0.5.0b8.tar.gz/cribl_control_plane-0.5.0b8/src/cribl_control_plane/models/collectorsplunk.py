"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class CollectorSplunkAuthentication7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType7(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectorSplunkOutputMode7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class CollectorSplunkCollectRequestParam7TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestParam7(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader7TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader7(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryType7(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorSplunkRetryRules7TypedDict(TypedDict):
    type: NotRequired[CollectorSplunkRetryType7]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules7(BaseModel):
    type: Annotated[
        Optional[CollectorSplunkRetryType7], PlainValidator(validate_open_enum(False))
    ] = CollectorSplunkRetryType7.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkRetryType7(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk7TypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    type: CollectorSplunkType7
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication7]
    r"""Authentication method for Discover and Collect REST calls"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[CollectorSplunkOutputMode7]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[CollectorSplunkCollectRequestParam7TypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader7TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules7TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""


class CollectorSplunkSplunk7(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    type: CollectorSplunkType7
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication7],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication7.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[CollectorSplunkOutputMode7],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = CollectorSplunkOutputMode7.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectorSplunkCollectRequestParam7]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader7]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules7], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication7(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkOutputMode7(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType6(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectorSplunkOutputMode6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class CollectorSplunkCollectRequestParam6TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestParam6(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader6TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader6(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryType6(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorSplunkRetryRules6TypedDict(TypedDict):
    type: NotRequired[CollectorSplunkRetryType6]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules6(BaseModel):
    type: Annotated[
        Optional[CollectorSplunkRetryType6], PlainValidator(validate_open_enum(False))
    ] = CollectorSplunkRetryType6.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkRetryType6(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk6TypedDict(TypedDict):
    username: str
    password: str
    type: CollectorSplunkType6
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication6]
    r"""Authentication method for Discover and Collect REST calls"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[CollectorSplunkOutputMode6]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[CollectorSplunkCollectRequestParam6TypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader6TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules6TypedDict]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""


class CollectorSplunkSplunk6(BaseModel):
    username: str

    password: str

    type: CollectorSplunkType6
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication6],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication6.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[CollectorSplunkOutputMode6],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = CollectorSplunkOutputMode6.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectorSplunkCollectRequestParam6]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader6]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules6], pydantic.Field(alias="retryRules")
    ] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication6(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkOutputMode6(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType5(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectorSplunkOutputMode5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class CollectorSplunkCollectRequestParam5TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestParam5(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader5TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader5(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryType5(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorSplunkRetryRules5TypedDict(TypedDict):
    type: NotRequired[CollectorSplunkRetryType5]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules5(BaseModel):
    type: Annotated[
        Optional[CollectorSplunkRetryType5], PlainValidator(validate_open_enum(False))
    ] = CollectorSplunkRetryType5.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkRetryType5(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk5TypedDict(TypedDict):
    token_secret: str
    r"""Select or create a stored secret that references your Bearer token"""
    type: CollectorSplunkType5
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication5]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[CollectorSplunkOutputMode5]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[CollectorSplunkCollectRequestParam5TypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader5TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules5TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token: NotRequired[str]
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkSplunk5(BaseModel):
    token_secret: Annotated[str, pydantic.Field(alias="tokenSecret")]
    r"""Select or create a stored secret that references your Bearer token"""

    type: CollectorSplunkType5
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication5],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication5.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[CollectorSplunkOutputMode5],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = CollectorSplunkOutputMode5.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectorSplunkCollectRequestParam5]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader5]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules5], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token: Optional[str] = None

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication5(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkOutputMode5(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType4(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectorSplunkOutputMode4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class CollectorSplunkCollectRequestParam4TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestParam4(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader4TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader4(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryType4(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorSplunkRetryRules4TypedDict(TypedDict):
    type: NotRequired[CollectorSplunkRetryType4]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules4(BaseModel):
    type: Annotated[
        Optional[CollectorSplunkRetryType4], PlainValidator(validate_open_enum(False))
    ] = CollectorSplunkRetryType4.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkRetryType4(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk4TypedDict(TypedDict):
    token: str
    type: CollectorSplunkType4
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication4]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[CollectorSplunkOutputMode4]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[CollectorSplunkCollectRequestParam4TypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader4TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules4TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkSplunk4(BaseModel):
    token: str

    type: CollectorSplunkType4
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication4],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication4.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[CollectorSplunkOutputMode4],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = CollectorSplunkOutputMode4.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectorSplunkCollectRequestParam4]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader4]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules4], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication4(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkOutputMode4(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType3(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectorSplunkOutputMode3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class CollectorSplunkCollectRequestParam3TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestParam3(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader3TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader3(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryType3(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorSplunkRetryRules3TypedDict(TypedDict):
    type: NotRequired[CollectorSplunkRetryType3]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules3(BaseModel):
    type: Annotated[
        Optional[CollectorSplunkRetryType3], PlainValidator(validate_open_enum(False))
    ] = CollectorSplunkRetryType3.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkRetryType3(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk3TypedDict(TypedDict):
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    type: CollectorSplunkType3
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication3]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[CollectorSplunkOutputMode3]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[CollectorSplunkCollectRequestParam3TypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader3TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules3TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkSplunk3(BaseModel):
    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    type: CollectorSplunkType3
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication3],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication3.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[CollectorSplunkOutputMode3],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = CollectorSplunkOutputMode3.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectorSplunkCollectRequestParam3]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader3]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules3], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication3(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkOutputMode3(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType2(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectorSplunkOutputMode2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class CollectorSplunkCollectRequestParam2TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestParam2(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader2TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader2(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryType2(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorSplunkRetryRules2TypedDict(TypedDict):
    type: NotRequired[CollectorSplunkRetryType2]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules2(BaseModel):
    type: Annotated[
        Optional[CollectorSplunkRetryType2], PlainValidator(validate_open_enum(False))
    ] = CollectorSplunkRetryType2.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkRetryType2(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk2TypedDict(TypedDict):
    username: str
    password: str
    type: CollectorSplunkType2
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication2]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[CollectorSplunkOutputMode2]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[CollectorSplunkCollectRequestParam2TypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader2TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules2TypedDict]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkSplunk2(BaseModel):
    username: str

    password: str

    type: CollectorSplunkType2
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication2],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication2.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[CollectorSplunkOutputMode2],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = CollectorSplunkOutputMode2.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectorSplunkCollectRequestParam2]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader2]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules2], pydantic.Field(alias="retryRules")
    ] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication2(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkOutputMode2(value)
            except ValueError:
                return value
        return value


class CollectorSplunkAuthentication1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkType1(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectorSplunkOutputMode1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class CollectorSplunkCollectRequestParam1TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestParam1(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader1TypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader1(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkRetryType1(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorSplunkRetryRules1TypedDict(TypedDict):
    type: NotRequired[CollectorSplunkRetryType1]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules1(BaseModel):
    type: Annotated[
        Optional[CollectorSplunkRetryType1], PlainValidator(validate_open_enum(False))
    ] = CollectorSplunkRetryType1.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkRetryType1(value)
            except ValueError:
                return value
        return value


class CollectorSplunkSplunk1TypedDict(TypedDict):
    type: CollectorSplunkType1
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    authentication: NotRequired[CollectorSplunkAuthentication1]
    r"""Authentication method for Discover and Collect REST calls"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[CollectorSplunkOutputMode1]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[
        List[CollectorSplunkCollectRequestParam1TypedDict]
    ]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeader1TypedDict]
    ]
    r"""Optional collect request headers"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRules1TypedDict]
    username: NotRequired[str]
    password: NotRequired[str]
    credentials_secret: NotRequired[str]
    r"""Select or create a stored secret that references your login credentials"""
    token: NotRequired[str]
    token_secret: NotRequired[str]
    r"""Select or create a stored secret that references your Bearer token"""
    login_url: NotRequired[str]
    r"""URL to use for login API call, this call is expected to be a POST."""
    login_body: NotRequired[str]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are allowed."""
    auth_header_expr: NotRequired[str]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""


class CollectorSplunkSplunk1(BaseModel):
    type: CollectorSplunkType1
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication1],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication1.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[CollectorSplunkOutputMode1],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = CollectorSplunkOutputMode1.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectorSplunkCollectRequestParam1]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader1]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules1], pydantic.Field(alias="retryRules")
    ] = None

    username: Optional[str] = None

    password: Optional[str] = None

    credentials_secret: Annotated[
        Optional[str], pydantic.Field(alias="credentialsSecret")
    ] = None
    r"""Select or create a stored secret that references your login credentials"""

    token: Optional[str] = None

    token_secret: Annotated[Optional[str], pydantic.Field(alias="tokenSecret")] = None
    r"""Select or create a stored secret that references your Bearer token"""

    login_url: Annotated[Optional[str], pydantic.Field(alias="loginUrl")] = (
        "`https://localhost:9000/api/v1/auth/login`"
    )
    r"""URL to use for login API call, this call is expected to be a POST."""

    login_body: Annotated[Optional[str], pydantic.Field(alias="loginBody")] = (
        '`{ "username": "${username}", "password": "${password}" }`'
    )
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = "token"
    r"""Path to token attribute in login response body. Nested attributes are allowed."""

    auth_header_expr: Annotated[
        Optional[str], pydantic.Field(alias="authHeaderExpr")
    ] = "`Bearer ${token}`"
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication1(value)
            except ValueError:
                return value
        return value

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkOutputMode1(value)
            except ValueError:
                return value
        return value


CollectorSplunkTypedDict = TypeAliasType(
    "CollectorSplunkTypedDict",
    Union[
        CollectorSplunkSplunk1TypedDict,
        CollectorSplunkSplunk2TypedDict,
        CollectorSplunkSplunk3TypedDict,
        CollectorSplunkSplunk4TypedDict,
        CollectorSplunkSplunk5TypedDict,
        CollectorSplunkSplunk6TypedDict,
        CollectorSplunkSplunk7TypedDict,
    ],
)


CollectorSplunk = TypeAliasType(
    "CollectorSplunk",
    Union[
        CollectorSplunkSplunk1,
        CollectorSplunkSplunk2,
        CollectorSplunkSplunk3,
        CollectorSplunkSplunk4,
        CollectorSplunkSplunk5,
        CollectorSplunkSplunk6,
        CollectorSplunkSplunk7,
    ],
)

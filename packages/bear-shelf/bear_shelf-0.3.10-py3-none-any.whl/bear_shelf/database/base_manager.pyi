from collections.abc import Generator
from contextlib import contextmanager
from functools import partial
from threading import RLock
from typing import Any, ClassVar, Literal, overload

from pydantic import SecretStr
from sqlalchemy import Engine
from sqlalchemy.orm import DeclarativeMeta, Query, scoped_session, sessionmaker
from sqlalchemy.orm.session import Session

from bear_shelf.datastore.wal.config import WALFlushMode

from ._extra import DynamicRecords, TableHandler, TableHandlers
from .config import DatabaseConfig, Schemas

class DatabaseManager[T_Table: DeclarativeMeta]:
    _scheme: ClassVar[Schemas] = "sqlite"
    long_lived: bool
    config_factory: partial[DatabaseConfig]
    engine_factory: partial[Engine]

    @classmethod
    def set_base(cls, base: DeclarativeMeta | None) -> None: ...
    @classmethod
    def get_base(cls) -> DeclarativeMeta: ...
    @classmethod
    def clear_base(cls) -> None: ...
    @classmethod
    def set_scheme(cls, scheme: Schemas) -> None: ...
    def __init__(
        self,
        *,
        database_config: DatabaseConfig | None = None,
        host: str | None = None,
        port: int | None = None,
        user: str | None = None,
        password: str | SecretStr | None = None,
        name: str | None = None,
        path: str | None = None,
        schema: Schemas | None = None,
        auto: bool = False,
        long_lived: bool = False,
        enable_wal: bool = False,
        flush_mode: WALFlushMode = ...,
        engine_create: bool = False,
        tables_create: bool = False,
        echo: bool = False,
        records: dict[str, type[T_Table]] | None = None,
    ) -> None: ...
    def register_record(self, tbl_obj: Any) -> DynamicRecords[T_Table]: ...
    def register_records(self, *tbl_objs: type[T_Table]) -> Generator[DynamicRecords[T_Table]]: ...
    def is_registered(self, table: type[T_Table] | str) -> bool: ...
    def get_records(self, table: type[T_Table] | str) -> DynamicRecords[T_Table]: ...
    def set_table(self, table: type[T_Table] | str) -> None: ...
    def get_current_table(self) -> type[T_Table]: ...
    def get_all(self, table: type[T_Table] | None = None) -> list[T_Table]: ...
    def get(self, table: type[T_Table] | None = None, ident: Any | None = None) -> T_Table | None: ...
    def count(self, table: type[T_Table] | None = None, **kwargs: Any) -> int: ...
    def query(self, table: type[T_Table] | None = None) -> Query[T_Table]: ...
    def filter_by(self, table: type[T_Table] | None = None, **kwargs: Any) -> Query[T_Table]: ...
    @overload
    def get_session(self, scoped: Literal[True]) -> scoped_session: ...
    @overload
    def get_session(self, scoped: Literal[False] = False) -> Session: ...
    def get_session(self, scoped: bool = False) -> scoped_session | Session: ...
    @contextmanager
    def open_session(self, remove: bool = False) -> Generator[Session, Any]: ...
    def close_session(self) -> None: ...
    def create_tables(self) -> TableHandlers: ...
    def table(self, name: str) -> TableHandler: ...
    def tables(self) -> TableHandlers: ...
    def table_names(self) -> list[str]: ...
    def get_table_objs(self) -> dict[str, Any]: ...
    def get_orm_tables(self) -> dict[str, type[T_Table]]: ...
    def close(self) -> None: ...
    @property
    def config(self) -> DatabaseConfig: ...
    @property
    def engine(self) -> Engine: ...
    @property
    def session_factory(self) -> sessionmaker[Session]: ...
    @property
    def session(self) -> scoped_session[Session]: ...
    @property
    def instance_session(self) -> scoped_session | None: ...
    @instance_session.setter
    def instance_session(self, value: scoped_session | None) -> None: ...
    @property
    def lock(self) -> RLock: ...
    def __enter__(self) -> DatabaseManager[T_Table]: ...
    def __exit__(self, exc_type: object, exc_value: object, traceback: object) -> None: ...

class SqliteDB[T: DeclarativeMeta](DatabaseManager[T]):
    _scheme: ClassVar[Schemas] = "sqlite"

class PostgresDB[T: DeclarativeMeta](DatabaseManager[T]):
    _scheme: ClassVar[Schemas] = "postgresql"

class MySQLDB[T: DeclarativeMeta](DatabaseManager[T]):
    _scheme: ClassVar[Schemas] = "mysql"

class BearShelfDB[T: DeclarativeMeta](DatabaseManager[T]):
    _scheme: ClassVar[Schemas] = "bearshelf"

__all__ = ["BearShelfDB", "DatabaseManager", "MySQLDB", "PostgresDB", "SqliteDB"]

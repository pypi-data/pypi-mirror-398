"""Command-line interface for DocRAG Kit."""

import click
from pathlib import Path
from docrag import __version__


def create_mcp_server_wrapper(docrag_dir: Path) -> bool:
    """
    Create mcp_server.py wrapper in .docrag directory.
    
    Args:
        docrag_dir: Path to .docrag directory
        
    Returns:
        True if successful, False otherwise
    """
    mcp_server_content = '''#!/usr/bin/env python3
"""
MCP Server wrapper for this project.

This file is auto-generated by DocRAG Kit.

IMPORTANT: This wrapper should be run via the installed docrag package:
    python -m docrag.mcp_server
    
NOT directly as a script (relative imports won't work):
    python .docrag/mcp_server.py  # ERROR: Don't do this

For MCP configuration, use:
    docrag mcp-config
"""

import sys
from pathlib import Path

print("WARNING:  WARNING: This wrapper is deprecated!", file=sys.stderr)
print("   Use 'python -m docrag.mcp_server' instead", file=sys.stderr)
print("   Or run 'docrag mcp-config' to update your MCP configuration", file=sys.stderr)
sys.exit(1)
'''
    
    try:
        mcp_server_path = docrag_dir / "mcp_server.py"
        mcp_server_path.write_text(mcp_server_content)
        mcp_server_path.chmod(0o755)  # Make executable
        return True
    except Exception:
        return False


@click.group()
@click.version_option(version=__version__, prog_name="docrag")
def cli():
    """DocRAG Kit - Universal RAG system for project documentation.
    
    Quick start:
    1. Run 'docrag init' to initialize RAG system in your project
    2. Run 'docrag index' to index your documentation
    3. Run 'docrag mcp-config' to get MCP server configuration
    """
    pass


@cli.command()
@click.option("--non-interactive", is_flag=True, help="Use default values without prompts")
@click.option("--template", type=click.Choice(['general', 'symfony', 'ios']), default='general', help="Project template to use")
def init(non_interactive, template):
    """Initialize DocRAG in current project."""
    from pathlib import Path
    from .config_manager import ConfigManager
    
    # Check if .docrag/ already exists
    docrag_dir = Path.cwd() / ".docrag"
    if docrag_dir.exists():
        click.echo("ERROR: Error: .docrag/ directory already exists")
        click.echo("   DocRAG is already initialized in this project")
        click.echo("   Use 'docrag config --edit' to modify configuration")
        return
    
    try:
        # Run setup wizard (interactive or non-interactive)
        config_manager = ConfigManager()
        if non_interactive:
            # Use default configuration based on template
            from .config_manager import DocRAGConfig
            config = DocRAGConfig.from_template(template)
            click.echo(f"SUCCESS: Using {template} template with default values")
        else:
            config = config_manager.interactive_setup()
        
        # Create .docrag/ directory
        docrag_dir.mkdir(parents=True, exist_ok=True)
        
        # Save configuration to config.yaml
        config_manager.save_config(config)
        click.echo(f"\nSUCCESS: Configuration saved to {config_manager.config_path}")
        
        # Create .docrag/.gitignore
        from .security import (
            create_docrag_gitignore, 
            display_gitignore_warning,
            create_env_example,
            display_security_reminder
        )
        
        if create_docrag_gitignore(docrag_dir):
            click.echo(f"SUCCESS: Created {docrag_dir / '.gitignore'}")
        else:
            click.echo(f"WARNING:  Failed to create {docrag_dir / '.gitignore'}")
        
        # Create .env.example template
        if create_env_example(Path.cwd()):
            click.echo(f"SUCCESS: Created .env.example template")
        else:
            click.echo(f"WARNING:  Failed to create .env.example")
        
        # Create mcp_server.py wrapper
        if create_mcp_server_wrapper(docrag_dir):
            click.echo(f"SUCCESS: Created {docrag_dir / 'mcp_server.py'}")
        else:
            click.echo(f"WARNING:  Failed to create {docrag_dir / 'mcp_server.py'}")
        
        # Check root .gitignore and warn if .env is not excluded
        display_gitignore_warning(Path.cwd(), offer_fix=True)
        
        # Display security reminder
        display_security_reminder()
        
        # Display next steps
        click.echo("\nNext steps:")
        click.echo("   1. Run: docrag index")
        click.echo("   2. Run: docrag mcp-config")
        click.echo("\n   Documentation: https://github.com/docrag-kit/docrag-kit")
        
    except KeyboardInterrupt:
        click.echo("\n\nERROR: Setup cancelled")
        return
    except Exception as e:
        click.echo(f"\nERROR: Error during initialization: {e}")
        return


@cli.command()
def fix_prompt():
    """Fix prompt template to include required placeholders."""
    from pathlib import Path
    from .config_manager import ConfigManager
    import yaml
    
    config_manager = ConfigManager()
    
    # Check if configuration exists
    if not config_manager.config_path.exists():
        click.echo("ERROR: Error: DocRAG not initialized in this project")
        click.echo("   Run 'docrag init' first")
        return
    
    try:
        # Load configuration
        config = config_manager.load_config()
        if not config:
            click.echo("ERROR: Error: Failed to load configuration")
            return
        
        # Check if template has required placeholders
        template = config.prompt.template
        if '{context}' in template and '{question}' in template:
            click.echo("SUCCESS: Prompt template already has required placeholders")
            return
        
        click.echo("üîß Fixing prompt template...")
        click.echo(f"\nüìã Current template (first 200 chars):")
        click.echo(f"{'=' * 80}")
        click.echo(template[:200] + "..." if len(template) > 200 else template)
        click.echo(f"{'=' * 80}\n")
        
        # Get project type and name
        project_type = config.project.type
        project_name = config.project.name
        
        # Create fixed template based on project type
        if project_type == 'symfony':
            base_instruction = f"You are an expert assistant for the {project_name} project - a Symfony-based application."
        elif project_type == 'ios':
            base_instruction = f"You are an iOS development expert for the {project_name} project."
        else:
            base_instruction = f"You are a developer assistant for the {project_name} project."
        
        fixed_template = f"""{base_instruction}
Answer questions based on the provided documentation context.
Be concise and accurate. Respond in Russian if the question is in Russian.
If you don't know the answer based on the context, say so.

Context:
{{context}}

Question: {{question}}

Answer:"""
        
        # Update configuration
        config.prompt.template = fixed_template
        config_manager.save_config(config)
        
        click.echo(f"SUCCESS: Fixed prompt template")
        click.echo(f"\nNew template:")
        click.echo(f"{'=' * 80}")
        click.echo(fixed_template)
        click.echo(f"{'=' * 80}\n")
        click.echo(f"SUCCESS: Configuration saved to {config_manager.config_path}")
        click.echo("\nNext steps:")
        click.echo("   1. Restart Kiro IDE to reload MCP server")
        click.echo("   2. Try asking a question with answer_question tool")
        
    except Exception as e:
        click.echo(f"ERROR: Error fixing prompt template: {e}")
        import traceback
        traceback.print_exc()


@cli.command()
@click.option("--force", is_flag=True, help="Overwrite existing database without confirmation")
def index(force):
    """Index project documents."""
    from pathlib import Path
    from .config_manager import ConfigManager
    from .document_processor import DocumentProcessor
    from .vector_db import VectorDBManager
    
    project_root = Path.cwd()
    
    # Load configuration
    config_manager = ConfigManager(project_root)
    config = config_manager.load_config()
    
    if config is None:
        click.echo("ERROR: Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Convert config to dictionary for processors
    config_dict = config.to_dict()
    
    try:
        # Check for API key
        vector_db = VectorDBManager(config_dict, project_root)
        
        # Check if database already exists
        db_path = project_root / ".docrag" / "vectordb"
        if db_path.exists() and not force:
            click.echo("WARNING:  Vector database already exists - overwriting...")
            # Automatically overwrite without confirmation
        
        # Scan and load documents
        click.echo("\nüìÅ Scanning documents...")
        doc_processor = DocumentProcessor(config_dict)
        chunks, stats = doc_processor.process(project_root)
        
        if stats['files_found'] == 0:
            click.echo("ERROR: No files found to index")
            click.echo("   Check your configuration:")
            click.echo(f"   - Directories: {config.indexing.directories}")
            click.echo(f"   - Extensions: {config.indexing.extensions}")
            return
        
        # Display file count
        click.echo(f"SUCCESS: Found {stats['files_found']} files to index")
        
        if stats['files_processed'] < stats['files_found']:
            click.echo(f"WARNING:  {stats['files_found'] - stats['files_processed']} files failed to load")
        
        # Create vector database
        click.echo(f"\nüìä Creating vector database...")
        click.echo(f"   Processing {stats['chunks_created']} chunks...")
        
        vector_db.create_database(chunks, show_progress=True)
        
        # Display statistics
        click.echo("\nSUCCESS: Indexing complete!")
        click.echo(f"   Files processed: {stats['files_processed']}")
        click.echo(f"   Chunks created: {stats['chunks_created']}")
        click.echo(f"   Total characters: {stats['total_characters']:,}")
        
        # Display next steps
        click.echo("\nNext steps:")
        click.echo("   Run: docrag mcp-config")
        
    except ValueError as e:
        click.echo(f"\n{e}")
        return
    except Exception as e:
        click.echo(f"\nERROR: Error during indexing: {e}")
        import traceback
        traceback.print_exc()
        return


@cli.command()
@click.option("--force", is_flag=True, help="Skip confirmation prompt")
def reindex(force):
    """Rebuild vector database from scratch."""
    from pathlib import Path
    from .config_manager import ConfigManager
    from .document_processor import DocumentProcessor
    from .vector_db import VectorDBManager
    
    project_root = Path.cwd()
    
    # Load configuration
    config_manager = ConfigManager(project_root)
    config = config_manager.load_config()
    
    if config is None:
        click.echo("ERROR: Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Convert config to dictionary for processors
    config_dict = config.to_dict()
    
    # Display info message
    click.echo("WARNING:  Rebuilding vector database from scratch...")
    click.echo("   All indexed data will be removed and rebuilt")
    
    try:
        # Initialize vector database manager
        vector_db = VectorDBManager(config_dict, project_root)
        
        # Delete old database
        click.echo("\nüóëÔ∏è  Deleting old database...")
        vector_db.delete_database()
        click.echo("SUCCESS: Old database deleted")
        
        # Scan and load documents
        click.echo("\nüìÅ Scanning documents...")
        doc_processor = DocumentProcessor(config_dict)
        chunks, stats = doc_processor.process(project_root)
        
        if stats['files_found'] == 0:
            click.echo("ERROR: No files found to index")
            click.echo("   Check your configuration:")
            click.echo(f"   - Directories: {config.indexing.directories}")
            click.echo(f"   - Extensions: {config.indexing.extensions}")
            return
        
        # Display file count
        click.echo(f"SUCCESS: Found {stats['files_found']} files to index")
        
        if stats['files_processed'] < stats['files_found']:
            click.echo(f"WARNING:  {stats['files_found'] - stats['files_processed']} files failed to load")
        
        # Create vector database
        click.echo(f"\nüìä Creating vector database...")
        click.echo(f"   Processing {stats['chunks_created']} chunks...")
        
        vector_db.create_database(chunks, show_progress=True)
        
        # Display updated statistics
        click.echo("\nSUCCESS: Reindexing complete!")
        click.echo(f"   Files processed: {stats['files_processed']}")
        click.echo(f"   Chunks created: {stats['chunks_created']}")
        click.echo(f"   Total characters: {stats['total_characters']:,}")
        
    except ValueError as e:
        click.echo(f"\n{e}")
        return
    except Exception as e:
        click.echo(f"\nERROR: Error during reindexing: {e}")
        import traceback
        traceback.print_exc()
        return


@cli.command()
@click.option("--edit", is_flag=True, help="Open configuration in editor")
def config(edit):
    """Display or edit current configuration."""
    from pathlib import Path
    import subprocess
    import os
    import yaml
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    config_manager = ConfigManager(project_root)
    
    # Check if configuration exists
    if not config_manager.config_path.exists():
        click.echo("ERROR: Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    if edit:
        # Open configuration in editor
        click.echo("‚úèÔ∏è  Opening configuration in editor...")
        
        # Determine editor (use EDITOR env var or default to system editor)
        editor = os.environ.get('EDITOR')
        
        if not editor:
            # Try common editors
            if os.system('which code > /dev/null 2>&1') == 0:
                editor = 'code'
            elif os.system('which nano > /dev/null 2>&1') == 0:
                editor = 'nano'
            elif os.system('which vim > /dev/null 2>&1') == 0:
                editor = 'vim'
            elif os.system('which vi > /dev/null 2>&1') == 0:
                editor = 'vi'
            else:
                # Fallback to open (macOS) or xdg-open (Linux)
                import platform
                if platform.system() == 'Darwin':
                    editor = 'open'
                else:
                    editor = 'xdg-open'
        
        try:
            subprocess.run([editor, str(config_manager.config_path)])
            click.echo("SUCCESS: Configuration file opened")
        except Exception as e:
            click.echo(f"ERROR: Error opening editor: {e}")
            click.echo(f"   Try manually editing: {config_manager.config_path}")
    
    else:
        # Display current configuration
        click.echo("‚öôÔ∏è  Current configuration:\n")
        
        try:
            # Load and display YAML
            with open(config_manager.config_path, 'r', encoding='utf-8') as f:
                config_data = yaml.safe_load(f)
            
            # Pretty print the configuration
            click.echo(yaml.dump(config_data, default_flow_style=False, sort_keys=False))
            
            click.echo(f"\nüìÅ Configuration file: {config_manager.config_path}")
            click.echo("   Use 'docrag config --edit' to modify")
        
        except Exception as e:
            click.echo(f"ERROR: Error reading configuration: {e}")


@cli.command("mcp-config")
@click.option("--non-interactive", is_flag=True, help="Skip confirmation prompts")
@click.option("--update", is_flag=True, help="Update existing MCP configuration with new tools")
def mcp_config(non_interactive, update):
    """Display MCP server configuration for Kiro."""
    from pathlib import Path
    import json
    import platform
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    config_manager = ConfigManager(project_root)
    
    # Check if configuration exists
    if not config_manager.config_path.exists():
        click.echo("ERROR: Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Load configuration to get project name
    config = config_manager.load_config()
    if config is None:
        click.echo("ERROR: Error: Failed to load configuration")
        return
    
    project_name = config.project.name
    
    # Get absolute path to mcp_server.py
    mcp_server_path = project_root / ".docrag" / "mcp_server.py"
    
    # Check if mcp_server.py exists
    if not mcp_server_path.exists():
        click.echo("WARNING:  Warning: mcp_server.py not found")
        click.echo(f"   Expected at: {mcp_server_path}")
        click.echo("   This file should be created during 'docrag init'")
        return
    
    # Generate MCP server configuration
    # Use simple name like other MCP servers (context7, perplexity, etc.)
    server_name = "docrag"
    
    # Detect Python executable with MCP library installed
    import sys
    import subprocess
    
    def find_python_with_mcp():
        """Find Python executable that has mcp library installed."""
        # Try current Python first
        candidates = [sys.executable]
        
        # Add common pyenv Python 3.10+ locations
        pyenv_root = Path.home() / ".pyenv" / "versions"
        if pyenv_root.exists():
            for version_dir in sorted(pyenv_root.iterdir(), reverse=True):
                if version_dir.is_dir() and version_dir.name.startswith("3.1"):
                    python_bin = version_dir / "bin" / "python"
                    if python_bin.exists():
                        candidates.append(str(python_bin))
        
        # Test each candidate
        for python_path in candidates:
            try:
                result = subprocess.run(
                    [python_path, "-c", "import mcp; import docrag"],
                    capture_output=True,
                    timeout=5
                )
                if result.returncode == 0:
                    return python_path
            except:
                continue
        
        # Fallback to current Python
        return sys.executable
    
    python_executable = find_python_with_mcp()
    
    # Use module execution instead of script path to avoid import issues
    mcp_config = {
        "mcpServers": {
            server_name: {
                "command": python_executable,
                "args": ["-m", "docrag.mcp_server"],
                "cwd": str(project_root),
                "env": {},
                "disabled": False,
                "autoApprove": []
            }
        }
    }
    
    # Display configuration
    if update:
        click.echo("Updating MCP Server Configuration\n")
    else:
        click.echo("MCP Server Configuration for Kiro\n")
        click.echo("Add this to your Kiro MCP configuration file:")
        click.echo(".kiro/settings/mcp.json (workspace config)\n")
        
        click.echo("```json")
        click.echo(json.dumps(mcp_config, indent=2))
        click.echo("```\n")
        
        # Display manual instructions
        click.echo("Manual Setup Instructions:")
        click.echo("1. Open or create: .kiro/settings/mcp.json")
        click.echo("2. Add the above configuration to the 'mcpServers' section")
        click.echo("3. Restart Kiro or reload MCP servers")
        click.echo("4. The server will appear as: " + server_name)
    
    # Try to add to workspace config automatically
    workspace_config_path = project_root / ".kiro" / "settings" / "mcp.json"
    
    click.echo("\nAdding to workspace configuration...")
    
    # Skip confirmation in non-interactive mode or update mode
    if update:
        should_add_config = True
        click.echo("Updating existing configuration...")
    else:
        should_add_config = non_interactive or click.confirm("   Would you like to automatically add this configuration?", default=True)
    
    if should_add_config:
        try:
            # Read existing config or create new one
            if workspace_config_path.exists():
                # Backup existing config
                backup_path = workspace_config_path.with_suffix('.json.backup')
                import shutil
                shutil.copy2(workspace_config_path, backup_path)
                click.echo(f"   SUCCESS: Backed up existing config to {backup_path}")
                
                # Load existing config
                with open(workspace_config_path, 'r', encoding='utf-8') as f:
                    existing_config = json.load(f)
            else:
                existing_config = {"mcpServers": {}}
            
            # Ensure mcpServers exists
            if "mcpServers" not in existing_config:
                existing_config["mcpServers"] = {}
            
            # Add new server entry
            existing_config["mcpServers"][server_name] = mcp_config["mcpServers"][server_name]
            
            # Ensure directory exists
            workspace_config_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write updated config
            with open(workspace_config_path, 'w', encoding='utf-8') as f:
                json.dump(existing_config, f, indent=2)
            
            if update:
                click.echo(f"   SUCCESS: Configuration updated in {workspace_config_path}")
                click.echo("   RESTART: Restart Kiro or reload MCP servers to see new tools:")
                click.echo("     ‚Ä¢ reindex_docs - Smart reindexing with change detection")
                click.echo("     ‚Ä¢ Enhanced search_docs and answer_question with staleness warnings")
            else:
                click.echo(f"   SUCCESS: Configuration added to {workspace_config_path}")
                click.echo("   RESTART: Restart Kiro or reload MCP servers to activate")
                
                # Add note about user config option
                click.echo("\nNOTE: Configuration added to workspace config (.kiro/settings/mcp.json)")
                click.echo("   This makes the MCP server available only in this workspace")
                click.echo("   To make it available globally, add to: ~/.kiro/settings/mcp.json")
                click.echo(f"\nIMPORTANT: MCP server will run from: {project_root}")
                click.echo("   This ensures MCP and CLI use the same database")
        
        except Exception as e:
            click.echo(f"   ERROR: Error adding configuration: {e}")
            click.echo("   Please add the configuration manually")
    else:
        click.echo("\nTIP: Tip: You can manually add the configuration to:")
        click.echo("   - Workspace: .kiro/settings/mcp.json (recommended)")
        click.echo("   - User: ~/.kiro/settings/mcp.json (global)")


@cli.command()
def update():
    """Update DocRAG configuration and MCP server for existing projects."""
    from pathlib import Path
    import json
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    
    # Check if DocRAG is initialized
    docrag_dir = project_root / ".docrag"
    if not docrag_dir.exists():
        click.echo("ERROR: DocRAG not initialized in this project")
        click.echo("   Run 'docrag init' first")
        return
    
    click.echo("UPDATE: Updating DocRAG configuration for new features...\n")
    
    # Check current configuration
    config_manager = ConfigManager(project_root)
    if not config_manager.config_path.exists():
        click.echo("ERROR: Configuration file not found")
        click.echo("   Run 'docrag init' to recreate configuration")
        return
    
    # Update MCP configuration
    click.echo("1. Updating MCP server configuration...")
    try:
        # Run mcp-config with update flag
        from click.testing import CliRunner
        runner = CliRunner()
        result = runner.invoke(mcp_config, ['--non-interactive', '--update'])
        if result.exit_code == 0:
            click.echo("   SUCCESS: MCP configuration updated")
        else:
            click.echo("   WARNING: MCP configuration update failed")
    except Exception as e:
        click.echo(f"   WARNING: MCP update failed: {e}")
    
    # Check if reindexing is recommended
    click.echo("\n2. Checking if reindexing is needed...")
    try:
        from .mcp_server import MCPServer
        server = MCPServer()
        # This will be available after the MCP server is updated
        click.echo("   INFO: Use 'reindex_docs' tool in Kiro to check for updates")
        click.echo("   Or run: docrag reindex")
    except Exception as e:
        click.echo(f"   INFO: Reindexing check will be available after MCP restart")
    
    # Display what's new
    click.echo("\n3. New features available:")
    click.echo("   ‚Ä¢ reindex_docs tool - Smart reindexing with change detection")
    click.echo("   ‚Ä¢ Automatic staleness warnings in search results")
    click.echo("   ‚Ä¢ Better performance for large documentation sets")
    
    click.echo("\nNEXT STEPS:")
    click.echo("1. Restart Kiro IDE or reload MCP servers")
    click.echo("2. Try the new 'reindex_docs' tool in Kiro")
    click.echo("3. Use 'reindex_docs(check_only=True)' to check for updates")


@cli.command("fix-database")
def fix_database():
    """Fix database permission and corruption issues."""
    from pathlib import Path
    from .database_repair import DatabaseRepair
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    repair = DatabaseRepair(project_root)
    
    click.echo("DATABASE FIX: Diagnosing database issues...\n")
    
    # Diagnose issues
    critical_issues, warnings = repair.diagnose_issues()
    
    if "DocRAG not initialized" in str(critical_issues):
        click.echo("ERROR: DocRAG not initialized in this project")
        click.echo("   Run 'docrag init' first")
        return
    
    # Display findings
    if critical_issues:
        click.echo("CRITICAL ISSUES:")
        for issue in critical_issues:
            click.echo(f"   ERROR: {issue}")
    
    if warnings:
        click.echo("\nWARNINGS:")
        for warning in warnings:
            click.echo(f"   WARNING: {warning}")
    
    if not critical_issues and not warnings:
        click.echo("SUCCESS: No database issues found!")
        return
    
    click.echo("\n" + "=" * 60)
    
    # Kill conflicting processes first
    conflicting_processes = repair.find_conflicting_processes()
    if conflicting_processes:
        click.echo(f"\nFound {len(conflicting_processes)} conflicting MCP server processes:")
        for proc in conflicting_processes:
            click.echo(f"   PID {proc['pid']}: {proc['cmdline']}")
        
        if click.confirm("Kill conflicting processes?", default=True):
            if repair.kill_conflicting_processes():
                click.echo("   SUCCESS: Conflicting processes terminated")
            else:
                click.echo("   WARNING: Some processes could not be terminated")
    
    # Apply comprehensive repair
    click.echo("\nAPPLYING AUTOMATIC FIXES:")
    fixes_applied, remaining_issues = repair.comprehensive_repair()
    
    if fixes_applied:
        click.echo("SUCCESS: Applied automatic fixes:")
        for fix in fixes_applied:
            click.echo(f"   ‚Ä¢ {fix}")
    
    # Handle remaining critical issues that need user confirmation
    if remaining_issues:
        click.echo(f"\nREMAINING ISSUES ({len(remaining_issues)}):")
        for issue in remaining_issues:
            click.echo(f"   ERROR: {issue}")
        
        # Check if database rebuild is needed
        if any("readonly" in issue.lower() or "corrupted" in issue.lower() or "locked" in issue.lower() 
               for issue in remaining_issues):
            click.echo("\nDatabase appears to be corrupted or locked.")
            if click.confirm("Rebuild database from scratch? (This will re-index all documents)", default=True):
                click.echo("   Rebuilding database...")
                if repair.rebuild_database():
                    click.echo("   SUCCESS: Database removed")
                    click.echo("   INFO: Run 'docrag index' to rebuild")
                    fixes_applied.append("Database rebuilt (requires reindexing)")
                else:
                    click.echo("   FAILED: Could not remove database")
    
    # Final summary
    click.echo("\n" + "=" * 60)
    click.echo("\nSUMMARY:")
    
    if fixes_applied:
        click.echo(f"SUCCESS: Applied {len(fixes_applied)} fix(es):")
        for fix in fixes_applied:
            click.echo(f"   ‚Ä¢ {fix}")
        
        click.echo("\nNEXT STEPS:")
        if any("requires reindexing" in fix for fix in fixes_applied):
            click.echo("   1. Run: docrag index")
        click.echo("   2. Restart Kiro IDE to reload MCP servers")
        click.echo("   3. Test with: docrag doctor")
    else:
        click.echo("INFO: No fixes were applied")
        
        # Show recommendations
        recommendations = repair.get_repair_recommendations(critical_issues, warnings)
        if recommendations:
            click.echo("\nRECOMMENDATIONS:")
            for rec in recommendations:
                click.echo(f"   ‚Ä¢ {rec}")
    
    # Re-diagnose to show final status
    if fixes_applied:
        click.echo("\nFINAL STATUS CHECK:")
        final_critical, final_warnings = repair.diagnose_issues()
        
        if not final_critical:
            click.echo("   SUCCESS: All critical issues resolved!")
        else:
            click.echo("   WARNING: Some critical issues remain:")
            for issue in final_critical:
                click.echo(f"      ‚Ä¢ {issue}")
        
        if final_warnings:
            click.echo("   INFO: Remaining warnings:")
            for warning in final_warnings:
                click.echo(f"      ‚Ä¢ {warning}")
    
    # Re-diagnose to check if issues are resolved
    if fixes_applied:
        click.echo("\nRE-CHECKING ISSUES:")
        new_critical, new_warnings = repair.diagnose_issues()
        
        if not new_critical:
            click.echo("   SUCCESS: All critical issues resolved!")
        else:
            click.echo("   WARNING: Some issues remain:")
            for issue in new_critical:
                click.echo(f"      ‚Ä¢ {issue}")
    
    # Check 1: Database directory permissions
    click.echo("1. Checking directory permissions...")
    try:
        if vectordb_path.exists():
            # Check if directory is writable
            test_file = vectordb_path / ".write_test"
            try:
                test_file.touch()
                test_file.unlink()
                click.echo("   SUCCESS: Directory is writable")
            except PermissionError:
                issues_found.append("Directory not writable")
                click.echo("   ERROR: Directory not writable")
                
                # Fix permissions
                try:
                    os.chmod(vectordb_path, 0o755)
                    for root, dirs, files in os.walk(vectordb_path):
                        for d in dirs:
                            os.chmod(os.path.join(root, d), 0o755)
                        for f in files:
                            os.chmod(os.path.join(root, f), 0o644)
                    fixes_applied.append("Fixed directory permissions")
                    click.echo("   FIXED: Directory permissions corrected")
                except Exception as e:
                    click.echo(f"   FAILED: Could not fix permissions: {e}")
        else:
            click.echo("   INFO: Database directory doesn't exist yet")
    except Exception as e:
        click.echo(f"   ERROR: Permission check failed: {e}")
    
    # Check 2: Database file locks
    click.echo("\n2. Checking for database locks...")
    if vectordb_path.exists():
        lock_files = list(vectordb_path.rglob("*.db-wal")) + list(vectordb_path.rglob("*.db-shm"))
        if lock_files:
            issues_found.append("Database lock files found")
            click.echo(f"   WARNING: Found {len(lock_files)} lock files")
            for lock_file in lock_files:
                click.echo(f"      {lock_file.name}")
            
            # Offer to remove lock files
            if click.confirm("   Remove lock files? (This will close any open connections)"):
                try:
                    for lock_file in lock_files:
                        lock_file.unlink()
                    fixes_applied.append("Removed database lock files")
                    click.echo("   FIXED: Lock files removed")
                except Exception as e:
                    click.echo(f"   FAILED: Could not remove lock files: {e}")
        else:
            click.echo("   SUCCESS: No lock files found")
    
    # Check 3: Database corruption
    click.echo("\n3. Checking database integrity...")
    if vectordb_path.exists():
        try:
            # Try to access ChromaDB
            from .vector_db import VectorDBManager
            config_manager = ConfigManager(project_root)
            config = config_manager.load_config()
            
            if config:
                config_dict = config.to_dict()
                vector_db = VectorDBManager(config_dict, project_root)
                
                # Try to list documents (this will fail if DB is corrupted)
                try:
                    docs = vector_db.list_documents()
                    click.echo(f"   SUCCESS: Database accessible ({len(docs)} documents)")
                except Exception as db_error:
                    issues_found.append("Database corruption detected")
                    click.echo(f"   ERROR: Database corrupted: {db_error}")
                    
                    # Offer to rebuild database
                    if click.confirm("   Rebuild database from scratch? (This will re-index all documents)"):
                        try:
                            # Remove corrupted database
                            shutil.rmtree(vectordb_path)
                            click.echo("   INFO: Corrupted database removed")
                            
                            # Trigger reindexing
                            click.echo("   INFO: Starting reindexing...")
                            from click.testing import CliRunner
                            runner = CliRunner()
                            result = runner.invoke(index, [])
                            
                            if result.exit_code == 0:
                                fixes_applied.append("Database rebuilt successfully")
                                click.echo("   FIXED: Database rebuilt successfully")
                            else:
                                click.echo("   FAILED: Database rebuild failed")
                        except Exception as e:
                            click.echo(f"   FAILED: Could not rebuild database: {e}")
            else:
                click.echo("   ERROR: Could not load configuration")
        except Exception as e:
            click.echo(f"   ERROR: Database check failed: {e}")
    
    # Check 4: Disk space
    click.echo("\n4. Checking disk space...")
    try:
        statvfs = os.statvfs(str(docrag_dir))
        free_bytes = statvfs.f_frsize * statvfs.f_bavail
        free_mb = free_bytes / (1024 * 1024)
        
        if free_mb < 100:  # Less than 100MB
            issues_found.append("Low disk space")
            click.echo(f"   WARNING: Low disk space ({free_mb:.1f} MB available)")
        else:
            click.echo(f"   SUCCESS: Sufficient disk space ({free_mb:.1f} MB available)")
    except Exception as e:
        click.echo(f"   ERROR: Could not check disk space: {e}")
    
    # Summary
    click.echo("\n" + "=" * 60)
    click.echo("\nSUMMARY:")
    
    if not issues_found:
        click.echo("SUCCESS: No database issues found!")
    else:
        click.echo(f"ISSUES: Found {len(issues_found)} issue(s):")
        for issue in issues_found:
            click.echo(f"   ‚Ä¢ {issue}")
    
    if fixes_applied:
        click.echo(f"\nFIXES: Applied {len(fixes_applied)} fix(es):")
        for fix in fixes_applied:
            click.echo(f"   ‚Ä¢ {fix}")
        
        click.echo("\nNEXT STEPS:")
        click.echo("   1. Restart any running MCP servers")
        click.echo("   2. Try running 'docrag index' if database was rebuilt")
        click.echo("   3. Test with 'docrag doctor' to verify everything works")
    
    if issues_found and not fixes_applied:
        click.echo("\nRECOMMENDED ACTIONS:")
        click.echo("   1. Run this command again and accept suggested fixes")
        click.echo("   2. Or manually run: rm -rf .docrag/vectordb && docrag index")
        click.echo("   3. Check file system permissions: ls -la .docrag/")


@cli.command("debug-mcp")
def debug_mcp():
    """Debug MCP server paths and synchronization issues."""
    from pathlib import Path
    import json
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    
    click.echo("MCP DEBUG: Diagnosing MCP server paths and synchronization...\n")
    
    # Check if DocRAG is initialized
    docrag_dir = project_root / ".docrag"
    if not docrag_dir.exists():
        click.echo("ERROR: DocRAG not initialized in this project")
        click.echo("   Run 'docrag init' first")
        return
    
    click.echo(f"Current project directory: {project_root}")
    click.echo(f"DocRAG config directory: {docrag_dir}")
    
    # Check CLI database
    click.echo("\n1. CLI Database Status:")
    try:
        config_manager = ConfigManager(project_root)
        config = config_manager.load_config()
        
        if config:
            from .vector_db import VectorDBManager
            config_dict = config.to_dict()
            vector_db = VectorDBManager(config_dict, project_root)
            
            try:
                cli_docs = vector_db.list_documents()
                click.echo(f"   CLI sees: {len(cli_docs)} documents")
                if cli_docs:
                    click.echo("   Sample documents:")
                    for doc in cli_docs[:5]:
                        click.echo(f"      ‚Ä¢ {doc}")
                    if len(cli_docs) > 5:
                        click.echo(f"      ... and {len(cli_docs) - 5} more")
            except Exception as e:
                click.echo(f"   ERROR: Cannot access CLI database: {e}")
        else:
            click.echo("   ERROR: Cannot load configuration")
    except Exception as e:
        click.echo(f"   ERROR: CLI check failed: {e}")
    
    # Check MCP configuration
    click.echo("\n2. MCP Configuration:")
    workspace_mcp = project_root / ".kiro" / "settings" / "mcp.json"
    user_mcp = Path.home() / ".kiro" / "settings" / "mcp.json"
    
    mcp_found = False
    mcp_working_dir = None
    
    if workspace_mcp.exists():
        click.echo(f"   Workspace MCP config: {workspace_mcp}")
        try:
            with open(workspace_mcp) as f:
                mcp_data = json.load(f)
                if "mcpServers" in mcp_data and "docrag" in mcp_data["mcpServers"]:
                    mcp_found = True
                    docrag_config = mcp_data["mcpServers"]["docrag"]
                    mcp_working_dir = docrag_config.get("cwd", "NOT SET")
                    click.echo(f"   MCP working directory: {mcp_working_dir}")
                    click.echo(f"   MCP command: {docrag_config.get('command', 'NOT SET')}")
                    click.echo(f"   MCP args: {docrag_config.get('args', 'NOT SET')}")
                else:
                    click.echo("   WARNING: docrag server not found in workspace config")
        except Exception as e:
            click.echo(f"   ERROR: Cannot read workspace MCP config: {e}")
    else:
        click.echo("   INFO: No workspace MCP config")
    
    if user_mcp.exists():
        click.echo(f"   User MCP config: {user_mcp}")
        try:
            with open(user_mcp) as f:
                user_mcp_data = json.load(f)
                if "mcpServers" in user_mcp_data and "docrag" in user_mcp_data["mcpServers"]:
                    if not mcp_found:
                        mcp_found = True
                        user_docrag_config = user_mcp_data["mcpServers"]["docrag"]
                        mcp_working_dir = user_docrag_config.get("cwd", "NOT SET")
                        click.echo(f"   User MCP working directory: {mcp_working_dir}")
                    else:
                        click.echo("   INFO: User config exists but workspace config takes precedence")
        except Exception as e:
            click.echo(f"   ERROR: Cannot read user MCP config: {e}")
    else:
        click.echo("   INFO: No user MCP config")
    
    # Check path mismatch
    click.echo("\n3. Path Analysis:")
    if mcp_working_dir and mcp_working_dir != "NOT SET":
        if Path(mcp_working_dir) == project_root:
            click.echo("   SUCCESS: MCP working directory matches current project")
        else:
            click.echo("   ERROR: PATH MISMATCH DETECTED!")
            click.echo(f"      MCP working directory: {mcp_working_dir}")
            click.echo(f"      Current project:       {project_root}")
            click.echo("   This explains why MCP sees different data than CLI!")
    else:
        click.echo("   ERROR: MCP working directory not configured")
    
    # Test MCP server access
    click.echo("\n4. MCP Server Test:")
    if mcp_found:
        try:
            from .mcp_server import MCPServer
            # Try to create MCP server in current directory
            mcp_server = MCPServer(project_root)
            mcp_docs = mcp_server.vector_db.list_documents()
            click.echo(f"   MCP server sees: {len(mcp_docs)} documents")
            
            if mcp_docs:
                click.echo("   Sample MCP documents:")
                for doc in mcp_docs[:5]:
                    click.echo(f"      ‚Ä¢ {doc}")
        except Exception as e:
            click.echo(f"   ERROR: Cannot test MCP server: {e}")
    else:
        click.echo("   SKIPPED: MCP not configured")
    
    # Recommendations
    click.echo("\n" + "=" * 60)
    click.echo("\nRECOMMENDATIONS:")
    
    if mcp_working_dir and Path(mcp_working_dir) != project_root:
        click.echo("CRITICAL: Fix MCP working directory mismatch")
        click.echo(f"   1. Update MCP config to use: {project_root}")
        click.echo("   2. Run: docrag mcp-config --update")
        click.echo("   3. Restart Kiro IDE")
    elif not mcp_found:
        click.echo("SETUP: Configure MCP server")
        click.echo("   1. Run: docrag mcp-config")
        click.echo("   2. Restart Kiro IDE")
    else:
        click.echo("INFO: Run 'docrag fix-database' if issues persist")


@cli.command("fix-database")
@click.option("--force", is_flag=True, help="Force rebuild without confirmation")
def fix_database(force):
    """Fix database permission and corruption issues."""
    from pathlib import Path
    import os
    import stat
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    
    # Check if DocRAG is initialized
    docrag_dir = project_root / ".docrag"
    if not docrag_dir.exists():
        click.echo("ERROR: DocRAG not initialized in this project")
        click.echo("   Run 'docrag init' first")
        return
    
    click.echo("DATABASE: Diagnosing database issues...\n")
    
    # Check database directory
    db_path = docrag_dir / "vectordb"
    issues_found = []
    
    if not db_path.exists():
        click.echo("INFO: No database found - this is normal for new projects")
        click.echo("   Run 'docrag index' to create initial database")
        return
    
    # Check permissions
    try:
        # Test read permission
        if not os.access(db_path, os.R_OK):
            issues_found.append("Database directory not readable")
        
        # Test write permission
        if not os.access(db_path, os.W_OK):
            issues_found.append("Database directory not writable")
        
        # Check for lock files
        lock_files = list(db_path.rglob("*.lock"))
        if lock_files:
            issues_found.append(f"Found {len(lock_files)} lock file(s)")
            for lock_file in lock_files:
                click.echo(f"   Lock file: {lock_file}")
        
        # Check for corrupted files
        db_files = list(db_path.rglob("*"))
        if len(db_files) < 3:  # ChromaDB should have multiple files
            issues_found.append("Database appears incomplete or corrupted")
        
    except Exception as e:
        issues_found.append(f"Permission check failed: {e}")
    
    if not issues_found:
        click.echo("SUCCESS: Database appears healthy")
        click.echo(f"   Location: {db_path}")
        click.echo(f"   Files: {len(list(db_path.rglob('*')))} files found")
        return
    
    # Report issues
    click.echo(f"ISSUES: Found {len(issues_found)} issue(s):")
    for issue in issues_found:
        click.echo(f"   ‚Ä¢ {issue}")
    
    # Offer fixes
    click.echo("\nFIXES: Available fixes:")
    
    # Fix permissions
    if "not readable" in str(issues_found) or "not writable" in str(issues_found):
        click.echo("1. Fix permissions...")
        try:
            # Make directory readable and writable
            os.chmod(db_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)
            for file_path in db_path.rglob("*"):
                if file_path.is_file():
                    os.chmod(file_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IROTH)
            click.echo("   SUCCESS: Permissions fixed")
        except Exception as e:
            click.echo(f"   ERROR: Failed to fix permissions: {e}")
    
    # Remove lock files
    lock_files = list(db_path.rglob("*.lock"))
    if lock_files:
        click.echo("2. Remove lock files...")
        for lock_file in lock_files:
            try:
                lock_file.unlink()
                click.echo(f"   SUCCESS: Removed {lock_file.name}")
            except Exception as e:
                click.echo(f"   ERROR: Failed to remove {lock_file.name}: {e}")
    
    # Offer database rebuild for corruption
    if "corrupted" in str(issues_found) or "incomplete" in str(issues_found):
        if force or click.confirm("3. Database appears corrupted. Rebuild from source files?"):
            click.echo("3. Rebuilding database...")
            try:
                # Load configuration
                config_manager = ConfigManager(project_root)
                config = config_manager.load_config()
                
                if config is None:
                    click.echo("   ERROR: Configuration not found")
                    return
                
                # Rebuild database
                from .document_processor import DocumentProcessor
                from .vector_db import VectorDBManager
                
                config_dict = config.to_dict()
                doc_processor = DocumentProcessor(config_dict)
                vector_db = VectorDBManager(config_dict, project_root)
                
                # Delete corrupted database
                vector_db.delete_database()
                
                # Rebuild from source
                chunks, stats = doc_processor.process(project_root)
                vector_db.create_database(chunks, show_progress=True)
                
                click.echo("   SUCCESS: Database rebuilt successfully")
                click.echo(f"   Files processed: {stats['files_processed']}")
                click.echo(f"   Chunks created: {stats['chunks_created']}")
                
            except Exception as e:
                click.echo(f"   ERROR: Database rebuild failed: {e}")
    
    click.echo("\nNEXT STEPS:")
    click.echo("1. Test MCP reindexing: Use 'reindex_docs' tool in Kiro")
    click.echo("2. If issues persist: Run 'docrag debug-mcp' for CLI/MCP sync diagnosis")


@cli.command("debug-mcp")
def debug_mcp():
    """Debug CLI vs MCP synchronization issues."""
    from pathlib import Path
    import os
    import json
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    
    click.echo("MCP DEBUG: Diagnosing CLI vs MCP synchronization...\n")
    
    # Check DocRAG initialization
    docrag_dir = project_root / ".docrag"
    if not docrag_dir.exists():
        click.echo("ERROR: DocRAG not initialized in this project")
        return
    
    # Check configuration
    config_manager = ConfigManager(project_root)
    config = config_manager.load_config()
    
    if config is None:
        click.echo("ERROR: Configuration not found")
        return
    
    click.echo("1. PROJECT PATHS:")
    click.echo(f"   Current directory: {project_root}")
    click.echo(f"   DocRAG config: {config_manager.config_path}")
    click.echo(f"   Database path: {docrag_dir / 'vectordb'}")
    
    # Check MCP configuration
    click.echo("\n2. MCP CONFIGURATION:")
    workspace_mcp = project_root / ".kiro" / "settings" / "mcp.json"
    user_mcp = Path.home() / ".kiro" / "settings" / "mcp.json"
    
    mcp_found = False
    
    if workspace_mcp.exists():
        click.echo(f"   Workspace MCP: {workspace_mcp}")
        try:
            with open(workspace_mcp) as f:
                mcp_data = json.load(f)
                if "mcpServers" in mcp_data and "docrag" in mcp_data["mcpServers"]:
                    server_config = mcp_data["mcpServers"]["docrag"]
                    click.echo(f"   Command: {server_config.get('command', 'N/A')}")
                    click.echo(f"   Working dir: {server_config.get('cwd', 'N/A')}")
                    mcp_found = True
                else:
                    click.echo("   WARNING: docrag server not found in workspace config")
        except Exception as e:
            click.echo(f"   ERROR: Failed to read workspace MCP config: {e}")
    
    if user_mcp.exists():
        click.echo(f"   User MCP: {user_mcp}")
        mcp_found = True
    
    if not mcp_found:
        click.echo("   ERROR: No MCP configuration found")
        click.echo("   Run: docrag mcp-config")
    
    # Check database status
    click.echo("\n3. DATABASE STATUS:")
    db_path = docrag_dir / "vectordb"
    
    if db_path.exists():
        try:
            from .vector_db import VectorDBManager
            vector_db = VectorDBManager(config.to_dict(), project_root)
            documents = vector_db.list_documents()
            click.echo(f"   Status: EXISTS")
            click.echo(f"   Documents: {len(documents)} files indexed")
            click.echo(f"   Size: {sum(f.stat().st_size for f in db_path.rglob('*') if f.is_file()) / 1024 / 1024:.1f} MB")
        except Exception as e:
            click.echo(f"   Status: ERROR - {e}")
    else:
        click.echo("   Status: NOT FOUND")
        click.echo("   Run: docrag index")
    
    # Check environment
    click.echo("\n4. ENVIRONMENT:")
    env_path = project_root / ".env"
    if env_path.exists():
        click.echo(f"   .env file: EXISTS")
        # Check API keys without exposing them
        from dotenv import load_dotenv
        load_dotenv(env_path)
        
        openai_key = os.getenv('OPENAI_API_KEY')
        google_key = os.getenv('GOOGLE_API_KEY')
        
        if openai_key:
            click.echo(f"   OpenAI key: SET ({len(openai_key)} chars)")
        if google_key:
            click.echo(f"   Google key: SET ({len(google_key)} chars)")
        
        if not openai_key and not google_key:
            click.echo("   WARNING: No API keys found")
    else:
        click.echo("   .env file: NOT FOUND")
    
    # Check for common issues
    click.echo("\n5. COMMON ISSUES:")
    issues = []
    
    # Path mismatch
    if mcp_found:
        try:
            with open(workspace_mcp) as f:
                mcp_data = json.load(f)
                server_cwd = mcp_data["mcpServers"]["docrag"].get("cwd")
                if server_cwd and Path(server_cwd) != project_root:
                    issues.append(f"MCP working directory mismatch: {server_cwd} vs {project_root}")
        except:
            pass
    
    # Database permissions
    if db_path.exists() and not os.access(db_path, os.W_OK):
        issues.append("Database directory not writable")
    
    # Lock files
    if db_path.exists():
        lock_files = list(db_path.rglob("*.lock"))
        if lock_files:
            issues.append(f"Database lock files found: {len(lock_files)}")
    
    if issues:
        for issue in issues:
            click.echo(f"   ‚Ä¢ {issue}")
        click.echo("\n   Run: docrag fix-database")
    else:
        click.echo("   No common issues detected")
    
    click.echo("\nRECOMMENDATIONS:")
    click.echo("1. If MCP reindexing fails: Run 'docrag fix-database'")
    click.echo("2. If CLI works but MCP doesn't: Check MCP working directory")
    click.echo("3. If both fail: Check API keys and database permissions")


@cli.command()
def doctor():
    """Diagnose DocRAG installation and configuration issues."""
    from pathlib import Path
    import os
    import sys
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    issues_found = []
    warnings_found = []
    
    click.echo("SEARCH: DocRAG Health Check\n")
    click.echo("=" * 70)
    
    # Check 1: DocRAG initialization
    click.echo("\nPROJECT: Checking DocRAG initialization...")
    docrag_dir = project_root / ".docrag"
    if not docrag_dir.exists():
        issues_found.append("DocRAG not initialized (.docrag/ directory missing)")
        click.echo("   ERROR: .docrag/ directory not found")
        click.echo("      Run: docrag init")
    else:
        click.echo("   SUCCESS: .docrag/ directory exists")
    
    # Check 2: Configuration file
    click.echo("\n‚öôÔ∏è  Checking configuration...")
    config_path = docrag_dir / "config.yaml"
    if not config_path.exists():
        issues_found.append("Configuration file missing (.docrag/config.yaml)")
        click.echo("   ERROR: config.yaml not found")
        click.echo("      Run: docrag init")
    else:
        click.echo("   SUCCESS: config.yaml exists")
        try:
            config_manager = ConfigManager(project_root)
            config = config_manager.load_config()
            if config:
                click.echo(f"      Project: {config.project.name}")
                click.echo(f"      Type: {config.project.type}")
                click.echo(f"      LLM Provider: {config.llm.provider}")
        except Exception as e:
            issues_found.append(f"Configuration file is invalid: {e}")
            click.echo(f"   ERROR: Failed to load config: {e}")
    
    # Check 3: API Keys
    click.echo("\nüîë Checking API keys...")
    env_path = project_root / ".env"
    if not env_path.exists():
        warnings_found.append(".env file not found")
        click.echo("   WARNING:  .env file not found")
        click.echo("      Create .env and add your API key")
    else:
        click.echo("   SUCCESS: .env file exists")
        # Check if API key is set (without exposing it)
        from dotenv import load_dotenv
        load_dotenv(env_path)
        
        openai_key = os.getenv('OPENAI_API_KEY')
        google_key = os.getenv('GOOGLE_API_KEY')
        
        if openai_key and len(openai_key) > 10:
            click.echo("      SUCCESS: OPENAI_API_KEY is set")
        else:
            warnings_found.append("OPENAI_API_KEY not set or empty")
            click.echo("      WARNING:  OPENAI_API_KEY not set")
        
        if google_key and len(google_key) > 10:
            click.echo("      SUCCESS: GOOGLE_API_KEY is set")
    
    # Check 4: Vector database
    click.echo("\nüìä Checking vector database...")
    vectordb_path = docrag_dir / "vectordb"
    if not vectordb_path.exists():
        warnings_found.append("Vector database not created yet")
        click.echo("   WARNING:  Vector database not found")
        click.echo("      Run: docrag index")
    else:
        click.echo("   SUCCESS: Vector database exists")
        # Check size
        total_size = sum(f.stat().st_size for f in vectordb_path.rglob('*') if f.is_file())
        size_mb = total_size / (1024 * 1024)
        click.echo(f"      Size: {size_mb:.1f} MB")
        
        if size_mb < 0.1:
            warnings_found.append("Vector database is very small (might be empty)")
            click.echo("      WARNING:  Database seems empty, consider reindexing")
    
    # Check 5: Python environment
    click.echo("\nüêç Checking Python environment...")
    click.echo(f"   Python version: {sys.version.split()[0]}")
    
    if sys.version_info < (3, 10):
        issues_found.append(f"Python {sys.version_info.major}.{sys.version_info.minor} is too old (need 3.10+)")
        click.echo("   ERROR: Python 3.10+ required")
    else:
        click.echo("   SUCCESS: Python version OK")
    
    # Check 6: Required packages
    click.echo("\nSOURCES: Checking required packages...")
    required_packages = ['langchain', 'chromadb', 'openai', 'mcp']
    for package in required_packages:
        try:
            __import__(package)
            click.echo(f"   SUCCESS: {package} installed")
        except ImportError:
            issues_found.append(f"Required package '{package}' not installed")
            click.echo(f"   ERROR: {package} not installed")
    
    # Check 7: Database-specific issues
    click.echo("\nChecking database-specific issues...")
    if vectordb_path.exists():
        # Check for readonly database issue
        try:
            import sqlite3
            db_files = list(vectordb_path.rglob("*.sqlite*")) + list(vectordb_path.rglob("*.db"))
            
            for db_file in db_files:
                try:
                    # Try to open database in write mode
                    conn = sqlite3.connect(str(db_file))
                    conn.execute("PRAGMA journal_mode=WAL;")
                    conn.close()
                    click.echo(f"   SUCCESS: {db_file.name} is writable")
                except sqlite3.OperationalError as e:
                    if "readonly database" in str(e).lower():
                        issues_found.append(f"Readonly database: {db_file.name}")
                        click.echo(f"   ERROR: {db_file.name} is readonly")
                    else:
                        warnings_found.append(f"Database issue in {db_file.name}: {e}")
                        click.echo(f"   WARNING: {db_file.name}: {e}")
                except Exception as e:
                    click.echo(f"   WARNING: Could not check {db_file.name}: {e}")
        except ImportError:
            click.echo("   INFO: sqlite3 not available for database check")
        except Exception as e:
            click.echo(f"   ERROR: Database check failed: {e}")
    
    # Check 8: CLI vs MCP synchronization
    click.echo("\nChecking CLI vs MCP synchronization...")
    try:
        # Check CLI database
        if config_path.exists():
            config_manager = ConfigManager(project_root)
            config = config_manager.load_config()
            
            if config:
                from .vector_db import VectorDBManager
                config_dict = config.to_dict()
                vector_db = VectorDBManager(config_dict, project_root)
                
                try:
                    cli_docs = vector_db.list_documents()
                    cli_count = len(cli_docs)
                    click.echo(f"   CLI database: {cli_count} documents")
                    
                    # Try to simulate MCP access
                    try:
                        from .mcp_server import MCPServer
                        mcp_server = MCPServer(project_root)
                        mcp_docs = mcp_server.vector_db.list_documents()
                        mcp_count = len(mcp_docs)
                        click.echo(f"   MCP database: {mcp_count} documents")
                        
                        if cli_count != mcp_count:
                            issues_found.append(f"CLI/MCP sync issue: CLI has {cli_count} docs, MCP has {mcp_count}")
                            click.echo(f"   ERROR: Synchronization issue detected!")
                            click.echo(f"      CLI sees {cli_count} documents")
                            click.echo(f"      MCP sees {mcp_count} documents")
                        else:
                            click.echo("   SUCCESS: CLI and MCP are synchronized")
                            
                    except Exception as mcp_error:
                        warnings_found.append(f"Could not test MCP access: {mcp_error}")
                        click.echo(f"   WARNING: Could not test MCP access: {mcp_error}")
                        
                except Exception as cli_error:
                    warnings_found.append(f"Could not check CLI database: {cli_error}")
                    click.echo(f"   WARNING: Could not check CLI database: {cli_error}")
            else:
                warnings_found.append("Could not load configuration for sync check")
                click.echo("   WARNING: Could not load configuration")
        else:
            warnings_found.append("Configuration missing for sync check")
            click.echo("   WARNING: Configuration file missing")
            
    except Exception as e:
        warnings_found.append(f"Could not check CLI/MCP sync: {e}")
        click.echo(f"   WARNING: Could not check synchronization: {e}")
    
    # Check 9: MCP configuration
    click.echo("\nChecking MCP configuration...")
    workspace_mcp = project_root / ".kiro" / "settings" / "mcp.json"
    user_mcp = Path.home() / ".kiro" / "settings" / "mcp.json"
    
    mcp_configured = False
    mcp_working_dir = None
    
    # Check workspace MCP config
    if workspace_mcp.exists():
        click.echo("   SUCCESS: Workspace MCP config exists")
        mcp_configured = True
        try:
            import json
            with open(workspace_mcp) as f:
                mcp_data = json.load(f)
                if "mcpServers" in mcp_data and "docrag" in mcp_data["mcpServers"]:
                    click.echo("      SUCCESS: docrag server configured")
                    
                    # Check working directory
                    docrag_config = mcp_data["mcpServers"]["docrag"]
                    if "cwd" in docrag_config:
                        mcp_working_dir = docrag_config["cwd"]
                        click.echo(f"      Working directory: {mcp_working_dir}")
                        
                        # Verify working directory matches current project
                        if Path(mcp_working_dir) != project_root:
                            issues_found.append("MCP working directory mismatch")
                            click.echo(f"      ERROR: MCP working directory mismatch!")
                            click.echo(f"         MCP uses: {mcp_working_dir}")
                            click.echo(f"         Current:  {project_root}")
                    else:
                        warnings_found.append("MCP working directory not specified")
                        click.echo("      WARNING: No working directory specified")
                else:
                    warnings_found.append("docrag server not found in MCP config")
                    click.echo("      WARNING: docrag server not configured")
        except Exception as e:
            warnings_found.append(f"Failed to read MCP config: {e}")
            click.echo(f"      WARNING: Failed to read config: {e}")
    
    # Check user MCP config
    if user_mcp.exists():
        click.echo("   INFO: User MCP config exists")
        mcp_configured = True
        try:
            import json
            with open(user_mcp) as f:
                user_mcp_data = json.load(f)
                if "mcpServers" in user_mcp_data and "docrag" in user_mcp_data["mcpServers"]:
                    user_docrag_config = user_mcp_data["mcpServers"]["docrag"]
                    if "cwd" in user_docrag_config:
                        user_mcp_dir = user_docrag_config["cwd"]
                        click.echo(f"      User MCP working directory: {user_mcp_dir}")
                        
                        if Path(user_mcp_dir) != project_root:
                            warnings_found.append("User MCP config points to different project")
                            click.echo(f"      WARNING: User MCP points to different project")
        except Exception as e:
            click.echo(f"      INFO: Could not read user MCP config: {e}")
    
    if not mcp_configured:
        warnings_found.append("MCP not configured")
        click.echo("   WARNING: MCP not configured")
        click.echo("      Run: docrag mcp-config")
    
    # Summary
    click.echo("\n" + "=" * 70)
    click.echo("\nüìã Summary:\n")
    
    if not issues_found and not warnings_found:
        click.echo("SUCCESS: Everything looks good! DocRAG is properly configured.")
    else:
        if issues_found:
            click.echo(f"ERROR: Found {len(issues_found)} issue(s):")
            for issue in issues_found:
                click.echo(f"   ‚Ä¢ {issue}")
        
        if warnings_found:
            click.echo(f"\nWARNING:  Found {len(warnings_found)} warning(s):")
            for warning in warnings_found:
                click.echo(f"   ‚Ä¢ {warning}")
        
        click.echo("\nTIP: Quick fixes:")
        if "DocRAG not initialized" in str(issues_found):
            click.echo("   1. Run: docrag init")
        if "Vector database not created" in str(warnings_found):
            click.echo("   2. Run: docrag index")
        if "MCP not configured" in str(warnings_found):
            click.echo("   3. Run: docrag mcp-config")


if __name__ == "__main__":
    cli()

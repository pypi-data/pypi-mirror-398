//
//   This file is automatically generated by sv_generator.py. See MEMORY_MAP.md for more information.
//
//
//   >>>> Memory Map <<<<
//
//   Memory Range                                                         |  R/W  | Size   | Cacheable?
// -----------------------------------------------------------------------|-------|--------|------------+
//              +-----------------+                                       |       |        |            |
//   0600_10ff  |                 |                                       |       |        |            |
//              |                 |                                       |       |        |            |
//              |  Flash Control  |                                       |   -   |  4kb   |            |
//              |                 |                                       |       |        |            |
//   0600_0000  |                 |                                       |       |        |            |
//              +-----------------+                                       +-------+--------+------------+
//   0500_0073  |                 |                                       |       |        |            |
//              |                 |                                       |       |        |            |
//              |   Peripherals   |                                       |   -   |  116b  |            |
//              |                 |                                       |       |        |            |
//   0500_0000  |                 |                                       |       |        |            |
//              +-----------------+                                       +-------+--------+------------+
//   0341_dfff  |                 |                                       |       |        |            |
//              |                 |                                       |       |        |            |
//              |      BRAM       |                                       |  R/W  |  4mb   |     *      |
//              |                 |                                       |       |        |            |
//   0300_0000  |                 |                                       |       |        |            |
//              +-----------------+                                       +-------+--------+------------+
//   02ff_ffff  |                 |                                       |       |        |            |
//              |                 |                                       |       |        |            |
//              |    Flash ROM    |                                       |  R/O  |  16mb  |     *      |
//              |                 |                                       |       |        |            |
//   0200_0000  |                 |                                       |       |        |            |
//              +-----------------+                                       +-------+--------+------------+
//   01ff_ffff  |                 |                                       |       |        |            |
//              |                 |                                       |       |        |            |
//              |      SDRAM      |                                       |  R/W  |  32mb  |     *      |
//              |                 |                                       |       |        |            |
//   0000_0000  |                 |                                       |       |        |            |
//              +-----------------+                                       +-------+--------+------------+
//                                                                                          * = cacheable
//
//
//
//   >>>> Memory Mapped Registers and Regions <<<
//
//   +-------------------------------------------------------------------------------------------------+
//   |                                              Flash                                              |
//   +-------------------------+------------------------------+----------+-----------------------------+
//   | Address                 | Name                         | R/W?     | Size                        |
//   +-------------------------+------------------------------+----------+-----------------------------+
//   | 06000000                | Flash Command Register       |    W     | 4 bytes                     |
//   | 06000004                | Flash Command Address        |   R/W    | 4 bytes                     |
//   | 06000008                | Flash Command Tag High       |   R/W    | 4 bytes                     |
//   | 0600000C                | Flash Command Tag Low        |   R/W    | 4 bytes                     |
//   | 06000010                | Flash Command Status         |    R     | 4 bytes                     |
//   | 06001000 - 060010FF     | Flash Page Buffer            |   R/W    | 256 bytes                   |
//   +-------------------------+------------------------------+----------+-----------------------------+
//
//   +-------------------------------------------------------------------------------------------------+
//   |                                               BRAM                                              |
//   +-------------------------+------------------------------+----------+-----------------------------+
//   | Address                 | Name                         | R/W?     | Size                        |
//   +-------------------------+------------------------------+----------+-----------------------------+
//   | 03000000 - 03005FFF     | OLED 1 Buffer                |   R/W    | 24 KB                       |
//   | 03006000 - 0300BFFF     | OLED 2 Buffer                |   R/W    | 24 KB                       |
//   | 0300C000 - 03011FFF     | OLED 3 Buffer                |   R/W    | 24 KB                       |
//   | 03012000 - 03017FFF     | OLED 4 Buffer                |   R/W    | 24 KB                       |
//   | 03018000 - 0301DFFF     | OLED 5 Buffer                |   R/W    | 24 KB                       |
//   | 0301E000 - 0341DFFF     | VGA Buffer                   |   R/W    | 4 MB                        |
//   +-------------------------+------------------------------+----------+-----------------------------+
//
//   +-------------------------------------------------------------------------------------------------+
//   |                                           Peripherals                                           |
//   +-------------------------+------------------------------+----------+-----------------------------+
//   | Address                 | Name                         | R/W?     | Size                        |
//   +-------------------------+------------------------------+----------+-----------------------------+
//   | 05000000                | UART RX Status               |    R     | 4 bytes                     |
//   | 05000004                | UART TX Status               |    R     | 4 bytes                     |
//   | 05000008                | UART RX Read Address         |    R     | 4 bytes                     |
//   | 0500000C                | UART TX Write Address        |    W     | 4 bytes                     |
//   | 05000010                | SPI RX Status                |    R     | 4 bytes                     |
//   | 05000014                | SPI TX Status                |    R     | 4 bytes                     |
//   | 05000018                | SPI RX Read Address          |    R     | 4 bytes                     |
//   | 0500001C                | SPI TX Write Address         |    W     | 4 bytes                     |
//   | 05000020                | I2C RX Status                |    R     | 4 bytes                     |
//   | 05000024                | I2C TX Status                |    R     | 4 bytes                     |
//   | 05000028                | I2C RX Read Address          |    R     | 4 bytes                     |
//   | 0500002C                | I2C TX Write Address         |    W     | 4 bytes                     |
//   | 05000040                | GPIO Direction               |   R/W    | 4 bytes                     |
//   | 05000044                | Input GPIOs                  |    R     | 4 bytes                     |
//   | 0500004C                | Output GPIOs                 |    W     | 4 bytes                     |
//   | 05000060                | LEDs                         |    W     | 4 bytes                     |
//   | 05000070                | Switches Inputs Read         |    R     | 4 bytes                     |
//   +-------------------------+------------------------------+----------+-----------------------------+
//

package memmappkg;

// verilator lint_off UNUSEDPARAM

localparam WB_SSEL_WIDTH                       = 4;
localparam WB_SLV_CNT                          = WB_SSEL_WIDTH; // equal since ssel is one-hot

// Highest cacheable address (for cache tag optimization)
localparam HIGHEST_CACHEABLE_ADDRESS           = 32'h0341_DFFF;

// Slave select constants (one-hot encoded)
localparam WB_SLAVE_SDRAM                      = 4'b0001;       // bit position 0
localparam WB_SLAVE_FLASH                      = 4'b0010;       // bit position 1
localparam WB_SLAVE_BRAM                       = 4'b0100;       // bit position 2
localparam WB_SLAVE_PERIPHERALS                = 4'b1000;       // bit position 3
localparam WB_SLAVE_NONE                       = 4'b0000;       // none selected

// ------------------------------------------------------------------------------------
// Functions for address translation
// ------------------------------------------------------------------------------------


// Compute slave_sel_o for the given address
function logic [3:0] get_slave_sel_o (input logic [31:0] addr);
    if (        ($unsigned(addr) <= 32'h01ffffff)    ) return WB_SLAVE_SDRAM;
    if (        ($unsigned(addr) >= 32'h02000000 && $unsigned(addr) <= 32'h02ffffff) ||        ($unsigned(addr) >= 32'h06000000 && $unsigned(addr) <= 32'h060010ff)    ) return WB_SLAVE_FLASH;
    if (        ($unsigned(addr) >= 32'h03000000 && $unsigned(addr) <= 32'h0341dfff)    ) return WB_SLAVE_BRAM;
    if (        ($unsigned(addr) >= 32'h05000000 && $unsigned(addr) <= 32'h05000073)    ) return WB_SLAVE_PERIPHERALS;
    return WB_SLAVE_NONE; // No slave selected
endfunction
// ------------------------------------------------------------------------------------
// Functions for slaves
// ------------------------------------------------------------------------------------

`ifdef SIMULATION

// Slave can use these to determine whether it is selected by the given address
localparam sdram_bitpos                        = 0;
localparam flash_bitpos                        = 1;
localparam bram_bitpos                         = 2;
localparam peripherals_bitpos                  = 3;

function logic is_selected_slave_sdram (input logic [31:0] addr, input logic [3:0] slave_sel_i);
    is_selected_slave_sdram                    = slave_sel_i[sdram_bitpos];
endfunction
function logic is_selected_slave_flash (input logic [31:0] addr, input logic [3:0] slave_sel_i);
    is_selected_slave_flash                    = slave_sel_i[flash_bitpos];
endfunction
function logic is_selected_slave_bram (input logic [31:0] addr, input logic [3:0] slave_sel_i);
    is_selected_slave_bram                     = slave_sel_i[bram_bitpos];
endfunction
function logic is_selected_slave_peripherals (input logic [31:0] addr, input logic [3:0] slave_sel_i);
    is_selected_slave_peripherals              = slave_sel_i[peripherals_bitpos];
endfunction

`ifdef SLANG
$static_assert(is_selected_slave_sdram(32'h0000_0000, WB_SLAVE_SDRAM), "WB_SLAVE_SDRAM should cause selected slave to be sdram");
$static_assert(!is_selected_slave_sdram(32'h0000_0000, WB_SLAVE_FLASH), "WB_SLAVE_FLASH should not cause selected slave to be sdram");
$static_assert(!is_selected_slave_sdram(32'h0000_0000, WB_SLAVE_BRAM), "WB_SLAVE_BRAM should not cause selected slave to be sdram");
$static_assert(!is_selected_slave_sdram(32'h0000_0000, WB_SLAVE_PERIPHERALS), "WB_SLAVE_PERIPHERALS should not cause selected slave to be sdram");
$static_assert(!is_selected_slave_sdram(32'h0000_0000, WB_SLAVE_NONE), "WB_SLAVE_NONE should not cause selected slave to be sdram");

$static_assert(!is_selected_slave_flash(32'h0000_0000, WB_SLAVE_SDRAM), "WB_SLAVE_SDRAM should not cause selected slave to be flash");
$static_assert(is_selected_slave_flash(32'h0000_0000, WB_SLAVE_FLASH), "WB_SLAVE_FLASH should cause selected slave to be flash");
$static_assert(!is_selected_slave_flash(32'h0000_0000, WB_SLAVE_BRAM), "WB_SLAVE_BRAM should not cause selected slave to be flash");
$static_assert(!is_selected_slave_flash(32'h0000_0000, WB_SLAVE_PERIPHERALS), "WB_SLAVE_PERIPHERALS should not cause selected slave to be flash");
$static_assert(!is_selected_slave_flash(32'h0000_0000, WB_SLAVE_NONE), "WB_SLAVE_NONE should not cause selected slave to be flash");

$static_assert(!is_selected_slave_bram(32'h0000_0000, WB_SLAVE_SDRAM), "WB_SLAVE_SDRAM should not cause selected slave to be bram");
$static_assert(!is_selected_slave_bram(32'h0000_0000, WB_SLAVE_FLASH), "WB_SLAVE_FLASH should not cause selected slave to be bram");
$static_assert(is_selected_slave_bram(32'h0000_0000, WB_SLAVE_BRAM), "WB_SLAVE_BRAM should not cause selected slave to be bram");
$static_assert(!is_selected_slave_bram(32'h0000_0000, WB_SLAVE_PERIPHERALS), "WB_SLAVE_PERIPHERALS should not cause selected slave to be bram");
$static_assert(!is_selected_slave_bram(32'h0000_0000, WB_SLAVE_NONE), "WB_SLAVE_NONE should not cause selected slave to be bram");

$static_assert(!is_selected_slave_peripherals(32'h0000_0000, WB_SLAVE_SDRAM), "WB_SLAVE_SDRAM should not cause selected slave to be peripherals");
$static_assert(!is_selected_slave_peripherals(32'h0000_0000, WB_SLAVE_FLASH), "WB_SLAVE_FLASH should not cause selected slave to be peripherals");
$static_assert(!is_selected_slave_peripherals(32'h0000_0000, WB_SLAVE_BRAM), "WB_SLAVE_BRAM should not cause selected slave to be peripherals");
$static_assert(is_selected_slave_peripherals(32'h0000_0000, WB_SLAVE_PERIPHERALS), "WB_SLAVE_PERIPHERALS should cause selected slave to be peripherals");
$static_assert(!is_selected_slave_peripherals(32'h0000_0000, WB_SLAVE_NONE), "WB_SLAVE_NONE should not cause selected slave to be peripherals");
`endif

`endif

// convert one-hot to index using priority encoder
function automatic int get_slave_idx (input logic [3:0] slave_sel_i);
    get_slave_idx = 0; // default to none selected
    for (int i = 0; i < WB_SLV_CNT; i++) begin
        if (slave_sel_i[i]) begin 
            get_slave_idx = i;
        end
    end
endfunction

`ifdef SLANG
$static_assert(get_slave_idx(WB_SLAVE_SDRAM) == sdram_bitpos, "WB_SLAVE_SDRAM should have index 0");
$static_assert(get_slave_idx(WB_SLAVE_FLASH) == flash_bitpos, "WB_SLAVE_FLASH should have index 1");
$static_assert(get_slave_idx(WB_SLAVE_BRAM) == bram_bitpos, "WB_SLAVE_BRAM should have index 2");
$static_assert(get_slave_idx(WB_SLAVE_PERIPHERALS) == peripherals_bitpos, "WB_SLAVE_PERIPHERALS should have index 3");
$static_assert(get_slave_idx(WB_SLAVE_NONE) == 0, "WB_SLAVE_NONE should have index 0");
`endif

// ------------------------------------------------------------------------------------
// Functions for access legality
// ------------------------------------------------------------------------------------

typedef enum logic [0:0] {
    READ_LEGAL  = 1'b0,
    WRITE_LEGAL = 1'b1
} access_mode_t;
function logic is_legal_access_sdram(input logic[31:0] addr, access_mode_t access);
    case (access)
        READ_LEGAL:  is_legal_access_sdram = ($unsigned(addr) <= 32'h01ffffff);
        WRITE_LEGAL: is_legal_access_sdram = ($unsigned(addr) <= 32'h01ffffff);
        default:     is_legal_access_sdram = 1'b0;
    endcase
endfunction

function logic is_legal_access_flash(input logic[31:0] addr, access_mode_t access);
    case (access)
        READ_LEGAL:  is_legal_access_flash = ($unsigned(addr) >= 32'h02000000 && $unsigned(addr) <= 32'h02ffffff) ||
        ($unsigned(addr) >= 32'h06000004 && $unsigned(addr) <= 32'h06000013) ||
        ($unsigned(addr) >= 32'h06001000 && $unsigned(addr) <= 32'h060010ff);
        WRITE_LEGAL: is_legal_access_flash = ($unsigned(addr) >= 32'h06000000 && $unsigned(addr) <= 32'h0600000f) ||
        ($unsigned(addr) >= 32'h06001000 && $unsigned(addr) <= 32'h060010ff);
        default:     is_legal_access_flash = 1'b0;
    endcase
endfunction

function logic is_legal_access_bram(input logic[31:0] addr, access_mode_t access);
    case (access)
        READ_LEGAL:  is_legal_access_bram = ($unsigned(addr) >= 32'h03000000 && $unsigned(addr) <= 32'h0341dfff);
        WRITE_LEGAL: is_legal_access_bram = ($unsigned(addr) >= 32'h03000000 && $unsigned(addr) <= 32'h0341dfff);
        default:     is_legal_access_bram = 1'b0;
    endcase
endfunction

function logic is_legal_access_peripherals(input logic[31:0] addr, access_mode_t access);
    case (access)
        READ_LEGAL:  is_legal_access_peripherals = ($unsigned(addr) >= 32'h05000000 && $unsigned(addr) <= 32'h0500000b) ||
        ($unsigned(addr) >= 32'h05000010 && $unsigned(addr) <= 32'h0500001b) ||
        ($unsigned(addr) >= 32'h05000020 && $unsigned(addr) <= 32'h0500002b) ||
        ($unsigned(addr) >= 32'h05000040 && $unsigned(addr) <= 32'h05000047) ||
        ($unsigned(addr) >= 32'h05000070 && $unsigned(addr) <= 32'h05000073);
        WRITE_LEGAL: is_legal_access_peripherals = ($unsigned(addr) >= 32'h0500000c && $unsigned(addr) <= 32'h0500000f) ||
        ($unsigned(addr) >= 32'h0500001c && $unsigned(addr) <= 32'h0500001f) ||
        ($unsigned(addr) >= 32'h0500002c && $unsigned(addr) <= 32'h0500002f) ||
        ($unsigned(addr) >= 32'h05000040 && $unsigned(addr) <= 32'h05000043) ||
        ($unsigned(addr) >= 32'h0500004c && $unsigned(addr) <= 32'h0500004f) ||
        ($unsigned(addr) >= 32'h05000060 && $unsigned(addr) <= 32'h05000063);
        default:     is_legal_access_peripherals = 1'b0;
    endcase
endfunction

// ------------------------------------------------------------------------------------
// Register address constants
// ------------------------------------------------------------------------------------


//
// Flash register addresses
//
localparam REG_FLASH_COMMAND_REGISTER         = 32'h06000000;
localparam REG_FLASH_COMMAND_ADDRESS          = 32'h06000004;
localparam REG_FLASH_COMMAND_TAG_HIGH         = 32'h06000008;
localparam REG_FLASH_COMMAND_TAG_LOW          = 32'h0600000c;
localparam REG_FLASH_COMMAND_STATUS           = 32'h06000010;

//
// Peripherals register addresses
//
localparam REG_UART_RX_STATUS                 = 32'h05000000;
localparam REG_UART_TX_STATUS                 = 32'h05000004;
localparam REG_UART_RX_READ_ADDRESS           = 32'h05000008;
localparam REG_UART_TX_WRITE_ADDRESS          = 32'h0500000c;
localparam REG_SPI_RX_STATUS                  = 32'h05000010;
localparam REG_SPI_TX_STATUS                  = 32'h05000014;
localparam REG_SPI_RX_READ_ADDRESS            = 32'h05000018;
localparam REG_SPI_TX_WRITE_ADDRESS           = 32'h0500001c;
localparam REG_I2C_RX_STATUS                  = 32'h05000020;
localparam REG_I2C_TX_STATUS                  = 32'h05000024;
localparam REG_I2C_RX_READ_ADDRESS            = 32'h05000028;
localparam REG_I2C_TX_WRITE_ADDRESS           = 32'h0500002c;
localparam REG_GPIO_DIRECTION                 = 32'h05000040;
localparam REG_INPUT_GPIOS                    = 32'h05000044;
localparam REG_OUTPUT_GPIOS                   = 32'h0500004c;
localparam REG_LEDS                           = 32'h05000060;
localparam REG_SWITCHES_INPUTS_READ           = 32'h05000070;

// ------------------------------------------------------------------------------------
// Register test functions
// ------------------------------------------------------------------------------------


//
// Flash register test functions
//

// is addr the Flash Command Register?
function logic is_addr_flash_command_register (input logic [31:0] addr);
    is_addr_flash_command_register = (addr==REG_FLASH_COMMAND_REGISTER);
endfunction
// is addr the Flash Command Address?
function logic is_addr_flash_command_address_register (input logic [31:0] addr);
    is_addr_flash_command_address_register = (addr==REG_FLASH_COMMAND_ADDRESS);
endfunction
// is addr the Flash Command Tag High?
function logic is_addr_flash_command_tag_high_register (input logic [31:0] addr);
    is_addr_flash_command_tag_high_register = (addr==REG_FLASH_COMMAND_TAG_HIGH);
endfunction
// is addr the Flash Command Tag Low?
function logic is_addr_flash_command_tag_low_register (input logic [31:0] addr);
    is_addr_flash_command_tag_low_register = (addr==REG_FLASH_COMMAND_TAG_LOW);
endfunction
// is addr the Flash Command Status?
function logic is_addr_flash_command_status_register (input logic [31:0] addr);
    is_addr_flash_command_status_register = (addr==REG_FLASH_COMMAND_STATUS);
endfunction


//
// Peripherals register test functions
//

// is addr the UART RX Status?
function logic is_addr_uart_rx_status_register (input logic [31:0] addr);
    is_addr_uart_rx_status_register = (addr==REG_UART_RX_STATUS);
endfunction
// is addr the UART TX Status?
function logic is_addr_uart_tx_status_register (input logic [31:0] addr);
    is_addr_uart_tx_status_register = (addr==REG_UART_TX_STATUS);
endfunction
// is addr the UART RX Read Address?
function logic is_addr_uart_rx_read_address_register (input logic [31:0] addr);
    is_addr_uart_rx_read_address_register = (addr==REG_UART_RX_READ_ADDRESS);
endfunction
// is addr the UART TX Write Address?
function logic is_addr_uart_tx_write_address_register (input logic [31:0] addr);
    is_addr_uart_tx_write_address_register = (addr==REG_UART_TX_WRITE_ADDRESS);
endfunction
// is addr the SPI RX Status?
function logic is_addr_spi_rx_status_register (input logic [31:0] addr);
    is_addr_spi_rx_status_register = (addr==REG_SPI_RX_STATUS);
endfunction
// is addr the SPI TX Status?
function logic is_addr_spi_tx_status_register (input logic [31:0] addr);
    is_addr_spi_tx_status_register = (addr==REG_SPI_TX_STATUS);
endfunction
// is addr the SPI RX Read Address?
function logic is_addr_spi_rx_read_address_register (input logic [31:0] addr);
    is_addr_spi_rx_read_address_register = (addr==REG_SPI_RX_READ_ADDRESS);
endfunction
// is addr the SPI TX Write Address?
function logic is_addr_spi_tx_write_address_register (input logic [31:0] addr);
    is_addr_spi_tx_write_address_register = (addr==REG_SPI_TX_WRITE_ADDRESS);
endfunction
// is addr the I2C RX Status?
function logic is_addr_i2c_rx_status_register (input logic [31:0] addr);
    is_addr_i2c_rx_status_register = (addr==REG_I2C_RX_STATUS);
endfunction
// is addr the I2C TX Status?
function logic is_addr_i2c_tx_status_register (input logic [31:0] addr);
    is_addr_i2c_tx_status_register = (addr==REG_I2C_TX_STATUS);
endfunction
// is addr the I2C RX Read Address?
function logic is_addr_i2c_rx_read_address_register (input logic [31:0] addr);
    is_addr_i2c_rx_read_address_register = (addr==REG_I2C_RX_READ_ADDRESS);
endfunction
// is addr the I2C TX Write Address?
function logic is_addr_i2c_tx_write_address_register (input logic [31:0] addr);
    is_addr_i2c_tx_write_address_register = (addr==REG_I2C_TX_WRITE_ADDRESS);
endfunction
// is addr the GPIO Direction?
function logic is_addr_gpio_direction_register (input logic [31:0] addr);
    is_addr_gpio_direction_register = (addr==REG_GPIO_DIRECTION);
endfunction
// is addr the Input GPIOs?
function logic is_addr_input_gpios_register (input logic [31:0] addr);
    is_addr_input_gpios_register = (addr==REG_INPUT_GPIOS);
endfunction
// is addr the Output GPIOs?
function logic is_addr_output_gpios_register (input logic [31:0] addr);
    is_addr_output_gpios_register = (addr==REG_OUTPUT_GPIOS);
endfunction
// is addr the LEDs?
function logic is_addr_leds_register (input logic [31:0] addr);
    is_addr_leds_register = (addr==REG_LEDS);
endfunction
// is addr the Switches Inputs Read?
function logic is_addr_switches_inputs_read_register (input logic [31:0] addr);
    is_addr_switches_inputs_read_register = (addr==REG_SWITCHES_INPUTS_READ);
endfunction


// ------------------------------------------------------------------------------------
// Range and buffer test functions
// ------------------------------------------------------------------------------------

//
// SDRAM range and buffer test functions
//

// is addr handled by SDRAM bus slave
function logic is_addr_in_sdram (input logic [31:0] addr);
    is_addr_in_sdram = ($unsigned(addr) <= 32'h01ffffff    );
endfunction

// is addr in range SDRAM of the SDRAM bus slave?
function logic is_addr_in_sdram_range (input logic [31:0] addr);
    is_addr_in_sdram_range = ($unsigned(addr) <= 32'h01ffffff);
endfunction

//
// Flash range and buffer test functions
//

// is addr handled by Flash bus slave
function logic is_addr_in_flash (input logic [31:0] addr);
    is_addr_in_flash = (($unsigned(addr) >= 32'h02000000 && $unsigned(addr) <= 32'h02ffffff) ||($unsigned(addr) >= 32'h06000000 && $unsigned(addr) <= 32'h060010ff)    );
endfunction

// is addr in range Flash ROM of the Flash bus slave?
function logic is_addr_in_flash_rom_range (input logic [31:0] addr);
    is_addr_in_flash_rom_range = ($unsigned(addr) >= 32'h02000000 && $unsigned(addr) <= 32'h02ffffff);
endfunction
// is addr in range Flash Control of the Flash bus slave?
function logic is_addr_in_flash_control_range (input logic [31:0] addr);
    is_addr_in_flash_control_range = ($unsigned(addr) >= 32'h06000000 && $unsigned(addr) <= 32'h060010ff);
endfunction
// is addr in buffer Flash Page Buffer?
function logic is_addr_in_flash_page_buffer (input logic [31:0] addr);
    is_addr_in_flash_page_buffer = ($unsigned(addr) >= 32'h06001000 && $unsigned(addr) <= 32'h060010ff);
endfunction

//
// BRAM range and buffer test functions
//

// is addr handled by BRAM bus slave
function logic is_addr_in_bram (input logic [31:0] addr);
    is_addr_in_bram = (($unsigned(addr) >= 32'h03000000 && $unsigned(addr) <= 32'h0341dfff)    );
endfunction

// is addr in range BRAM of the BRAM bus slave?
function logic is_addr_in_bram_range (input logic [31:0] addr);
    is_addr_in_bram_range = ($unsigned(addr) >= 32'h03000000 && $unsigned(addr) <= 32'h0341dfff);
endfunction
// is addr in buffer OLED 1 Buffer?
function logic is_addr_in_oled_1_buffer (input logic [31:0] addr);
    is_addr_in_oled_1_buffer = ($unsigned(addr) >= 32'h03000000 && $unsigned(addr) <= 32'h03005fff);
endfunction
// is addr in buffer OLED 2 Buffer?
function logic is_addr_in_oled_2_buffer (input logic [31:0] addr);
    is_addr_in_oled_2_buffer = ($unsigned(addr) >= 32'h03006000 && $unsigned(addr) <= 32'h0300bfff);
endfunction
// is addr in buffer OLED 3 Buffer?
function logic is_addr_in_oled_3_buffer (input logic [31:0] addr);
    is_addr_in_oled_3_buffer = ($unsigned(addr) >= 32'h0300c000 && $unsigned(addr) <= 32'h03011fff);
endfunction
// is addr in buffer OLED 4 Buffer?
function logic is_addr_in_oled_4_buffer (input logic [31:0] addr);
    is_addr_in_oled_4_buffer = ($unsigned(addr) >= 32'h03012000 && $unsigned(addr) <= 32'h03017fff);
endfunction
// is addr in buffer OLED 5 Buffer?
function logic is_addr_in_oled_5_buffer (input logic [31:0] addr);
    is_addr_in_oled_5_buffer = ($unsigned(addr) >= 32'h03018000 && $unsigned(addr) <= 32'h0301dfff);
endfunction
// is addr in buffer VGA Buffer?
function logic is_addr_in_vga_buffer (input logic [31:0] addr);
    is_addr_in_vga_buffer = ($unsigned(addr) >= 32'h0301e000 && $unsigned(addr) <= 32'h0341dfff);
endfunction

//
// Peripherals range and buffer test functions
//

// is addr handled by Peripherals bus slave
function logic is_addr_in_peripherals (input logic [31:0] addr);
    is_addr_in_peripherals = (($unsigned(addr) >= 32'h05000000 && $unsigned(addr) <= 32'h05000073)    );
endfunction

// is addr in range Peripherals of the Peripherals bus slave?
function logic is_addr_in_peripherals_range (input logic [31:0] addr);
    is_addr_in_peripherals_range = ($unsigned(addr) >= 32'h05000000 && $unsigned(addr) <= 32'h05000073);
endfunction

// verilator lint_on UNUSEDPARAM

endpackage

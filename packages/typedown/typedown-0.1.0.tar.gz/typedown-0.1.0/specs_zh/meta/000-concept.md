# Typedown 核心概念

Typedown 的设计初衷是降低“渐进式形式化”过程中的思维阻力。它不是要取代 Markdown，而是增强它。

## 什么是“渐进式形式化”？

在项目初期，我们的想法往往是发散的、非结构化的。此时，Markdown 是最好的载体。随着项目的推进，我们需要对这些想法进行约束、验证和关联。

Typedown 不仅仅是让 Markdown 支持数据，更提供了一套**模型演进的方法论**：

1. **起步：文档即定义**
   初期，你可以在 Typedown 文档中直接定义 Schema (数据模型)。这让你无需离开文档环境即可快速构建和调整数据结构。

2. **固化：迁移至代码**
   当模型结构稳定后，你可以将其迁移至标准的 Python 代码中。这一过程对数据层是透明的，运行结果完全一致，但能让你享受版本控制和 IDE 的全部能力。

3. **迭代：安全的覆盖机制**
   当需要引入新特性时，你无需直接修改生产环境的 Python 代码。Typedown 允许你在文档中临时定义一个同名类来**覆盖**原有定义。这让你能够在正式重构之前，在一个沙盒环境中测试新模型或新约束对现有数据的影响，清晰地理解变更的副作用。

## 核心三要素

1. **Markdown (宿主)**: 提供人类可读的上下文。
2. **Pydantic (结构)**: 提供数据校验和类型定义。
3. **Pytest (逻辑)**: 提供跨文件的引用完整性检查和复杂逻辑验证。

## 关键术语

### 数据结构

- **Model (模型)**: 定义数据结构的蓝图，通常由 Pydantic 类表示。它决定了数据包含哪些字段以及字段的类型。
- **Entity (实体)**: Model 的具体实例化对象。它们以 Markdown 代码块的形式存在于文档中，承载具体的数据内容。

### 处理流程

- **Desugar (脱糖)**: 编译器解析 Entity 之间的关系（如 `former`, `derived_from`），将引用的部分展开，形成完整独立对象的过程。
- **Materialize (物化)**: 可选步骤。将脱糖后的完整数据回填到 Markdown 源码中，提升文档的自解释性和阅读体验。

### 验证层级

- **Validator (验证器)**: **关注个体内部的正确性**。通常使用 Pydantic validator 实现，负责检查 Entity 自身的字段是否合法（如：分数不能为负数，日期格式必须正确）。这是常识逻辑。
- **Specification (规格)**: **关注系统层面的正确性**。通常涉及复杂的业务逻辑，需要访问全局的实体表（Entity Table）才能进行判断（如：确保怪物掉落的物品 ID 确实存在于物品表中）。这需要引入 Fixture 和 Test-case 来辅助表达。

### 运行环境

- **Context (上下文)**: 决定当前文档可用的 Model 定义集合。它采用**逐层注入与覆盖**的机制，加载顺序如下（后加载的同名 Model 会覆盖前者）：
  1. **Python 代码**: 基础定义。
  2. **根目录 `config.td`**: 项目级覆盖。
  3. **逐级目录 `config.td`**: 目录级覆盖。
  4. **当前文件 `model` block**: 文件级临时定义或测试用覆盖。

<!DOCTYPE html>
<html lang="en" data-theme="playbooks-light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Playbooks playground</title>

    <!-- Fonts - Inter & Source Serif -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Source+Serif+4:wght@600;700&display=swap"
      rel="stylesheet"
    />

    <!-- Tailwind CSS with DaisyUI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/daisyui@4.12.14/dist/full.min.css"
      rel="stylesheet"
      type="text/css"
    />

    <!-- React and ReactDOM from CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>

    <!-- Babel for JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Heroicons -->
    <script
      src="https://unpkg.com/heroicons@2.0.18/24/outline/index.js"
      type="module"
    ></script>

    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>

    <!-- Prism.js for syntax highlighting -->
    <link
      href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <style>
      html {
        font-size: 16px;
      }

      :root {
        --foreground-rgb: 0, 0, 0;
        --background-start-rgb: 214, 219, 220;
        --background-end-rgb: 255, 255, 255;
        --font-source-serif-pro: "Source Serif 4", Georgia, Cambria,
          "Times New Roman", Times, serif;

        --background: 0 0% 99%;
        --foreground: 0 0% 10%;
        --card: 0 0% 100%;
        --card-foreground: 0 0% 12%;
        --popover: 0 0% 100%;
        --popover-foreground: 0 0% 12%;
        --primary: 213 85% 54%;
        --primary-foreground: 0 0% 98%;
        --secondary: 28 92% 56%;
        --secondary-foreground: 0 0% 12%;
        --muted: 0 0% 94%;
        --muted-foreground: 0 0% 40%;
        --accent: 48 96% 58%;
        --accent-foreground: 0 0% 12%;
        --destructive: 0 72% 50%;
        --destructive-foreground: 0 0% 98%;
        --border: 0 0% 85%;
        --input: 0 0% 92%;
        --ring: 213 85% 54%;
        --radius: 0.75rem;
      }

      :root[data-theme="playbooks-dark"] {
        --foreground-rgb: 245, 245, 255;
        --background-start-rgb: 0, 0, 0;
        --background-end-rgb: 0, 0, 0;

        --background: 220 18% 10%;
        --foreground: 0 0% 90%;
        --card: 220 15% 13%;
        --card-foreground: 0 0% 88%;
        --popover: 220 15% 13%;
        --popover-foreground: 0 0% 88%;
        --primary: 205 100% 68%;
        --primary-foreground: 0 0% 12%;
        --secondary: 28 92% 62%;
        --secondary-foreground: 0 0% 12%;
        --muted: 220 10% 22%;
        --muted-foreground: 0 0% 72%;
        --accent: 48 95% 64%;
        --accent-foreground: 0 0% 10%;
        --destructive: 0 72% 55%;
        --destructive-foreground: 0 0% 98%;
        --border: 220 10% 26%;
        --input: 220 10% 26%;
        --ring: 205 100% 68%;
      }

      /* Map palette to DaisyUI tokens */
      :root[data-theme="playbooks-light"],
      :root[data-theme="playbooks-dark"] {
        color-scheme: light;
        --b1: hsl(var(--card));
        --b2: hsl(var(--background));
        --b3: hsl(var(--muted));
        --bc: hsl(var(--foreground));
        --p: hsl(var(--primary));
        --pc: hsl(var(--primary-foreground));
        --s: hsl(var(--secondary));
        --sc: hsl(var(--secondary-foreground));
        --a: hsl(var(--accent));
        --ac: hsl(var(--accent-foreground));
        --n: hsl(var(--muted));
        --nc: hsl(var(--foreground));
        --in: #2563eb;
        --su: #15803d;
        --wa: #b45309;
        --er: #dc2626;
        --rounded-box: 1rem;
        --rounded-btn: 0.75rem;
        --shadow-soft: 0 20px 60px rgba(0, 0, 0, 0.08);
      }

      :root[data-theme="playbooks-dark"] {
        color-scheme: dark;
        --shadow-soft: 0 20px 60px rgba(0, 0, 0, 0.35);
      }

      body {
        font-family: "Inter", "SF Pro Text", -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        margin: 0;
        background: hsl(var(--background));
        color: hsl(var(--foreground));
        min-height: 100vh;
        letter-spacing: -0.01em;
        overflow: hidden;
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-family: var(--font-source-serif-pro);
        font-weight: 700;
        letter-spacing: -0.03em;
      }

      /* Panels */
      .surface-card {
        background: hsl(var(--card));
      }

      .surface-card .section-header {
        border-bottom: 1px solid hsla(var(--border) / 0.8);
      }

      /* Keep all borders aligned to the same tone */
      .border-base-300 {
        border-color: hsla(var(--border) / 0.8) !important;
      }

      /* Ensure checkbox checked state is visible */
      .checkbox {
        --chkbg: hsl(var(--primary));
        --chkfg: hsl(var(--primary-foreground));
        border-color: hsla(var(--border) / 0.9);
      }

      .checkbox:checked {
        background-color: var(--chkbg);
        border-color: var(--chkbg);
      }

      .app-shell {
        width: 100%;
        margin: 0;
      }

      /* Custom styles for syntax highlighting and markdown */
      .markdown-content {
        line-height: 1.7;
      }

      .markdown-content p {
        margin: 0.5rem 0;
      }

      .markdown-content p:first-child {
        margin-top: 0;
      }

      .markdown-content p:last-child {
        margin-bottom: 0;
      }

      .markdown-content h1,
      .markdown-content h2,
      .markdown-content h3,
      .markdown-content h4,
      .markdown-content h5,
      .markdown-content h6 {
        margin: 1rem 0 0.5rem 0;
        font-weight: 700;
        color: hsl(var(--foreground));
      }

      .markdown-content ul,
      .markdown-content ol {
        margin: 0.5rem 0;
        padding-left: 1.5rem;
      }

      .markdown-content li {
        margin: 0.25rem 0;
      }

      .markdown-content blockquote {
        border-left: 4px solid hsla(var(--border) / 0.9);
        padding-left: 1rem;
        margin: 1rem 0;
        color: hsl(var(--muted-foreground));
        font-style: italic;
      }

      .markdown-content pre {
        background: hsla(var(--muted) / 0.65);
        padding: 1rem;
        border-radius: calc(var(--radius) * 0.9);
        overflow-x: auto;
        margin: 1rem 0;
        border: 1px solid hsla(var(--border) / 0.7);
      }

      .markdown-content code {
        background: hsla(var(--accent) / 0.6);
        padding: 0.2rem 0.5rem;
        border-radius: 0.4rem;
        font-size: 0.9em;
      }

      .markdown-content pre code {
        background: none;
        padding: 0;
      }

      .markdown-content strong {
        font-weight: 700;
      }

      .markdown-content em {
        font-style: italic;
      }

      .markdown-content a {
        color: hsl(var(--ring));
        text-decoration: underline;
      }

      .markdown-content a:hover {
        color: hsl(var(--foreground));
      }

      .chat-bubble {
        border-radius: 1rem;
        box-shadow: var(--shadow-soft);
        border: 1px solid hsla(var(--border) / 0.8);
      }

      .chat-bubble.chat-bubble-user {
        background: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
      }

      .chat-bubble.chat-bubble-assistant::before {
        display: none;
      }
      .chat-bubble.chat-bubble-assistant {
        background: hsl(var(--secondary));
        color: hsl(var(--secondary-foreground));
        padding: 0.9rem 1rem;
        margin: 0;
        margin-top: 0.5rem;
      }

      .chat.chat-log {
        margin: 0 !important;
        padding: 0 !important;
      }

      /* Event visibility controls */
      body:not(.show-messages) .event-message {
        display: none !important;
      }

      body:not(.show-execution-logs) .event-session-log {
        display: none !important;
      }

      .status-pill {
        border-radius: 9999px;
        padding: 0.2rem 0.75rem;
        border: 1px solid hsla(var(--border) / 0.8);
        background: hsla(var(--muted) / 0.7);
      }

      .hero-eyebrow {
        font-size: 0.9rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: hsl(var(--muted-foreground));
      }

      .glass-input {
        background: hsla(var(--card) / 0.75);
        border: 1px solid hsla(var(--border) / 0.85);
        box-shadow: inset 0 1px 0 hsla(0, 0%, 100%, 0.08);
      }
    </style>
  </head>
  <body class="bg-base-200 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // Message component with markdown support
      function Message({ message }) {
        const messageRef = useRef(null);

        useEffect(() => {
          if (messageRef.current && window.Prism) {
            window.Prism.highlightAllUnder(messageRef.current);
          }
        }, [message.content]);

        const renderContent = (content, message) => {
          // Handle log entries specially
          if (message.role === "log" && message.content.indicator) {
            const logData = message.content;
            const levelColors = {
              HIGH: "text-red-600",
              MEDIUM: "text-yellow-600",
              LOW: "text-gray-600",
            };

            return (
              <div
                className={`flex items-start gap-2 ${
                  levelColors[logData.level] || "text-gray-600"
                }`}
              >
                <span className="flex-1 font-mono text-xs">
                  {message.sender}: {message["metadata"]["log_full"]}
                </span>
              </div>
            );
          }

          if (typeof content === "string") {
            // Configure marked to handle line breaks properly
            marked.setOptions({
              breaks: true, // Convert \n to <br>
              gfm: true, // GitHub Flavored Markdown
            });
            const html = marked.parse(content);
            return (
              <div
                className="markdown-content"
                dangerouslySetInnerHTML={{ __html: html }}
              />
            );
          }
          return <div>{content}</div>;
        };

        const getBadgeColor = (role) => {
          switch (role) {
            case "user":
              return "badge";
            case "assistant":
              return "badge";
            case "system":
              return "badge";
            default:
              return "badge";
          }
        };

        const getChatClass = (role) => {
          const side = role === "user" ? "chat-start" : "chat-start";
          let eventClass = "";

          // Add event type classes for filtering
          if (role === "assistant" || role === "user") {
            eventClass += " event-message";
          }
          if (role === "log") {
            eventClass += " event-session-log";
          }

          return `chat ${side} chat-${role}${eventClass}`;
        };

        const getChatBubbleClass = (role) => {
          switch (role) {
            case "user":
              return "chat-bubble chat-bubble-primary chat-bubble-user";
            case "assistant":
              return "chat-bubble chat-bubble-assistant";
            case "system":
              return "text-xs pl-3";
            case "log":
              return "text-sm pl-3 opacity-75";
            default:
              return "chat-bubble-neutral";
          }
        };

        const renderChatHeader = (message) => {
          if (message.role === "system" || message.role === "log") {
            return null;
          }
          if (message.role === "assistant") {
            return (
              <div className="chat-header">
                <span className="text-xs">
                  {message.messageType === "MEETING_BROADCAST_REQUEST" &&
                  message.meetingId
                    ? `MEETING: ${message.sender} ‚Üí Meeting(${message.meetingId})`
                    : message.messageType
                    ? `${message.messageType}: ${message.sender} ‚Üí ${message.recipient}`
                    : `${message.sender} ‚Üí ${message.recipient}`}
                </span>
                {message.timestamp && (
                  <time className="text-xs opacity-50 ml-2">
                    {new Date(message.timestamp).toLocaleTimeString()}
                  </time>
                )}
              </div>
            );
          }

          if (message.role === "user") {
            return (
              <div className="chat-header">
                {message.timestamp && (
                  <time className="text-xs opacity-50 ml-2">
                    {new Date(message.timestamp).toLocaleTimeString()}
                  </time>
                )}
              </div>
            );
          }
        };

        return (
          <div className={`${getChatClass(message.role)}`} ref={messageRef}>
            {renderChatHeader(message)}

            <div
              className={`${getChatBubbleClass(message.role)} ${
                message.isStreaming ? "relative" : ""
              }`}
            >
              {renderContent(message.content, message)}
              {message.isStreaming && (
                <span className="inline-block ml-1 w-2 h-4 bg-current opacity-75 animate-pulse">
                  |
                </span>
              )}
            </div>
          </div>
        );
      }

      // Status indicator component
      function StatusIndicator({ status, text, eventCount }) {
        const getStatusColor = () => {
          switch (status) {
            case "connected":
              return "bg-success";
            case "connecting":
              return "bg-warning";
            case "disconnected":
              return "bg-error";
            default:
              return "bg-base-300";
          }
        };

        return (
          <div className="status-pill flex items-center gap-3 justify-center">
            <div className="flex items-center gap-2">
              <div className={`w-3 h-3 rounded-full ${getStatusColor()}`}></div>
              <span className="text-sm font-medium">{text}</span>
            </div>
            <div className="badge badge-outline badge-sm border-base-300">
              Events: {eventCount}
            </div>
          </div>
        );
      }

      // Welcome screen component
      function WelcomeScreen() {
        return (
          <div className="text-center p-8">
            <h3 className="text-2xl font-bold mb-4">
              Welcome to Playbooks Playground!
            </h3>
            <p className="text-base-content/70 mb-6">
              This is a playground to run and interact with Playbooks programs.
              It also serves as documentation for how to integrate web UI with
              Playbooks web server.
            </p>
            <div className="steps steps-vertical lg:steps-horizontal">
              <div className="step step-primary">
                <div className="text-left">
                  <div className="font-semibold">Start playground</div>
                  <div className="text-sm opacity-70">
                    Run{" "}
                    <code className="bg-base-200 px-2 py-1 rounded">
                      playbooks playground
                    </code>{" "}
                    to start server and open browser
                  </div>
                </div>
              </div>
              <div className="step step-primary">
                <div className="text-left">
                  <div className="font-semibold">
                    Enter Playbooks program path
                  </div>
                  <div className="text-sm opacity-70">
                    Use the default or enter your own
                  </div>
                </div>
              </div>
              <div className="step step-primary">
                <div className="text-left">
                  <div className="font-semibold">Run the program</div>
                  <div className="text-sm opacity-70">
                    Click "Run Program" to begin
                  </div>
                </div>
              </div>
              <div className="step step-primary">
                <div className="text-left">
                  <div className="font-semibold">See it in action</div>
                  <div className="text-sm opacity-70">
                    Watch and interact with the AI agents in real-time!
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }

      function ProgramViewer({
        programContent,
        programPaths,
        isLoading,
        error,
      }) {
        const hasProgram = Boolean(programContent);
        const hasPaths = programPaths && programPaths.length > 0;

        return (
          <div className="surface-card flex-col h-full min-h-0 border-r border-base-300">
            <div className="section-header flex items-center justify-between px-6 lg:px-8 py-3">
              <div className="space-y-1">
                <div className="text-sm font-semibold tracking-tight">
                  Loaded Program
                </div>
                <div className="text-xs text-base-content/70 truncate">
                  {hasPaths ? programPaths.join(", ") : "No program loaded yet"}
                </div>
              </div>
              {isLoading && (
                <span className="loading loading-spinner loading-sm" />
              )}
            </div>
            <div className="flex-1 overflow-y-auto p-4 px-6 lg:px-8 space-y-3 bg-card">
              {error && (
                <div className="alert alert-error text-sm">
                  <span>{error}</span>
                </div>
              )}

              {!hasProgram && !error && (
                <p className="text-sm text-base-content/70">
                  {isLoading
                    ? "Fetching program..."
                    : "Start a run to preview the loaded program here."}
                </p>
              )}

              {hasProgram && (
                <code className="font-mono whitespace-pre-wrap">
                  {programContent}
                </code>
              )}
            </div>
          </div>
        );
      }

      const getInitialTheme = () => {
        if (typeof window === "undefined") return "light";
        const saved = localStorage.getItem("playbooks-theme");
        if (saved === "light" || saved === "dark") return saved;
        return window.matchMedia("(prefers-color-scheme: dark)").matches
          ? "dark"
          : "light";
      };

      // Main App component
      function App() {
        const [ws, setWs] = useState(null);
        const [runId, setRunId] = useState(null);
        const [eventCounter, setEventCounter] = useState(0);
        const [isConnected, setIsConnected] = useState(false);
        const [status, setStatus] = useState("disconnected");
        const [statusText, setStatusText] = useState("Disconnected");
        const [messages, setMessages] = useState([]);
        const [streamingMessages, setStreamingMessages] = useState(new Map()); // Track streaming messages by agent_id
        const [playbookPath, setPlaybookPath] = useState(
          "tests/data/02-personalized-greeting.pb"
        );
        const [messageInput, setMessageInput] = useState("");
        const [showWelcome, setShowWelcome] = useState(true);
        const [showMessages, setShowMessages] = useState(true);
        const [showExecutionLogs, setShowExecutionLogs] = useState(false);
        const [programContent, setProgramContent] = useState("");
        const [programPaths, setProgramPaths] = useState([]);
        const [programError, setProgramError] = useState(null);
        const [isProgramLoading, setIsProgramLoading] = useState(false);
        const [theme, setTheme] = useState(getInitialTheme);
        const messagesEndRef = useRef(null);

        const scrollToBottom = () => {
          messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
        };

        useEffect(() => {
          scrollToBottom();
        }, [messages, streamingMessages]);

        useEffect(() => {
          const root = document.documentElement;
          const themeName =
            theme === "dark" ? "playbooks-dark" : "playbooks-light";
          root.setAttribute("data-theme", themeName);
          root.classList.toggle("dark", theme === "dark");
          localStorage.setItem("playbooks-theme", theme);
        }, [theme]);

        useEffect(() => {
          const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
          const handler = (event) => {
            if (!localStorage.getItem("playbooks-theme")) {
              setTheme(event.matches ? "dark" : "light");
            }
          };
          const addListener = mediaQuery.addEventListener
            ? () => mediaQuery.addEventListener("change", handler)
            : () => mediaQuery.addListener(handler);
          const removeListener = mediaQuery.removeEventListener
            ? () => mediaQuery.removeEventListener("change", handler)
            : () => mediaQuery.removeListener(handler);
          addListener();
          return () => removeListener();
        }, []);

        // Update body classes for event filtering
        useEffect(() => {
          const body = document.body;
          if (showMessages) {
            body.classList.add("show-messages");
          } else {
            body.classList.remove("show-messages");
          }

          if (showExecutionLogs) {
            body.classList.add("show-execution-logs");
          } else {
            body.classList.remove("show-execution-logs");
          }
        }, [showMessages, showExecutionLogs]);

        // Set initial body classes
        useEffect(() => {
          const body = document.body;
          if (showMessages) {
            body.classList.add("show-messages");
          }
          if (showExecutionLogs) {
            body.classList.add("show-execution-logs");
          }
        }, []);

        const updateStatus = (newStatus, text) => {
          setStatus(newStatus);
          setStatusText(text);
        };

        const fetchProgramDetails = async (targetRunId) => {
          if (!targetRunId) return;

          setIsProgramLoading(true);
          setProgramError(null);
          try {
            const response = await fetch(
              `http://localhost:8080/runs/${targetRunId}/program`
            );
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }

            const data = await response.json();
            setProgramContent(data.program_content || "");
            setProgramPaths(data.program_paths || []);
          } catch (error) {
            setProgramError(error.message);
          } finally {
            setIsProgramLoading(false);
          }
        };

        const toggleEventDisplay = (eventType) => {
          if (eventType === "messages") {
            setShowMessages((prev) => !prev);
          } else if (eventType === "session_log_entry") {
            setShowExecutionLogs((prev) => !prev);
          }
        };

        const addMessage = (
          role,
          sender,
          content,
          timestamp = null,
          recipient = null,
          messageType = null,
          meetingId = null,
          metadata = null
        ) => {
          const message = {
            id: Date.now(),
            role,
            sender,
            recipient,
            messageType,
            meetingId,
            content,
            timestamp: timestamp || new Date().toISOString(),
            metadata,
          };
          setMessages((prev) => [...prev, message]);
        };

        const formatSessionLogEntry = (event) => {
          // Use appropriate log format based on item type
          const logFormat =
            event.log_compact || event.log_full || event.content;

          // Add visual indicators based on item type
          const typeIndicators = {
            playbookcall: "üìû",
            playbookcallresult: "‚úÖ",
            sessionlogitemplaybook_start: "‚ñ∂Ô∏è",
            sessionlogitemplaybook_end: "‚èπÔ∏è",
            sessionlogitemllm_request: "ü§ñ",
            sessionlogitemllm_response: "üí¨",
            sessionlogitemstep_execution: "‚Üí",
            sessionlogitemvariable_update: "üìù",
            sessionlogitemagent_message: "üì®",
            sessionlogitemerror: "‚ùå",
            sessionlogitemdebug: "üêõ",
            message: "üí≠",
          };

          const indicator = typeIndicators[event.item_type] || "üìÑ";

          return {
            type: event.item_type,
            level: event.level,
            indicator: indicator,
            content: logFormat,
            metadata: event.metadata,
          };
        };

        const handleEvent = (event) => {
          setEventCounter((prev) => prev + 1);

          const type = event.type;
          const timestamp = event.timestamp;

          // Debug logging
          console.log(`Event received: ${type}`, event);

          switch (type) {
            case "connection_established":
              addMessage(
                "system",
                "System",
                `Connected to session ${event.run_id.slice(0, 8)}...`,
                timestamp
              );
              break;

            case "run_started":
              addMessage(
                "system",
                "System",
                "Playbook execution started",
                timestamp
              );
              break;

            // Non-streaming agent messages (commented out in favor of streaming)
            // Uncomment this case if you want to use non-streaming messages instead
            // case 'agent_message':
            //     const sender = `${event.sender_klass}(${event.sender_id})`;
            //     const recipient = `${event.recipient_klass}(${event.recipient_id})`;
            //     const messageType = event.message_type;
            //     const meetingId = event.metadata?.meeting_id;
            //     const message = event.message;
            //
            //     if (message && message !== '<eom>') {
            //         addMessage('assistant', sender, message, timestamp, recipient, messageType, meetingId);
            //     }
            //     break;

            case "agent_streaming_update":
              const streamingSender = `${event.agent_klass}(${event.agent_id})`;
              const streamingRecipient = event.recipient_id
                ? `${event.recipient_klass || "Unknown"}(${event.recipient_id})`
                : "HumanAgent(human)";
              const streamingKey = `${event.agent_klass}-${event.agent_id}`;

              setStreamingMessages((prev) => {
                const newMap = new Map(prev);
                const existing = newMap.get(streamingKey) || {
                  role: "assistant",
                  sender: streamingSender,
                  recipient: streamingRecipient,
                  messageType: event.message_type || "DIRECT",
                  content: "",
                  timestamp: timestamp,
                  id: `streaming-${streamingKey}-${Date.now()}`,
                  isStreaming: true,
                };
                existing.content += event.content;
                newMap.set(streamingKey, existing);
                return newMap;
              });
              break;

            case "agent_streaming_complete":
              const completedKey = `${event.agent_klass}-${event.agent_id}`;

              setStreamingMessages((prev) => {
                const newMap = new Map(prev);
                const streamingMessage = newMap.get(completedKey);

                if (streamingMessage) {
                  // Add the completed streaming message as a regular message
                  addMessage(
                    "assistant",
                    streamingMessage.sender,
                    streamingMessage.content,
                    streamingMessage.timestamp,
                    streamingMessage.recipient,
                    streamingMessage.messageType
                  );

                  // Remove from streaming messages
                  newMap.delete(completedKey);
                }
                return newMap;
              });
              break;

            case "human_input_requested":
              addMessage(
                "system",
                "System",
                "Waiting for your input...",
                timestamp
              );
              break;

            case "human_message":
              addMessage("system", "System", "You sent a message", timestamp);
              break;

            case "meeting_broadcast":
              const meetingSender = `${event.sender_klass}(${event.sender_id})`;
              addMessage(
                "system",
                `Meeting ${event.meeting_id}`,
                `${meetingSender}: ${event.message}`,
                timestamp
              );
              break;

            case "run_terminated":
              addMessage(
                "system",
                "System",
                "Playbook execution completed",
                timestamp
              );
              break;

            case "error":
              addMessage(
                "system",
                "Error",
                event.message || "Unknown error occurred",
                timestamp
              );
              break;

            case "session_log_entry":
              console.log("Session log entry received:", event);
              const logSender = `${event.agent_klass}(${event.agent_id})`;
              const formattedLog = formatSessionLogEntry(event);
              addMessage(
                "log",
                logSender,
                formattedLog,
                timestamp,
                null,
                null,
                null,
                event
              );
              break;

            case "agent_created":
              addMessage(
                "system",
                "System",
                `New agent created: ${event.agent_klass}(${event.agent_id})`,
                timestamp
              );
              break;

            default:
              console.log("Unhandled event type:", type, event);
          }
        };

        const connectWebSocket = (runId) => {
          try {
            const websocket = new WebSocket(`ws://localhost:8081/ws/${runId}`);

            websocket.onopen = () => {
              updateStatus("connected", `Connected (${runId.slice(0, 8)}...)`);
              setIsConnected(true);
              setShowWelcome(false);
            };

            websocket.onmessage = (event) => {
              try {
                console.log("WebSocket message received:", event.data);
                const data = JSON.parse(event.data);
                handleEvent(data);
              } catch (error) {
                console.error("Error parsing WebSocket message:", error);
              }
            };

            websocket.onclose = () => {
              updateStatus("disconnected", "Disconnected");
              setIsConnected(false);
            };

            websocket.onerror = (error) => {
              addMessage("system", "Error", "WebSocket connection error");
              console.error("WebSocket error:", error);
            };

            setWs(websocket);
          } catch (error) {
            addMessage(
              "system",
              "Error",
              `WebSocket connection failed: ${error.message}`
            );
            updateStatus("disconnected", "Error");
          }
        };

        const startChat = async () => {
          try {
            updateStatus("connecting", "Connecting...");
            setProgramContent("");
            setProgramPaths([]);
            setProgramError(null);

            const response = await fetch("http://localhost:8080/runs/new", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                path: playbookPath,
              }),
            });

            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${
                  response.statusText
                }: ${JSON.stringify(await response.json())}`
              );
            }

            const data = await response.json();
            setRunId(data.run_id);
            connectWebSocket(data.run_id);
            fetchProgramDetails(data.run_id);
          } catch (error) {
            addMessage("system", "Error", `Failed to start chat: ${error}`);
            updateStatus("disconnected", "Error");
          }
        };

        const stopChat = () => {
          if (ws) {
            ws.close();
            setWs(null);
          }
          setRunId(null);
          setEventCounter(0);
          updateStatus("disconnected", "Disconnected");
          setIsConnected(false);
          setProgramContent("");
          setProgramPaths([]);
          setProgramError(null);
          setIsProgramLoading(false);
        };

        const sendMessage = () => {
          const message = messageInput.trim();
          if (!message || !isConnected) return;

          addMessage("user", "You", message);

          ws.send(
            JSON.stringify({
              type: "human_message",
              run_id: runId,
              message: message,
            })
          );

          setMessageInput("");
        };

        const handleKeyPress = (e) => {
          if (e.key === "Enter") {
            sendMessage();
          }
        };

        const toggleTheme = () => {
          setTheme((prev) => (prev === "dark" ? "light" : "dark"));
        };

        return (
          <div className="h-screen flex flex-col overflow-hidden">
            <div className="flex-0 px-6 lg:px-8 py-6">
              <div className="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
                <div className="space-y-2">
                  <div className="hero-eyebrow">Playbooks</div>
                  <h1 className="text-3xl leading-tight">
                    Playbooks playground
                  </h1>
                  <p className="text-sm text-base-content/70 max-w-2xl">
                    Launch runs, watch live agent messages, and skim execution
                    logs inside a focused console-inspired workspace.
                  </p>
                </div>
                <div className="flex items-center gap-3 flex-wrap justify-end">
                  <button
                    className="btn btn-sm glass-input gap-2"
                    onClick={toggleTheme}
                    type="button"
                  >
                    <span className="text-lg">
                      {theme === "dark" ? "üåô" : "‚òÄÔ∏è"}
                    </span>
                    {theme === "dark" ? "Dark" : "Light"} mode
                  </button>
                  <StatusIndicator
                    status={status}
                    text={statusText}
                    eventCount={eventCounter}
                  />
                </div>
              </div>

              {/* Controls */}
              <div className="mt-6 space-y-3">
                <div className="flex gap-3 items-center flex-wrap">
                  <input
                    type="text"
                    placeholder="Playbook path"
                    className="input glass-input flex-1 min-w-[220px]"
                    value={playbookPath}
                    onChange={(e) => setPlaybookPath(e.target.value)}
                  />
                  <button
                    className="btn btn-primary"
                    onClick={startChat}
                    disabled={isConnected}
                  >
                    {isConnected ? "Running..." : "Run Program"}
                  </button>
                  <button
                    className="btn btn-outline"
                    onClick={stopChat}
                    disabled={!isConnected}
                  >
                    Stop
                  </button>
                </div>

                <div className="flex gap-4 items-center flex-wrap">
                  <span className="text-sm font-semibold text-base-content/80">
                    Show Events
                  </span>
                  <label className="label cursor-pointer gap-2 px-2 py-1 rounded-lg hover:bg-base-200 transition-colors">
                    <input
                      type="checkbox"
                      className="checkbox checkbox-sm"
                      checked={showMessages}
                      onChange={() => toggleEventDisplay("messages")}
                    />
                    <span className="label-text text-sm">Messages</span>
                  </label>
                  <label className="label cursor-pointer gap-2 px-2 py-1 rounded-lg hover:bg-base-200 transition-colors">
                    <input
                      type="checkbox"
                      className="checkbox checkbox-sm"
                      checked={showExecutionLogs}
                      onChange={() => toggleEventDisplay("session_log_entry")}
                    />
                    <span className="label-text text-sm">Execution Logs</span>
                  </label>
                </div>
              </div>
            </div>

            {/* Main Content */}
            <div className="flex-1 app-shell mx-auto w-full px-0 lg:px-0 pb-0 min-h-0 border-t border-base-300">
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-0 h-full min-h-0">
                <ProgramViewer
                  programContent={programContent}
                  programPaths={programPaths}
                  isLoading={isProgramLoading}
                  error={programError}
                />

                <div className="surface-card flex flex-col h-full min-h-0">
                  {/* Messages */}
                  <div className="flex-1 overflow-y-auto p-4 lg:p-4 space-y-4">
                    {showWelcome && <WelcomeScreen />}
                    {messages.map((message) => (
                      <Message key={message.id} message={message} />
                    ))}
                    {Array.from(streamingMessages.values()).map((message) => (
                      <Message key={message.id} message={message} />
                    ))}
                    <div ref={messagesEndRef} />
                  </div>

                  {/* Input Area */}
                  <div className="p-4 lg:p-4 border-t border-base-300 bg-base-100 backdrop-blur">
                    <div className="flex gap-2">
                      <input
                        type="text"
                        placeholder="Type your message..."
                        className="input glass-input flex-1"
                        value={messageInput}
                        onChange={(e) => setMessageInput(e.target.value)}
                        onKeyPress={handleKeyPress}
                        disabled={!isConnected}
                      />
                      <button
                        className="btn btn-primary"
                        onClick={sendMessage}
                        disabled={!isConnected || !messageInput.trim()}
                      >
                        Send
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // Initialize the app
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>

<!--
Playbooks Playground - Enhanced with React, Tailwind CSS, and DaisyUI

Usage Instructions:
1. Start the playground: playbooks playground (starts server and opens browser automatically)
2. Alternatively, manual setup:
   a. Start web server: playbooks webserver
   b. Open this HTML file in a web browser
3. Enter a playbook path (default: tests/data/02-personalized-greeting.pb)
4. Click "Run program" to create a new session
5. Chat with your AI agents in real-time!

Features:
- Modern React-based UI with hooks and state management
- Tailwind CSS + DaisyUI for beautiful, responsive design
- Real-time WebSocket communication
- Markdown rendering with syntax highlighting (Prism.js)
- Modern chat interface with avatars and message bubbles
- Enhanced status indicators and progress tracking
- Responsive design that works on all devices
- All modern frameworks loaded via CDN (no build process)

Technologies Used:
- React 18 with in-browser JSX compilation (Babel standalone)
- Tailwind CSS 3.x for utility-first styling
- DaisyUI 4.x for component library
- Marked.js for markdown rendering
- Prism.js for syntax highlighting
- Heroicons for consistent iconography

API Endpoints Used:
- POST http://localhost:8080/runs/new - Create new playbook run
- WebSocket ws://localhost:8081/ws/{run_id} - Real-time events
-->

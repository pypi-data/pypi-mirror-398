Metadata-Version: 2.4
Name: httpxx
Version: 0.1.0
Summary: httpxçš„å°è£…
License: MIT
License-File: LICENSE
Keywords: cache,http,httpx
Requires-Python: >=3.8
Requires-Dist: httpx>=0.28.1
Description-Content-Type: text/markdown

# HTTPXX

ğŸš€ **HTTPXX** æ˜¯ä¸€ä¸ªåŸºäº `httpx` HTTP å®¢æˆ·ç«¯å°è£…åº“ï¼Œæä¾›å®Œå…¨å¼‚æ­¥æ”¯æŒã€è‡ªåŠ¨é‡è¯•ã€æ–­è·¯å™¨ã€é€Ÿç‡é™åˆ¶ç­‰é«˜çº§ç‰¹æ€§ã€‚

## âœ¨ ç‰¹æ€§

- âš¡ **å®Œå…¨å¼‚æ­¥æ”¯æŒ** - åŸºäº asyncioï¼Œæ”¯æŒé«˜å¹¶å‘è¯·æ±‚
- ğŸ”„ **è‡ªåŠ¨é‡è¯•æœºåˆ¶** - æ”¯æŒå¤šç§é€€é¿ç­–ç•¥ï¼ˆæŒ‡æ•°ã€çº¿æ€§ã€å›ºå®šï¼‰
- ğŸ”Œ **æ–­è·¯å™¨æ¨¡å¼** - é˜²æ­¢çº§è”æ•…éšœï¼ŒæœåŠ¡é™çº§ä¿æŠ¤
- â±ï¸ **é€Ÿç‡é™åˆ¶** - æ§åˆ¶è¯·æ±‚é¢‘ç‡å’Œå¹¶å‘æ•°ï¼Œé˜²æ­¢è¿‡è½½
- ğŸ’¾ **æ™ºèƒ½ç¼“å­˜** - è‡ªåŠ¨ç¼“å­˜å“åº”ï¼Œå‡å°‘é‡å¤è¯·æ±‚
- ğŸª **å®Œæ•´é’©å­ç³»ç»Ÿ** - æ”¯æŒåœ¨è¯·æ±‚ç”Ÿå‘½å‘¨æœŸå„é˜¶æ®µè‡ªå®šä¹‰é€»è¾‘
- ğŸ”’ **SSL/TLS æ”¯æŒ** - æ— ç¼çš„è¯ä¹¦å¤„ç†å’ŒéªŒè¯
- ğŸŒ **HTTP/2 & HTTP/3** - æ”¯æŒæœ€æ–° HTTP åè®®
- ğŸ”— **ä»£ç†æ”¯æŒ** - æ”¯æŒ HTTPã€HTTPSã€SOCKS5 ä»£ç†
- ğŸ“Š **å®Œå–„æ—¥å¿—ç³»ç»Ÿ** - è¯¦ç»†çš„è¯·æ±‚è¿½è¸ªå’Œé”™è¯¯è®°å½•
- ğŸ›¡ï¸ **çµæ´»é”™è¯¯å¤„ç†** - æ”¯æŒæŠ›å¼‚å¸¸æˆ–è¿”å›é”™è¯¯æ•°æ®ä¸¤ç§æ¨¡å¼

## ğŸ“¦ å®‰è£…

```bash
pip install httpxx
```

## ğŸš€ å¿«é€Ÿå¼€å§‹

### åŸºç¡€ä½¿ç”¨

```python
import asyncio
from httpxx import HTTPXClient, RequestConfig, HTTPMethod

async def main():
    # åˆ›å»ºå®¢æˆ·ç«¯
    async with HTTPXClient(base_url="https://api.example.com") as client:
        # å‘é€ GET è¯·æ±‚
        config = RequestConfig(
            url="/users",
            method=HTTPMethod.GET
        )
        response = await client.request(config)
        
        if response.is_success():
            print(response.json_data)
        else:
            print(f"è¯·æ±‚å¤±è´¥: {response.error_message}")

asyncio.run(main())
```

### ç®€åŒ–è¯·æ±‚æ–¹æ³•

```python
async def main():
    async with HTTPXClient() as client:
        # GET è¯·æ±‚
        response = await client.get("https://api.example.com/users")
        
        # POST è¯·æ±‚
        response = await client.post(
            "https://api.example.com/users",
            json={"name": "John", "age": 30}
        )
        
        # PUT è¯·æ±‚
        response = await client.put(
            "https://api.example.com/users/1",
            json={"age": 31}
        )
        
        # DELETE è¯·æ±‚
        response = await client.delete("https://api.example.com/users/1")
```

## ğŸ“– æ ¸å¿ƒé…ç½®

### 1. é‡è¯•é…ç½® (RetryConfig)

è‡ªåŠ¨é‡è¯•å¤±è´¥çš„è¯·æ±‚ï¼Œæ”¯æŒå¤šç§é€€é¿ç­–ç•¥ã€‚

```python
from httpxx import HTTPXClient, RetryConfig, RetryStrategy

retry_config = RetryConfig(
    max_retries=3,                    # æœ€å¤§é‡è¯•æ¬¡æ•°
    strategy=RetryStrategy.EXPONENTIAL,  # é‡è¯•ç­–ç•¥ï¼šæŒ‡æ•°é€€é¿
    base_delay=1.0,                   # åŸºç¡€å»¶è¿Ÿï¼ˆç§’ï¼‰
    max_delay=60.0,                   # æœ€å¤§å»¶è¿Ÿï¼ˆç§’ï¼‰
    jitter=True,                      # æ·»åŠ éšæœºæŠ–åŠ¨
    retry_on_status_codes=[408, 429, 500, 502, 503, 504],  # éœ€è¦é‡è¯•çš„çŠ¶æ€ç 
)

async with HTTPXClient(retry_config=retry_config) as client:
    response = await client.get("https://api.example.com/data")
```

**é‡è¯•ç­–ç•¥è¯´æ˜ï¼š**
- `EXPONENTIAL` - æŒ‡æ•°é€€é¿ï¼ˆæ¨èï¼‰ï¼š1s, 2s, 4s, 8s...
- `LINEAR` - çº¿æ€§å¢é•¿ï¼š1s, 2s, 3s, 4s...
- `FIXED` - å›ºå®šå»¶è¿Ÿï¼š1s, 1s, 1s, 1s...
- `NONE` - ä¸é‡è¯•

### 2. è¶…æ—¶é…ç½® (TimeoutConfig)

ç²¾ç¡®æ§åˆ¶è¯·æ±‚å„é˜¶æ®µçš„è¶…æ—¶æ—¶é—´ã€‚

```python
from httpxx import HTTPXClient, TimeoutConfig

# æ–¹å¼1ï¼šç®€å•è¶…æ—¶
timeout = TimeoutConfig(timeout=30.0)  # å…¨å±€30ç§’è¶…æ—¶

# æ–¹å¼2ï¼šè¯¦ç»†è¶…æ—¶é…ç½®
timeout = TimeoutConfig(
    connect=10.0,  # è¿æ¥è¶…æ—¶
    read=30.0,     # è¯»å–è¶…æ—¶
    write=30.0,    # å†™å…¥è¶…æ—¶
    pool=5.0       # è¿æ¥æ± è¶…æ—¶
)

# æ–¹å¼3ï¼šå¿«æ·æ–¹æ³•
timeout = TimeoutConfig.from_timeout(30.0)
timeout = TimeoutConfig.from_detailed(connect=10, read=30, write=30, pool=5)

async with HTTPXClient(timeout=timeout) as client:
    response = await client.get("https://api.example.com/data")
```

### 3. é€Ÿç‡é™åˆ¶ (RateLimitConfig)

æ§åˆ¶è¯·æ±‚é¢‘ç‡ï¼Œé˜²æ­¢ API é™æµã€‚

```python
from httpxx import HTTPXClient, RateLimitConfig

rate_limit = RateLimitConfig(
    max_requests_per_second=10,      # æ¯ç§’æœ€å¤š10ä¸ªè¯·æ±‚
    max_concurrent_requests=5,       # æœ€å¤š5ä¸ªå¹¶å‘è¯·æ±‚
    per_host_rate_limit=5            # æ¯ä¸ªä¸»æœºæ¯ç§’æœ€å¤š5ä¸ªè¯·æ±‚
)

async with HTTPXClient(rate_limit_config=rate_limit) as client:
    # è‡ªåŠ¨æ§åˆ¶è¯·æ±‚é€Ÿç‡
    tasks = [client.get(f"https://api.example.com/item/{i}") for i in range(100)]
    responses = await asyncio.gather(*tasks)
```

### 4. æ–­è·¯å™¨ (CircuitBreakerConfig)

é˜²æ­¢çº§è”æ•…éšœï¼Œè‡ªåŠ¨ç†”æ–­ä¸å¯ç”¨æœåŠ¡ã€‚

```python
from httpxx import HTTPXClient, CircuitBreakerConfig

circuit_breaker = CircuitBreakerConfig(
    enabled=True,              # å¯ç”¨æ–­è·¯å™¨
    failure_threshold=5,       # è¿ç»­å¤±è´¥5æ¬¡åæ‰“å¼€æ–­è·¯å™¨
    recovery_timeout=60.0,     # 60ç§’åå°è¯•æ¢å¤
    expected_exception=Exception  # è§¦å‘æ–­è·¯å™¨çš„å¼‚å¸¸ç±»å‹
)

async with HTTPXClient(circuit_breaker_config=circuit_breaker) as client:
    try:
        response = await client.get("https://unstable-api.example.com/data")
    except CircuitBreakerOpenError:
        print("æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œæ–­è·¯å™¨å·²æ‰“å¼€")
```

**æ–­è·¯å™¨çŠ¶æ€ï¼š**
- `closed` - æ­£å¸¸çŠ¶æ€ï¼Œå…è®¸è¯·æ±‚é€šè¿‡
- `open` - ç†”æ–­çŠ¶æ€ï¼Œç›´æ¥æ‹’ç»è¯·æ±‚
- `half-open` - åŠå¼€çŠ¶æ€ï¼Œå°è¯•æ¢å¤æœåŠ¡

### 5. ç¼“å­˜é…ç½® (CacheConfig)

è‡ªåŠ¨ç¼“å­˜å“åº”ï¼Œå‡å°‘é‡å¤è¯·æ±‚ã€‚

```python
from httpxx import HTTPXClient, CacheConfig

cache = CacheConfig(
    enabled=True,                     # å¯ç”¨ç¼“å­˜
    ttl=300.0,                        # ç¼“å­˜æœ‰æ•ˆæœŸï¼ˆç§’ï¼‰
    max_cache_memory=10*1024*1024,    # æœ€å¤§ç¼“å­˜å†…å­˜ 10MB
    cacheable_methods=["GET", "HEAD"],  # å¯ç¼“å­˜çš„æ–¹æ³•
    cacheable_status_codes=[200, 203, 204, 206, 300, 301, 404]  # å¯ç¼“å­˜çš„çŠ¶æ€ç 
)

async with HTTPXClient(cache_config=cache) as client:
    # ç¬¬ä¸€æ¬¡è¯·æ±‚ï¼Œä»æœåŠ¡å™¨è·å–
    response1 = await client.get("https://api.example.com/data")
    
    # ç¬¬äºŒæ¬¡è¯·æ±‚ï¼Œä»ç¼“å­˜è¿”å›
    response2 = await client.get("https://api.example.com/data")
```

### 6. ä»£ç†é…ç½® (ProxyConfig)

æ”¯æŒ HTTPã€HTTPSã€SOCKS5 ä»£ç†ã€‚

```python
from httpxx import HTTPXClient, ProxyConfig, ProxyType

# æ–¹å¼1ï¼šç®€å•ä»£ç†
async with HTTPXClient(proxies="http://proxy.example.com:8080") as client:
    response = await client.get("https://api.example.com/data")

# æ–¹å¼2ï¼šè¯¦ç»†ä»£ç†é…ç½®
proxy = ProxyConfig(
    url="proxy.example.com:8080",
    username="user",
    password="pass",
    proxy_type=ProxyType.HTTP,
    verify_ssl=True,
    timeout=30.0
)

async with HTTPXClient(proxies=[proxy]) as client:
    response = await client.get("https://api.example.com/data")

# æ–¹å¼3ï¼šæŒ‰åè®®é…ç½®ä»£ç†
proxies = {
    "http://": "http://proxy1.example.com:8080",
    "https://": "https://proxy2.example.com:8080"
}

async with HTTPXClient(proxies=proxies) as client:
    response = await client.get("https://api.example.com/data")
```

## ğŸª é’©å­ç³»ç»Ÿ

HTTPXX æä¾›å®Œæ•´çš„é’©å­ç³»ç»Ÿï¼Œæ”¯æŒåœ¨è¯·æ±‚ç”Ÿå‘½å‘¨æœŸçš„å„ä¸ªé˜¶æ®µæ‰§è¡Œè‡ªå®šä¹‰é€»è¾‘ã€‚

### é’©å­ç±»å‹

#### 1. ä¿®æ”¹å‹é’©å­ï¼ˆå¯ä¿®æ”¹æ•°æ®ï¼‰

- **`before_request`** - è¯·æ±‚å‘é€å‰ï¼Œå¯ä¿®æ”¹ RequestConfig
- **`after_response`** - æ”¶åˆ°å“åº”åï¼Œå¯ä¿®æ”¹ ResponseData
- **`on_request_failure`** - è¯·æ±‚å¤±è´¥æ—¶ï¼Œå¯ä¿®æ”¹å¤±è´¥çš„ ResponseData

#### 2. é€šçŸ¥å‹é’©å­ï¼ˆä»…é€šçŸ¥ï¼‰

- **`response_from_cache`** - ä½¿ç”¨ç¼“å­˜å“åº”æ—¶
- **`circuit_breaker_open`** - æ–­è·¯å™¨æ‰“å¼€æ—¶
- **`request_error`** - è¯·æ±‚å‘ç”Ÿé”™è¯¯æ—¶
- **`request_failed`** - è¯·æ±‚æœ€ç»ˆå¤±è´¥æ—¶
- **`request_retry`** - è¯·æ±‚é‡è¯•æ—¶
- **`http_error`** - HTTP é”™è¯¯æ—¶

### é’©å­ä½¿ç”¨ç¤ºä¾‹

```python
from httpxx import HTTPXClient, RequestConfig, ResponseData

async def add_auth_header(config: RequestConfig) -> RequestConfig:
    """åœ¨è¯·æ±‚å‰æ·»åŠ è®¤è¯å¤´"""
    if config.headers is None:
        config.headers = {}
    config.headers["Authorization"] = "Bearer token123"
    return config

async def log_response(response: ResponseData) -> ResponseData:
    """è®°å½•å“åº”ä¿¡æ¯"""
    print(f"æ”¶åˆ°å“åº”: {response.status_code} - {response.url}")
    return response

async def handle_error(response: ResponseData, config: RequestConfig, error: Exception) -> ResponseData:
    """å¤„ç†è¯·æ±‚å¤±è´¥"""
    print(f"è¯·æ±‚å¤±è´¥: {config.url} - {error}")
    return response

def on_retry(attempt: int, delay: float, url: str):
    """é€šçŸ¥é‡è¯•äº‹ä»¶"""
    print(f"é‡è¯•ç¬¬ {attempt} æ¬¡ï¼Œå»¶è¿Ÿ {delay}ç§’: {url}")

async def main():
    async with HTTPXClient() as client:
        # æ³¨å†Œé’©å­
        client.hooks.register("before_request", add_auth_header)
        client.hooks.register("after_response", log_response)
        client.hooks.register("on_request_failure", handle_error)
        client.hooks.register("request_retry", on_retry)
        
        response = await client.get("https://api.example.com/data")
```

## ğŸ”§ é«˜çº§åŠŸèƒ½

### 1. å¹¶å‘è¯·æ±‚

```python
async def fetch_multiple():
    async with HTTPXClient() as client:
        urls = [
            "https://api.example.com/user/1",
            "https://api.example.com/user/2",
            "https://api.example.com/user/3"
        ]
        
        # å¹¶å‘å‘é€è¯·æ±‚
        tasks = [client.get(url) for url in urls]
        responses = await asyncio.gather(*tasks)
        
        for response in responses:
            if response.is_success():
                print(response.json_data)
```

### 2. æµå¼è¯·æ±‚

```python
async def download_file():
    async with HTTPXClient() as client:
        # æµå¼ä¸‹è½½å¤§æ–‡ä»¶
        async for chunk in client.stream_request(
            RequestConfig(
                url="https://example.com/large-file.zip",
                method=HTTPMethod.GET
            )
        ):
            # å¤„ç†æ•°æ®å—
            process_chunk(chunk)
```

### 3. æ‰¹é‡è¯·æ±‚

```python
async def batch_requests():
    async with HTTPXClient() as client:
        configs = [
            RequestConfig(url="https://api.example.com/endpoint1", method=HTTPMethod.GET),
            RequestConfig(url="https://api.example.com/endpoint2", method=HTTPMethod.POST, json={"key": "value"}),
            RequestConfig(url="https://api.example.com/endpoint3", method=HTTPMethod.PUT, json={"id": 1})
        ]
        
        responses = await client.batch_request(configs, max_concurrent=5)
        
        for response in responses:
            print(f"{response.url}: {response.status_code}")
```

### 4. é”™è¯¯å¤„ç†æ¨¡å¼

```python
# æ¨¡å¼1ï¼šæŠ›å¼‚å¸¸æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰
async with HTTPXClient(raise_on_error=True) as client:
    try:
        response = await client.get("https://api.example.com/data")
    except httpx.HTTPError as e:
        print(f"è¯·æ±‚å¤±è´¥: {e}")

# æ¨¡å¼2ï¼šè¿”å›é”™è¯¯æ•°æ®æ¨¡å¼
async with HTTPXClient(raise_on_error=False) as client:
    response = await client.get("https://api.example.com/data")
    
    if response.has_error():
        error_info = response.get_error_info()
        print(f"é”™è¯¯ç±»å‹: {error_info['type']}")
        print(f"é”™è¯¯ä¿¡æ¯: {error_info['message']}")
        print(f"å †æ ˆè·Ÿè¸ª: {error_info['traceback']}")
    else:
        print(response.json_data)
```

### 5. è‡ªå®šä¹‰è¯·æ±‚å¤´å’Œè®¤è¯

```python
# é»˜è®¤è¯·æ±‚å¤´
async with HTTPXClient(
    headers={
        "User-Agent": "MyApp/1.0",
        "Accept": "application/json"
    }
) as client:
    response = await client.get("https://api.example.com/data")

# HTTP åŸºæœ¬è®¤è¯
async with HTTPXClient(auth=("username", "password")) as client:
    response = await client.get("https://api.example.com/secure-data")

# Bearer Token è®¤è¯ï¼ˆé€šè¿‡é’©å­ï¼‰
async def add_bearer_token(config: RequestConfig) -> RequestConfig:
    if config.headers is None:
        config.headers = {}
    config.headers["Authorization"] = f"Bearer {get_token()}"
    return config

async with HTTPXClient() as client:
    client.hooks.register("before_request", add_bearer_token)
    response = await client.get("https://api.example.com/protected")
```

### 6. è¿æ¥æ± ä¼˜åŒ–

```python
from httpxx import HTTPXClient

async with HTTPXClient(
    max_connections=100,           # æœ€å¤§è¿æ¥æ•°
    max_keepalive_connections=20,  # æœ€å¤§ä¿æ´»è¿æ¥æ•°
    pool_timeout=30.0,             # è¿æ¥æ± è¶…æ—¶
    http2=True                     # å¯ç”¨ HTTP/2
) as client:
    # å¤ç”¨è¿æ¥ï¼Œæå‡æ€§èƒ½
    tasks = [client.get(f"https://api.example.com/item/{i}") for i in range(1000)]
    responses = await asyncio.gather(*tasks)
```

## ğŸ“Š ResponseData API

`ResponseData` å¯¹è±¡å°è£…äº†å®Œæ•´çš„å“åº”ä¿¡æ¯ï¼š

```python
response = await client.get("https://api.example.com/data")

# å“åº”å±æ€§
response.status_code      # HTTP çŠ¶æ€ç 
response.headers          # å“åº”å¤´ï¼ˆå­—å…¸ï¼‰
response.content          # å“åº”ä½“ï¼ˆå­—èŠ‚ï¼‰
response.text             # å“åº”ä½“ï¼ˆå­—ç¬¦ä¸²ï¼‰
response.json_data        # å“åº”ä½“ï¼ˆJSON å¯¹è±¡ï¼‰
response.url              # è¯·æ±‚ URL
response.elapsed          # è¯·æ±‚è€—æ—¶ï¼ˆç§’ï¼‰
response.history          # é‡å®šå‘å†å²

# é”™è¯¯ä¿¡æ¯
response.error            # å¼‚å¸¸å¯¹è±¡
response.error_message    # é”™è¯¯æ¶ˆæ¯
response.error_type       # é”™è¯¯ç±»å‹
response.error_traceback  # å †æ ˆè·Ÿè¸ª

# çŠ¶æ€æ£€æŸ¥æ–¹æ³•
response.is_success()      # æ˜¯å¦æˆåŠŸ (2xx)
response.has_error()       # æ˜¯å¦æœ‰é”™è¯¯
response.is_redirect()     # æ˜¯å¦é‡å®šå‘ (3xx)
response.is_client_error() # æ˜¯å¦å®¢æˆ·ç«¯é”™è¯¯ (4xx)
response.is_server_error() # æ˜¯å¦æœåŠ¡å™¨é”™è¯¯ (5xx)

# é”™è¯¯å¤„ç†
response.raise_for_error()  # å¦‚æœæœ‰é”™è¯¯åˆ™æŠ›å‡ºå¼‚å¸¸
error_info = response.get_error_info()  # è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. ä½¿ç”¨ä¸Šä¸‹æ–‡ç®¡ç†å™¨

```python
# âœ… æ¨èï¼šè‡ªåŠ¨ç®¡ç†èµ„æº
async with HTTPXClient() as client:
    response = await client.get("https://api.example.com/data")

# âŒ ä¸æ¨èï¼šéœ€æ‰‹åŠ¨å…³é—­
client = HTTPXClient()
response = await client.get("https://api.example.com/data")
await client.close()  # å®¹æ˜“å¿˜è®°
```

### 2. åˆç†é…ç½®é‡è¯•

```python
# âœ… æ¨èï¼šé’ˆå¯¹ä¸åŒåœºæ™¯é…ç½®
retry_config = RetryConfig(
    max_retries=3,
    strategy=RetryStrategy.EXPONENTIAL,
    retry_on_status_codes=[429, 500, 502, 503, 504]  # åªé‡è¯•ç‰¹å®šé”™è¯¯
)

# âŒ ä¸æ¨èï¼šç›²ç›®é‡è¯•æ‰€æœ‰é”™è¯¯
retry_config = RetryConfig(max_retries=10)  # å¯èƒ½é‡è¯• 4xx é”™è¯¯
```

### 3. å¯ç”¨ç¼“å­˜å‡å°‘è¯·æ±‚

```python
# âœ… æ¨èï¼šç¼“å­˜ä¸å¸¸å˜åŒ–çš„æ•°æ®
cache_config = CacheConfig(
    enabled=True,
    ttl=300,  # 5åˆ†é’Ÿç¼“å­˜
    cacheable_methods=["GET"]
)
```

### 4. ä½¿ç”¨é€Ÿç‡é™åˆ¶ä¿æŠ¤ API

```python
# âœ… æ¨èï¼šéµå®ˆ API é™åˆ¶
rate_limit = RateLimitConfig(
    max_requests_per_second=10,  # API é™åˆ¶
    max_concurrent_requests=5
)
```

### 5. ç›‘æ§å’Œæ—¥å¿—

```python
import logging

# å¯ç”¨è¯¦ç»†æ—¥å¿—
logging.basicConfig(level=logging.DEBUG)

# è‡ªå®šä¹‰é’©å­è®°å½•è¯·æ±‚
async def log_request(config: RequestConfig) -> RequestConfig:
    logger.info(f"å‘é€è¯·æ±‚: {config.method.value} {config.url}")
    return config

async def log_response(response: ResponseData) -> ResponseData:
    logger.info(f"æ”¶åˆ°å“åº”: {response.status_code} - è€—æ—¶ {response.elapsed}s")
    return response

client.hooks.register("before_request", log_request)
client.hooks.register("after_response", log_response)
```

## ğŸ” å®Œæ•´ç¤ºä¾‹

```python
import asyncio
import logging
from httpxx import (
    HTTPXClient,
    RequestConfig,
    HTTPMethod,
    RetryConfig,
    RetryStrategy,
    TimeoutConfig,
    RateLimitConfig,
    CacheConfig,
)

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)

async def main():
    # é…ç½®å®¢æˆ·ç«¯
    client = HTTPXClient(
        base_url="https://api.example.com",
        timeout=TimeoutConfig.from_timeout(30),
        retry_config=RetryConfig(
            max_retries=3,
            strategy=RetryStrategy.EXPONENTIAL,
            base_delay=1.0
        ),
        rate_limit_config=RateLimitConfig(
            max_requests_per_second=10,
            max_concurrent_requests=5
        ),
        cache_config=CacheConfig(
            enabled=True,
            ttl=300
        ),
        headers={"User-Agent": "MyApp/1.0"},
        raise_on_error=False  # ä¸æŠ›å¼‚å¸¸ï¼Œè¿”å›é”™è¯¯æ•°æ®
    )
    
    # æ³¨å†Œé’©å­
    async def add_auth(config: RequestConfig) -> RequestConfig:
        if config.headers is None:
            config.headers = {}
        config.headers["Authorization"] = "Bearer YOUR_TOKEN"
        return config
    
    client.hooks.register("before_request", add_auth)
    
    async with client:
        # å‘é€è¯·æ±‚
        response = await client.get("/users")
        
        if response.is_success():
            users = response.json_data
            print(f"è·å–åˆ° {len(users)} ä¸ªç”¨æˆ·")
        else:
            error_info = response.get_error_info()
            print(f"è¯·æ±‚å¤±è´¥: {error_info['message']}")
        
        # æ‰¹é‡è¯·æ±‚
        tasks = [client.get(f"/users/{i}") for i in range(1, 11)]
        responses = await asyncio.gather(*tasks)
        
        successful = [r for r in responses if r.is_success()]
        print(f"æˆåŠŸè·å– {len(successful)} ä¸ªç”¨æˆ·è¯¦æƒ…")

if __name__ == "__main__":
    asyncio.run(main())
```

## ğŸ“ å¼‚å¸¸ç±»å‹

- `HTTPXWrapperException` - åŸºç¡€å¼‚å¸¸ç±»
- `CircuitBreakerOpenError` - æ–­è·¯å™¨æ‰“å¼€å¼‚å¸¸
- `RateLimitExceededError` - é€Ÿç‡é™åˆ¶è¶…å‡ºå¼‚å¸¸
- `CacheError` - ç¼“å­˜é”™è¯¯å¼‚å¸¸


## ğŸ“„ è®¸å¯è¯

æœ¬é¡¹ç›®é‡‡ç”¨ MIT è®¸å¯è¯ã€‚è¯¦è§ [LICENSE](LICENSE) æ–‡ä»¶ã€‚

## ğŸ”— ç›¸å…³é“¾æ¥

- [HTTPX å®˜æ–¹æ–‡æ¡£](https://www.python-httpx.org/)

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **Python ç‰ˆæœ¬è¦æ±‚**ï¼šéœ€è¦ Python 3.8+
2. **HTTP/3 æ”¯æŒ**ï¼šéœ€è¦å®‰è£… `httpx[http3]`
3. **å¼‚æ­¥ç¯å¢ƒ**ï¼šæ‰€æœ‰æ–¹æ³•éƒ½æ˜¯å¼‚æ­¥çš„ï¼Œéœ€è¦åœ¨ `async` å‡½æ•°ä¸­ä½¿ç”¨
4. **å†…å­˜ç®¡ç†**ï¼šå¯ç”¨ç¼“å­˜æ—¶æ³¨æ„ `max_cache_memory` é…ç½®
5. **æ•æ„Ÿä¿¡æ¯**ï¼šæ—¥å¿—ä¼šè‡ªåŠ¨è¿‡æ»¤æ•æ„Ÿè¯·æ±‚å¤´ï¼ˆå¦‚ Authorizationã€Cookieï¼‰

## ğŸ’¡ æç¤º

- ä½¿ç”¨ `raise_on_error=False` å¯ä»¥é¿å…å¼‚å¸¸ï¼Œè·å–å®Œæ•´çš„é”™è¯¯ä¿¡æ¯
- é’©å­ç³»ç»Ÿæ”¯æŒä¿®æ”¹è¯·æ±‚å’Œå“åº”ï¼Œéå¸¸é€‚åˆæ·»åŠ è®¤è¯ã€æ—¥å¿—ç­‰
- æ–­è·¯å™¨å¯ä»¥ä¿æŠ¤æœåŠ¡å…å—é›ªå´©æ•ˆåº”å½±å“
- ç¼“å­˜åªå¯¹ JSON å“åº”ç”Ÿæ•ˆï¼Œç¡®ä¿ Content-Type æ­£ç¡®
- é€Ÿç‡é™åˆ¶å™¨åœ¨å¹¶å‘åœºæ™¯ä¸‹è‡ªåŠ¨æ§åˆ¶è¯·æ±‚é¢‘ç‡

---

**Happy Coding! ğŸ‰**

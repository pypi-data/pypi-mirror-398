"""
Result Schema - มาตรฐานสำหรับผลการสแกน
Non-intrusive Security Scanner Result Format
"""

from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Any
from datetime import datetime
import uuid
import json
import logging

logger = logging.getLogger(__name__)

@dataclass
class Location:
    """Location of a finding"""
    type: str  # endpoint, header, cookie, config, logic
    path: Optional[str] = None
    method: Optional[str] = None
    parameter: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'type': self.type,
            'path': self.path,
            'method': self.method,
            'parameter': self.parameter
        }

@dataclass
class Evidence:
    """Evidence of a finding (Non-intrusive observation)"""
    request_observed: bool = False
    response_pattern: Optional[str] = None
    notes: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'request_observed': self.request_observed,
            'response_pattern': self.response_pattern,
            'notes': self.notes
        }

@dataclass
class Finding:
    """Single security finding"""
    id: str
    title: str
    category: str
    severity: str  # critical, high, medium, low
    confidence: str  # high, medium, low
    description: str
    impact: str
    location: Location
    evidence: Evidence
    recommendation: str
    references: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        """Validate finding after initialization"""
        # Validate severity
        valid_severities = ['critical', 'high', 'medium', 'low']
        if self.severity not in valid_severities:
            logger.warning(f"Invalid severity '{self.severity}', using 'medium'")
            self.severity = 'medium'
        
        # Validate confidence
        valid_confidences = ['high', 'medium', 'low']
        if self.confidence not in valid_confidences:
            logger.warning(f"Invalid confidence '{self.confidence}', using 'medium'")
            self.confidence = 'medium'
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'id': self.id,
            'title': self.title,
            'category': self.category,
            'severity': self.severity,
            'confidence': self.confidence,
            'description': self.description,
            'impact': self.impact,
            'location': self.location.to_dict(),
            'evidence': self.evidence.to_dict(),
            'recommendation': self.recommendation,
            'references': self.references
        }

@dataclass
class Summary:
    """Scan summary statistics"""
    total_checks: int = 0
    total_findings: int = 0
    severity_count: Dict[str, int] = field(default_factory=lambda: {
        'critical': 0,
        'high': 0,
        'medium': 0,
        'low': 0
    })
    risk_score: int = 0  # 0-100
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'total_checks': self.total_checks,
            'total_findings': self.total_findings,
            'severity_count': self.severity_count,
            'risk_score': self.risk_score
        }
    
    def calculate_risk_score(self) -> int:
        """
        Calculate risk score based on findings
        
        Returns:
            Risk score (0-100)
        """
        weights = {
            'critical': 25,
            'high': 15,
            'medium': 8,
            'low': 3
        }
        score = 0
        for severity, count in self.severity_count.items():
            score += weights.get(severity, 0) * count
        self.risk_score = min(100, max(0, score))
        return self.risk_score

@dataclass
class ScanMetadata:
    """Scan metadata"""
    scanner_mode: str = "passive"  # passive, active-light
    scan_policy: str = "internal-assessment"
    legal_scope: str = "authorized-only"
    scanner_version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate metadata after initialization"""
        if self.scanner_mode not in ['passive', 'active-light']:
            logger.warning(f"Invalid scanner_mode '{self.scanner_mode}', using 'passive'")
            self.scanner_mode = 'passive'
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'scanner_mode': self.scanner_mode,
            'scan_policy': self.scan_policy,
            'legal_scope': self.legal_scope,
            'scanner_version': self.scanner_version
        }

@dataclass
class ScanResult:
    """Complete scan result following standard schema"""
    scan_id: str
    target: str
    scan_time: str
    summary: Summary
    findings: List[Finding]
    metadata: ScanMetadata
    
    def __init__(self, target: str, scanner_mode: str = "passive"):
        """
        Initialize scan result
        
        Args:
            target: Target URL
            scanner_mode: Scanner mode (passive or active-light)
        """
        if not target:
            raise ValueError("target cannot be empty")
        
        self.scan_id = str(uuid.uuid4())[:8]
        self.target = target
        self.scan_time = datetime.utcnow().isoformat() + 'Z'
        self.summary = Summary()
        self.findings = []
        self.metadata = ScanMetadata(scanner_mode=scanner_mode)
        logger.debug(f"ScanResult initialized: {self.scan_id}")
    
    def add_finding(self, finding: Finding):
        """
        Add a finding and update summary
        
        Args:
            finding: Finding object to add
        """
        if not isinstance(finding, Finding):
            raise TypeError("finding must be a Finding instance")
        
        self.findings.append(finding)
        self.summary.total_findings += 1
        self.summary.severity_count[finding.severity] = \
            self.summary.severity_count.get(finding.severity, 0) + 1
        self.summary.calculate_risk_score()
        logger.debug(f"Added finding: {finding.id} ({finding.severity})")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            'scan_id': self.scan_id,
            'target': self.target,
            'scan_time': self.scan_time,
            'scanner_version': self.metadata.scanner_version,
            'summary': self.summary.to_dict(),
            'findings': [f.to_dict() for f in self.findings],
            'metadata': self.metadata.to_dict()
        }
    
    def to_json(self, indent: int = 2) -> str:
        """
        Convert to JSON string
        
        Args:
            indent: JSON indentation
            
        Returns:
            JSON string
        """
        try:
            return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Error converting to JSON: {e}")
            raise
    
    def save_json(self, filepath: str):
        """
        Save to JSON file
        
        Args:
            filepath: Path to save JSON file
            
        Raises:
            IOError: If file cannot be written
        """
        try:
            from pathlib import Path
            Path(filepath).parent.mkdir(parents=True, exist_ok=True)
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(self.to_json())
            logger.info(f"Saved JSON report to {filepath}")
        except Exception as e:
            logger.error(f"Error saving JSON to {filepath}: {e}")
            raise

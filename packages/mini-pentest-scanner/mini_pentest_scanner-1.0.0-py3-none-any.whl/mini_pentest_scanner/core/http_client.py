"""
HTTP Client - Wrapper for making requests
Non-intrusive request handling with error handling
"""

import requests
from typing import Optional, Dict, Any
from urllib.parse import urljoin
import logging

logger = logging.getLogger(__name__)

class HTTPClient:
    """HTTP client for scanner (Non-intrusive)"""
    
    def __init__(self, base_url: str, timeout: int = 10, user_agent: str = "SecurityScanner/1.0"):
        """
        Initialize HTTP client
        
        Args:
            base_url: Base URL for requests
            timeout: Request timeout in seconds
            user_agent: User agent string
        """
        if not base_url:
            raise ValueError("base_url cannot be empty")
        
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': user_agent
        })
        logger.debug(f"HTTPClient initialized for {self.base_url}")
    
    def get(self, path: str, params: Optional[Dict] = None, **kwargs) -> Optional[requests.Response]:
        """
        Make GET request
        
        Args:
            path: URL path
            params: Query parameters
            **kwargs: Additional request arguments
            
        Returns:
            Response object or None if error
        """
        try:
            url = urljoin(self.base_url, path)
            logger.debug(f"GET {url}")
            response = self.session.get(url, params=params, timeout=self.timeout, **kwargs)
            return response
        except requests.exceptions.Timeout:
            logger.warning(f"Request timeout for {path}")
            return None
        except requests.exceptions.ConnectionError as e:
            logger.warning(f"Connection error for {path}: {e}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Request error for {path}: {e}")
            return None
    
    def post(self, path: str, data: Optional[Dict] = None, json: Optional[Dict] = None, **kwargs) -> Optional[requests.Response]:
        """
        Make POST request
        
        Args:
            path: URL path
            data: Form data
            json: JSON data
            **kwargs: Additional request arguments
            
        Returns:
            Response object or None if error
        """
        try:
            url = urljoin(self.base_url, path)
            logger.debug(f"POST {url}")
            response = self.session.post(url, data=data, json=json, timeout=self.timeout, **kwargs)
            return response
        except requests.exceptions.Timeout:
            logger.warning(f"Request timeout for {path}")
            return None
        except requests.exceptions.ConnectionError as e:
            logger.warning(f"Connection error for {path}: {e}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Request error for {path}: {e}")
            return None
    
    def observe_response(self, response: requests.Response) -> Dict[str, Any]:
        """
        Observe response characteristics (Non-intrusive)
        
        Args:
            response: HTTP response object
            
        Returns:
            Dictionary of observed characteristics
        """
        if not response:
            return {}
        
        try:
            return {
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'content_length': len(response.content),
                'content_type': response.headers.get('Content-Type', ''),
                'has_cookies': len(response.cookies) > 0,
                'cookies': {name: cookie.value for name, cookie in response.cookies.items()}
            }
        except Exception as e:
            logger.error(f"Error observing response: {e}")
            return {}
    
    def check_security_headers(self, response: requests.Response) -> Dict[str, bool]:
        """
        Check presence of security headers (Non-intrusive)
        
        Args:
            response: HTTP response object
            
        Returns:
            Dictionary of security header presence
        """
        if not response:
            return {}
        
        security_headers = [
            'X-Content-Type-Options',
            'X-Frame-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'Referrer-Policy'
        ]
        
        result = {}
        try:
            for header in security_headers:
                result[header] = header in response.headers
        except Exception as e:
            logger.error(f"Error checking security headers: {e}")
        
        return result

# -*- coding: utf-8 -*-
"""
Trend Analysis Module
‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÅ‡∏ô‡∏ß‡πÇ‡∏ô‡πâ‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á (Risk ‚Üë/‚Üì)
"""

from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

class TrendAnalyzer:
    """Analyze risk trends over time"""
    
    def __init__(self, history_db):
        """
        Initialize trend analyzer
        
        Args:
            history_db: ScanHistoryDB instance
        """
        self.db = history_db
    
    def analyze_trends(self, target_url: str, days: int = 30) -> Dict[str, Any]:
        """
        Analyze risk trends for a target
        
        Args:
            target_url: Target URL
            days: Number of days to analyze (must be > 0)
            
        Returns:
            Trend analysis result
            
        Raises:
            ValueError: If target_url is empty or days is invalid
        """
        if not target_url:
            raise ValueError("target_url cannot be empty")
        
        if days <= 0:
            raise ValueError("days must be greater than 0")
        
        scans = self.db.get_scans_by_target(target_url, limit=100)
        
        if len(scans) < 2:
            return {
                'has_enough_data': False,
                'message': 'Need at least 2 scans for trend analysis'
            }
        
        # Sort by scan_time
        scans.sort(key=lambda x: x.get('scan_time', ''))
        
        # Extract data points
        risk_scores = [s.get('risk_score', 0) for s in scans]
        total_findings = [s.get('total_findings', 0) for s in scans]
        scan_times = [s.get('scan_time', '') for s in scans]
        
        # Calculate trends
        risk_trend = self._calculate_trend(risk_scores)
        findings_trend = self._calculate_trend(total_findings)
        
        # Calculate severity trends
        severity_trends = self._calculate_severity_trends(scans)
        
        # Calculate statistics
        avg_risk = sum(risk_scores) / len(risk_scores) if risk_scores else 0
        max_risk = max(risk_scores) if risk_scores else 0
        min_risk = min(risk_scores) if risk_scores else 0
        
        # Predict next risk (simple linear regression)
        predicted_risk = self._predict_next_risk(risk_scores)
        
        return {
            'target_url': target_url,
            'period_days': days,
            'total_scans': len(scans),
            'risk_trend': {
                'direction': risk_trend['direction'],
                'change': risk_trend['change'],
                'change_percent': risk_trend['change_percent'],
                'average': round(avg_risk, 2),
                'maximum': max_risk,
                'minimum': min_risk,
                'current': risk_scores[-1] if risk_scores else 0,
                'predicted_next': round(predicted_risk, 2)
            },
            'findings_trend': {
                'direction': findings_trend['direction'],
                'change': findings_trend['change'],
                'current': total_findings[-1] if total_findings else 0
            },
            'severity_trends': severity_trends,
            'data_points': [
                {
                    'scan_time': time,
                    'risk_score': risk,
                    'total_findings': findings
                }
                for time, risk, findings in zip(scan_times, risk_scores, total_findings)
            ],
            'recommendations': self._generate_recommendations(risk_trend, findings_trend, severity_trends)
        }
    
    def _calculate_trend(self, values: List[int]) -> Dict[str, Any]:
        """Calculate trend direction and change"""
        if not values or len(values) < 2:
            return {
                'direction': 'stable',
                'change': 0,
                'change_percent': 0
            }
        
        first = values[0]
        last = values[-1]
        change = last - first
        
        # Prevent division by zero
        if first == 0:
            change_percent = 100.0 if last > 0 else 0.0
        else:
            change_percent = ((last - first) / first * 100)
        
        # Determine direction
        if change < -5:
            direction = 'improving'
        elif change > 5:
            direction = 'worsening'
        else:
            direction = 'stable'
        
        return {
            'direction': direction,
            'change': change,
            'change_percent': round(change_percent, 2)
        }
    
    def _calculate_severity_trends(self, scans: List[Dict]) -> Dict[str, Any]:
        """Calculate severity-specific trends"""
        if len(scans) < 2:
            return {}
        
        # Get full scan results for severity counts
        first_scan = self.db.get_scan(scans[0].get('scan_id'))
        last_scan = self.db.get_scan(scans[-1].get('scan_id'))
        
        if not first_scan or not last_scan:
            return {}
        
        first_summary = first_scan.get('summary', {})
        last_summary = last_scan.get('summary', {})
        
        first_severity = first_summary.get('severity_count', {})
        last_severity = last_summary.get('severity_count', {})
        
        trends = {}
        for severity in ['critical', 'high', 'medium', 'low']:
            first_count = first_severity.get(severity, 0)
            last_count = last_severity.get(severity, 0)
            change = last_count - first_count
            
            trends[severity] = {
                'before': first_count,
                'after': last_count,
                'change': change,
                'trend': 'increasing' if change > 0 else 'decreasing' if change < 0 else 'stable'
            }
        
        return trends
    
    def _predict_next_risk(self, risk_scores: List[int]) -> float:
        """Simple linear regression to predict next risk score"""
        if len(risk_scores) < 2:
            return risk_scores[0] if risk_scores else 0
        
        # Simple moving average with trend
        n = len(risk_scores)
        if n >= 3:
            # Use last 3 points for trend
            recent = risk_scores[-3:]
            trend = (recent[-1] - recent[0]) / 2
            predicted = recent[-1] + trend
        else:
            # Simple average
            predicted = sum(risk_scores) / n
        
        return max(0, min(100, predicted))  # Clamp to 0-100
    
    def _generate_recommendations(self, risk_trend: Dict, findings_trend: Dict, severity_trends: Dict) -> List[str]:
        """Generate recommendations based on trends"""
        recommendations = []
        
        if risk_trend['direction'] == 'worsening':
            recommendations.append("‚ö†Ô∏è Risk score is increasing. Review recent changes and prioritize fixing high-severity findings.")
        
        if risk_trend['direction'] == 'improving':
            recommendations.append("‚úÖ Risk score is decreasing. Continue current security practices.")
        
        if severity_trends.get('critical', {}).get('trend') == 'increasing':
            recommendations.append("üî¥ Critical findings are increasing. Immediate action required.")
        
        if findings_trend['direction'] == 'worsening':
            recommendations.append("üìà Total findings are increasing. Consider implementing additional security controls.")
        
        if not recommendations:
            recommendations.append("üìä Security posture is stable. Continue regular monitoring.")
        
        return recommendations


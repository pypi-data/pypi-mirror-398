# -*- coding: utf-8 -*-
"""
Compliance Mapping Module
แมป findings กับมาตรฐาน ISO 27001, SOC 2, OWASP ASVS
"""

from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)

# ISO 27001 Controls Mapping
ISO27001_MAPPING = {
    'A.9.4.2': {
        'name': 'Secure log-on procedures',
        'categories': ['Authentication', 'Session Management'],
        'severities': ['high', 'critical']
    },
    'A.9.4.3': {
        'name': 'Password management system',
        'categories': ['Authentication'],
        'severities': ['high', 'critical']
    },
    'A.14.2.1': {
        'name': 'Secure development policy',
        'categories': ['Injection', 'XSS'],
        'severities': ['high', 'critical', 'medium']
    },
    'A.14.2.5': {
        'name': 'Secure system architecture and engineering principles',
        'categories': ['Security Misconfiguration', 'Information Disclosure'],
        'severities': ['high', 'medium']
    },
    'A.14.2.6': {
        'name': 'Secure development environment',
        'categories': ['Security Misconfiguration'],
        'severities': ['medium', 'high']
    },
    'A.14.2.8': {
        'name': 'System security testing',
        'categories': ['All'],
        'severities': ['all']
    },
    'A.14.3.1': {
        'name': 'Protection of test data',
        'categories': ['Information Disclosure'],
        'severities': ['high', 'medium']
    }
}

# SOC 2 Controls Mapping
SOC2_MAPPING = {
    'CC6.1': {
        'name': 'Logical and physical access controls',
        'categories': ['Authentication', 'Access Control'],
        'severities': ['high', 'critical']
    },
    'CC6.2': {
        'name': 'Prior to issuing system credentials',
        'categories': ['Authentication'],
        'severities': ['high', 'critical']
    },
    'CC6.3': {
        'name': 'Password requirements',
        'categories': ['Authentication'],
        'severities': ['high', 'critical']
    },
    'CC6.6': {
        'name': 'Unauthorized access',
        'categories': ['Access Control', 'IDOR'],
        'severities': ['high', 'critical']
    },
    'CC7.1': {
        'name': 'System configuration',
        'categories': ['Security Misconfiguration'],
        'severities': ['high', 'medium']
    },
    'CC7.2': {
        'name': 'System changes',
        'categories': ['Security Misconfiguration'],
        'severities': ['medium', 'high']
    },
    'CC7.3': {
        'name': 'Vulnerability and patch management',
        'categories': ['All'],
        'severities': ['all']
    },
    'CC7.4': {
        'name': 'Network and software vulnerabilities',
        'categories': ['Injection', 'XSS', 'Security Misconfiguration'],
        'severities': ['high', 'critical', 'medium']
    }
}

# OWASP ASVS Mapping
OWASP_ASVS_MAPPING = {
    'V2.1.1': {
        'name': 'Verify that user set passwords are at least 12 characters in length',
        'categories': ['Authentication'],
        'severities': ['high', 'medium']
    },
    'V2.1.2': {
        'name': 'Verify that passwords can contain any characters including unicode',
        'categories': ['Authentication'],
        'severities': ['medium']
    },
    'V3.1.1': {
        'name': 'Verify that session management controls are in place',
        'categories': ['Session Management'],
        'severities': ['high', 'critical']
    },
    'V3.2.1': {
        'name': 'Verify that sessions are invalidated when user logs out',
        'categories': ['Session Management'],
        'severities': ['high']
    },
    'V5.1.1': {
        'name': 'Verify that the application validates input from all data sources',
        'categories': ['Injection', 'XSS'],
        'severities': ['high', 'critical']
    },
    'V5.2.1': {
        'name': 'Verify that all input validation failures result in input rejection',
        'categories': ['Injection', 'XSS'],
        'severities': ['high', 'critical']
    },
    'V7.1.1': {
        'name': 'Verify that a security control framework is chosen and adopted',
        'categories': ['Security Misconfiguration'],
        'severities': ['medium', 'high']
    },
    'V14.1.1': {
        'name': 'Verify that error handling logic in security controls denies access by default',
        'categories': ['Information Disclosure'],
        'severities': ['high', 'medium']
    }
}

class ComplianceMapper:
    """Map findings to compliance standards"""
    
    def __init__(self, history_db):
        """
        Initialize compliance mapper
        
        Args:
            history_db: ScanHistoryDB instance
        """
        self.db = history_db
        self.standards = {
            'ISO27001': ISO27001_MAPPING,
            'SOC2': SOC2_MAPPING,
            'OWASP_ASVS': OWASP_ASVS_MAPPING
        }
    
    def map_scan_to_compliance(self, scan_id: str, standards: List[str] = None) -> Dict[str, Any]:
        """
        Map scan findings to compliance standards
        
        Args:
            scan_id: Scan ID
            standards: List of standards to map (default: all)
            
        Returns:
            Compliance mapping results
            
        Raises:
            ValueError: If scan_id is invalid or scan not found
        """
        if not scan_id:
            raise ValueError("scan_id cannot be empty")
        
        if standards is None:
            standards = ['ISO27001', 'SOC2', 'OWASP_ASVS']
        elif not isinstance(standards, list):
            raise ValueError("standards must be a list")
        
        # Validate standards
        valid_standards = ['ISO27001', 'SOC2', 'OWASP_ASVS']
        invalid = [s for s in standards if s not in valid_standards]
        if invalid:
            raise ValueError(f"Invalid standards: {invalid}. Valid: {valid_standards}")
        
        scan = self.db.get_scan(scan_id)
        if not scan:
            raise ValueError(f"Scan {scan_id} not found")
        
        findings = scan.get('findings', [])
        
        compliance_results = {}
        
        for standard in standards:
            if standard not in self.standards:
                logger.warning(f"Unknown standard: {standard}")
                continue
            
            mapping = self.standards[standard]
            compliance_results[standard] = self._map_to_standard(findings, mapping, standard)
        
        # Save compliance mappings to database
        self._save_compliance_mappings(scan_id, compliance_results)
        
        return {
            'scan_id': scan_id,
            'target': scan.get('target'),
            'scan_time': scan.get('scan_time'),
            'compliance': compliance_results,
            'summary': self._generate_compliance_summary(compliance_results)
        }
    
    def _map_to_standard(self, findings: List[Dict], mapping: Dict, standard: str) -> Dict[str, Any]:
        """Map findings to a specific standard"""
        requirements = {}
        compliant_count = 0
        non_compliant_count = 0
        
        for req_id, req_info in mapping.items():
            matched_findings = []
            
            for finding in findings:
                category = finding.get('category', '')
                severity = finding.get('severity', 'medium')
                
                # Check if finding matches requirement
                if self._finding_matches_requirement(finding, req_info):
                    matched_findings.append({
                        'finding_id': finding.get('id'),
                        'title': finding.get('title'),
                        'severity': severity,
                        'category': category
                    })
            
            # Determine compliance status
            if matched_findings:
                status = 'non_compliant'
                non_compliant_count += 1
            else:
                status = 'compliant'
                compliant_count += 1
            
            requirements[req_id] = {
                'name': req_info['name'],
                'status': status,
                'matched_findings': matched_findings,
                'finding_count': len(matched_findings)
            }
        
        total_requirements = len(requirements)
        # Prevent division by zero
        compliance_percentage = (compliant_count / total_requirements * 100) if total_requirements > 0 else 100.0
        
        return {
            'requirements': requirements,
            'summary': {
                'total_requirements': total_requirements,
                'compliant': compliant_count,
                'non_compliant': non_compliant_count,
                'compliance_percentage': round(compliance_percentage, 2)
            }
        }
    
    def _finding_matches_requirement(self, finding: Dict, req_info: Dict) -> bool:
        """Check if a finding matches a requirement"""
        category = finding.get('category', '')
        severity = finding.get('severity', 'medium')
        
        # Check category match
        categories = req_info.get('categories', [])
        if 'All' not in categories and category not in categories:
            return False
        
        # Check severity match
        severities = req_info.get('severities', [])
        if 'all' not in severities and severity not in severities:
            return False
        
        return True
    
    def _save_compliance_mappings(self, scan_id: str, compliance_results: Dict):
        """Save compliance mappings to database"""
        import sqlite3
        from datetime import datetime
        
        conn = sqlite3.connect(str(self.db.db_path))
        cursor = conn.cursor()
        
        try:
            now = datetime.utcnow().isoformat()
            
            for standard, results in compliance_results.items():
                for req_id, req_data in results.get('requirements', {}).items():
                    status = req_data.get('status', 'unknown')
                    finding_ids = ','.join([f['finding_id'] for f in req_data.get('matched_findings', [])])
                    
                    cursor.execute('''
                        INSERT INTO compliance_mappings 
                        (scan_id, standard, requirement_id, status, finding_ids, created_at)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ''', (scan_id, standard, req_id, status, finding_ids, now))
            
            conn.commit()
            
        except Exception as e:
            conn.rollback()
            logger.error(f"Error saving compliance mappings: {e}")
        finally:
            conn.close()
    
    def _generate_compliance_summary(self, compliance_results: Dict) -> Dict[str, Any]:
        """Generate overall compliance summary"""
        summary = {
            'standards_checked': len(compliance_results),
            'overall_compliance': {},
            'critical_issues': []
        }
        
        for standard, results in compliance_results.items():
            std_summary = results.get('summary', {})
            summary['overall_compliance'][standard] = {
                'compliance_percentage': std_summary.get('compliance_percentage', 0),
                'non_compliant': std_summary.get('non_compliant', 0)
            }
            
            # Find critical non-compliant requirements
            for req_id, req_data in results.get('requirements', {}).items():
                if req_data.get('status') == 'non_compliant':
                    critical_findings = [f for f in req_data.get('matched_findings', []) 
                                       if f.get('severity') in ['critical', 'high']]
                    if critical_findings:
                        summary['critical_issues'].append({
                            'standard': standard,
                            'requirement': req_id,
                            'name': req_data.get('name'),
                            'critical_findings': len(critical_findings)
                        })
        
        return summary
    
    def get_compliance_report(self, scan_id: str, format: str = 'json') -> Dict[str, Any]:
        """
        Generate compliance report for a scan
        
        Args:
            scan_id: Scan ID
            format: Report format ('json', 'summary')
            
        Returns:
            Compliance report
        """
        compliance = self.map_scan_to_compliance(scan_id)
        
        if format == 'summary':
            return {
                'scan_id': scan_id,
                'summary': compliance['summary'],
                'standards': {
                    std: data['summary'] 
                    for std, data in compliance['compliance'].items()
                }
            }
        
        return compliance


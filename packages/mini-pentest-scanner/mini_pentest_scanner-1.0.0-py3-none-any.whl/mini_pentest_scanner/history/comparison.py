# -*- coding: utf-8 -*-
"""
Scan Comparison Module
เปรียบเทียบความเสี่ยงระหว่างการสแกนแต่ละรอบ
"""

from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class ScanComparison:
    """Compare scan results"""
    
    def __init__(self, history_db):
        """
        Initialize comparison module
        
        Args:
            history_db: ScanHistoryDB instance
        """
        self.db = history_db
    
    def compare_scans(self, scan_id1: str, scan_id2: str) -> Dict[str, Any]:
        """
        Compare two scans
        
        Args:
            scan_id1: First scan ID
            scan_id2: Second scan ID
            
        Returns:
            Comparison result dictionary
            
        Raises:
            ValueError: If scan IDs are invalid or scans not found
        """
        if not scan_id1 or not scan_id2:
            raise ValueError("Both scan_id1 and scan_id2 are required")
        
        if scan_id1 == scan_id2:
            raise ValueError("Cannot compare a scan with itself")
        
        scan1 = self.db.get_scan(scan_id1)
        scan2 = self.db.get_scan(scan_id2)
        
        if not scan1:
            raise ValueError(f"Scan {scan_id1} not found")
        if not scan2:
            raise ValueError(f"Scan {scan_id2} not found")
        
        summary1 = scan1.get('summary', {})
        summary2 = scan2.get('summary', {})
        
        findings1 = {f['id']: f for f in scan1.get('findings', [])}
        findings2 = {f['id']: f for f in scan2.get('findings', [])}
        
        # Risk score comparison
        risk_score1 = summary1.get('risk_score', 0)
        risk_score2 = summary2.get('risk_score', 0)
        risk_change = risk_score2 - risk_score1
        
        # Prevent division by zero
        if risk_score1 == 0:
            risk_change_percent = 100.0 if risk_score2 > 0 else 0.0
        else:
            risk_change_percent = ((risk_score2 - risk_score1) / risk_score1 * 100)
        
        # Findings comparison
        findings_added = []
        findings_removed = []
        findings_changed = []
        
        # Find new findings
        for finding_id, finding in findings2.items():
            if finding_id not in findings1:
                findings_added.append(finding)
        
        # Find removed findings
        for finding_id, finding in findings1.items():
            if finding_id not in findings2:
                findings_removed.append(finding)
        
        # Find changed findings (severity or status)
        for finding_id in set(findings1.keys()) & set(findings2.keys()):
            f1 = findings1[finding_id]
            f2 = findings2[finding_id]
            
            if (f1.get('severity') != f2.get('severity') or 
                f1.get('confidence') != f2.get('confidence')):
                findings_changed.append({
                    'finding_id': finding_id,
                    'before': f1,
                    'after': f2
                })
        
        # Severity count comparison
        severity_count1 = summary1.get('severity_count', {})
        severity_count2 = summary2.get('severity_count', {})
        
        severity_changes = {}
        for severity in ['critical', 'high', 'medium', 'low']:
            count1 = severity_count1.get(severity, 0)
            count2 = severity_count2.get(severity, 0)
            severity_changes[severity] = {
                'before': count1,
                'after': count2,
                'change': count2 - count1
            }
        
        return {
            'scan1': {
                'scan_id': scan_id1,
                'scan_time': scan1.get('scan_time'),
                'risk_score': risk_score1,
                'total_findings': summary1.get('total_findings', 0)
            },
            'scan2': {
                'scan_id': scan_id2,
                'scan_time': scan2.get('scan_time'),
                'risk_score': risk_score2,
                'total_findings': summary2.get('total_findings', 0)
            },
            'risk_comparison': {
                'before': risk_score1,
                'after': risk_score2,
                'change': risk_change,
                'change_percent': round(risk_change_percent, 2),
                'trend': 'improved' if risk_change < 0 else 'worsened' if risk_change > 0 else 'stable'
            },
            'findings_comparison': {
                'added': len(findings_added),
                'removed': len(findings_removed),
                'changed': len(findings_changed),
                'added_details': findings_added,
                'removed_details': findings_removed,
                'changed_details': findings_changed
            },
            'severity_changes': severity_changes,
            'overall_trend': self._determine_overall_trend(risk_change, findings_added, findings_removed)
        }
    
    def compare_with_baseline(self, scan_id: str, target_url: str) -> Dict[str, Any]:
        """
        Compare scan with baseline
        
        Args:
            scan_id: Current scan ID
            target_url: Target URL
            
        Returns:
            Comparison with baseline
            
        Raises:
            ValueError: If parameters are invalid
        """
        if not scan_id:
            raise ValueError("scan_id cannot be empty")
        if not target_url:
            raise ValueError("target_url cannot be empty")
        
        from .baseline import BaselineManager
        
        baseline_mgr = BaselineManager(self.db)
        baseline_scan_id = baseline_mgr.get_baseline(target_url)
        
        if not baseline_scan_id:
            return {
                'has_baseline': False,
                'message': 'No baseline set for this target'
            }
        
        return self.compare_scans(baseline_scan_id, scan_id)
    
    def _determine_overall_trend(self, risk_change: int, added: List, removed: List) -> str:
        """Determine overall trend"""
        if risk_change < -5 and len(removed) > len(added):
            return 'significantly_improved'
        elif risk_change < 0:
            return 'improved'
        elif risk_change > 5 and len(added) > len(removed):
            return 'significantly_worsened'
        elif risk_change > 0:
            return 'worsened'
        else:
            return 'stable'


"""
SQL Injection Check
ตรวจสอบช่องโหว่ SQL Injection ใน endpoints ต่างๆ (Non-intrusive)
"""

import re
from typing import List
from ..core.engine import ScannerEngine
from ..core.result import Finding, Location, Evidence

def check_new(engine: ScannerEngine) -> List[Finding]:
    """
    Check for SQL Injection vulnerabilities (New format using Result Schema)
    
    Args:
        engine: ScannerEngine instance
        
    Returns:
        List of Finding objects
    """
    findings = []
    
    # Only run in active-light mode (requires safe input testing)
    if engine.scan_result.metadata.scanner_mode == 'passive':
        return findings  # Skip in passive mode
    
    if not engine or not engine.http_client:
        return findings
    
    # SQL Injection test payloads (safe - ไม่ทำลายข้อมูล)
    test_payloads = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "admin' --",
    ]
    
    # Test endpoints
    endpoints = [
        {
            'path': '/login',
            'method': 'POST',
            'params': {'username': '', 'password': ''},
            'name': 'Login endpoint'
        },
        {
            'path': '/register',
            'method': 'POST',
            'params': {'username': '', 'password': '', 'email': ''},
            'name': 'Register endpoint'
        },
        {
            'path': '/search',
            'method': 'GET',
            'params': {'q': ''},
            'name': 'Search endpoint'
        }
    ]
    
    # SQL error patterns (Non-intrusive observation)
    error_patterns = [
        r'sqlite3\.OperationalError',
        r'sqlite3\.IntegrityError',
        r'SQL syntax',
        r'database error',
        r'unrecognized token',
        r'near "',
    ]
    
    for endpoint in endpoints:
        for payload in test_payloads[:2]:  # Limit payloads for active-light
            try:
                if endpoint['method'] == 'POST':
                    test_params = endpoint['params'].copy()
                    test_params['username'] = payload
                    if 'password' in test_params:
                        test_params['password'] = 'test123'
                    
                    response = engine.http_client.post(
                        endpoint['path'],
                        data=test_params
                    )
                    
                    if not response:
                        continue
                    
                    # Observe response (Non-intrusive)
                    response_text = response.text.lower()
                    detected_pattern = None
                    
                    for pattern in error_patterns:
                        if re.search(pattern, response_text, re.IGNORECASE):
                            detected_pattern = pattern
                            break
                    
                    # Check for authentication bypass behavior
                    auth_bypass = (response.status_code == 302 and 
                                 'dashboard' in response.headers.get('Location', ''))
                    
                    if detected_pattern or auth_bypass:
                        finding = Finding(
                            id=f"SQLI-{endpoint['path'].replace('/', '')}-001",
                            title="SQL Injection Indicators Detected",
                            category="Injection",
                            severity="high",
                            confidence="medium",
                            description=f"SQL error pattern or authentication bypass behavior detected in {endpoint['name']}",
                            impact="An attacker may be able to manipulate database queries, potentially leading to unauthorized data access or authentication bypass.",
                            location=Location(
                                type="endpoint",
                                path=endpoint['path'],
                                method=endpoint['method'],
                                parameter="username"
                            ),
                            evidence=Evidence(
                                request_observed=True,
                                response_pattern=f"SQL error pattern: {detected_pattern}" if detected_pattern else "Authentication bypass behavior",
                                notes=f"Response indicates potential SQL injection vulnerability"
                            ),
                            recommendation="Use parameterized queries (prepared statements) instead of string concatenation. Validate and sanitize all user inputs.",
                            references=[
                                "OWASP Top 10 - A03:2021 Injection",
                                "CWE-89: SQL Injection"
                            ]
                        )
                        findings.append(finding)
                        break  # One finding per endpoint is enough
                
                elif endpoint['method'] == 'GET':
                    test_params = {'q': payload}
                    response = engine.http_client.get(
                        endpoint['path'],
                        params=test_params
                    )
                    
                    if not response:
                        continue
                    
                    response_text = response.text.lower()
                    detected_pattern = None
                    
                    for pattern in error_patterns:
                        if re.search(pattern, response_text, re.IGNORECASE):
                            detected_pattern = pattern
                            break
                    
                    if detected_pattern:
                        finding = Finding(
                            id=f"SQLI-{endpoint['path'].replace('/', '')}-001",
                            title="SQL Injection Indicators Detected",
                            category="Injection",
                            severity="high",
                            confidence="medium",
                            description=f"SQL error pattern detected in {endpoint['name']}",
                            impact="An attacker may be able to manipulate database queries through the search parameter.",
                            location=Location(
                                type="endpoint",
                                path=endpoint['path'],
                                method=endpoint['method'],
                                parameter="q"
                            ),
                            evidence=Evidence(
                                request_observed=True,
                                response_pattern=f"SQL error pattern: {detected_pattern}",
                                notes="Response contains database error information"
                            ),
                            recommendation="Use parameterized queries and input validation for search functionality.",
                            references=[
                                "OWASP Top 10 - A03:2021 Injection",
                                "CWE-89: SQL Injection"
                            ]
                        )
                        findings.append(finding)
                        break
                        
            except Exception as e:
                continue
    
    return findings

# Keep old function for backward compatibility
def check(base_url, session):
    """Legacy check function (for backward compatibility)"""
    # This is kept for compatibility but should use check_new instead
    return {
        'status': 'info',
        'message': 'Please use check_new() with ScannerEngine'
    }

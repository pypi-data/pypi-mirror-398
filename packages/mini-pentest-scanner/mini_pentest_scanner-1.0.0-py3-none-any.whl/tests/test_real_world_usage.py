# -*- coding: utf-8 -*-
"""
Real-World Usage Tests
à¸—à¸”à¸ªà¸­à¸šà¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸ˆà¸£à¸´à¸‡à¹à¸šà¸š end-to-end
"""

import unittest
import sys
import os
import tempfile
import shutil
from pathlib import Path
from datetime import datetime, timedelta

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from mini_pentest_scanner.history.database import ScanHistoryDB
from mini_pentest_scanner.history.comparison import ScanComparison
from mini_pentest_scanner.history.trends import TrendAnalyzer
from mini_pentest_scanner.history.baseline import BaselineManager
from mini_pentest_scanner.history.compliance import ComplianceMapper
from mini_pentest_scanner.core.result import ScanResult, Finding, Location, Evidence


class TestRealWorldWorkflow(unittest.TestCase):
    """Test complete real-world workflows"""
    
    def setUp(self):
        """Set up test database"""
        self.temp_dir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.temp_dir, 'test_history.db')
        self.db = ScanHistoryDB(db_path=self.db_path)
        self.target_url = "http://example.com"
    
    def tearDown(self):
        """Clean up"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_workflow_1_scan_save_retrieve(self):
        """Test: Scan -> Save -> Retrieve"""
        # Step 1: Create scan result
        result = ScanResult(
            target=self.target_url,
            scanner_mode="passive"
        )
        
        finding = Finding(
            id="TEST-001",
            title="SQL Injection",
            category="Injection",
            severity="high",
            confidence="medium",
            description="Test finding",
            impact="Test impact",
            location=Location(type="endpoint", path="/login"),
            evidence=Evidence(),
            recommendation="Fix it"
        )
        result.add_finding(finding)
        
        # Step 2: Save to database
        scan_id = self.db.save_scan(result.to_dict())
        self.assertIsNotNone(scan_id)
        
        # Step 3: Retrieve from database
        retrieved = self.db.get_scan(scan_id)
        self.assertIsNotNone(retrieved)
        self.assertEqual(retrieved['target'], self.target_url)
        self.assertEqual(len(retrieved['findings']), 1)
    
    def test_workflow_2_multiple_scans_comparison(self):
        """Test: Multiple scans -> Compare"""
        # Create first scan
        result1 = ScanResult(target=self.target_url, scanner_mode="passive")
        finding1 = Finding(
            id="FIND-001", title="XSS", category="Injection", severity="high",
            confidence="medium", description="XSS", impact="Impact",
            location=Location(type="endpoint"), evidence=Evidence(),
            recommendation="Fix"
        )
        result1.add_finding(finding1)
        scan_id1 = self.db.save_scan(result1.to_dict())
        
        # Create second scan (more findings)
        result2 = ScanResult(target=self.target_url, scanner_mode="passive")
        finding2 = Finding(
            id="FIND-002", title="SQL Injection", category="Injection", severity="critical",
            confidence="high", description="SQL", impact="Impact",
            location=Location(type="endpoint"), evidence=Evidence(),
            recommendation="Fix"
        )
        result2.add_finding(finding1)  # Same finding
        result2.add_finding(finding2)  # New finding
        scan_id2 = self.db.save_scan(result2.to_dict())
        
        # Compare scans
        comparison = ScanComparison(self.db)
        comp_result = comparison.compare_scans(scan_id1, scan_id2)
        
        self.assertIn('risk_comparison', comp_result)
        self.assertIn('findings_comparison', comp_result)
        self.assertEqual(comp_result['findings_comparison']['added'], 1)
    
    def test_workflow_3_baseline_comparison(self):
        """Test: Set baseline -> Scan -> Compare with baseline"""
        # Create baseline scan
        baseline_result = ScanResult(target=self.target_url, scanner_mode="passive")
        baseline_id = self.db.save_scan(baseline_result.to_dict())
        
        # Set as baseline
        baseline_mgr = BaselineManager(self.db)
        success = baseline_mgr.set_baseline(self.target_url, baseline_id)
        self.assertTrue(success)
        
        # Create new scan
        new_result = ScanResult(target=self.target_url, scanner_mode="passive")
        finding = Finding(
            id="NEW-001", title="New Issue", category="Test", severity="high",
            confidence="medium", description="New", impact="Impact",
            location=Location(type="endpoint"), evidence=Evidence(),
            recommendation="Fix"
        )
        new_result.add_finding(finding)
        new_scan_id = self.db.save_scan(new_result.to_dict())
        
        # Compare with baseline
        comparison = ScanComparison(self.db)
        comp_result = comparison.compare_with_baseline(new_scan_id, self.target_url)
        
        # If baseline exists, returns comparison result (has scan1, scan2 keys)
        # If no baseline, returns {'has_baseline': False, ...}
        if 'has_baseline' in comp_result:
            # No baseline set
            self.assertFalse(comp_result['has_baseline'])
        else:
            # Baseline exists, should have comparison structure
            self.assertIn('scan1', comp_result)
            self.assertIn('scan2', comp_result)
            self.assertIn('findings_comparison', comp_result)
    
    def test_workflow_4_trend_analysis(self):
        """Test: Multiple scans over time -> Trend analysis"""
        # Create multiple scans with different risk scores
        scan_ids = []
        for i in range(5):
            result = ScanResult(target=self.target_url, scanner_mode="passive")
            # Add findings to increase risk score
            for j in range(i):
                finding = Finding(
                    id=f"FIND-{i}-{j}", title=f"Issue {j}", category="Test",
                    severity="high" if j % 2 == 0 else "medium",
                    confidence="medium", description="Test", impact="Impact",
                    location=Location(type="endpoint"), evidence=Evidence(),
                    recommendation="Fix"
                )
                result.add_finding(finding)
            scan_id = self.db.save_scan(result.to_dict())
            scan_ids.append(scan_id)
        
        # Analyze trends
        analyzer = TrendAnalyzer(self.db)
        trends = analyzer.analyze_trends(self.target_url, days=30)
        
        self.assertIn('risk_trend', trends)
        self.assertIn('findings_trend', trends)
        self.assertGreaterEqual(trends['total_scans'], 5)
    
    def test_workflow_5_compliance_mapping(self):
        """Test: Scan -> Compliance mapping"""
        # Create scan with findings
        result = ScanResult(target=self.target_url, scanner_mode="passive")
        finding = Finding(
            id="COMP-001", title="SQL Injection", category="Injection",
            severity="high", confidence="medium", description="SQL",
            impact="Impact", location=Location(type="endpoint"),
            evidence=Evidence(), recommendation="Fix"
        )
        result.add_finding(finding)
        scan_id = self.db.save_scan(result.to_dict())
        
        # Map to compliance
        mapper = ComplianceMapper(self.db)
        compliance = mapper.map_scan_to_compliance(scan_id, ['ISO27001'])
        
        self.assertIn('compliance', compliance)
        self.assertIn('ISO27001', compliance['compliance'])
        self.assertIn('summary', compliance)


class TestErrorScenarios(unittest.TestCase):
    """Test error scenarios that might occur in real usage"""
    
    def setUp(self):
        """Set up test database"""
        self.temp_dir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.temp_dir, 'test_history.db')
        self.db = ScanHistoryDB(db_path=self.db_path)
    
    def tearDown(self):
        """Clean up"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_scenario_1_database_locked(self):
        """Test: What happens if database is locked?"""
        # This is handled by SQLite automatically
        # But we should test that operations don't crash
        result = ScanResult(target="http://test.com", scanner_mode="passive")
        
        # Multiple rapid saves (simulating concurrent access)
        scan_ids = []
        for i in range(10):
            try:
                scan_id = self.db.save_scan(result.to_dict())
                scan_ids.append(scan_id)
            except Exception as e:
                # Should handle gracefully
                self.fail(f"Database operation failed: {e}")
        
        self.assertEqual(len(scan_ids), 10)
    
    def test_scenario_2_corrupted_scan_data(self):
        """Test: What happens with corrupted/invalid scan data?"""
        # Test with missing required fields
        invalid_data = {'scan_id': 'test-123'}  # Missing target
        
        with self.assertRaises(ValueError):
            self.db.save_scan(invalid_data)
        
        # Test with None
        with self.assertRaises(ValueError):
            self.db.save_scan(None)
    
    def test_scenario_3_missing_scan_comparison(self):
        """Test: Compare with non-existent scans"""
        comparison = ScanComparison(self.db)
        
        with self.assertRaises(ValueError):
            comparison.compare_scans("nonexistent1", "nonexistent2")
    
    def test_scenario_4_empty_database_operations(self):
        """Test: Operations on empty database"""
        # Get scans from empty database
        scans = self.db.get_all_scans()
        self.assertEqual(len(scans), 0)
        
        # Get scan that doesn't exist
        scan = self.db.get_scan("nonexistent")
        self.assertIsNone(scan)
        
        # Trends with no data
        analyzer = TrendAnalyzer(self.db)
        trends = analyzer.analyze_trends("http://test.com", days=30)
        self.assertFalse(trends.get('has_enough_data', True))
    
    def test_scenario_5_large_dataset(self):
        """Test: Performance with large dataset"""
        # Create many scans
        scan_ids = []
        for i in range(100):
            result = ScanResult(
                target=f"http://example{i % 10}.com",
                scanner_mode="passive"
            )
            scan_id = self.db.save_scan(result.to_dict())
            scan_ids.append(scan_id)
        
        # Test retrieval
        all_scans = self.db.get_all_scans(limit=1000)
        self.assertGreaterEqual(len(all_scans), 100)
        
        # Test query by target
        target_scans = self.db.get_scans_by_target("http://example0.com", limit=100)
        self.assertGreater(len(target_scans), 0)


class TestEdgeCasesRealWorld(unittest.TestCase):
    """Test edge cases that might occur in real usage"""
    
    def setUp(self):
        """Set up test database"""
        self.temp_dir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.temp_dir, 'test_history.db')
        self.db = ScanHistoryDB(db_path=self.db_path)
    
    def tearDown(self):
        """Clean up"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_edge_case_1_very_long_url(self):
        """Test: Very long target URL"""
        long_url = "http://" + "a" * 1000 + ".com"
        result = ScanResult(target=long_url, scanner_mode="passive")
        
        # Should handle gracefully
        scan_id = self.db.save_scan(result.to_dict())
        self.assertIsNotNone(scan_id)
        
        retrieved = self.db.get_scan(scan_id)
        self.assertEqual(retrieved['target'], long_url)
    
    def test_edge_case_2_special_characters(self):
        """Test: Special characters in data"""
        result = ScanResult(target="http://test.com", scanner_mode="passive")
        finding = Finding(
            id="SPEC-001", title="Test <script>alert('XSS')</script>",
            category="Injection", severity="high", confidence="medium",
            description="Test with 'quotes' and \"double quotes\"",
            impact="Impact", location=Location(type="endpoint"),
            evidence=Evidence(), recommendation="Fix & escape"
        )
        result.add_finding(finding)
        
        scan_id = self.db.save_scan(result.to_dict())
        retrieved = self.db.get_scan(scan_id)
        
        self.assertEqual(len(retrieved['findings']), 1)
        self.assertIn("<script>", retrieved['findings'][0]['title'])
    
    def test_edge_case_3_unicode_characters(self):
        """Test: Unicode characters"""
        result = ScanResult(target="http://test.com", scanner_mode="passive")
        finding = Finding(
            id="UNI-001", title="à¸—à¸”à¸ªà¸­à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢ ä¸­æ–‡ ðŸš€",
            category="Test", severity="high", confidence="medium",
            description="Unicode test", impact="Impact",
            location=Location(type="endpoint"), evidence=Evidence(),
            recommendation="Test"
        )
        result.add_finding(finding)
        
        scan_id = self.db.save_scan(result.to_dict())
        retrieved = self.db.get_scan(scan_id)
        
        self.assertIn("à¸ à¸²à¸©à¸²à¹„à¸—à¸¢", retrieved['findings'][0]['title'])
    
    def test_edge_case_4_zero_risk_score(self):
        """Test: Scan with zero risk score"""
        result = ScanResult(target="http://test.com", scanner_mode="passive")
        # No findings = zero risk
        
        scan_id = self.db.save_scan(result.to_dict())
        retrieved = self.db.get_scan(scan_id)
        
        self.assertEqual(retrieved['summary']['risk_score'], 0)
        
        # Compare with another zero-risk scan
        result2 = ScanResult(target="http://test.com", scanner_mode="passive")
        scan_id2 = self.db.save_scan(result2.to_dict())
        
        comparison = ScanComparison(self.db)
        comp_result = comparison.compare_scans(scan_id, scan_id2)
        
        # Should handle zero risk gracefully
        self.assertIn('risk_comparison', comp_result)
        self.assertEqual(comp_result['risk_comparison']['change'], 0)
    
    def test_edge_case_5_duplicate_scan_ids(self):
        """Test: Saving same scan twice (should update, not error)"""
        result = ScanResult(target="http://test.com", scanner_mode="passive")
        scan_id = result.scan_id
        
        # Save first time
        saved_id1 = self.db.save_scan(result.to_dict())
        
        # Save again (same scan_id)
        saved_id2 = self.db.save_scan(result.to_dict())
        
        self.assertEqual(saved_id1, saved_id2)
        self.assertEqual(saved_id1, scan_id)
        
        # Should have only one entry
        scans = self.db.get_all_scans()
        scan_ids = [s['scan_id'] for s in scans]
        self.assertEqual(scan_ids.count(scan_id), 1)


class TestConcurrentOperations(unittest.TestCase):
    """Test concurrent operations (simulated)"""
    
    def setUp(self):
        """Set up test database"""
        self.temp_dir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.temp_dir, 'test_history.db')
        self.db = ScanHistoryDB(db_path=self.db_path)
    
    def tearDown(self):
        """Clean up"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_concurrent_saves(self):
        """Test: Multiple rapid saves"""
        scan_ids = []
        for i in range(20):
            result = ScanResult(
                target=f"http://test{i}.com",
                scanner_mode="passive"
            )
            try:
                scan_id = self.db.save_scan(result.to_dict())
                scan_ids.append(scan_id)
            except Exception as e:
                self.fail(f"Concurrent save failed: {e}")
        
        self.assertEqual(len(scan_ids), 20)
        
        # Verify all saved
        all_scans = self.db.get_all_scans(limit=100)
        self.assertGreaterEqual(len(all_scans), 20)
    
    def test_concurrent_reads(self):
        """Test: Multiple concurrent reads"""
        # Create some scans
        scan_ids = []
        for i in range(10):
            result = ScanResult(target="http://test.com", scanner_mode="passive")
            scan_id = self.db.save_scan(result.to_dict())
            scan_ids.append(scan_id)
        
        # Read concurrently (simulated)
        results = []
        for scan_id in scan_ids:
            try:
                scan = self.db.get_scan(scan_id)
                results.append(scan)
            except Exception as e:
                self.fail(f"Concurrent read failed: {e}")
        
        self.assertEqual(len(results), 10)


if __name__ == '__main__':
    unittest.main(verbosity=2)


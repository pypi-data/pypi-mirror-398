"""
Test Cases for Vulnerabilities
‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ä‡πà‡∏≠‡∏á‡πÇ‡∏´‡∏ß‡πà‡πÉ‡∏ô Vulnerable App
"""

import unittest
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    import requests
except ImportError:
    print("ERROR: requests module not found!")
    print("Please install it with: pip install requests")
    sys.exit(1)

import hashlib
from urllib.parse import urljoin

class TestVulnerabilities(unittest.TestCase):
    """Test cases for security vulnerabilities"""
    
    BASE_URL = "http://127.0.0.1:5000"
    session = None
    
    @classmethod
    def setUpClass(cls):
        """Setup test session"""
        cls.session = requests.Session()
    
    def test_sql_injection_login(self):
        """Test SQL Injection in login endpoint"""
        url = urljoin(self.BASE_URL, '/login')
        
        # SQL Injection payload
        payloads = [
            "admin' --",
            "admin' #",
            "' OR '1'='1",
            "' OR '1'='1' --",
        ]
        
        for payload in payloads:
            response = self.session.post(url, data={
                'username': payload,
                'password': 'anything'
            }, allow_redirects=False)
            
            # Check if SQL error is exposed
            self.assertNotIn('sqlite3', response.text.lower(), 
                            f"SQL error exposed with payload: {payload}")
            
            # Check if authentication bypass occurred
            if response.status_code == 302:
                location = response.headers.get('Location', '')
                if 'dashboard' in location:
                    self.fail(f"Possible SQL Injection bypass with payload: {payload}")
    
    def test_sql_injection_search(self):
        """Test SQL Injection in search endpoint"""
        url = urljoin(self.BASE_URL, '/search')
        
        payloads = [
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "test' AND '1'='1",
        ]
        
        for payload in payloads:
            response = self.session.get(url, params={'q': payload})
            
            # Check if SQL error is exposed
            self.assertNotIn('sqlite3', response.text.lower(),
                            f"SQL error exposed with payload: {payload}")
    
    def test_xss_search(self):
        """Test XSS in search endpoint"""
        url = urljoin(self.BASE_URL, '/search')
        
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
        ]
        
        for payload in payloads:
            response = self.session.get(url, params={'q': payload})
            
            # Check if payload is reflected unsanitized
            # In secure app, script tags should be escaped
            if '<script>' in payload.lower():
                self.assertNotIn('<script>', response.text,
                                f"XSS vulnerability: script tag not escaped with payload: {payload}")
    
    def test_xss_post_creation(self):
        """Test XSS in post creation"""
        # Login first
        login_url = urljoin(self.BASE_URL, '/login')
        self.session.post(login_url, data={
            'username': 'user1',
            'password': 'password123'
        })
        
        # Create post with XSS payload
        create_url = urljoin(self.BASE_URL, '/post/create')
        payload = "<script>alert('XSS')</script>"
        
        response = self.session.post(create_url, data={
            'title': 'Test Post',
            'content': payload
        }, allow_redirects=False)
        
        # If redirect, check the post page
        if response.status_code == 302:
            # In secure app, content should be escaped
            # This test documents the vulnerability
            pass
    
    def test_idor_profile(self):
        """Test IDOR in profile endpoint"""
        # Login as user1
        login_url = urljoin(self.BASE_URL, '/login')
        self.session.post(login_url, data={
            'username': 'user1',
            'password': 'password123'
        })
        
        # Try to access admin profile (user_id=1)
        profile_url = urljoin(self.BASE_URL, '/profile/1')
        response = self.session.get(profile_url)
        
        # In secure app, should return 403 Forbidden
        # This test documents the vulnerability
        if response.status_code == 200:
            # Check if we can see admin's email
            if 'admin@lab.local' in response.text:
                self.fail("IDOR vulnerability: Can access other user's profile")
    
    def test_idor_api(self):
        """Test IDOR in API endpoint"""
        # Login as user1
        login_url = urljoin(self.BASE_URL, '/login')
        self.session.post(login_url, data={
            'username': 'user1',
            'password': 'password123'
        })
        
        # Try to access admin data via API
        api_url = urljoin(self.BASE_URL, '/api/user/1')
        response = self.session.get(api_url)
        
        if response.status_code == 200:
            data = response.json()
            # In secure app, should return 403 or empty data
            if 'email' in data and data['email'] == 'admin@lab.local':
                self.fail("IDOR vulnerability: Can access other user's data via API")
    
    def test_weak_authentication(self):
        """Test weak authentication (MD5 hashing)"""
        # This test documents the vulnerability
        # In secure app, should use bcrypt
        password = 'test123'
        md5_hash = hashlib.md5(password.encode()).hexdigest()
        
        # MD5 is weak - this should not be used
        self.assertNotEqual(len(md5_hash), 60,  # bcrypt hash length
                          "Using weak password hashing (MD5)")
    
    def test_information_disclosure_debug(self):
        """Test information disclosure in debug endpoint"""
        debug_url = urljoin(self.BASE_URL, '/debug')
        response = self.session.get(debug_url)
        
        # Debug endpoint should not exist in production
        if response.status_code == 200:
            # Check for sensitive information
            sensitive_info = ['python_version', 'environment', 'session']
            for info in sensitive_info:
                if info in response.text.lower():
                    self.fail(f"Information disclosure: {info} exposed in debug endpoint")
    
    def test_information_disclosure_error(self):
        """Test information disclosure in error messages"""
        # Try to access non-existent page
        url = urljoin(self.BASE_URL, '/nonexistent-page-12345')
        response = self.session.get(url)
        
        # Error message should be generic
        if 'traceback' in response.text.lower():
            self.fail("Information disclosure: Stack trace exposed in error message")
        
        if 'file' in response.text.lower() and 'line' in response.text.lower():
            self.fail("Information disclosure: File paths exposed in error message")
    
    def test_session_fixation(self):
        """Test session fixation vulnerability"""
        # Get session ID before login
        old_session_id = self.session.cookies.get('session', '')
        
        # Login
        login_url = urljoin(self.BASE_URL, '/login')
        self.session.post(login_url, data={
            'username': 'user1',
            'password': 'password123'
        })
        
        # Get session ID after login
        new_session_id = self.session.cookies.get('session', '')
        
        # Session ID should be regenerated
        if old_session_id and new_session_id == old_session_id:
            self.fail("Session fixation: Session ID not regenerated after login")
    
    def test_csrf_protection(self):
        """Test CSRF protection"""
        # Login first
        login_url = urljoin(self.BASE_URL, '/login')
        self.session.post(login_url, data={
            'username': 'user1',
            'password': 'password123'
        })
        
        # Try to create post without CSRF token
        create_url = urljoin(self.BASE_URL, '/post/create')
        response = self.session.post(create_url, data={
            'title': 'CSRF Test',
            'content': 'Test content'
        }, allow_redirects=False)
        
        # In secure app, should check for CSRF token
        # This test documents the vulnerability
        if response.status_code == 302:
            # Post was created without CSRF token - vulnerability
            pass
    
    def test_path_traversal(self):
        """Test path traversal vulnerability"""
        # Try to access files outside allowed directory
        payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\config\\sam',
            '../../app/main.py',
        ]
        
        for payload in payloads:
            url = urljoin(self.BASE_URL, f'/file?file={payload}')
            response = self.session.get(url)
            
            # Should return 403 or 404, not the file
            if response.status_code == 200:
                # Check if it's actually a system file
                if 'root:' in response.text or '#!/usr/bin' in response.text:
                    self.fail(f"Path traversal vulnerability: Can access {payload}")

if __name__ == '__main__':
    print("=" * 60)
    print("üß™ Running Vulnerability Tests")
    print("=" * 60)
    print("‚ö†Ô∏è  Make sure Vulnerable App is running on http://127.0.0.1:5000")
    print("=" * 60)
    print()
    
    # Check if app is running
    try:
        import requests
        response = requests.get("http://127.0.0.1:5000", timeout=2)
        print("‚úÖ Vulnerable App is running")
    except:
        print("‚ùå ERROR: Vulnerable App is not running!")
        print("   Please start it first:")
        print("   cd ../vulnerable-app")
        print("   python -m app.main")
        print()
        response = input("Continue anyway? (y/n): ")
        if response.lower() != 'y':
            sys.exit(1)
    
    print()
    unittest.main(verbosity=2)


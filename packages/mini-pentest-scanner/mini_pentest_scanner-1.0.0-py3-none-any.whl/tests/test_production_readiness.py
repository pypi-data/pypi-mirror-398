# -*- coding: utf-8 -*-
"""
Production Readiness Tests
ทดสอบความพร้อมใช้งานจริงแบบครอบคลุม
"""

import unittest
import sys
import os
import tempfile
import shutil
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from mini_pentest_scanner.history.database import ScanHistoryDB
from mini_pentest_scanner.history.comparison import ScanComparison
from mini_pentest_scanner.history.trends import TrendAnalyzer
from mini_pentest_scanner.history.baseline import BaselineManager
from mini_pentest_scanner.history.compliance import ComplianceMapper
from mini_pentest_scanner.core.result import ScanResult, Finding, Location, Evidence
from mini_pentest_scanner.core.config import ScannerConfig
from mini_pentest_scanner.scanner import SecurityScanner


class TestProductionReadiness(unittest.TestCase):
    """Test production readiness scenarios"""
    
    def setUp(self):
        """Set up test environment"""
        self.temp_dir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.temp_dir, 'test_prod.db')
        self.db = ScanHistoryDB(db_path=self.db_path)
        self.target_url = "http://example.com"
    
    def tearDown(self):
        """Clean up"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_production_scenario_1_full_workflow(self):
        """Test: Complete production workflow"""
        # 1. Create and save multiple scans
        scan_ids = []
        for i in range(5):
            result = ScanResult(target=self.target_url, scanner_mode="passive")
            if i > 0:
                finding = Finding(
                    id=f"FIND-{i}", title=f"Issue {i}", category="Test",
                    severity="high", confidence="medium", description="Test",
                    impact="Impact", location=Location(type="endpoint"),
                    evidence=Evidence(), recommendation="Fix"
                )
                result.add_finding(finding)
            scan_id = self.db.save_scan(result.to_dict())
            scan_ids.append(scan_id)
        
        # 2. Set baseline
        baseline_mgr = BaselineManager(self.db)
        baseline_mgr.set_baseline(self.target_url, scan_ids[0])
        
        # 3. Compare latest with baseline
        comparison = ScanComparison(self.db)
        comp_result = comparison.compare_with_baseline(scan_ids[-1], self.target_url)
        self.assertIsNotNone(comp_result)
        
        # 4. Analyze trends
        analyzer = TrendAnalyzer(self.db)
        trends = analyzer.analyze_trends(self.target_url, days=30)
        self.assertIn('risk_trend', trends)
        
        # 5. Compliance mapping
        mapper = ComplianceMapper(self.db)
        compliance = mapper.map_scan_to_compliance(scan_ids[-1], ['ISO27001'])
        self.assertIn('compliance', compliance)
        
        # All operations successful
        self.assertTrue(True)
    
    def test_production_scenario_2_data_integrity(self):
        """Test: Data integrity after multiple operations"""
        # Create scan
        result = ScanResult(target=self.target_url, scanner_mode="passive")
        finding = Finding(
            id="INT-001", title="Integrity Test", category="Test",
            severity="high", confidence="medium", description="Test",
            impact="Impact", location=Location(type="endpoint"),
            evidence=Evidence(), recommendation="Fix"
        )
        result.add_finding(finding)
        scan_id = self.db.save_scan(result.to_dict())
        
        # Retrieve and verify
        retrieved = self.db.get_scan(scan_id)
        self.assertEqual(retrieved['target'], self.target_url)
        self.assertEqual(len(retrieved['findings']), 1)
        self.assertEqual(retrieved['findings'][0]['id'], "INT-001")
        
        # Update (save again)
        result.add_finding(Finding(
            id="INT-002", title="Second Finding", category="Test",
            severity="medium", confidence="high", description="Test",
            impact="Impact", location=Location(type="endpoint"),
            evidence=Evidence(), recommendation="Fix"
        ))
        self.db.save_scan(result.to_dict())
        
        # Verify update
        updated = self.db.get_scan(scan_id)
        self.assertEqual(len(updated['findings']), 2)
    
    def test_production_scenario_3_error_recovery(self):
        """Test: Error recovery and resilience"""
        # Test with invalid data
        with self.assertRaises(ValueError):
            self.db.save_scan(None)
        
        with self.assertRaises(ValueError):
            self.db.save_scan({})
        
        # Database should still work after errors
        result = ScanResult(target=self.target_url, scanner_mode="passive")
        scan_id = self.db.save_scan(result.to_dict())
        self.assertIsNotNone(scan_id)
        
        # Retrieve should work
        retrieved = self.db.get_scan(scan_id)
        self.assertIsNotNone(retrieved)
    
    def test_production_scenario_4_concurrent_operations(self):
        """Test: Multiple concurrent-like operations"""
        scan_ids = []
        
        # Simulate concurrent saves
        for i in range(50):
            result = ScanResult(
                target=f"http://example{i % 5}.com",
                scanner_mode="passive"
            )
            try:
                scan_id = self.db.save_scan(result.to_dict())
                scan_ids.append(scan_id)
            except Exception as e:
                self.fail(f"Concurrent operation failed: {e}")
        
        self.assertEqual(len(scan_ids), 50)
        
        # Verify all saved
        all_scans = self.db.get_all_scans(limit=1000)
        self.assertGreaterEqual(len(all_scans), 50)
        
        # Test concurrent reads
        for scan_id in scan_ids[:10]:
            scan = self.db.get_scan(scan_id)
            self.assertIsNotNone(scan)
    
    def test_production_scenario_5_large_scale(self):
        """Test: Large scale operations"""
        # Create many scans
        scan_ids = []
        for i in range(200):
            result = ScanResult(
                target=self.target_url,
                scanner_mode="passive"
            )
            scan_id = self.db.save_scan(result.to_dict())
            scan_ids.append(scan_id)
        
        # Test retrieval
        scans = self.db.get_scans_by_target(self.target_url, limit=1000)
        self.assertGreaterEqual(len(scans), 200)
        
        # Test comparison (should work even with many scans)
        if len(scan_ids) >= 2:
            comparison = ScanComparison(self.db)
            comp_result = comparison.compare_scans(scan_ids[0], scan_ids[-1])
            self.assertIn('risk_comparison', comp_result)
        
        # Test trends
        analyzer = TrendAnalyzer(self.db)
        trends = analyzer.analyze_trends(self.target_url, days=30)
        self.assertIn('risk_trend', trends)
    
    def test_production_scenario_6_configuration(self):
        """Test: Configuration handling"""
        # Test default config
        config = ScannerConfig()
        self.assertIsNotNone(config)
        
        # Test config from file
        config_path = project_root / 'config.yaml'
        if config_path.exists():
            config = ScannerConfig(str(config_path))
            self.assertIsNotNone(config)
        
        # Test scanner with config
        scanner = SecurityScanner("http://example.com", config)
        self.assertIsNotNone(scanner)
    
    def test_production_scenario_7_api_data_consistency(self):
        """Test: Data consistency across operations"""
        # Create scan
        result = ScanResult(target=self.target_url, scanner_mode="passive")
        finding = Finding(
            id="CONS-001", title="Consistency Test", category="Test",
            severity="high", confidence="medium", description="Test",
            impact="Impact", location=Location(type="endpoint"),
            evidence=Evidence(), recommendation="Fix"
        )
        result.add_finding(finding)
        scan_id = self.db.save_scan(result.to_dict())
        
        # Get summary
        summary = self.db.get_scan_summary(scan_id)
        self.assertIsNotNone(summary)
        self.assertEqual(summary['total_findings'], 1)
        
        # Get full scan
        full_scan = self.db.get_scan(scan_id)
        self.assertIsNotNone(full_scan)
        self.assertEqual(full_scan['summary']['total_findings'], 1)
        
        # Data should be consistent
        self.assertEqual(summary['total_findings'], full_scan['summary']['total_findings'])
        self.assertEqual(summary['risk_score'], full_scan['summary']['risk_score'])


class TestDataIntegrity(unittest.TestCase):
    """Test data integrity"""
    
    def setUp(self):
        """Set up test environment"""
        self.temp_dir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.temp_dir, 'test_integrity.db')
        self.db = ScanHistoryDB(db_path=self.db_path)
    
    def tearDown(self):
        """Clean up"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_integrity_1_scan_persistence(self):
        """Test: Scan data persists correctly"""
        result = ScanResult(target="http://test.com", scanner_mode="passive")
        finding = Finding(
            id="PERSIST-001", title="Persistence Test", category="Test",
            severity="high", confidence="medium", description="Test",
            impact="Impact", location=Location(type="endpoint", path="/test"),
            evidence=Evidence(response_pattern="test pattern"),
            recommendation="Fix"
        )
        result.add_finding(finding)
        scan_id = self.db.save_scan(result.to_dict())
        
        # Close and reopen database
        del self.db
        self.db = ScanHistoryDB(db_path=self.db_path)
        
        # Data should persist
        retrieved = self.db.get_scan(scan_id)
        self.assertIsNotNone(retrieved)
        self.assertEqual(retrieved['target'], "http://test.com")
        self.assertEqual(len(retrieved['findings']), 1)
        self.assertEqual(retrieved['findings'][0]['id'], "PERSIST-001")
        self.assertEqual(retrieved['findings'][0]['location']['path'], "/test")
    
    def test_integrity_2_findings_consistency(self):
        """Test: Findings data consistency"""
        result = ScanResult(target="http://test.com", scanner_mode="passive")
        
        # Add multiple findings
        for i in range(5):
            finding = Finding(
                id=f"FIND-{i}", title=f"Finding {i}", category="Test",
                severity="high" if i % 2 == 0 else "medium",
                confidence="medium", description="Test", impact="Impact",
                location=Location(type="endpoint", path=f"/path{i}"),
                evidence=Evidence(), recommendation="Fix"
            )
            result.add_finding(finding)
        
        scan_id = self.db.save_scan(result.to_dict())
        
        # Verify all findings saved
        retrieved = self.db.get_scan(scan_id)
        self.assertEqual(len(retrieved['findings']), 5)
        
        # Verify finding details
        for i, finding in enumerate(retrieved['findings']):
            self.assertEqual(finding['id'], f"FIND-{i}")
            self.assertEqual(finding['location']['path'], f"/path{i}")


class TestErrorRecovery(unittest.TestCase):
    """Test error recovery"""
    
    def setUp(self):
        """Set up test environment"""
        self.temp_dir = tempfile.mkdtemp()
        self.db_path = os.path.join(self.temp_dir, 'test_recovery.db')
        self.db = ScanHistoryDB(db_path=self.db_path)
    
    def tearDown(self):
        """Clean up"""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_recovery_1_after_invalid_operations(self):
        """Test: System recovers after invalid operations"""
        # Try invalid operations
        with self.assertRaises(ValueError):
            self.db.save_scan(None)
        
        with self.assertRaises(ValueError):
            self.db.save_scan({})
        
        # System should still work
        result = ScanResult(target="http://test.com", scanner_mode="passive")
        scan_id = self.db.save_scan(result.to_dict())
        self.assertIsNotNone(scan_id)
    
    def test_recovery_2_after_comparison_errors(self):
        """Test: System recovers after comparison errors"""
        comparison = ScanComparison(self.db)
        
        # Try invalid comparisons
        with self.assertRaises(ValueError):
            comparison.compare_scans("", "test")
        
        with self.assertRaises(ValueError):
            comparison.compare_scans("test", "")
        
        # Create valid scans and compare
        result1 = ScanResult(target="http://test.com", scanner_mode="passive")
        scan_id1 = self.db.save_scan(result1.to_dict())
        
        result2 = ScanResult(target="http://test.com", scanner_mode="passive")
        scan_id2 = self.db.save_scan(result2.to_dict())
        
        comp_result = comparison.compare_scans(scan_id1, scan_id2)
        self.assertIsNotNone(comp_result)


if __name__ == '__main__':
    unittest.main(verbosity=2)


"""
Unit Tests for Scanner Core Modules
ทดสอบ core modules ของ scanner
"""

import unittest
import sys
import os
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from mini_pentest_scanner.core.result import (
    ScanResult, Finding, Location, Evidence, Summary, ScanMetadata
)
from mini_pentest_scanner.core.config import ScannerConfig
from mini_pentest_scanner.core.http_client import HTTPClient
from mini_pentest_scanner.core.checker import SecurityChecker


class TestResultSchema(unittest.TestCase):
    """Test Result Schema classes"""
    
    def test_location_creation(self):
        """Test Location creation"""
        loc = Location(
            type="endpoint",
            path="/test",
            method="GET",
            parameter="id"
        )
        self.assertEqual(loc.type, "endpoint")
        self.assertEqual(loc.path, "/test")
        self.assertEqual(loc.method, "GET")
        self.assertEqual(loc.parameter, "id")
    
    def test_location_to_dict(self):
        """Test Location to_dict"""
        loc = Location(type="endpoint", path="/test")
        loc_dict = loc.to_dict()
        self.assertIn('type', loc_dict)
        self.assertIn('path', loc_dict)
        self.assertEqual(loc_dict['type'], "endpoint")
    
    def test_evidence_creation(self):
        """Test Evidence creation"""
        ev = Evidence(
            request_observed=True,
            response_pattern="Error pattern",
            notes="Test note"
        )
        self.assertTrue(ev.request_observed)
        self.assertEqual(ev.response_pattern, "Error pattern")
        self.assertEqual(ev.notes, "Test note")
    
    def test_finding_creation(self):
        """Test Finding creation"""
        finding = Finding(
            id="TEST-001",
            title="Test Finding",
            category="Test",
            severity="high",
            confidence="medium",
            description="Test description",
            impact="Test impact",
            location=Location(type="endpoint", path="/test"),
            evidence=Evidence(request_observed=True),
            recommendation="Test recommendation"
        )
        self.assertEqual(finding.id, "TEST-001")
        self.assertEqual(finding.severity, "high")
        self.assertIsNotNone(finding.location)
    
    def test_scan_result_creation(self):
        """Test ScanResult creation"""
        result = ScanResult(
            target="http://example.com",
            scanner_mode="passive"
        )
        self.assertEqual(result.target, "http://example.com")
        self.assertIsNotNone(result.scan_id)
        self.assertIsNotNone(result.scan_time)
        self.assertIsNotNone(result.summary)
        self.assertIsNotNone(result.metadata)
    
    def test_scan_result_add_finding(self):
        """Test adding finding to ScanResult"""
        result = ScanResult(
            target="http://example.com",
            scanner_mode="passive"
        )
        finding = Finding(
            id="TEST-001",
            title="Test",
            category="Test",
            severity="high",
            confidence="medium",
            description="Test",
            impact="Test",
            location=Location(type="endpoint"),
            evidence=Evidence(),
            recommendation="Test"
        )
        result.add_finding(finding)
        self.assertEqual(len(result.findings), 1)
        self.assertEqual(result.summary.total_findings, 1)
    
    def test_scan_result_save_json(self):
        """Test saving ScanResult to JSON"""
        import tempfile
        result = ScanResult(
            target="http://example.com",
            scanner_mode="passive"
        )
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            temp_path = f.name
        
        try:
            result.save_json(temp_path)
            self.assertTrue(os.path.exists(temp_path))
            
            # Verify JSON can be loaded
            import json
            with open(temp_path, 'r') as f:
                data = json.load(f)
            self.assertEqual(data['target'], "http://example.com")
        finally:
            if os.path.exists(temp_path):
                os.unlink(temp_path)


class TestScannerConfig(unittest.TestCase):
    """Test ScannerConfig"""
    
    def test_default_config(self):
        """Test default configuration"""
        config = ScannerConfig()
        self.assertIsNotNone(config)
        mode = config.get('scanner.mode', 'passive')
        self.assertIn(mode, ['passive', 'active-light'])
    
    def test_config_get_set(self):
        """Test config get/set"""
        config = ScannerConfig()
        config.set('test.key', 'test_value')
        value = config.get('test.key')
        self.assertEqual(value, 'test_value')
    
    def test_config_from_file(self):
        """Test loading config from file"""
        config_path = project_root / 'config.yaml'
        if config_path.exists():
            config = ScannerConfig(str(config_path))
            self.assertIsNotNone(config)
        else:
            self.skipTest("config.yaml not found")


class TestHTTPClient(unittest.TestCase):
    """Test HTTPClient"""
    
    def test_http_client_creation(self):
        """Test HTTPClient creation"""
        client = HTTPClient("http://example.com", timeout=10)
        self.assertEqual(client.base_url, "http://example.com")
        self.assertEqual(client.timeout, 10)
    
    def test_http_client_get(self):
        """Test HTTP GET request"""
        # This will fail if no internet, but that's okay for unit test
        client = HTTPClient("https://httpbin.org", timeout=5)
        try:
            response = client.get("/get")
            self.assertIsNotNone(response)
            self.assertEqual(response.status_code, 200)
        except Exception:
            self.skipTest("Network request failed (expected in some environments)")


class TestSecurityChecker(unittest.TestCase):
    """Test SecurityChecker"""
    
    def test_checker_creation(self):
        """Test SecurityChecker creation"""
        checker = SecurityChecker("http://example.com")
        self.assertEqual(checker.base_url, "http://example.com")
    
    def test_check_response_pattern_with_string(self):
        """Test pattern checking with string response"""
        checker = SecurityChecker("http://example.com")
        
        # Test with plain string pattern
        result = checker.check_response_pattern("SQL error: syntax error", "SQL error")
        self.assertIsNotNone(result)
        self.assertEqual(result, "SQL error")
        
        # Test with case insensitive
        result = checker.check_response_pattern("sql ERROR: syntax", "SQL error", case_sensitive=False)
        self.assertIsNotNone(result)
    
    def test_check_response_pattern_with_regex(self):
        """Test pattern checking with regex pattern"""
        checker = SecurityChecker("http://example.com")
        
        # Test with regex pattern
        result = checker.check_response_pattern("Error: sqlite3.OperationalError", r'sqlite3\.\w+Error')
        self.assertIsNotNone(result)
        self.assertIn("sqlite3", result)
        
        # Test with case insensitive regex
        result = checker.check_response_pattern("SQL ERROR detected", r'sql.*error', case_sensitive=False)
        self.assertIsNotNone(result)
    
    def test_check_response_pattern_with_response_object(self):
        """Test pattern checking with response-like object"""
        checker = SecurityChecker("http://example.com")
        
        # Create mock response object
        class MockResponse:
            def __init__(self, text):
                self.text = text
        
        response = MockResponse("Database error: connection failed")
        result = checker.check_response_pattern(response, r'database.*error')
        self.assertIsNotNone(result)
        self.assertIn("error", result.lower())
    
    def test_check_response_pattern_no_match(self):
        """Test pattern checking when no match found"""
        checker = SecurityChecker("http://example.com")
        
        result = checker.check_response_pattern("Normal response text", "SQL error")
        self.assertIsNone(result)
    
    def test_check_response_pattern_invalid_pattern(self):
        """Test pattern checking with invalid regex"""
        checker = SecurityChecker("http://example.com")
        
        # Invalid regex pattern
        result = checker.check_response_pattern("Test text", "[invalid[")
        self.assertIsNone(result)


if __name__ == '__main__':
    unittest.main(verbosity=2)


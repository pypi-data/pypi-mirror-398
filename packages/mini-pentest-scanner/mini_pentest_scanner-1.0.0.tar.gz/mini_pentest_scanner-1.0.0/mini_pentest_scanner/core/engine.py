"""
Scanner Engine - Orchestrator for security checks
"""

from typing import List, Callable, Dict, Any, Optional
from .result import ScanResult, Finding, Location, Evidence
from .http_client import HTTPClient
from .config import ScannerConfig
import logging

logger = logging.getLogger(__name__)

class ScannerEngine:
    """Main scanner engine (orchestrator)"""
    
    def __init__(self, base_url: str, config: Optional[ScannerConfig] = None):
        """
        Initialize scanner engine
        
        Args:
            base_url: Target URL to scan
            config: Scanner configuration
        """
        if not base_url:
            raise ValueError("base_url cannot be empty")
        
        self.base_url = base_url
        self.config = config or ScannerConfig()
        self.http_client = HTTPClient(
            base_url,
            timeout=self.config.get_timeout(),
            user_agent=self.config.get_user_agent()
        )
        self.scan_result = ScanResult(
            base_url,
            scanner_mode=self.config.get_scanner_mode()
        )
        self.checks: List[Dict[str, Any]] = []
        logger.info(f"ScannerEngine initialized for {base_url}")
    
    def register_check(self, check_func: Callable, name: str, category: str):
        """
        Register a check function
        
        Args:
            check_func: Check function that takes ScannerEngine and returns List[Finding]
            name: Check name
            category: Check category
        """
        if not callable(check_func):
            raise TypeError("check_func must be callable")
        
        self.checks.append({
            'name': name,
            'category': category,
            'func': check_func
        })
        logger.debug(f"Registered check: {name} ({category})")
    
    def run_scan(self, enabled_checks: Optional[List[str]] = None) -> ScanResult:
        """
        Run all registered checks
        
        Args:
            enabled_checks: List of check names to run (None = all)
            
        Returns:
            ScanResult object
        """
        print("=" * 60)
        print("ðŸ” Security Scanner - Non-intrusive Assessment")
        print("=" * 60)
        print(f"Target: {self.base_url}")
        print(f"Mode: {self.scan_result.metadata.scanner_mode}")
        print(f"Policy: {self.scan_result.metadata.scan_policy}")
        print("=" * 60)
        print()
        
        # Verify authorization if required
        if self.config.require_authorization():
            if not self._verify_authorization():
                print("âŒ Authorization check failed. Scan cancelled.")
                logger.warning("Authorization check failed")
                return self.scan_result
        
        # Run checks
        checks_to_run = self.checks
        if enabled_checks:
            checks_to_run = [c for c in self.checks if c['name'] in enabled_checks]
            if not checks_to_run:
                logger.warning(f"No matching checks found for: {enabled_checks}")
                print("âš ï¸  No matching checks found")
                return self.scan_result
        
        for check in checks_to_run:
            check_name = check['name']
            print(f"ðŸ”Ž Checking: {check_name}...")
            try:
                findings = check['func'](self)
                if findings:
                    if not isinstance(findings, list):
                        logger.error(f"Check {check_name} returned non-list result")
                        findings = []
                    
                    for finding in findings:
                        if isinstance(finding, Finding):
                            self.scan_result.add_finding(finding)
                        else:
                            logger.warning(f"Check {check_name} returned invalid finding type")
                    
                    print(f"   âš ï¸  Found {len(findings)} issue(s)")
                else:
                    print(f"   âœ… No issues found")
            except KeyboardInterrupt:
                logger.info("Scan interrupted by user")
                print("\nâš ï¸  Scan interrupted by user")
                raise
            except Exception as e:
                logger.error(f"Error in check {check_name}: {e}", exc_info=True)
                print(f"   âŒ Error: {str(e)}")
            print()
        
        # Update summary
        self.scan_result.summary.total_checks = len(checks_to_run)
        logger.info(f"Scan completed: {self.scan_result.summary.total_findings} findings")
        
        return self.scan_result
    
    def _verify_authorization(self) -> bool:
        """
        Verify authorization to scan (placeholder)
        
        Returns:
            True if authorized, False otherwise
        """
        # In real implementation, check:
        # - Internal network flag
        # - Authorization file
        # - User confirmation
        
        # For active-light mode, require explicit confirmation
        if self.scan_result.metadata.scanner_mode == 'active-light':
            if not self.config.allow_active_light():
                logger.warning("Active-light mode not allowed by config")
                return False
        
        return True  # Placeholder - in production, implement proper checks
    
    def get_result(self) -> ScanResult:
        """Get scan result"""
        return self.scan_result

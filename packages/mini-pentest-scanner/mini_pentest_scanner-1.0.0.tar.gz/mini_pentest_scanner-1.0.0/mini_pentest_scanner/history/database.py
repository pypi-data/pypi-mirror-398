# -*- coding: utf-8 -*-
"""
Scan History Database
เก็บประวัติการสแกนในฐานข้อมูล SQLite
"""

import sqlite3
import json
from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class ScanHistoryDB:
    """Database manager for scan history"""
    
    def __init__(self, db_path: Optional[str] = None):
        """
        Initialize scan history database
        
        Args:
            db_path: Path to SQLite database file (default: ./scan_history.db)
        """
        if db_path is None:
            db_path = Path.cwd() / 'scan_history.db'
        
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        self._init_database()
        logger.info(f"ScanHistoryDB initialized: {self.db_path}")
    
    def _init_database(self):
        """Initialize database schema"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        # Scans table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT UNIQUE NOT NULL,
                target_url TEXT NOT NULL,
                scan_time TEXT NOT NULL,
                scanner_mode TEXT NOT NULL,
                scan_policy TEXT NOT NULL,
                risk_score INTEGER DEFAULT 0,
                total_findings INTEGER DEFAULT 0,
                total_checks INTEGER DEFAULT 0,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL
            )
        ''')
        
        # Findings table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS findings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT NOT NULL,
                finding_id TEXT NOT NULL,
                title TEXT NOT NULL,
                category TEXT NOT NULL,
                severity TEXT NOT NULL,
                confidence TEXT NOT NULL,
                risk_score INTEGER DEFAULT 0,
                created_at TEXT NOT NULL,
                FOREIGN KEY (scan_id) REFERENCES scans(scan_id) ON DELETE CASCADE
            )
        ''')
        
        # Scan results (full JSON)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scan_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT UNIQUE NOT NULL,
                result_json TEXT NOT NULL,
                created_at TEXT NOT NULL,
                FOREIGN KEY (scan_id) REFERENCES scans(scan_id) ON DELETE CASCADE
            )
        ''')
        
        # Baseline table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS baselines (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target_url TEXT NOT NULL,
                baseline_scan_id TEXT NOT NULL,
                risk_score INTEGER DEFAULT 0,
                total_findings INTEGER DEFAULT 0,
                created_at TEXT NOT NULL,
                is_active INTEGER DEFAULT 1,
                FOREIGN KEY (baseline_scan_id) REFERENCES scans(scan_id)
            )
        ''')
        
        # Compliance mappings
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS compliance_mappings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT NOT NULL,
                standard TEXT NOT NULL,
                requirement_id TEXT NOT NULL,
                status TEXT NOT NULL,
                finding_ids TEXT,
                created_at TEXT NOT NULL,
                FOREIGN KEY (scan_id) REFERENCES scans(scan_id) ON DELETE CASCADE
            )
        ''')
        
        # Indexes
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_scans_target ON scans(target_url)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_scans_time ON scans(scan_time)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_findings_scan ON findings(scan_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_baselines_target ON baselines(target_url)')
        
        conn.commit()
        conn.close()
        logger.debug("Database schema initialized")
    
    def save_scan(self, scan_result: Dict[str, Any]) -> str:
        """
        Save scan result to database
        
        Args:
            scan_result: ScanResult.to_dict() output
            
        Returns:
            scan_id from database
            
        Raises:
            ValueError: If scan_result is invalid
        """
        if not scan_result:
            raise ValueError("scan_result cannot be None or empty")
        
        scan_id = scan_result.get('scan_id')
        target = scan_result.get('target')
        
        if not scan_id:
            raise ValueError("scan_result must contain 'scan_id'")
        if not target:
            raise ValueError("scan_result must contain 'target'")
        
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        try:
            scan_time = scan_result.get('scan_time', datetime.utcnow().isoformat() + 'Z')
            metadata = scan_result.get('metadata', {})
            summary = scan_result.get('summary', {})
            findings = scan_result.get('findings', [])
            
            scanner_mode = metadata.get('scanner_mode', 'passive')
            scan_policy = metadata.get('scan_policy', 'internal-assessment')
            
            risk_score = summary.get('risk_score', 0)
            total_findings = summary.get('total_findings', 0)
            total_checks = summary.get('total_checks', 0)
            
            now = datetime.utcnow().isoformat()
            
            # Insert scan
            cursor.execute('''
                INSERT OR REPLACE INTO scans 
                (scan_id, target_url, scan_time, scanner_mode, scan_policy,
                 risk_score, total_findings, total_checks, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (scan_id, target, scan_time, scanner_mode, scan_policy,
                  risk_score, total_findings, total_checks, now, now))
            
            # Delete old findings for this scan
            cursor.execute('DELETE FROM findings WHERE scan_id = ?', (scan_id,))
            
            # Insert findings
            for finding in findings:
                finding_id = finding.get('id')
                title = finding.get('title', '')
                category = finding.get('category', '')
                severity = finding.get('severity', 'medium')
                confidence = finding.get('confidence', 'medium')
                
                # Calculate finding risk score
                finding_risk = self._calculate_finding_risk(severity, confidence)
                
                cursor.execute('''
                    INSERT INTO findings 
                    (scan_id, finding_id, title, category, severity, confidence, risk_score, created_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (scan_id, finding_id, title, category, severity, confidence, finding_risk, now))
            
            # Save full JSON result
            result_json = json.dumps(scan_result, ensure_ascii=False)
            cursor.execute('''
                INSERT OR REPLACE INTO scan_results (scan_id, result_json, created_at)
                VALUES (?, ?, ?)
            ''', (scan_id, result_json, now))
            
            conn.commit()
            logger.info(f"Scan saved to database: {scan_id}")
            return scan_id
            
        except Exception as e:
            conn.rollback()
            logger.error(f"Error saving scan to database: {e}")
            raise
        finally:
            conn.close()
    
    def get_scan(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """
        Get scan result by scan_id
        
        Args:
            scan_id: Scan ID to retrieve
            
        Returns:
            Scan result dictionary or None if not found
        """
        if not scan_id:
            logger.warning("Empty scan_id provided to get_scan")
            return None
        
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        try:
            cursor.execute('SELECT result_json FROM scan_results WHERE scan_id = ?', (scan_id,))
            row = cursor.fetchone()
            
            if row:
                return json.loads(row[0])
            return None
            
        except Exception as e:
            logger.error(f"Error getting scan: {e}")
            return None
        finally:
            conn.close()
    
    def get_scans_by_target(self, target_url: str, limit: int = 100) -> List[Dict[str, Any]]:
        """
        Get all scans for a target URL
        
        Args:
            target_url: Target URL
            limit: Maximum number of scans to return (must be > 0, default: 100)
            
        Returns:
            List of scan dictionaries
        """
        if not target_url:
            logger.warning("Empty target_url provided to get_scans_by_target")
            return []
        
        if limit <= 0:
            limit = 100
        if limit > 10000:  # Prevent excessive queries
            limit = 10000
            logger.warning(f"Limit capped at 10000 for get_scans_by_target")
        
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT * FROM scans 
                WHERE target_url = ? 
                ORDER BY scan_time DESC 
                LIMIT ?
            ''', (target_url, limit))
            
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            logger.error(f"Error getting scans by target: {e}")
            return []
        finally:
            conn.close()
    
    def get_all_scans(self, limit: int = 100) -> List[Dict[str, Any]]:
        """
        Get all scans
        
        Args:
            limit: Maximum number of scans to return (must be > 0, default: 100)
            
        Returns:
            List of scan dictionaries
        """
        if limit <= 0:
            limit = 100
        if limit > 10000:  # Prevent excessive queries
            limit = 10000
            logger.warning(f"Limit capped at 10000 for get_all_scans")
        
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT * FROM scans 
                ORDER BY scan_time DESC 
                LIMIT ?
            ''', (limit,))
            
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            logger.error(f"Error getting all scans: {e}")
            return []
        finally:
            conn.close()
    
    def get_scan_summary(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """
        Get scan summary (without full JSON)
        
        Args:
            scan_id: Scan ID to retrieve
            
        Returns:
            Scan summary dictionary or None if not found
        """
        if not scan_id:
            logger.warning("Empty scan_id provided to get_scan_summary")
            return None
        
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        try:
            cursor.execute('SELECT * FROM scans WHERE scan_id = ?', (scan_id,))
            row = cursor.fetchone()
            
            if row:
                return dict(row)
            return None
            
        except Exception as e:
            logger.error(f"Error getting scan summary: {e}")
            return None
        finally:
            conn.close()
    
    def _calculate_finding_risk(self, severity: str, confidence: str) -> int:
        """Calculate risk score for a finding"""
        severity_weights = {
            'critical': 25,
            'high': 15,
            'medium': 8,
            'low': 3
        }
        
        confidence_multipliers = {
            'high': 1.0,
            'medium': 0.7,
            'low': 0.4
        }
        
        base_score = severity_weights.get(severity, 8)
        multiplier = confidence_multipliers.get(confidence, 0.7)
        
        return int(base_score * multiplier)


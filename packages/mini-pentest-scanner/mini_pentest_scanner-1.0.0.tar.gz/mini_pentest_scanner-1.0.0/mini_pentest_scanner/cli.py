"""
CLI Entry Point for mini-pentest command
"""

import sys
import argparse
import logging
from pathlib import Path
from typing import Optional
import io
import os

# Fix encoding for Windows console (especially for .exe)
if sys.platform == 'win32':
    try:
        # Set UTF-8 encoding for stdout/stderr
        if hasattr(sys.stdout, 'buffer'):
            sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
        if hasattr(sys.stderr, 'buffer'):
            sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')
        # Set console code page to UTF-8
        os.system('chcp 65001 >nul 2>&1')
    except (AttributeError, OSError):
        pass  # Already wrapped or not available

try:
    from .scanner import SecurityScanner
    from .core.config import ScannerConfig
    from .core.result import ScanResult
except ImportError:
    # For PyInstaller compatibility
    from mini_pentest_scanner.scanner import SecurityScanner
    from mini_pentest_scanner.core.config import ScannerConfig
    from mini_pentest_scanner.core.result import ScanResult

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def main():
    """Main entry point for mini-pentest command"""
    # Use ASCII-safe help text for Windows console compatibility
    parser = argparse.ArgumentParser(
        description='Mini Pentest Scanner - Non-intrusive Security Assessment Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  mini-pentest scan http://127.0.0.1:5000
  mini-pentest scan http://example.com --policy passive
  mini-pentest scan http://example.com --policy active-light
  mini-pentest scan http://example.com --checks "SQL Injection Indicators" "XSS Risk Indicators"

Legal Notice:
This tool is for educational purposes and authorized security testing only.
Always ensure you have proper authorization before scanning any system.
        """
    )
    
    # Global arguments
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose logging'
    )
    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s 1.0.0'
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Scan command
    scan_parser = subparsers.add_parser('scan', help='Run security scan')
    scan_parser.add_argument('target', help='Target URL to scan')
    scan_parser.add_argument(
        '--policy',
        choices=['passive', 'active-light'],
        default='passive',
        help='Scan policy (default: passive)'
    )
    scan_parser.add_argument(
        '--config',
        help='Path to config file (default: config.yaml)'
    )
    scan_parser.add_argument(
        '--checks',
        nargs='+',
        help='Specific checks to run (default: all)'
    )
    
    args = parser.parse_args()
    
    # Set logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logger.debug("Verbose logging enabled")
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    if args.command == 'scan':
        try:
            run_scan(args)
        except KeyboardInterrupt:
            print("\n\n‚ö†Ô∏è  Scan interrupted by user")
            logger.info("Scan interrupted by user")
            sys.exit(130)
        except Exception as e:
            logger.error(f"Fatal error: {e}", exc_info=True)
            print(f"\n‚ùå Error: {e}")
            if args.verbose:
                import traceback
                traceback.print_exc()
            sys.exit(1)
    else:
        parser.print_help()
        sys.exit(1)

def run_scan(args):
    """
    Run security scan
    
    Args:
        args: Parsed command line arguments
    """
    # Validate target URL
    target = args.target.strip()
    if not target:
        print("‚ùå Error: Target URL cannot be empty")
        sys.exit(1)
    
    if not (target.startswith('http://') or target.startswith('https://')):
        print("‚ö†Ô∏è  Warning: Target URL should start with http:// or https://")
        print(f"   Using: http://{target}")
        target = f"http://{target}"
    
    try:
        # Load config
        config_path = None
        if args.config:
            config_path = args.config
            if not Path(config_path).exists():
                print(f"‚ö†Ô∏è  Warning: Config file not found: {config_path}")
                print("   Using default configuration")
                config_path = None
        else:
            # Try to find config.yaml in current directory or package directory
            current_dir = Path.cwd() / 'config.yaml'
            package_dir = Path(__file__).parent.parent / 'config.yaml'
            if current_dir.exists():
                config_path = str(current_dir)
            elif package_dir.exists():
                config_path = str(package_dir)
        
        config = ScannerConfig(config_path) if config_path else ScannerConfig()
        
        # Create scanner
        scanner = SecurityScanner(target, config)
        
        # Run scan
        result = scanner.scan(policy=args.policy, enabled_checks=args.checks)
        
        # Print summary
        print("\n" + "=" * 60)
        print("üìä Scan Summary")
        print("=" * 60)
        print(f"Target: {result.target}")
        print(f"Scan ID: {result.scan_id}")
        print(f"Scan Time: {result.scan_time}")
        print(f"Mode: {result.metadata.scanner_mode}")
        print("-" * 60)
        print(f"Total Checks: {result.summary.total_checks}")
        print(f"Total Findings: {result.summary.total_findings}")
        print(f"Risk Score: {result.summary.risk_score}/100")
        print(f"Severity Breakdown:")
        print(f"  - Critical: {result.summary.severity_count.get('critical', 0)}")
        print(f"  - High: {result.summary.severity_count.get('high', 0)}")
        print(f"  - Medium: {result.summary.severity_count.get('medium', 0)}")
        print(f"  - Low: {result.summary.severity_count.get('low', 0)}")
        print("=" * 60)
        print("üí° Remember: This is for educational purposes only!")
        print("=" * 60)
        
        # Exit with appropriate code
        if result.summary.total_findings > 0:
            sys.exit(1)  # Findings found
        else:
            sys.exit(0)  # No findings
    
    except ValueError as e:
        logger.error(f"Validation error: {e}")
        print(f"‚ùå Validation Error: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Unexpected error: {e}", exc_info=True)
        print(f"‚ùå Unexpected Error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)

if __name__ == '__main__':
    main()

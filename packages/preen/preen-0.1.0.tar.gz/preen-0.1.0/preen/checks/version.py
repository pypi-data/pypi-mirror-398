"""Version hardcoding detection check."""

from __future__ import annotations

import re
from pathlib import Path

from .base import Check, CheckResult, Issue, Fix, Severity


class VersionCheck(Check):
    """Check for hardcoded version strings outside pyproject.toml."""

    @property
    def name(self) -> str:
        return "version"

    @property
    def description(self) -> str:
        return "Check for hardcoded version strings"

    def run(self) -> CheckResult:
        """Check for version hardcoding."""
        issues = []

        # Get version from pyproject.toml
        pyproject_version = self._get_pyproject_version()
        if not pyproject_version:
            return CheckResult(
                check=self.name,
                passed=False,
                issues=[
                    Issue(
                        check=self.name,
                        severity=Severity.ERROR,
                        description="Could not read version from pyproject.toml",
                    )
                ],
            )

        # Files to check for version hardcoding
        check_patterns = [
            "**/*.py",
            "**/*.md",
            "**/*.rst",
            "**/*.yml",
            "**/*.yaml",
            "**/conf.py",
        ]

        # Exclude patterns
        exclude_patterns = [
            "**/build/**",
            "**/dist/**",
            "**/.git/**",
            "**/__pycache__/**",
            "**/*.egg-info/**",
            "**/node_modules/**",
            "**/.venv/**",
            "**/.env/**",
        ]

        files_to_check = set()
        for pattern in check_patterns:
            files_to_check.update(self.project_dir.glob(pattern))

        # Filter out excluded paths
        for exclude_pattern in exclude_patterns:
            excluded = set(self.project_dir.glob(exclude_pattern))
            files_to_check -= excluded

        # Check each file
        for file_path in files_to_check:
            if file_path.is_file():
                issues.extend(
                    self._check_file_for_version(file_path, pyproject_version)
                )

        return CheckResult(
            check=self.name,
            passed=len(issues) == 0,
            issues=issues,
        )

    def _get_pyproject_version(self) -> str | None:
        """Get version from pyproject.toml."""
        try:
            import tomllib
        except ImportError:
            import tomli as tomllib  # type: ignore

        pyproject_path = self.project_dir / "pyproject.toml"
        if not pyproject_path.exists():
            return None

        with pyproject_path.open("rb") as f:
            data = tomllib.load(f)

        return data.get("project", {}).get("version", None)

    def _check_file_for_version(self, file_path: Path, version: str) -> list[Issue]:
        """Check a file for hardcoded version strings."""
        issues = []

        try:
            content = file_path.read_text(encoding="utf-8")
        except (UnicodeDecodeError, OSError):
            # Skip binary files or files we can't read
            return issues

        # Skip if file is pyproject.toml (version is supposed to be here)
        if file_path.name == "pyproject.toml":
            return issues

        # Skip if this is a generated file (has preen header)
        if "Generated by preen" in content:
            return issues

        # Version patterns to look for
        version_patterns = [
            # Exact version string
            re.escape(version),
            # Version in quotes
            f'"{re.escape(version)}"',
            f"'{re.escape(version)}'",
            # Version assignment
            f'version = "{re.escape(version)}"',
            f"version = '{re.escape(version)}'",
            f'__version__ = "{re.escape(version)}"',
            f"__version__ = '{re.escape(version)}'",
        ]

        relative_path = file_path.relative_to(self.project_dir)

        for pattern in version_patterns:
            matches = list(re.finditer(pattern, content))
            for match in matches:
                # Find line number
                line_num = content[: match.start()].count("\n") + 1
                line_content = content.split("\n")[line_num - 1].strip()

                # Skip some acceptable patterns
                if self._is_acceptable_version_usage(line_content, file_path):
                    continue

                issues.append(
                    Issue(
                        check=self.name,
                        severity=Severity.WARNING,
                        description=f"Hardcoded version '{version}' found",
                        file=relative_path,
                        line=line_num,
                        proposed_fix=Fix(
                            description="Use dynamic version from importlib.metadata",
                            diff=self._generate_version_fix(line_content, file_path),
                            apply=lambda: None,  # Manual fix required
                        ),
                    )
                )

        return issues

    def _is_acceptable_version_usage(self, line_content: str, file_path: Path) -> bool:
        """Check if this is an acceptable version usage that we shouldn't flag."""
        # Skip comments
        if line_content.strip().startswith("#"):
            return True

        # Skip URLs (might contain version numbers)
        if "http" in line_content or "www" in line_content:
            return True

        # Skip changelog entries
        if file_path.name.lower() in [
            "changelog.md",
            "changelog.rst",
            "history.md",
            "history.rst",
        ]:
            return True

        # Skip if it's already using importlib.metadata
        if "importlib.metadata" in line_content or "importlib_metadata" in line_content:
            return True

        return False

    def _generate_version_fix(self, line_content: str, file_path: Path) -> str:
        """Generate a fix suggestion for hardcoded version."""
        if file_path.suffix == ".py":
            return (
                "Replace hardcoded version with:\n"
                "from importlib.metadata import version\n"
                "__version__ = version('your-package-name')"
            )
        elif file_path.suffix in [".md", ".rst"]:
            return (
                "Consider using a dynamic reference or accept that documentation "
                "may need manual updates for each release."
            )
        else:
            return "Replace hardcoded version with dynamic reference"

    def can_fix(self) -> bool:
        return False  # Version fixes require manual intervention

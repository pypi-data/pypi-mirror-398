\section{The Mapping: Biology $\leftrightarrow$ Software}

To treat Agentic Systems and Gene Regulatory Networks (GRNs) as isomorphic \textbf{at the level of their typed
interfaces}, we must map them to a common mathematical object. We utilize the category $\mathbf{Poly}$, where
objects are polynomial functors representing interfaces, and morphisms represent interaction protocols.

\subsection{Preliminaries: The Category $\mathbf{Poly}$}

In Applied Category Theory, a Polynomial Functor $P$ represents a typed interface for a dynamical system. It is
defined as a sum of representable functors:
\begin{equation}
P(y) = \sum_{o\in O} y^{I_o}.
\tag{2}
\end{equation}
Here, $O$ is the set of possible Positions (or Outputs) the system can expose. For each position $o\in O$, there
is a set $I_o$ of Directions (or Inputs) required to transition the system to a new state.
\begin{itemize}[leftmargin=*]
\item The coefficient $o$ represents the value produced by the system.
\item The exponent $I_o$ represents the capacity to receive information from the environment.
\end{itemize}
This formalism captures the essence of a ``stateful interface'': the system outputs a value $o$ and then waits
for a specific type of input $i\in I_o$ before it can proceed.

\begin{figure}[h]
\centering
\begin{tikzpicture}[>=Latex, node distance=12mm]
  \node[draw, rounded corners, minimum width=30mm, minimum height=10mm] (cap) {Output $o\in O$};
  \node[draw, circle, below left=10mm and 10mm of cap] (i1) {$i_1\in I_o$};
  \node[draw, circle, below=10mm of cap] (i2) {$i_2\in I_o$};
  \node[draw, circle, below right=10mm and 10mm of cap] (i3) {$\cdots$};
  \draw[->] (i1) -- (cap);
  \draw[->] (i2) -- (cap);
  \draw[->] (i3) -- (cap);
  \node[below=12mm of i2] {The Interface $P(y)$};
\end{tikzpicture}
\caption{A visual representation of a Polynomial Functor (often called a ``Mushroom'' or ``Corolla''). The system
offers an Output (the cap) and exposes specific Input ports (the stalks) dependent on that output.}
\end{figure}

\subsection{The Isomorphism: Genes and Agents}

We now apply this abstract definition to our specific domains.

\paragraph{Definition 1 (The Gene Object).}
A gene $G$ is a polynomial functor where $O_G$ is the set of expressed proteins and
$I_G=(I_{\text{prot}})_{\text{prot}\in O_G}$ is the \textbf{family} of regulatory-signal sets (transcription factors)
available at each expressed protein:
\begin{equation}
P_{\text{Gene}}(y) = \sum_{\text{prot}\in \text{Proteins}} y^{I_{\text{prot}}}.
\tag{3}
\end{equation}

\paragraph{Definition 2 (The Agent Object).}
An autonomous agent $A$ is a polynomial functor where $O_A$ is the set of generated messages/actions, and
$I_A=(I_{\text{action}})_{\text{action}\in O_A}$ is the \textbf{family} of observation sets available at each action:
\begin{equation}
P_{\text{Agent}}(y) = \sum_{\text{action}\in \text{Actions}} y^{I_{\text{action}}}.
\tag{4}
\end{equation}

\subsection{The Interface: Promoters as Lenses}

In biology, a gene is not universally accessible. It is guarded by a Promoter Region---a specific DNA sequence
that only binds to compatible Transcription Factors. In software, an agent is guarded by an API Schema or
Context Window definition.

We model this gating mechanism using Optics, specifically Lenses. A Lens consists of two maps between a global
state $S$ and a local view $V$:
\begin{enumerate}[leftmargin=*]
\item Get (View): $\mathrm{get}: S \to V$ (Extracting relevant signal from global state).
\item Put (Update): $\mathrm{put}: S\times V' \to S$ (Updating global state based on local change).
\end{enumerate}

The ``Promoter'' acts as a filter that determines which part of the global cellular environment ($S$) is visible
($V$) to the gene.
\begin{itemize}[leftmargin=*]
\item \textbf{Biological Lens:} The promoter filters the chaotic cellular soup, allowing the gene to ``see''
only specific molecules (e.g., Lac Repressor).
\item \textbf{Agentic Lens:} The Context Window filters the massive vector database, allowing the agent to
``see'' only the relevant retrieved chunks (RAG).
\end{itemize}

If the input signal does not match the Schema (Promoter), the Lens fails to focus, and the interaction is routed
to an explicit \textbf{inactive/error} case (equivalently, one works with a \textbf{partial} lens, or a total lens
into $V+\mathrm{Error}$) (the agent does not run; the gene is not expressed).

\subsection{Epigenetics and State: The Coalgebra}

Neither genes nor agents are stateless functions. They possess memory.
\begin{itemize}[leftmargin=*]
\item \textbf{Biology:} Epigenetic markers (Methylation, Histone modification) alter how a gene responds to
signals without changing the DNA code.
\item \textbf{Software:} Retrieval Augmented Generation (RAG) and Conversation History alter how an agent
responds to a prompt without changing the LLM weights.
\end{itemize}

We model this as a Coalgebra for the polynomial functor $P$. A dynamical system is defined as a tuple $(S,\phi)$,
where $S$ is the state space and $\phi$ is the structure map:
\begin{equation}
\phi: S \to P(S).
\tag{5}
\end{equation}

By expanding $P(S)$, we derive the two fundamental operations of the state machine:
\begin{enumerate}[leftmargin=*]
\item Readout: $S \to O$ (Given current state/memory, what action do I take?)
\item Update: $\displaystyle \sum_{s\in S} I_{o(s)} \to S$ (Given current state $s$ and a new input
$i\in I_{o(s)}$ compatible with its current output $o(s)$, what is my new state?)
\end{enumerate}

By establishing this formal dictionary (Table 1), we \textbf{can regard} GRNs and Agentic Systems as distinct
implementations of the same abstract dynamical system \textbf{under this interface-level abstraction}.

\begin{figure}[h]
\centering
\begin{tabular}{@{}c@{\qquad}c@{}}
\begin{tabular}{@{}c@{}}
Gene\\(Function)\\[0.25em]
Transcription Factors ($I$)\\
Proteins ($O$)\\
Promoter Binding\\
Expression
\end{tabular}
&
\begin{tabular}{@{}c@{}}
Agent\\(LLM + Tools)\\[0.25em]
Observations ($I$)\\
Actions ($O$)\\
Schema Match\\
Generation
\end{tabular}
\end{tabular}
\\[0.5em]
\caption{The Structural Isomorphism. Both Genes and Agents act as transducers converting Input Contexts ($I$) into
Output Expressions ($O$), governed by the same categorical laws (at the level of polynomial-interface models).}
\end{figure}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
Category Concept & Biological Realization (GRN) & Software Realization (Agentic)\\
\midrule
Polynomial Functor ($P$) & Gene Interface & Agent Interface (System Prompt)\\
Output Position ($O$) & Protein Expression & Tool Call / Message\\
Input Direction ($I$) & Transcription Factor Binding & Observation / User Prompt\\
Lens (Optic) & Promoter Region & API Schema / Context Window\\
Internal State ($S$) & Epigenetic Markers (Methylation) & Vector Store / Chat History\\
Morphism ($\circ$) & Signal Transduction Pathway & Data Pipeline\\
\bottomrule
\end{tabular}
\caption{The Isomorphism Dictionary}
\end{table}

\subsection{Metabolic Coalgebras: Formalizing Resource Constraints}

Finally, we address the physical constraints of computation. Just as biological systems are limited by ATP availability \cite{lynch2015bioenergetic}, agentic systems are limited by token budgets and latency. To model this, we extend our coalgebraic framework to include resource constraints, defining a \textbf{Metabolic Coalgebra}. Mathematically, this is an instance of a Quantitative Coalgebra enriched over a resource monoid, effectively restricting the domain of the state transition function to resource-sufficient states.

We align this definition with the theory of \textbf{Quantitative Polynomial Functors} \cite{nakov2021quantitative}, treating the system as a state machine enriched over a resource monoid.

\begin{definition}[The Resource Monoid]
Let $(\mathcal{R}, +, 0, \ge)$ be an ordered commutative monoid representing computational resources (e.g., token counts), where $\mathcal{R} \cong \mathbb{N}$.
\end{definition}

\begin{definition}[Metabolic Coalgebra]
A resource-constrained agent is a coalgebra $(S, \alpha)$ over a polynomial functor $P$, where the state space is the product of the logical state $L$ and the resource state $\mathcal{R}$:
\begin{equation}
    S \cong L \times \mathcal{R}
\end{equation}
The structure map $\alpha: S \to P(S) + \bot$ is defined as a \textbf{partial map} guarded by cost. For a transition requiring cost $c \in \mathcal{R}$:
\begin{equation}
    \alpha(l, r) = 
    \begin{cases} 
      (l', r - c) & \text{if } r \ge c \\
      \bot & \text{if } r < c \quad \text{(Apoptosis)}
    \end{cases}
\end{equation}
\end{definition}

This structure maps to the energetics of transcriptional elongation. A gene (Agent) cannot express its protein (Action) instantaneously; it must transcribe an mRNA sequence (Chain of Thought) nucleotide by nucleotide. This process consumes a distinct amount of chemical energy (NTPs) per step. The Metabolic Coalgebra models this dependency: if the cellular energy budget is exhausted, transcription stalls (Ischemia), and the gene fails to execute its function, regardless of its regulatory logic.

This formalism establishes that ``Ischemia'' (Token Starvation) is not merely a runtime error, but a reachable terminal state $\bot$ in the system's dynamics. This mirrors the biological mechanism where failure to meet metabolic costs triggers p53-mediated apoptosis \cite{aubrey2018p53}.


\begin{theorem}[The Metabolic Bound]
For any agentic topology $T$ composed of $N$ agents with total budget $R_{total}$, the system is guaranteed to halt. Unlike the general Halting Problem, termination is decidable for Metabolic Coalgebras: the resource state $r$ is strictly decreasing for every non-identity morphism, providing a well-founded termination measure \cite{boreale2023weighted}.
\end{theorem}

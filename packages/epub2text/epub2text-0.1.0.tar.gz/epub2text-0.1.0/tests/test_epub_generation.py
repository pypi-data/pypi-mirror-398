"""
Tests for epub2text using dynamically generated EPUB files with pypub3.

These tests create EPUB files programmatically and verify that epub2text
can correctly extract text from them.
"""

from datetime import datetime
from pathlib import Path
from typing import cast

import pypub  # type: ignore[import-untyped]
import pytest

from epub2text import EPUBParser, epub2txt

# Check if spaCy is available
try:
    import spacy  # noqa: F401

    SPACY_AVAILABLE = True
except ImportError:
    SPACY_AVAILABLE = False

requires_spacy = pytest.mark.skipif(
    not SPACY_AVAILABLE,
    reason="spaCy required. Install with: pip install epub2text[sentences]",
)


class TestGeneratedEpub:
    """Test epub2text with EPUBs generated by pypub3."""

    @pytest.fixture
    def simple_epub(self, tmp_path: Path) -> Path:
        """Create a simple EPUB with a few chapters."""
        epub_path = tmp_path / "simple_book.epub"

        book = pypub.Epub("Simple Test Book", creator="Test Author")

        # Create chapters with simple HTML content
        chapter1 = pypub.create_chapter_from_text(
            "This is the first chapter.\n\nIt has multiple paragraphs.\n\n"
            "Each paragraph should be preserved.",
            title="Chapter 1: Introduction",
        )

        chapter2 = pypub.create_chapter_from_text(
            "The second chapter continues the story.\n\n"
            "More content follows here.\n\n"
            "And even more text to test extraction.",
            title="Chapter 2: The Middle",
        )

        chapter3 = pypub.create_chapter_from_text(
            "Finally, the conclusion.\n\nThis is the end of our test book.",
            title="Chapter 3: Conclusion",
        )

        book.add_chapter(chapter1)
        book.add_chapter(chapter2)
        book.add_chapter(chapter3)

        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def html_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with HTML-formatted chapters."""
        epub_path = tmp_path / "html_book.epub"

        book = pypub.Epub("HTML Test Book", creator="HTML Author")

        # Create chapter from HTML
        html_content = b"""
        <html>
        <head><title>HTML Chapter</title></head>
        <body>
            <h1>Welcome to HTML</h1>
            <p>This is a paragraph with <strong>bold</strong> text.</p>
            <p>This is another paragraph with <em>italic</em> text.</p>
            <ul>
                <li>First item</li>
                <li>Second item</li>
                <li>Third item</li>
            </ul>
            <p>Final paragraph after the list.</p>
        </body>
        </html>
        """

        chapter1 = pypub.create_chapter_from_html(
            html_content,
            title="HTML Chapter",
        )

        book.add_chapter(chapter1)
        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def multi_paragraph_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with many paragraphs for text extraction testing."""
        epub_path = tmp_path / "paragraphs_book.epub"

        book = pypub.Epub("Paragraphs Test", creator="Paragraph Author")

        # Create content with multiple distinct paragraphs
        paragraphs = [
            "Paragraph one of the test.",
            "Paragraph two with more content.",
            "Paragraph three continues.",
            "Paragraph four is here.",
            "Paragraph five ends this chapter.",
        ]

        chapter = pypub.create_chapter_from_text(
            "\n\n".join(paragraphs),
            title="Many Paragraphs",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_simple_epub_extraction(self, simple_epub: Path) -> None:
        """Test basic text extraction from a simple EPUB."""
        text = cast(str, epub2txt(str(simple_epub)))

        # Verify content is extracted
        assert len(text) > 0
        assert "first chapter" in text.lower()
        assert "second chapter" in text.lower()
        assert "conclusion" in text.lower()

    def test_simple_epub_chapters(self, simple_epub: Path) -> None:
        """Test chapter extraction from a simple EPUB."""
        chapters = cast(list[str], epub2txt(str(simple_epub), outputlist=True))

        # Should have chapters
        assert len(chapters) >= 1
        # At least one chapter should have content
        assert any(len(ch) > 0 for ch in chapters)

    def test_html_epub_extraction(self, html_epub: Path) -> None:
        """Test extraction from HTML-formatted EPUB."""
        text = cast(str, epub2txt(str(html_epub)))

        # Verify HTML content is converted to text
        assert len(text) > 0
        assert "bold" in text.lower() or "paragraph" in text.lower()

    def test_parser_metadata(self, simple_epub: Path) -> None:
        """Test metadata extraction from generated EPUB."""
        parser = EPUBParser(str(simple_epub))
        metadata = parser.get_metadata()

        # Check title and author
        assert metadata.title == "Simple Test Book"
        assert "Test Author" in metadata.authors

    def test_parser_chapters(self, simple_epub: Path) -> None:
        """Test chapter listing from EPUBParser."""
        parser = EPUBParser(str(simple_epub))
        chapters = parser.get_chapters()

        # Should have chapters
        assert len(chapters) >= 1

        # Chapters should have titles and content
        for chapter in chapters:
            assert chapter.title is not None
            assert chapter.id is not None

    def test_extract_specific_chapter(self, simple_epub: Path) -> None:
        """Test extracting a specific chapter by ID."""
        parser = EPUBParser(str(simple_epub))
        chapters = parser.get_chapters()

        if len(chapters) > 0:
            # Extract first chapter
            first_chapter_id = chapters[0].id
            text = parser.extract_chapters([first_chapter_id])

            assert len(text) > 0

    def test_multi_paragraph_extraction(self, multi_paragraph_epub: Path) -> None:
        """Test that multiple paragraphs are properly extracted."""
        text = cast(str, epub2txt(str(multi_paragraph_epub)))

        # Check that paragraphs are present
        assert "paragraph one" in text.lower()
        assert "paragraph five" in text.lower()

    def test_clean_vs_raw_extraction(self, simple_epub: Path) -> None:
        """Test difference between clean and raw extraction."""
        clean_text = cast(str, epub2txt(str(simple_epub), clean=True))
        raw_text = cast(str, epub2txt(str(simple_epub), clean=False))

        # Both should have content
        assert len(clean_text) > 0
        assert len(raw_text) > 0

    def test_outputlist_format(self, simple_epub: Path) -> None:
        """Test that outputlist returns a list of strings."""
        result = epub2txt(str(simple_epub), outputlist=True)

        assert isinstance(result, list)
        assert all(isinstance(item, str) for item in result)


class TestComplexEpub:
    """Test more complex EPUB structures."""

    @pytest.fixture
    def nested_chapters_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with nested chapter structure."""
        epub_path = tmp_path / "nested_book.epub"

        book = pypub.Epub("Nested Chapters Book", creator="Nested Author")

        # Part 1
        part1_intro = pypub.create_chapter_from_text(
            "This is Part 1 of the book.\n\nIt contains multiple chapters.",
            title="Part 1: Beginning",
        )

        chapter1_1 = pypub.create_chapter_from_text(
            "Chapter 1.1 content goes here.\n\nMore details follow.",
            title="Chapter 1.1",
        )

        chapter1_2 = pypub.create_chapter_from_text(
            "Chapter 1.2 continues from 1.1.\n\nAdditional information.",
            title="Chapter 1.2",
        )

        # Part 2
        part2_intro = pypub.create_chapter_from_text(
            "Part 2 begins here.\n\nNew section of the book.",
            title="Part 2: Middle",
        )

        chapter2_1 = pypub.create_chapter_from_text(
            "Chapter 2.1 is the first chapter of Part 2.\n\nContent here.",
            title="Chapter 2.1",
        )

        book.add_chapter(part1_intro)
        book.add_chapter(chapter1_1)
        book.add_chapter(chapter1_2)
        book.add_chapter(part2_intro)
        book.add_chapter(chapter2_1)

        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def special_chars_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with special characters."""
        epub_path = tmp_path / "special_chars_book.epub"

        book = pypub.Epub("Special Characters Test", creator="Special Author")

        # Content with various special characters
        special_content = (
            "Testing special characters:\n\n"
            "Quotes: 'single' and \"double\"\n\n"
            "Dashes: em-dash and en-dash\n\n"
            "Ellipsis: Wait for it...\n\n"
            "Ampersand: Fish & Chips\n\n"
            "Less/Greater: 5 < 10 > 3\n\n"
            "Unicode: cafe with accent"
        )

        chapter = pypub.create_chapter_from_text(
            special_content,
            title="Special Characters Chapter",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def long_chapter_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with a long chapter."""
        epub_path = tmp_path / "long_chapter_book.epub"

        book = pypub.Epub("Long Chapter Test", creator="Long Author")

        # Generate long content
        paragraphs = []
        for i in range(50):
            paragraphs.append(
                f"This is paragraph number {i + 1}. "
                f"It contains some text to make the chapter longer. "
                f"Testing extraction of larger content blocks."
            )

        chapter = pypub.create_chapter_from_text(
            "\n\n".join(paragraphs),
            title="A Very Long Chapter",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_nested_chapters_extraction(self, nested_chapters_epub: Path) -> None:
        """Test extraction from EPUB with nested chapters."""
        text = cast(str, epub2txt(str(nested_chapters_epub)))

        # Verify all parts are extracted
        assert "part 1" in text.lower()
        assert "part 2" in text.lower()
        assert "chapter 1.1" in text.lower() or "1.1" in text

    def test_special_characters(self, special_chars_epub: Path) -> None:
        """Test that special characters are handled correctly."""
        text = cast(str, epub2txt(str(special_chars_epub)))

        # Basic content should be present
        assert "special characters" in text.lower()
        assert "ampersand" in text.lower() or "&" in text

    def test_long_chapter_extraction(self, long_chapter_epub: Path) -> None:
        """Test extraction of long chapters."""
        text = cast(str, epub2txt(str(long_chapter_epub)))

        # Should have substantial content
        assert len(text) > 1000

        # Should contain content from throughout the chapter
        assert "paragraph number 1" in text.lower()
        assert "paragraph number 50" in text.lower()

    def test_chapter_count(self, nested_chapters_epub: Path) -> None:
        """Test that correct number of chapters are detected."""
        parser = EPUBParser(str(nested_chapters_epub))
        chapters = parser.get_chapters()

        # Should detect multiple chapters
        assert len(chapters) >= 3


class TestEdgeCases:
    """Test edge cases and error handling."""

    @pytest.fixture
    def empty_chapter_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with an empty chapter."""
        epub_path = tmp_path / "empty_chapter_book.epub"

        book = pypub.Epub("Empty Chapter Test", creator="Empty Author")

        # One chapter with content
        chapter1 = pypub.create_chapter_from_text(
            "This chapter has content.",
            title="Chapter with Content",
        )

        # One chapter with minimal content
        chapter2 = pypub.create_chapter_from_text(
            " ",
            title="Nearly Empty Chapter",
        )

        book.add_chapter(chapter1)
        book.add_chapter(chapter2)

        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def single_chapter_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with only one chapter."""
        epub_path = tmp_path / "single_chapter_book.epub"

        book = pypub.Epub("Single Chapter Book", creator="Single Author")

        chapter = pypub.create_chapter_from_text(
            "This is the only chapter in the entire book.\n\n"
            "It should still be extracted correctly.",
            title="The Only Chapter",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_empty_chapter_handling(self, empty_chapter_epub: Path) -> None:
        """Test that empty chapters don't cause errors."""
        text = cast(str, epub2txt(str(empty_chapter_epub)))

        # Should still get content from non-empty chapter
        assert "has content" in text.lower()

    def test_single_chapter_epub(self, single_chapter_epub: Path) -> None:
        """Test EPUB with only one chapter."""
        text = cast(str, epub2txt(str(single_chapter_epub)))

        assert "only chapter" in text.lower()

    def test_single_chapter_list(self, single_chapter_epub: Path) -> None:
        """Test outputlist with single chapter."""
        chapters = cast(list[str], epub2txt(str(single_chapter_epub), outputlist=True))

        assert len(chapters) >= 1
        assert any("only chapter" in ch.lower() for ch in chapters if ch)

    def test_file_not_found(self) -> None:
        """Test that FileNotFoundError is raised for missing files."""
        with pytest.raises(FileNotFoundError):
            EPUBParser("/nonexistent/path/to/book.epub")

    def test_invalid_epub(self, tmp_path: Path) -> None:
        """Test that invalid EPUB raises appropriate error."""
        # Create a fake file that's not a valid EPUB
        fake_epub = tmp_path / "fake.epub"
        fake_epub.write_text("This is not an EPUB file")

        with pytest.raises((ValueError, Exception)):
            EPUBParser(str(fake_epub))


class TestHTMLContent:
    """Test EPUB generation with various HTML structures."""

    @pytest.fixture
    def ordered_list_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with ordered lists."""
        epub_path = tmp_path / "ordered_list_book.epub"

        book = pypub.Epub("Ordered List Test", creator="List Author")

        html_content = b"""
        <html>
        <body>
            <h1>Instructions</h1>
            <p>Follow these steps:</p>
            <ol>
                <li>First step of the process</li>
                <li>Second step comes next</li>
                <li>Third step follows</li>
                <li>Fourth and final step</li>
            </ol>
            <p>That completes the instructions.</p>
        </body>
        </html>
        """

        chapter = pypub.create_chapter_from_html(
            html_content,
            title="Step by Step",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def mixed_content_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with mixed HTML content."""
        epub_path = tmp_path / "mixed_content_book.epub"

        book = pypub.Epub("Mixed Content Test", creator="Mixed Author")

        html_content = b"""
        <html>
        <body>
            <h1>Mixed Content Chapter</h1>
            <p>This chapter has various content types.</p>

            <h2>A Subsection</h2>
            <p>With its own paragraph.</p>

            <blockquote>
                <p>A quote from someone important.</p>
            </blockquote>

            <p>Back to regular content.</p>

            <pre>Some preformatted text
            that preserves spacing</pre>

            <p>Final paragraph.</p>
        </body>
        </html>
        """

        chapter = pypub.create_chapter_from_html(
            html_content,
            title="Mixed Content",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_ordered_list_extraction(self, ordered_list_epub: Path) -> None:
        """Test that ordered lists are extracted."""
        text = cast(str, epub2txt(str(ordered_list_epub)))

        # List items should be present
        assert "first step" in text.lower()
        assert "fourth" in text.lower()

    def test_mixed_content_extraction(self, mixed_content_epub: Path) -> None:
        """Test extraction of mixed HTML content."""
        text = cast(str, epub2txt(str(mixed_content_epub)))

        # Various content types should be present
        assert "subsection" in text.lower()
        assert "quote" in text.lower()
        assert "final paragraph" in text.lower()


class TestFormatStyles:
    """Test different format styles (compact vs readable)."""

    @pytest.fixture
    def multi_paragraph_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with multiple paragraphs for format testing."""
        epub_path = tmp_path / "format_test_book.epub"

        book = pypub.Epub("Format Test Book", creator="Format Author")

        # Create content with clear paragraph structure
        html_content = b"""
        <html>
        <body>
            <p>First paragraph of the chapter with some content.</p>
            <p>Second paragraph follows the first one.</p>
            <p>Third paragraph is here as well.</p>
            <p>Fourth paragraph continues the text.</p>
            <p>Fifth and final paragraph ends this chapter.</p>
        </body>
        </html>
        """

        chapter = pypub.create_chapter_from_html(
            html_content,
            title="Format Test Chapter",
        )

        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_compact_format_uses_single_newlines(
        self, multi_paragraph_epub: Path
    ) -> None:
        """Test that compact format uses single newlines between paragraphs."""
        parser = EPUBParser(str(multi_paragraph_epub), paragraph_separator="\n")
        chapters = parser.get_chapters()

        # Get text from first chapter with content
        text = ""
        for ch in chapters:
            if ch.text:
                text = ch.text
                break

        # Compact format: paragraphs separated by single newlines
        # Should have newlines in the text
        assert "\n" in text or len(text) > 0
        # Count lines - should have at least 1 line with content
        line_count = len([line for line in text.split("\n") if line.strip()])
        assert line_count >= 1  # At least some content

    def test_readable_format_uses_double_newlines(
        self, multi_paragraph_epub: Path
    ) -> None:
        """Test that readable format uses double newlines between paragraphs."""
        parser = EPUBParser(str(multi_paragraph_epub), paragraph_separator="\n\n")
        chapters = parser.get_chapters()

        # Get text from first chapter with content
        text = ""
        for ch in chapters:
            if ch.text:
                text = ch.text
                break

        # Readable format: paragraphs separated by double newlines
        assert "\n\n" in text or len(text.split("\n")) >= 1

    def test_compact_has_more_lines_than_readable(
        self, multi_paragraph_epub: Path
    ) -> None:
        """Test that compact format produces more lines than readable format."""
        from epub2text.cleaner import TextCleaner

        # Extract with compact settings
        parser_compact = EPUBParser(str(multi_paragraph_epub), paragraph_separator="\n")
        chapters_compact = parser_compact.get_chapters()
        text_compact = ""
        for ch in chapters_compact:
            if ch.text:
                text_compact = ch.text
                break

        cleaner_compact = TextCleaner(preserve_single_newlines=True)
        cleaned_compact = cleaner_compact.clean(text_compact)

        # Extract with readable settings
        parser_readable = EPUBParser(
            str(multi_paragraph_epub), paragraph_separator="\n\n"
        )
        chapters_readable = parser_readable.get_chapters()
        text_readable = ""
        for ch in chapters_readable:
            if ch.text:
                text_readable = ch.text
                break

        cleaner_readable = TextCleaner(preserve_single_newlines=False)
        cleaned_readable = cleaner_readable.clean(text_readable)

        # Count non-empty lines
        compact_lines = len(
            [line for line in cleaned_compact.split("\n") if line.strip()]
        )
        readable_lines = len(
            [line for line in cleaned_readable.split("\n") if line.strip()]
        )

        # Compact should have at least as many lines (typically more due to
        # single newline separation)
        # Note: This depends on content structure
        assert compact_lines >= 1
        assert readable_lines >= 1

    def test_paragraph_separator_affects_output(
        self, multi_paragraph_epub: Path
    ) -> None:
        """Test that paragraph_separator parameter affects the output."""
        parser_single = EPUBParser(str(multi_paragraph_epub), paragraph_separator="\n")
        parser_double = EPUBParser(
            str(multi_paragraph_epub), paragraph_separator="\n\n"
        )

        chapters_single = parser_single.get_chapters()
        chapters_double = parser_double.get_chapters()

        # Both should extract content
        assert len(chapters_single) >= 1
        assert len(chapters_double) >= 1

        # Get text from chapters
        text_single = ""
        text_double = ""
        for ch in chapters_single:
            if ch.text:
                text_single = ch.text
                break
        for ch in chapters_double:
            if ch.text:
                text_double = ch.text
                break

        # Both should have content
        assert len(text_single) > 0
        assert len(text_double) > 0


class TestTextCleaner:
    """Test the TextCleaner class directly."""

    def test_preserve_single_newlines_true(self) -> None:
        """Test that preserve_single_newlines=True keeps single newlines."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(preserve_single_newlines=True)
        text = "Line one.\nLine two.\nLine three."
        result = cleaner.clean(text)

        # Single newlines should be preserved
        assert "\n" in result
        assert "Line one." in result
        assert "Line two." in result

    def test_preserve_single_newlines_false(self) -> None:
        """Test that preserve_single_newlines=False replaces single newlines."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(
            preserve_single_newlines=False, replace_single_newlines=True
        )
        text = "Line one.\nLine two.\nLine three."
        result = cleaner.clean(text)

        # Single newlines should be replaced with spaces
        assert (
            "Line one. Line two. Line three." in result
            or "\n" not in result.replace("\n\n", "")
        )

    def test_multiple_newlines_collapsed_compact(self) -> None:
        """Test that multiple newlines are collapsed to single in compact mode."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(preserve_single_newlines=True)
        text = "Para one.\n\n\n\nPara two."
        result = cleaner.clean(text)

        # Multiple newlines should become single newline
        assert "\n\n\n" not in result

    def test_multiple_newlines_collapsed_readable(self) -> None:
        """Test that multiple newlines are collapsed to double in readable mode."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(preserve_single_newlines=False)
        text = "Para one.\n\n\n\nPara two."
        result = cleaner.clean(text)

        # Multiple newlines should become exactly two
        assert "\n\n\n" not in result

    def test_remove_footnotes(self) -> None:
        """Test footnote removal."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(remove_footnotes=True)
        text = "This is text [1] with footnotes [23] in it."
        result = cleaner.clean(text)

        assert "[1]" not in result
        assert "[23]" not in result
        assert "This is text" in result

    def test_keep_footnotes(self) -> None:
        """Test keeping footnotes when disabled."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(remove_footnotes=False, remove_page_numbers=False)
        text = "This is text [1] with footnotes [23] in it."
        result = cleaner.clean(text)

        assert "[1]" in result
        assert "[23]" in result

    def test_remove_page_numbers_standalone(self) -> None:
        """Test removal of standalone page numbers."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(remove_page_numbers=True)
        text = "Some text.\n42\nMore text."
        result = cleaner.clean(text)

        # Standalone "42" should be removed
        lines = [line.strip() for line in result.split("\n") if line.strip()]
        assert "42" not in lines

    def test_normalize_whitespace(self) -> None:
        """Test whitespace normalization."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner(normalize_whitespace=True)
        text = "Text   with    multiple     spaces."
        result = cleaner.clean(text)

        assert "   " not in result
        assert "Text with multiple spaces." in result

    def test_calculate_length(self) -> None:
        """Test text length calculation."""
        from epub2text.cleaner import TextCleaner

        cleaner = TextCleaner()
        text = "Hello World"
        length = cleaner.calculate_length(text)

        # calculate_length removes newlines but keeps other characters
        assert length == len("Hello World")  # Spaces are kept, newlines stripped

    def test_clean_text_function(self) -> None:
        """Test the clean_text convenience function."""
        from epub2text.cleaner import clean_text

        text = "Some   text [1] with\n\n\n\nmultiple issues."
        result = clean_text(text)

        # Should clean up various issues
        assert "   " not in result
        assert "[1]" not in result
        assert "\n\n\n" not in result


class TestMetadataExtraction:
    """Test metadata extraction with all Dublin Core fields."""

    @pytest.fixture
    def full_metadata_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with all available metadata fields."""
        epub_path = tmp_path / "full_metadata_book.epub"

        book = pypub.Epub(
            title="Complete Metadata Book",
            creator="John Doe",
            language="en-US",
            rights="Copyright 2024 John Doe. All rights reserved.",
            publisher="Test Publishing House",
            date=datetime(2023, 6, 15),
        )

        chapter = pypub.create_chapter_from_text(
            "This is a test chapter with some content.",
            title="Chapter 1",
        )
        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    @pytest.fixture
    def minimal_metadata_epub(self, tmp_path: Path) -> Path:
        """Create an EPUB with minimal metadata."""
        epub_path = tmp_path / "minimal_metadata_book.epub"

        book = pypub.Epub(title="Minimal Book")

        chapter = pypub.create_chapter_from_text(
            "Simple content.",
            title="Chapter 1",
        )
        book.add_chapter(chapter)
        book.create(str(epub_path))
        return epub_path

    def test_full_metadata_extraction(self, full_metadata_epub: Path) -> None:
        """Test extraction of all metadata fields."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        assert metadata.title == "Complete Metadata Book"
        assert "John Doe" in metadata.authors
        assert metadata.language == "en-US"
        assert metadata.rights == "Copyright 2024 John Doe. All rights reserved."
        assert metadata.publisher == "Test Publishing House"
        assert metadata.publication_year == "2023"

    def test_language_extraction(self, full_metadata_epub: Path) -> None:
        """Test language metadata extraction."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        assert metadata.language is not None
        assert metadata.language == "en-US"

    def test_rights_extraction(self, full_metadata_epub: Path) -> None:
        """Test rights/copyright metadata extraction."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        assert metadata.rights is not None
        assert "Copyright" in metadata.rights
        assert "2024" in metadata.rights

    def test_publisher_extraction(self, full_metadata_epub: Path) -> None:
        """Test publisher metadata extraction."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        assert metadata.publisher is not None
        assert metadata.publisher == "Test Publishing House"

    def test_publication_year_extraction(self, full_metadata_epub: Path) -> None:
        """Test publication year extraction from date."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        assert metadata.publication_year is not None
        assert metadata.publication_year == "2023"

    def test_minimal_metadata_has_title(self, minimal_metadata_epub: Path) -> None:
        """Test that minimal EPUB still has title."""
        parser = EPUBParser(str(minimal_metadata_epub))
        metadata = parser.get_metadata()

        assert metadata.title == "Minimal Book"

    def test_minimal_metadata_optional_fields_none(
        self, minimal_metadata_epub: Path
    ) -> None:
        """Test that optional fields can be None or empty."""
        parser = EPUBParser(str(minimal_metadata_epub))
        metadata = parser.get_metadata()

        # These fields may be None or have default values
        # depending on pypub's defaults
        assert metadata.title is not None  # Title should always exist

    def test_metadata_str_representation(self, full_metadata_epub: Path) -> None:
        """Test the __str__ method of Metadata class."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        metadata_str = str(metadata)

        assert "Title:" in metadata_str
        assert "Complete Metadata Book" in metadata_str
        assert "Author" in metadata_str
        assert "John Doe" in metadata_str
        assert "Language:" in metadata_str
        assert "en-US" in metadata_str

    def test_metadata_caching(self, full_metadata_epub: Path) -> None:
        """Test that metadata is cached after first call."""
        parser = EPUBParser(str(full_metadata_epub))

        # First call
        metadata1 = parser.get_metadata()
        # Second call should return same object
        metadata2 = parser.get_metadata()

        assert metadata1 is metadata2

    def test_identifier_extraction(self, full_metadata_epub: Path) -> None:
        """Test identifier extraction (may be auto-generated by pypub)."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        # pypub generates an identifier automatically
        # It should be present
        assert metadata.identifier is not None

    def test_contributors_empty_by_default(self, full_metadata_epub: Path) -> None:
        """Test that contributors is empty list when not set."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        # pypub doesn't support contributors, so should be empty
        assert metadata.contributors == []

    def test_coverage_none_by_default(self, full_metadata_epub: Path) -> None:
        """Test that coverage is None when not set."""
        parser = EPUBParser(str(full_metadata_epub))
        metadata = parser.get_metadata()

        # pypub doesn't support coverage, so should be None
        assert metadata.coverage is None


class TestFormatters:
    """Test text formatting functions."""

    def test_split_at_clauses_preserves_all_text(self) -> None:
        """Test that _split_at_clauses doesn't lose any text."""
        from epub2text.formatters import _split_at_clauses

        text = (
            "When the professor picked up the ancient manuscript for the "
            "ninth time, Sarah whispered, 'You will find the answer in the margins.'"
        )

        result = _split_at_clauses(text, max_length=80)
        joined = " ".join(result)

        # All words from original should be in result
        assert "professor" in joined
        assert "manuscript" in joined
        assert "ninth time" in joined
        assert "Sarah whispered" in joined
        assert "margins" in joined

    def test_split_at_clauses_no_trailing_comma(self) -> None:
        """Test that _split_at_clauses doesn't produce lines ending with just comma."""
        from epub2text.formatters import _split_at_clauses

        text = (
            "When the professor picked up the ancient manuscript for the "
            "ninth time, Sarah whispered, 'You will find the answer in the margins.'"
        )

        result = _split_at_clauses(text, max_length=80)

        # No line should end with just a comma (indicates lost text)
        for line in result:
            assert not line.rstrip().endswith(", ,"), f"Line ends with ', ,': {line}"
            # Line shouldn't be just punctuation
            stripped = line.strip()
            assert len(stripped) > 2, f"Line too short: {line}"

    @requires_spacy
    def test_split_long_lines_preserves_text(self) -> None:
        """Test that split_long_lines doesn't lose any text."""
        from epub2text.formatters import split_long_lines

        text = (
            "  When the professor picked up the ancient manuscript for the "
            "ninth time, Sarah whispered, 'You will find the answer in the margins.'"
        )

        result = split_long_lines(text, max_length=80, separator="  ")
        joined = " ".join(result.split("\n"))

        # All key words should be preserved
        assert "professor" in joined
        assert "manuscript" in joined
        assert "Sarah" in joined
        assert "margins" in joined

    @requires_spacy
    def test_split_long_lines_respects_max_length(self) -> None:
        """Test that split_long_lines produces lines within max_length."""
        from epub2text.formatters import split_long_lines

        text = (
            "This is a very long sentence that contains many words and should be "
            "split at clause boundaries when it exceeds the maximum line length "
            "specified by the user."
        )

        result = split_long_lines(text, max_length=60, separator="")

        for line in result.split("\n"):
            # Allow some tolerance for edge cases
            assert len(line) <= 80, f"Line too long ({len(line)}): {line}"

    @requires_spacy
    def test_format_sentences_preserves_text(self) -> None:
        """Test that format_sentences doesn't lose any text."""
        from epub2text.formatters import format_sentences

        text = """First paragraph with one sentence.

Second paragraph has two sentences. Here is the second one.

Third paragraph ends the test."""

        result = format_sentences(text, separator="  ")

        # All sentences should be present
        assert "First paragraph" in result
        assert "Second paragraph" in result
        assert "second one" in result
        assert "Third paragraph" in result

    def test_format_paragraphs_adds_separator(self) -> None:
        """Test that format_paragraphs adds separator to new paragraphs."""
        from epub2text.formatters import format_paragraphs

        text = """First paragraph.

Second paragraph.

Third paragraph."""

        result = format_paragraphs(text, separator=">>")

        lines = result.split("\n")
        assert lines[0] == "First paragraph."  # No separator on first
        assert lines[1] == ">>Second paragraph."  # Separator on second
        assert lines[2] == ">>Third paragraph."  # Separator on third

    def test_format_paragraphs_one_line_mode(self) -> None:
        """Test that format_paragraphs collapses paragraphs to single lines."""
        from epub2text.formatters import format_paragraphs

        text = """First line of para one.
Second line of para one.

First line of para two.
Second line of para two."""

        result = format_paragraphs(text, separator="  ", one_line_per_paragraph=True)

        lines = result.split("\n")
        assert len(lines) == 2
        assert "First line of para one. Second line of para one." in lines[0]
        assert "First line of para two. Second line of para two." in lines[1]

    @requires_spacy
    def test_format_sentences_ellipsis_not_sentence_boundary(self) -> None:
        """Test that ellipsis (. . . or ...) does not create sentence boundary."""
        from epub2text.formatters import format_sentences

        text = "He paused and thought . . . then continued speaking."

        result = format_sentences(text, separator="  ")

        # Should be one sentence, not split at ellipsis
        lines = result.split("\n")
        assert len(lines) == 1
        assert "thought . . . then" in result or "thought ... then" in result

    @requires_spacy
    def test_format_sentences_ellipsis_three_dots(self) -> None:
        """Test that three dots ellipsis (...) does not create sentence boundary."""
        from epub2text.formatters import format_sentences

        text = "She waited... and waited... until finally he arrived."

        result = format_sentences(text, separator="  ")

        # Should be one sentence
        lines = result.split("\n")
        assert len(lines) == 1
        assert "waited" in result
        assert "arrived" in result

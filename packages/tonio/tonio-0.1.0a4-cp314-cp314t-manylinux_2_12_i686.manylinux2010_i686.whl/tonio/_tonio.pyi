from socket import SocketType as _SocketType
from typing import Any, TypeVar

_T = TypeVar('_T')

__version__: str

class Runtime:
    _clock: int
    _closed: bool
    _sig_listening: bool
    _sig_loop_handled: bool
    _stopping: bool

    def __init__(self, threads: int, threads_blocking: int, threads_blocking_timeout: int, context: bool): ...
    def _run(self): ...
    def _spawn_pygen(self, coro): ...
    def _spawn_pyasyncgen(self, coro): ...
    def _spawn_blocking(self, f, *args, **kwargs) -> tuple[Event, ResultHolder]: ...
    def _reader_add(self, fd: int, persisted: bool = True) -> Event: ...
    def _reader_rem(self, fd: int): ...
    def _writer_add(self, fd: int, persisted: bool = True) -> Event: ...
    def _writer_rem(self, fd: int): ...

class Waiter:
    def __init__(self, *events: Event): ...

class Event:
    def __init__(self): ...
    def set(self): ...
    def clear(self): ...
    def is_set(self) -> bool: ...
    def waiter(self, timeout: int | None) -> Waiter: ...

class ResultHolder:
    def __init__(self, size: int = 1): ...
    def store(self, value, index: int | None = None): ...
    def fetch(self): ...

class Scope:
    def __init__(self): ...
    def _consume(self) -> bool: ...
    def _track_pygen(self, coro) -> Event: ...
    def _track_pyasyncgen(self, coro) -> Event: ...
    def _stack(self) -> tuple[Waiter, list[Any]]: ...
    def cancel(self) -> bool: ...

class Lock:
    def acquire(self) -> None | Event: ...
    def release(self): ...

class LockCtx:
    def __init__(self, lock: Lock): ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, exc_tb): ...

class Semaphore:
    def __init__(self, value: int): ...
    def acquire(self) -> None | Event: ...
    def release(self): ...

class SemaphoreCtx:
    def __init__(self, semaphore: Semaphore): ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_value, exc_tb): ...

class Barrier:
    _event: Event

    def __init__(self, value: int): ...
    def ack(self) -> int: ...

class Channel:
    def __init__(self, size: int): ...

class ChannelSender:
    def __init__(self, channel: Channel): ...
    def _send(self, message) -> Event: ...
    def close(self): ...

class ChannelReceiver[_T]:
    def __init__(self, channel: Channel): ...
    def _receive(self) -> tuple[Event, bool, _T]: ...

class UnboundedChannel:
    def __init__(self): ...

class UnboundedChannelSender[_T]:
    def __init__(self, channel: UnboundedChannel): ...
    def send(self, message: _T): ...

class UnboundedChannelReceiver[_T]:
    def __init__(self, channel: UnboundedChannel): ...
    def _receive(self) -> tuple[Event, bool, _T]: ...

class CancelledError(BaseException): ...
class RuntimeAlreadyInitializedError(RuntimeError): ...
class RuntimeNotInitializedError(RuntimeError): ...
class TimeoutError(BaseException): ...
class WouldBlock(Exception): ...

class Socket:
    _sock: _SocketType

    def __init__(self, stdlib_socket: _SocketType): ...

def get_runtime() -> Runtime: ...
def set_runtime(runtime: Runtime): ...

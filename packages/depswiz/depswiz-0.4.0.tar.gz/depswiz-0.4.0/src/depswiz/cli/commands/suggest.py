"""Suggest command - AI-powered upgrade suggestions using Claude Code."""

import subprocess
from datetime import datetime
from pathlib import Path

import typer
from rich.console import Console
from rich.markdown import Markdown
from rich.panel import Panel

from depswiz.ai import claude_client
from depswiz.ai.prompts import get_agent_prompt, get_prompt, list_prompts

app = typer.Typer(invoke_without_command=True)
console = Console()


def generate_agent_prompt_file(project_path: Path, output_path: Path | None = None) -> Path:
    """Generate an AI coding agent prompt file for dependency updates.

    Args:
        project_path: Path to the project to analyze
        output_path: Optional output path for the prompt file

    Returns:
        Path to the generated prompt file
    """
    if output_path is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_path = project_path / f"depswiz_update_prompt_{timestamp}.md"

    # Get the base agent prompt
    agent_prompt = get_agent_prompt()

    # Build the full prompt with project context
    content = f"""# AI Coding Agent: Dependency Update Task

> Generated by depswiz on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
> Project: {project_path}

---

{agent_prompt}

---

## Project Context

**Project Path:** `{project_path}`

### Instructions for AI Coding Agent

1. Start by reading the manifest files in this project
2. Follow the update strategy outlined above
3. Execute updates in priority order
4. Run tests after each batch of updates
5. Commit changes with descriptive messages
6. Report any issues or packages that couldn't be updated

### Suggested First Steps

```bash
# Navigate to the project
cd {project_path}

# Check current dependency status
depswiz check

# Check for security vulnerabilities
depswiz audit

# Then proceed with updates following the priority order above
```

---

*This prompt was generated by [depswiz](https://github.com/moinsen-dev/depswiz) - the dependency wizard.*
"""

    output_path.write_text(content)
    return output_path


@app.callback(invoke_without_command=True)
def suggest(
    ctx: typer.Context,
    path: Path = typer.Argument(
        Path(),
        help="Project path to analyze",
        exists=True,
        file_okay=False,
        dir_okay=True,
    ),
    focus: str = typer.Option(
        "upgrade",
        "--focus",
        "-f",
        help="Analysis focus: upgrade, security, breaking, quick, toolchain",
    ),
    timeout: int = typer.Option(
        300,
        "--timeout",
        "-t",
        help="Timeout in seconds for Claude response",
    ),
    raw: bool = typer.Option(
        False,
        "--raw",
        help="Output raw response without formatting",
    ),
    prompt: bool = typer.Option(
        False,
        "--prompt",
        "-p",
        help="Generate an AI coding agent prompt file (no Claude required)",
    ),
    prompt_output: Path | None = typer.Option(
        None,
        "--prompt-output",
        "-po",
        help="Output path for the prompt file (default: depswiz_update_prompt_<timestamp>.md)",
    ),
    markdown: Path | None = typer.Option(
        None,
        "--markdown",
        "-m",
        help="Output Claude's analysis to a markdown file",
    ),
) -> None:
    """Get AI-powered upgrade suggestions using Claude Code.

    This command leverages Claude Code CLI to analyze your project's
    dependencies and provide intelligent upgrade recommendations.

    Focus options:
    - upgrade: Full upgrade strategy with priorities and risks
    - security: Focus on security vulnerabilities
    - breaking: Analyze breaking changes in major updates
    - quick: Quick summary of dependency health
    - toolchain: Analyze development tools

    Special modes:
    - --prompt: Generate an AI coding agent prompt file (no Claude required)
    - --markdown: Save Claude's analysis to a markdown file

    Requires Claude Code CLI to be installed (except for --prompt mode).
    Install from: https://claude.ai/code
    """
    # Resolve the path
    project_path = path.resolve()

    # Handle --prompt mode (doesn't require Claude)
    if prompt:
        console.print("\n[bold blue]depswiz suggest --prompt[/bold blue]")
        console.print(f"Project: [cyan]{project_path}[/cyan]")
        console.print()

        output_file = generate_agent_prompt_file(project_path, prompt_output)
        console.print(
            Panel(
                f"[green]AI coding agent prompt generated![/green]\n\n"
                f"File: [cyan]{output_file}[/cyan]\n\n"
                "Use this prompt with any AI coding agent (Claude Code, Cursor, Aider, etc.)\n"
                "to perform intelligent dependency updates.",
                title="Prompt Generated",
                border_style="green",
            )
        )
        return

    # Check if Claude is available (required for non-prompt modes)
    if not claude_client.is_available():
        console.print(
            Panel(
                "[yellow]Claude Code CLI not found.[/yellow]\n\n"
                "To use AI-powered suggestions, install Claude Code:\n"
                "[link=https://claude.ai/code]https://claude.ai/code[/link]\n\n"
                "After installation, run: [bold]claude --version[/bold]\n\n"
                "[dim]Tip: Use --prompt to generate an agent prompt file without Claude.[/dim]",
                title="Claude Code Required",
                border_style="yellow",
            )
        )
        raise typer.Exit(1)

    # Validate focus option
    valid_focuses = list_prompts()
    if focus not in valid_focuses:
        console.print(f"[red]Invalid focus: {focus}[/red]")
        console.print(f"Valid options: {', '.join(valid_focuses)}")
        raise typer.Exit(1)

    # Get the prompt for the requested focus
    prompt_text = get_prompt(focus)

    console.print("\n[bold blue]depswiz suggest[/bold blue] - AI-Powered Analysis")
    console.print(f"Project: [cyan]{project_path}[/cyan]")
    console.print(f"Focus: [cyan]{focus}[/cyan]")
    if markdown:
        console.print(f"Output: [cyan]{markdown}[/cyan]")
    console.print()

    try:
        with console.status(
            "[bold blue]Claude is analyzing your dependencies...[/bold blue]",
            spinner="dots",
        ):
            response = claude_client.run_claude(
                prompt_text,
                timeout=timeout,
                cwd=project_path,
            )

        # Handle --markdown output
        if markdown:
            markdown_content = f"""# Dependency Analysis Report

> Generated by depswiz on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
> Project: {project_path}
> Focus: {focus}

---

{response}

---

*Generated by [depswiz](https://github.com/moinsen-dev/depswiz) using Claude Code.*
"""
            markdown.write_text(markdown_content)
            console.print(
                Panel(
                    f"[green]Analysis saved to markdown![/green]\n\nFile: [cyan]{markdown}[/cyan]",
                    title="Report Generated",
                    border_style="green",
                )
            )
            # Also show a brief summary
            console.print("\n[dim]Preview:[/dim]")
            # Show first few lines
            preview_lines = response.split("\n")[:10]
            console.print(Markdown("\n".join(preview_lines) + "\n..."))
            return

        # Display Claude's response
        console.print()
        if raw:
            console.print(response)
        else:
            console.print(
                Panel(
                    Markdown(response),
                    title="Claude's Analysis",
                    border_style="green",
                )
            )

    except subprocess.TimeoutExpired:
        console.print(
            f"[red]Claude timed out after {timeout} seconds.[/red]\n"
            "Try increasing the timeout with --timeout"
        )
        raise typer.Exit(1)

    except claude_client.ClaudeError as e:
        console.print(f"[red]Claude error: {e}[/red]")
        raise typer.Exit(1)

    except Exception as e:
        console.print(f"[red]Unexpected error: {e}[/red]")
        raise typer.Exit(1)

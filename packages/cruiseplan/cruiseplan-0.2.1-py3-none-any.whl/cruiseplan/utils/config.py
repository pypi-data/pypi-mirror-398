# cruiseplan/utils/config.py
import logging
from pathlib import Path
from typing import Any, Dict, Optional, Union

from pydantic import ValidationError

# Centralized imports for configuration models and the custom error
from cruiseplan.core.validation import CruiseConfig, CruiseConfigurationError
from cruiseplan.utils.yaml_io import YAMLIOError, load_yaml, save_yaml

logger = logging.getLogger(__name__)


def _add_yaml_documentation(data: Dict) -> Dict:
    """
    Add comprehensive documentation headers to YAML configuration data.

    This function enhances generated YAML files with rich documentation including:
    - Field descriptions and validation requirements
    - Operation type and action examples
    - Cruise planning workflow guidance
    - Required vs optional field indicators

    Parameters
    ----------
    data : dict
        Original configuration dictionary

    Returns
    -------
    dict
        Enhanced dictionary with documentation headers using ruamel.yaml comments
    """
    from datetime import datetime

    from ruamel.yaml.comments import CommentedMap

    # Convert to CommentedMap for comment support
    documented_data = CommentedMap()

    # Add file header documentation
    header_comment = f"""
CruisePlan YAML Configuration
Generated by Interactive Station Picker
Creation Date: {datetime.now().replace(microsecond=0).isoformat()}

======================================================================================
CRUISE PLANNING WORKFLOW - Next Steps:
======================================================================================
1. Review and update all 'UPDATE-*' placeholders below
2. Set operation_type (CTD, mooring, water_sampling, etc.)
3. Set action (profile, deployment, recovery, etc.)  
4. Run validation: cruiseplan validate <filename>
5. Add depths: cruiseplan enrich <filename> --add-depths --add-coords --expand-sections   
6. Generate schedule: cruiseplan schedule <filename>

======================================================================================
FIELD DOCUMENTATION:
======================================================================================
Required fields are marked with [REQUIRED]
Optional fields are marked with [OPTIONAL]
Fields marked 'UPDATE-*' must be reviewed and updated

For complete field reference, see: 
https://ocean-uhh.github.io/cruiseplan/yaml_reference.html
"""
    documented_data.yaml_set_start_comment(header_comment)

    # Copy data with field-specific documentation
    for key, value in data.items():
        documented_data[key] = value

        # Add field-specific comments
        if key == "cruise_name":
            documented_data.yaml_set_comment_before_after_key(
                key, before="[REQUIRED] Unique identifier for this cruise"
            )
        elif key == "description":
            documented_data.yaml_set_comment_before_after_key(
                key, before="[OPTIONAL] Human-readable cruise description"
            )
        elif key == "start_date":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="[REQUIRED] Cruise start date (ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ)",
            )
        elif key == "departure_port":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="""[DEPRECATED] Global departure port - use leg-level fields instead
Move this field to individual leg definitions to avoid validation conflicts""",
            )
        elif key == "arrival_port":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="""[DEPRECATED] Global arrival port - use leg-level fields instead
Move this field to individual leg definitions to avoid validation conflicts""",
            )
        elif key == "stations":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="""[REQUIRED] Station catalog - Point operations (CTD, moorings, sampling)
Each station must have:
  - name: Unique identifier (e.g., STN_001, MOOR_A)
  - latitude/longitude: Decimal degrees (WGS84)
  - operation_type: CTD, mooring, water_sampling, calibration
  - action: profile, deployment, recovery, sampling
Optional fields:
  - water_depth: Seafloor depth in meters (auto-enriched if not provided)
  - operation_depth: Target operation depth for CTD casts
  - duration: Operation duration in minutes (calculated if not provided)
  - comment: Free-text description""",
            )
        elif key == "transits":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="""[OPTIONAL] Transit catalog - Line operations and scientific transects
For transit legs between stations, these are auto-generated
Define custom transits for:
  - Underway scientific operations (ADCP, multibeam)
  - Specific route requirements
  - Non-standard vessel speeds""",
            )
        elif key == "areas":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="""[OPTIONAL] Area survey catalog - Survey boxes and polygons
Define survey areas for:
  - Multibeam bathymetry surveys
  - Side-scan sonar operations
  - Systematic sampling grids""",
            )
        elif key == "legs":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="""[REQUIRED] Operational sequence definition
Legs define the order and grouping of operations
Each leg must include:
  - departure_port/arrival_port: Port references for this leg
  - first_waypoint/last_waypoint: Starting and ending operations
  - activities: List of operations to execute in sequence
Strategy options: sequential, cluster, nearest_neighbor
Each leg can override default vessel speeds and routing""",
            )
        elif key == "first_station":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="""[DEPRECATED] Global first station - use leg-level first_waypoint instead
Move this field to individual leg definitions to avoid validation conflicts""",
            )
        elif key == "last_station":
            documented_data.yaml_set_comment_before_after_key(
                key,
                before="""[DEPRECATED] Global last station - use leg-level last_waypoint instead
Move this field to individual leg definitions to avoid validation conflicts""",
            )
        elif key == "default_vessel_speed":
            documented_data.yaml_set_comment_before_after_key(
                key, before="[REQUIRED] Default transit speed in knots"
            )
        elif key == "default_distance_between_stations":
            documented_data.yaml_set_comment_before_after_key(
                key, before="[REQUIRED] Default distance between stations in kilometers"
            )

    return documented_data


# --- YAML SAVING UTILITIES (Existing Functions) ---


def save_cruise_config(
    data: Dict, filepath: Union[str, Path], add_documentation: bool = True
) -> None:
    """
    Save a dictionary to a YAML file with standard formatting and optional documentation headers.

    Parameters
    ----------
    data : dict
        The dictionary containing cruise configuration data.
    filepath : str or Path
        Destination path for the YAML file.
    add_documentation : bool, optional
        Whether to add rich documentation headers (default: True)

    Notes
    -----
    Ensures the parent directory exists and uses consistent YAML formatting
    with preserved key ordering. When add_documentation=True, includes
    comprehensive field documentation and workflow guidance.
    """
    path = Path(filepath)

    # Ensure directory exists
    path.parent.mkdir(parents=True, exist_ok=True)

    try:
        if add_documentation:
            # Enhance data with rich documentation headers
            data = _add_yaml_documentation(data)

        save_yaml(data, path, backup=False)  # No backup for new configs
        logger.info(f"✅ Configuration saved to {path}")
    except YAMLIOError as e:
        logger.error(f"❌ Failed to save configuration: {e}")
        raise


def format_station_for_yaml(station_data: Dict, index: int) -> Dict:
    """
    Transform internal station data into the YAML schema format with enhanced depth semantics.

    Parameters
    ----------
    station_data : dict
        Internal station data from the picker interface.
    index : int
        Station index for naming.

    Returns
    -------
    dict
        Formatted station data conforming to the updated YAML schema with semantic depth fields.

    Notes
    -----
    Converts coordinates to native Python floats to avoid NumPy serialization issues.
    Uses water_depth for bathymetric depth and provides operation_type examples.
    """
    # Calculate water depth from bathymetry if available
    water_depth = station_data.get("depth")
    if water_depth is not None and water_depth != -9999:
        water_depth = round(abs(float(water_depth)), 1)
    else:
        water_depth = None

    station_dict = {
        "name": f"STN_{index:03d}",
        # FIX: Cast to float() BEFORE rounding. Rounding alone may not be enough.
        "latitude": round(float(station_data["lat"]), 5),
        "longitude": round(float(station_data["lon"]), 5),
        "comment": "Interactive selection - Review coordinates and update operation details",
        "operation_type": "UPDATE-CTD-mooring-etc",  # CTD, mooring, water_sampling, calibration
        "action": "UPDATE-profile-sampling-etc",  # profile, deployment, recovery, sampling
    }

    # Add water_depth only if we have valid bathymetry data
    if water_depth is not None:
        station_dict["water_depth"] = water_depth

    return station_dict


def format_transect_for_yaml(transect_data, index):
    """
    Format internal transect data into the standardized YAML schema with enhanced placeholders.

    Parameters
    ----------
    transect_data : dict
        Internal transect data from the interactive interface.
    index : int
        Transect index for naming.

    Returns
    -------
    dict
        Formatted transect data conforming to the YAML schema.

    Notes
    -----
    Ensures coordinates are native Python floats for proper YAML serialization.
    Provides clearer operation_type and action guidance.
    """
    return {
        "name": f"Transit_{index:02d}",
        "comment": "Interactive transect - Review route and update operation details",
        "operation_type": "underway",  # underway, survey_line
        "action": "UPDATE-ADCP-bathymetry-etc",  # transit, ADCP, multibeam, bathymetry
        "vessel_speed": 10.0,
        "route": [
            {
                "latitude": round(float(transect_data["start"]["lat"]), 5),
                "longitude": round(float(transect_data["start"]["lon"]), 5),
            },
            {
                "latitude": round(float(transect_data["end"]["lat"]), 5),
                "longitude": round(float(transect_data["end"]["lon"]), 5),
            },
        ],
    }


def format_area_for_yaml(area_data, index):
    """
    Format internal area survey data into the standardized YAML schema with enhanced placeholders.

    Parameters
    ----------
    area_data : dict
        Internal area survey data from the interactive interface.
    index : int
        Area index for naming.

    Returns
    -------
    dict
        Formatted area data conforming to the YAML schema.

    Notes
    -----
    Ensures coordinates are native Python floats for proper YAML serialization.
    Provides clearer operation_type and action guidance.
    """
    return {
        "name": f"Area_{index:02d}",
        "corners": [
            {
                "latitude": round(float(lat), 5),
                "longitude": round(float(lon), 5),
            }
            for lon, lat in area_data["points"]
        ],
        "comment": "Interactive area survey - Review polygon and update operation details",
        "operation_type": "survey",  # survey, mapping
        "action": "UPDATE-bathymetry-survey-etc",  # bathymetry, multibeam, sidescan, sampling
        "duration": 9999.0,  # Placeholder duration in minutes - update based on survey type and area size
    }


# --- YAML LOADING CLASS (New Implementation) ---


class ConfigLoader:
    """
    Utility class to load, validate, and parse YAML cruise configuration files.

    This class provides a complete workflow for loading cruise configuration data
    from YAML files, validating it against the schema, and returning structured
    CruiseConfig objects.

    Attributes
    ----------
    config_path : Path
        Path to the YAML configuration file.
    raw_data : dict or None
        Raw dictionary data loaded from the YAML file.
    cruise_config : CruiseConfig or None
        Validated and parsed configuration object.
    """

    def __init__(self, config_path: Union[str, Path]):
        """
        Initializes the loader with the path to the configuration file.

        Parameters
        ----------
        config_path : Union[str, Path]
            Path to the YAML configuration file.
        """
        self.config_path = Path(config_path)
        self.raw_data: Optional[Dict[str, Any]] = None
        self.cruise_config: Optional[CruiseConfig] = None

    def load_raw_data(self) -> Dict[str, Any]:
        """
        Loads the raw data from the YAML file, handling file system errors.

        Returns
        -------
        Dict[str, Any]
            The raw dictionary loaded from the YAML file.

        Raises
        ------
        CruiseConfigurationError
            If the file cannot be found, read, or is not valid YAML.
        """
        if not self.config_path.exists():
            raise CruiseConfigurationError(
                f"Configuration file not found: {self.config_path}"
            )

        try:
            raw_data = load_yaml(self.config_path)
        except YAMLIOError as e:
            # Catch YAML I/O and parsing errors (not validation errors)
            raise CruiseConfigurationError(
                f"Failed to load or parse YAML file {self.config_path}: {e}"
            ) from e

        if not isinstance(raw_data, dict):
            raise CruiseConfigurationError(
                f"YAML content in {self.config_path} is not a valid dictionary (Root structure error)."
            )

        self.raw_data = raw_data
        return self.raw_data

    def validate_and_parse(
        self, raw_data: Optional[Dict[str, Any]] = None
    ) -> CruiseConfig:
        """
        Validates the raw dictionary data against the CruiseConfig schema.

        Parameters
        ----------
        raw_data : Optional[Dict[str, Any]], optional
            The raw data to validate. If None, uses data loaded by load_raw_data.

        Returns
        -------
        CruiseConfig
            A fully validated and structured configuration object.

        Raises
        ------
        CruiseConfigurationError
            If Pydantic validation fails, wraps the error for user clarity.
        """
        if raw_data is None:
            raw_data = self.raw_data

        if raw_data is None:
            # Ensure data is loaded if this method is called directly
            raw_data = self.load_raw_data()

        try:
            # Pydantic does the heavy lifting here, applying all validators
            config = CruiseConfig(**raw_data)
            self.cruise_config = config
            return config
        except ValidationError as e:
            # Catch Pydantic's ValidationError and re-raise it with a user-friendly message
            error_details = "\n".join(
                [
                    f"  -> {'.'.join(str(l) for l in err['loc'])}: {err['msg']}"
                    for err in e.errors()
                ]
            )
            raise CruiseConfigurationError(
                f"Configuration Validation Failed in {self.config_path} "
                f"({len(e.errors())} errors):\n{error_details}"
            ) from e

    def load(self) -> CruiseConfig:
        """
        Performs the complete load-and-validate workflow.

        Returns
        -------
        CruiseConfig
            The validated configuration object.
        """
        self.load_raw_data()
        return self.validate_and_parse()

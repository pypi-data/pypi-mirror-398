Metadata-Version: 2.4
Name: pyrust-native
Version: 0.0.1
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Rust
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Dist: build>=1.2 ; extra == 'dev'
Requires-Dist: pytest>=8 ; extra == 'dev'
Requires-Dist: ruff>=0.5 ; extra == 'dev'
Requires-Dist: mypy>=1.10 ; extra == 'dev'
Requires-Dist: maturin>=1.6,<2.0 ; extra == 'dev'
Requires-Dist: ipython>=8 ; extra == 'dev'
Requires-Dist: maturin>=1.6,<2.0 ; extra == 'rust'
Requires-Dist: ipython>=8 ; extra == 'examples'
Requires-Dist: rich>=13 ; extra == 'examples'
Requires-Dist: mkdocs>=1.5 ; extra == 'docs'
Requires-Dist: mkdocs-material>=9.5 ; extra == 'docs'
Provides-Extra: dev
Provides-Extra: rust
Provides-Extra: examples
Provides-Extra: docs
License-File: LICENSE
Summary: Python-first auto-optimizer that rustifies hotspots (skeleton repo)
Keywords: rust,pyo3,maturin,cython,jit,optimizer
Author: PyRust Contributors
Maintainer: PyRust Maintainers
License: MIT
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Project-URL: Homepage, https://github.com/pyrust-dev/pyrust
Project-URL: Repository, https://github.com/pyrust-dev/pyrust
Project-URL: Issues, https://github.com/pyrust-dev/pyrust/issues
Project-URL: Documentation, https://pyrust-dev.github.io/pyrust/
Project-URL: Changelog, https://github.com/pyrust-dev/pyrust/blob/main/CHANGELOG.md
Project-URL: Discussions, https://github.com/pyrust-dev/pyrust/discussions
Project-URL: Release Notes, https://github.com/pyrust-dev/pyrust/releases

# PyRust (skeleton)

[![PyPI version](https://img.shields.io/pypi/v/pyrust)](https://pypi.org/project/pyrust/)
[![PyPI status](https://img.shields.io/pypi/status/pyrust)](https://pypi.org/project/pyrust/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://github.com/pyrust-dev/pyrust/blob/main/LICENSE)

PyRust is a **Python-first library** that aims to automatically identify performance hotspots in a Python project
and "rustify" them by generating and compiling Rust extensions (via **PyO3 + maturin**), with safe fallback to Python.

This repository is an **initial skeleton**: it builds a minimal Rust-backed Python module and exposes a tiny API.
Next phases will add profiling, AST analysis, transpilation, caching, and hot-swapping.

üìö **Documentaci√≥n**: https://pyrust-dev.github.io/pyrust/ (versi√≥n HTML generada con MkDocs) ¬∑ https://github.com/pyrust-dev/pyrust/tree/main/docs (fuentes en GitHub)
üóíÔ∏è **Notas de publicaci√≥n**: https://github.com/pyrust-dev/pyrust/releases

## √çndice

- [Instalaci√≥n](#instalaci√≥n)
- [Ejemplo r√°pido](#ejemplo-r√°pido)
- [Compatibilidad resumida](#compatibilidad-resumida)
- [Perfilado r√°pido con `profile_project`](#perfilado-r√°pido-con-profile_project)
- [Recarga de extensiones y hot-swap seguro](#recarga-de-extensiones-y-hot-swap-seguro)
- [Analizador de rustyficabilidad](#analizador-de-rustyficabilidad)
- [Transpilaci√≥n con filtro del analizador](#transpilaci√≥n-con-filtro-del-analizador)
- [Ejemplos](#ejemplos)
- [Quick start (dev)](#quick-start-dev)
- [Comprobaci√≥n recomendada (entorno aislado)](#comprobaci√≥n-recomendada-entorno-aislado)
- [Extras opcionales](#extras-opcionales)
- [Build the Rust extension](#build-the-rust-extension)
- [Generar la rueda nativa (release)](#generar-la-rueda-nativa-release)
- [Flujo de publicaci√≥n con maturin](#flujo-de-publicaci√≥n-con-maturin)
- [Integraci√≥n continua (Fase 1)](#integraci√≥n-continua-fase-1)
- [Layout](#layout)

### Gu√≠a r√°pida para PyPI

- **Objetivo del paquete**: exponer una librer√≠a Python con aceleradores en Rust para perfilar, analizar y probar la "rustificaci√≥n" de proyectos.
- **Plataformas con rueda publicada**: Linux x86_64/aarch64, macOS x86_64/arm64 y Windows x86_64.
- **Dependencias m√≠nimas**: Python 3.10+ para ejecutar la librer√≠a y las CLI; Rust 1.70+ solo si quieres compilar desde fuente.
- **Entrypoints instalados**: `pyrust-profile`, `pyrust-analyze` y el m√≥dulo `pyrust` para importaci√≥n directa.

Instalaci√≥n directa desde PyPI:

```bash
pip install pyrust
```

Instalaci√≥n de prueba desde TestPyPI (√∫til para validar lanzamientos previos):

```bash
pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple pyrust
```

Verificaci√≥n r√°pida tras la instalaci√≥n:

```bash
python -c "import pyrust; print(pyrust.hello())"
pyrust-profile --help
```

Para el flujo completo de publicaci√≥n consulta https://pyrust-dev.github.io/pyrust/publish/ y, si necesitas reproducir la rueda localmente, usa el objetivo `make build-native`.

## Instalaci√≥n

```bash
pip install pyrust
```

Requisitos m√≠nimos:

- **Python 3.10+** para ejecutar la librer√≠a y las herramientas de l√≠nea de comandos.
- **Rust 1.70+** (edici√≥n 2021) solo es necesario si quieres compilar desde el c√≥digo fuente o generar ruedas t√∫ mismo; no se requiere para usar las ruedas ya publicadas.

## Ejemplo r√°pido

Importa el paquete instalado y usa la API b√°sica:

```python
import pyrust

print(pyrust.hello())
print(pyrust.add(2, 3))
```

Entrypoints de CLI instalados con la rueda est√°ndar:

```bash
# Perfilado r√°pido de un proyecto o script
pyrust-profile examples --limit 5

# An√°lisis de rustyficabilidad con salida en tabla
pyrust-analyze my_project --limit 3
```

## Compatibilidad resumida

| Python | Rust (solo para build desde fuente) | Ruedas publicadas (SO) | Enlaces de detalle |
| --- | --- | --- | --- |
| 3.10+ | 1.70+ | Linux x86_64/aarch64, macOS x86_64/arm64, Windows x86_64 | [Generar la rueda nativa](#generar-la-rueda-nativa-release), [Flujo de publicaci√≥n](#flujo-de-publicaci√≥n-con-maturin) |

## Perfilado r√°pido con `profile_project`

PyRust incluye un perfilador ligero para localizar hotspots antes de rustyficar.
El punto de entrada p√∫blico es `pyrust.profile_project(path, *, entrypoint=None, command=None, limit=None, use_sys_profile=True, include_stdlib=False, output_path=None)`.

- Si `path` apunta a un archivo, se ejecuta directamente con `runpy.run_path`.
- Si `path` es un directorio, se busca `__main__.py` o el `entrypoint` proporcionado.
- `command` permite pasar un callable ya preparado (por ejemplo, una funci√≥n de pruebas).
- `limit` recorta el n√∫mero de filas del resumen (√∫til para tablas compactas).
- `use_sys_profile` activa/desactiva `cProfile` (el hook de alto nivel se mantiene para medir tiempo total).
- `include_stdlib` a√±ade llamadas de la stdlib a la tabla (por defecto se filtran para centrarse en tu c√≥digo).
- `output_path` permite volcar el JSON serializado al disco tras el perfilado.

Ejemplo m√≠nimo desde un REPL o script:

```python
from pathlib import Path
from pyrust import profile_project

summary = profile_project(Path("examples"))
print(f"Tiempo total: {summary.total_runtime:.3f}s")
print(summary.to_table(limit=5))

# Guardar el JSON para an√°lisis posteriores
summary.to_json("profile_report.json")
```

CLI equivalente (instalaci√≥n editable o entorno con el entrypoint `pyrust-profile` disponible):

```bash
pyrust-profile examples --limit 5 --include-stdlib --no-use-sys-profile --output-path profile_report.json
```

Salida t√≠pica (hotspots ordenados por `total_time`):

```
# | total_time (s) | runtime (%) | call_count | avg_time (s) | function
-----------------------------------------------------------------------
 1 |        0.152341 |       90.30 |          2 |     0.076170 | /ruta/proyecto/examples/basic.py:11:run
 2 |        0.010250 |        6.08 |         10 |     0.001025 | /ruta/proyecto/examples/utils.py:45:expensive_op
 3 |        0.001902 |        1.13 |          1 |     0.001902 | /ruta/proyecto/examples/basic.py:22:main
```

C√≥mo leer la tabla de hotspots:

- **total_time**: tiempo acumulado en la funci√≥n (mayor ‚Üí m√°s candidato a rustyficar).
- **call_count**: n√∫mero de llamadas (√∫til para detectar funciones ligeras pero muy frecuentes).
- **avg_time**: tiempo medio por llamada; si es alto, conviene optimizar la funci√≥n individualmente.

Usa `include_stdlib=True` si necesitas ver el impacto de dependencias est√°ndar y ajusta `limit`
para centrarte en los hotspots principales.

## Recarga de extensiones y hot-swap seguro

La fachada `pyrust.runtime.reload_extension` crea internamente un `RuntimeManager`, aplica
la pol√≠tica de cach√© indicada y devuelve un `ReloadResult` con el m√≥dulo cargado y las
m√©tricas de recarga. Puedes adjuntar validadores y hooks de √©xito/fallo/rollback; el
gestor usado queda expuesto en `ReloadResult.runtime_manager` para reusar la misma
instancia en recargas posteriores y consultar `last_metrics`.

Ejemplo b√°sico con validaci√≥n y sustituci√≥n de funciones en vivo:

```python
from pathlib import Path
from pyrust.runtime import reload_extension

runtime = None

def validator(module: object) -> bool:
    return hasattr(module, "compute")

def on_success(name, loaded, metrics):
    print(f"{name} swap #{metrics.swap_count}; cache={metrics.used_cache}")

result_v1 = reload_extension(
    "my_hot_ext",
    source=Path("/tmp/my_hot_ext_v1.py"),
    cache_dir=Path(".cache/pyrust"),
    validate=validator,
    on_success=on_success,
)
runtime = result_v1.runtime_manager

# Recarga con otra versi√≥n y reusa el mismo gestor para mantener el estado
result_v2 = reload_extension(
    "my_hot_ext",
    source=Path("/tmp/my_hot_ext_v2.py"),
    runtime_manager=runtime,
    force_recompile=True,
)
runtime.replace_function(target_object, "compute", result_v2.loaded.module.compute)
print("√öltimo swap:", runtime.last_metrics.swap_count)
```

Opciones adicionales: `cache_manager` (para usar uno existente), `compiler` (callable
que genere el artefacto), `event_hooks` (tabla inicial de hooks por evento) y banderas
`force_recompile`/`invalidate_cache`/`use_cache` que controlan el origen del artefacto.

## Analizador de rustyficabilidad

El analizador revisa m√≥dulos y funciones para estimar su compatibilidad con una conversi√≥n a Rust.
Recorre el AST con una pol√≠tica conservadora:

- **Reglas AST**: se permiten expresiones aritm√©ticas y booleanas simples, bucles sobre ``range``/``enumerate`` o contenedores b√°sicos, y condiciones de comparaciones sencillas. ``yield``/``yield from`` y comprensiones generan ``PARTIAL``.
- **Heur√≠sticas de tipos**: las anotaciones primitivas (``int``, ``float``, ``bool``, ``str``, etc.) son aceptadas. Contenedores sin parametrizar o anotaciones ambiguas (``Any``, ``object``) degradan a ``PARTIAL``. Tipos complejos/personalizados o vari√°dicos sin anotar se marcan como ``NO``.
- **Pol√≠tica conservadora**: IO, reflexi√≥n, async/await, acceso din√°mico a ``__dict__`` o mutaciones complejas generan razones bloqueantes. Si hay dudas, se degrada el veredicto y se registran todas las razones.

### API Python

```python
from pathlib import Path
from pyrust import analyze_summary

summary = analyze_summary(Path("src"), excluded_dirs=["venv", "__pycache__"])
print(summary.to_dict()["counts"])
for result in summary.blockers:
    print(f"Bloqueante: {result.target} -> {result.reasons[0]}")
```

### CLI

Se instala el entrypoint `pyrust-analyze` (o puedes usar `python -m pyrust.analyzer`):

```bash
# Tabla legible con los primeros hallazgos
pyrust-analyze my_project --exclude venv --exclude build --limit 3

# JSON estructurado (ideal para pipelines)
pyrust-analyze my_project --format json

# Mostrar todas las razones encontradas por objetivo
pyrust-analyze my_project --show-reasons
```

La salida incluye conteos por veredicto (`FULL`, `PARTIAL`, `NO`) y listados de objetivos
parciales o bloqueantes con sus razones completas (todas las razones si se usa
`--show-reasons`).

## Transpilaci√≥n con filtro del analizador

Puedes encadenar el analizador con el transpiler usando la API p√∫blica
`pyrust.transpile_with_analysis(path, *, backend=None, excluded_dirs=None)`. La
funci√≥n ejecuta el an√°lisis primero, salta funciones con veredicto `NO` y a√±ade
el veredicto como metadato en el `IRFunction` antes de renderizar con el backend
elegido (`RustTemplateBackend` por defecto).

```python
from pathlib import Path
from pyrust import transpile_with_analysis

results = transpile_with_analysis(Path("src"))
for item in results:
    if item.skipped:
        print(f"Saltada por veredicto {item.verdict.name}: {item.target}")
    else:
        print(f"Renderizada: {item.target}\n{item.rendered}")
```

Si se intenta renderizar manualmente una funci√≥n con veredicto `NO`, el
transpiler devolver√° un error claro (`IRValidationError`) en vez de generar
plantilla incompleta.

## Ejemplos

Consulta [examples/README.md](examples/README.md) para ejecutar los ejemplos r√°pidos:

1. Compila el m√≥dulo nativo: `maturin develop`.
2. Verifica la integraci√≥n Rust: `python examples/basic.py`.
3. Fuerza el modo solo-Python: `PYRUST_FORCE_PYTHON_FALLBACK=1 python examples/fallback.py`.

## Quick start (dev)

```bash
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install -U pip
pip install -e "[dev]"
```

### Comprobaci√≥n recomendada (entorno aislado)

Para validar que las dependencias de desarrollo se instalan correctamente y que el m√≥dulo funciona despu√©s de compilarse con `maturin`, puedes ejecutar:

```bash
pytest tests/test_dev_environment_setup.py -k dev_environment_install_and_import
```

La prueba crea un entorno virtual temporal, instala `.[dev]`, ejecuta `maturin develop` con `CARGO_TARGET_DIR` apuntando a un directorio ef√≠mero y verifica que `pyrust.hello()` y `pyrust.add()` funcionan, sin dejar artefactos en el repositorio.

> Compatibilidad: Python 3.10+ y Rust 1.70+ (edici√≥n 2021) funcionan correctamente con la versi√≥n actual de PyO3 y maturin.

### Extras opcionales

- **Dev** (tooling de contribuci√≥n: linting, pruebas y build nativo): `pip install -e "[dev]"`.
- **Rust** (tooling de compilaci√≥n): `pip install -e "[rust]"`.
- **Ejemplos** (IPython + helpers de consola para depuraci√≥n): `pip install -e "[examples]"`.
- **Docs** (generar documentaci√≥n est√°tica con MkDocs): `pip install -e "[docs]"`.

## Build the Rust extension

```bash
maturin develop
```

## Generar la rueda nativa (release)

Para producir la rueda compilada usa el objetivo de Make:

```bash
make build-native
```

El objetivo ejecuta `maturin build --release -m rust/Cargo.toml` y deja el artefacto generado en `target/wheels/` (p. ej., `target/wheels/pyrust_native-<version>-*.whl`).

### Verificaci√≥n opcional del m√≥dulo nativo

Despu√©s de construir la rueda puedes validarla con:

```bash
make verify-native
```

El paso anterior crea un entorno virtual temporal, instala la rueda reci√©n construida y ejecuta `python -c "import pyrust; print(pyrust.hello())"` para comprobar que el m√≥dulo `_native` carga correctamente.

## Flujo de publicaci√≥n con maturin

Para un checklist detallado y paso a paso (versionado, changelog, build, validaci√≥n y publicaci√≥n), consulta https://pyrust-dev.github.io/pyrust/publish/.

Requisitos previos:

- Python **3.10+** y Rust **1.70+** (edici√≥n 2021) instalados.
- `maturin>=1.6` disponible en el entorno (`pip install maturin`).
- Variable opcional `CARGO_TARGET_DIR` apuntando a un directorio de artefactos (p. ej., `export CARGO_TARGET_DIR="$(pwd)/target"`) para mantener los builds fuera de otras carpetas.

Pasos locales para generar y verificar artefactos antes de publicar:

```bash
# Compila la rueda en modo release reutilizando el script del repo
CARGO_TARGET_DIR="$(pwd)/target" ./scripts/build_native.sh

# Valida que la rueda generada se puede instalar y cargar
./scripts/verify_native.sh

# Instalaci√≥n manual (opcional) de la rueda reci√©n creada
python -m pip install target/wheels/*.whl
```

Publicaci√≥n manual a PyPI o TestPyPI desde el entorno local (usa tokens almacenados como variables de entorno):

```bash
# TestPyPI (rama de pruebas)
MATURIN_PASSWORD="$TEST_PYPI_API_TOKEN" maturin publish \
  --username __token__ \
  --password "$MATURIN_PASSWORD" \
  --repository-url https://test.pypi.org/legacy/ \
  --skip-existing \
  -m rust/Cargo.toml

# PyPI (tag de lanzamiento)
MATURIN_PASSWORD="$PYPI_API_TOKEN" maturin publish \
  --username __token__ \
  --password "$MATURIN_PASSWORD" \
  --skip-existing \
  -m rust/Cargo.toml
```

El workflow de CI (`.github/workflows/publish.yml`) reutiliza estos scripts para construir y verificar ruedas en cada push a `release/*` o en tags `v*`, adjunta los artefactos generados y, si hay tokens configurados, publica autom√°ticamente a TestPyPI o PyPI seg√∫n la referencia.

## Integraci√≥n continua (Fase 1)

El workflow de CI (`.github/workflows/ci.yml`) se ejecuta en cada push y pull request. Configura Python 3.10 y Rust estable, crea un entorno virtual local, instala las dependencias con `pip install -e "[dev]"`, compila el m√≥dulo con `python -m maturin develop` usando `CARGO_TARGET_DIR="$PWD/target"` y ejecuta las pruebas `pytest tests/test_smoke.py` y `pytest tests/test_dev_environment_setup.py` (esta √∫ltima usa rutas temporales para no dejar residuos).

Para acelerar los builds, el workflow cachea `~/.cargo` y `target/` en funci√≥n del `Cargo.lock` del crate de Rust. Si quieres reproducir localmente los mismos pasos, ejecuta los comandos anteriores desde un entorno limpio y con Python 3.10+ activado.

## Layout

- `pyrust/` ‚Äî Python package (public API + placeholders)
- `rust/` ‚Äî Rust crate compiled as a Python extension (PyO3)
- `examples/` ‚Äî Examples (will grow)
- `tests/` ‚Äî Tests (will grow)


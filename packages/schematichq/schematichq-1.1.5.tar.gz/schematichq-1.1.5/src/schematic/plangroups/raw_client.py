# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError as core_api_error_ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..types.api_error import ApiError as types_api_error_ApiError
from ..types.compatible_plans import CompatiblePlans
from ..types.custom_plan_config import CustomPlanConfig
from ..types.ordered_plans_in_group import OrderedPlansInGroup
from ..types.plan_group_bundle_order import PlanGroupBundleOrder
from ..types.proration_behavior import ProrationBehavior
from .types.create_plan_group_response import CreatePlanGroupResponse
from .types.get_plan_group_response import GetPlanGroupResponse
from .types.update_plan_group_response import UpdatePlanGroupResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawPlangroupsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_plan_group(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[GetPlanGroupResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[GetPlanGroupResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            "plan-groups",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetPlanGroupResponse,
                    parse_obj_as(
                        type_=GetPlanGroupResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, headers=dict(_response.headers), body=_response_json
        )

    def create_plan_group(
        self,
        *,
        add_on_ids: typing.Sequence[str],
        checkout_collect_address: bool,
        checkout_collect_email: bool,
        checkout_collect_phone: bool,
        enable_tax_collection: bool,
        ordered_add_ons: typing.Sequence[OrderedPlansInGroup],
        ordered_bundle_list: typing.Sequence[PlanGroupBundleOrder],
        ordered_plans: typing.Sequence[OrderedPlansInGroup],
        prevent_downgrades_when_over_limit: bool,
        prevent_self_service_downgrade: bool,
        proration_behavior: ProrationBehavior,
        show_as_monthly_prices: bool,
        show_credits: bool,
        show_period_toggle: bool,
        show_zero_price_as_free: bool,
        sync_customer_billing_details: bool,
        add_on_compatibilities: typing.Optional[typing.Sequence[CompatiblePlans]] = OMIT,
        custom_plan_config: typing.Optional[CustomPlanConfig] = OMIT,
        custom_plan_id: typing.Optional[str] = OMIT,
        fallback_plan_id: typing.Optional[str] = OMIT,
        initial_plan_id: typing.Optional[str] = OMIT,
        initial_plan_price_id: typing.Optional[str] = OMIT,
        prevent_self_service_downgrade_button_text: typing.Optional[str] = OMIT,
        prevent_self_service_downgrade_url: typing.Optional[str] = OMIT,
        trial_days: typing.Optional[int] = OMIT,
        trial_expiry_plan_id: typing.Optional[str] = OMIT,
        trial_expiry_plan_price_id: typing.Optional[str] = OMIT,
        trial_payment_method_required: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[CreatePlanGroupResponse]:
        """
        Parameters
        ----------
        add_on_ids : typing.Sequence[str]
            Use OrderedAddOns instead

        checkout_collect_address : bool

        checkout_collect_email : bool

        checkout_collect_phone : bool

        enable_tax_collection : bool

        ordered_add_ons : typing.Sequence[OrderedPlansInGroup]

        ordered_bundle_list : typing.Sequence[PlanGroupBundleOrder]

        ordered_plans : typing.Sequence[OrderedPlansInGroup]

        prevent_downgrades_when_over_limit : bool

        prevent_self_service_downgrade : bool

        proration_behavior : ProrationBehavior

        show_as_monthly_prices : bool

        show_credits : bool

        show_period_toggle : bool

        show_zero_price_as_free : bool

        sync_customer_billing_details : bool

        add_on_compatibilities : typing.Optional[typing.Sequence[CompatiblePlans]]

        custom_plan_config : typing.Optional[CustomPlanConfig]

        custom_plan_id : typing.Optional[str]

        fallback_plan_id : typing.Optional[str]

        initial_plan_id : typing.Optional[str]

        initial_plan_price_id : typing.Optional[str]

        prevent_self_service_downgrade_button_text : typing.Optional[str]

        prevent_self_service_downgrade_url : typing.Optional[str]

        trial_days : typing.Optional[int]

        trial_expiry_plan_id : typing.Optional[str]

        trial_expiry_plan_price_id : typing.Optional[str]

        trial_payment_method_required : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreatePlanGroupResponse]
            Created
        """
        _response = self._client_wrapper.httpx_client.request(
            "plan-groups",
            method="POST",
            json={
                "add_on_compatibilities": convert_and_respect_annotation_metadata(
                    object_=add_on_compatibilities, annotation=typing.Sequence[CompatiblePlans], direction="write"
                ),
                "add_on_ids": add_on_ids,
                "checkout_collect_address": checkout_collect_address,
                "checkout_collect_email": checkout_collect_email,
                "checkout_collect_phone": checkout_collect_phone,
                "custom_plan_config": convert_and_respect_annotation_metadata(
                    object_=custom_plan_config, annotation=CustomPlanConfig, direction="write"
                ),
                "custom_plan_id": custom_plan_id,
                "enable_tax_collection": enable_tax_collection,
                "fallback_plan_id": fallback_plan_id,
                "initial_plan_id": initial_plan_id,
                "initial_plan_price_id": initial_plan_price_id,
                "ordered_add_ons": convert_and_respect_annotation_metadata(
                    object_=ordered_add_ons, annotation=typing.Sequence[OrderedPlansInGroup], direction="write"
                ),
                "ordered_bundle_list": convert_and_respect_annotation_metadata(
                    object_=ordered_bundle_list, annotation=typing.Sequence[PlanGroupBundleOrder], direction="write"
                ),
                "ordered_plans": convert_and_respect_annotation_metadata(
                    object_=ordered_plans, annotation=typing.Sequence[OrderedPlansInGroup], direction="write"
                ),
                "prevent_downgrades_when_over_limit": prevent_downgrades_when_over_limit,
                "prevent_self_service_downgrade": prevent_self_service_downgrade,
                "prevent_self_service_downgrade_button_text": prevent_self_service_downgrade_button_text,
                "prevent_self_service_downgrade_url": prevent_self_service_downgrade_url,
                "proration_behavior": proration_behavior,
                "show_as_monthly_prices": show_as_monthly_prices,
                "show_credits": show_credits,
                "show_period_toggle": show_period_toggle,
                "show_zero_price_as_free": show_zero_price_as_free,
                "sync_customer_billing_details": sync_customer_billing_details,
                "trial_days": trial_days,
                "trial_expiry_plan_id": trial_expiry_plan_id,
                "trial_expiry_plan_price_id": trial_expiry_plan_price_id,
                "trial_payment_method_required": trial_payment_method_required,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreatePlanGroupResponse,
                    parse_obj_as(
                        type_=CreatePlanGroupResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, headers=dict(_response.headers), body=_response_json
        )

    def update_plan_group(
        self,
        plan_group_id: str,
        *,
        add_on_ids: typing.Sequence[str],
        checkout_collect_address: bool,
        checkout_collect_email: bool,
        checkout_collect_phone: bool,
        enable_tax_collection: bool,
        ordered_add_ons: typing.Sequence[OrderedPlansInGroup],
        ordered_bundle_list: typing.Sequence[PlanGroupBundleOrder],
        ordered_plans: typing.Sequence[OrderedPlansInGroup],
        prevent_downgrades_when_over_limit: bool,
        prevent_self_service_downgrade: bool,
        proration_behavior: ProrationBehavior,
        show_as_monthly_prices: bool,
        show_credits: bool,
        show_period_toggle: bool,
        show_zero_price_as_free: bool,
        sync_customer_billing_details: bool,
        add_on_compatibilities: typing.Optional[typing.Sequence[CompatiblePlans]] = OMIT,
        custom_plan_config: typing.Optional[CustomPlanConfig] = OMIT,
        custom_plan_id: typing.Optional[str] = OMIT,
        fallback_plan_id: typing.Optional[str] = OMIT,
        initial_plan_id: typing.Optional[str] = OMIT,
        initial_plan_price_id: typing.Optional[str] = OMIT,
        prevent_self_service_downgrade_button_text: typing.Optional[str] = OMIT,
        prevent_self_service_downgrade_url: typing.Optional[str] = OMIT,
        trial_days: typing.Optional[int] = OMIT,
        trial_expiry_plan_id: typing.Optional[str] = OMIT,
        trial_expiry_plan_price_id: typing.Optional[str] = OMIT,
        trial_payment_method_required: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[UpdatePlanGroupResponse]:
        """
        Parameters
        ----------
        plan_group_id : str
            plan_group_id

        add_on_ids : typing.Sequence[str]
            Use OrderedAddOns instead

        checkout_collect_address : bool

        checkout_collect_email : bool

        checkout_collect_phone : bool

        enable_tax_collection : bool

        ordered_add_ons : typing.Sequence[OrderedPlansInGroup]

        ordered_bundle_list : typing.Sequence[PlanGroupBundleOrder]

        ordered_plans : typing.Sequence[OrderedPlansInGroup]

        prevent_downgrades_when_over_limit : bool

        prevent_self_service_downgrade : bool

        proration_behavior : ProrationBehavior

        show_as_monthly_prices : bool

        show_credits : bool

        show_period_toggle : bool

        show_zero_price_as_free : bool

        sync_customer_billing_details : bool

        add_on_compatibilities : typing.Optional[typing.Sequence[CompatiblePlans]]

        custom_plan_config : typing.Optional[CustomPlanConfig]

        custom_plan_id : typing.Optional[str]

        fallback_plan_id : typing.Optional[str]

        initial_plan_id : typing.Optional[str]

        initial_plan_price_id : typing.Optional[str]

        prevent_self_service_downgrade_button_text : typing.Optional[str]

        prevent_self_service_downgrade_url : typing.Optional[str]

        trial_days : typing.Optional[int]

        trial_expiry_plan_id : typing.Optional[str]

        trial_expiry_plan_price_id : typing.Optional[str]

        trial_payment_method_required : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[UpdatePlanGroupResponse]
            OK
        """
        _response = self._client_wrapper.httpx_client.request(
            f"plan-groups/{jsonable_encoder(plan_group_id)}",
            method="PUT",
            json={
                "add_on_compatibilities": convert_and_respect_annotation_metadata(
                    object_=add_on_compatibilities, annotation=typing.Sequence[CompatiblePlans], direction="write"
                ),
                "add_on_ids": add_on_ids,
                "checkout_collect_address": checkout_collect_address,
                "checkout_collect_email": checkout_collect_email,
                "checkout_collect_phone": checkout_collect_phone,
                "custom_plan_config": convert_and_respect_annotation_metadata(
                    object_=custom_plan_config, annotation=CustomPlanConfig, direction="write"
                ),
                "custom_plan_id": custom_plan_id,
                "enable_tax_collection": enable_tax_collection,
                "fallback_plan_id": fallback_plan_id,
                "initial_plan_id": initial_plan_id,
                "initial_plan_price_id": initial_plan_price_id,
                "ordered_add_ons": convert_and_respect_annotation_metadata(
                    object_=ordered_add_ons, annotation=typing.Sequence[OrderedPlansInGroup], direction="write"
                ),
                "ordered_bundle_list": convert_and_respect_annotation_metadata(
                    object_=ordered_bundle_list, annotation=typing.Sequence[PlanGroupBundleOrder], direction="write"
                ),
                "ordered_plans": convert_and_respect_annotation_metadata(
                    object_=ordered_plans, annotation=typing.Sequence[OrderedPlansInGroup], direction="write"
                ),
                "prevent_downgrades_when_over_limit": prevent_downgrades_when_over_limit,
                "prevent_self_service_downgrade": prevent_self_service_downgrade,
                "prevent_self_service_downgrade_button_text": prevent_self_service_downgrade_button_text,
                "prevent_self_service_downgrade_url": prevent_self_service_downgrade_url,
                "proration_behavior": proration_behavior,
                "show_as_monthly_prices": show_as_monthly_prices,
                "show_credits": show_credits,
                "show_period_toggle": show_period_toggle,
                "show_zero_price_as_free": show_zero_price_as_free,
                "sync_customer_billing_details": sync_customer_billing_details,
                "trial_days": trial_days,
                "trial_expiry_plan_id": trial_expiry_plan_id,
                "trial_expiry_plan_price_id": trial_expiry_plan_price_id,
                "trial_payment_method_required": trial_payment_method_required,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdatePlanGroupResponse,
                    parse_obj_as(
                        type_=UpdatePlanGroupResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, headers=dict(_response.headers), body=_response_json
        )


class AsyncRawPlangroupsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_plan_group(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[GetPlanGroupResponse]:
        """
        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[GetPlanGroupResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            "plan-groups",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    GetPlanGroupResponse,
                    parse_obj_as(
                        type_=GetPlanGroupResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, headers=dict(_response.headers), body=_response_json
        )

    async def create_plan_group(
        self,
        *,
        add_on_ids: typing.Sequence[str],
        checkout_collect_address: bool,
        checkout_collect_email: bool,
        checkout_collect_phone: bool,
        enable_tax_collection: bool,
        ordered_add_ons: typing.Sequence[OrderedPlansInGroup],
        ordered_bundle_list: typing.Sequence[PlanGroupBundleOrder],
        ordered_plans: typing.Sequence[OrderedPlansInGroup],
        prevent_downgrades_when_over_limit: bool,
        prevent_self_service_downgrade: bool,
        proration_behavior: ProrationBehavior,
        show_as_monthly_prices: bool,
        show_credits: bool,
        show_period_toggle: bool,
        show_zero_price_as_free: bool,
        sync_customer_billing_details: bool,
        add_on_compatibilities: typing.Optional[typing.Sequence[CompatiblePlans]] = OMIT,
        custom_plan_config: typing.Optional[CustomPlanConfig] = OMIT,
        custom_plan_id: typing.Optional[str] = OMIT,
        fallback_plan_id: typing.Optional[str] = OMIT,
        initial_plan_id: typing.Optional[str] = OMIT,
        initial_plan_price_id: typing.Optional[str] = OMIT,
        prevent_self_service_downgrade_button_text: typing.Optional[str] = OMIT,
        prevent_self_service_downgrade_url: typing.Optional[str] = OMIT,
        trial_days: typing.Optional[int] = OMIT,
        trial_expiry_plan_id: typing.Optional[str] = OMIT,
        trial_expiry_plan_price_id: typing.Optional[str] = OMIT,
        trial_payment_method_required: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[CreatePlanGroupResponse]:
        """
        Parameters
        ----------
        add_on_ids : typing.Sequence[str]
            Use OrderedAddOns instead

        checkout_collect_address : bool

        checkout_collect_email : bool

        checkout_collect_phone : bool

        enable_tax_collection : bool

        ordered_add_ons : typing.Sequence[OrderedPlansInGroup]

        ordered_bundle_list : typing.Sequence[PlanGroupBundleOrder]

        ordered_plans : typing.Sequence[OrderedPlansInGroup]

        prevent_downgrades_when_over_limit : bool

        prevent_self_service_downgrade : bool

        proration_behavior : ProrationBehavior

        show_as_monthly_prices : bool

        show_credits : bool

        show_period_toggle : bool

        show_zero_price_as_free : bool

        sync_customer_billing_details : bool

        add_on_compatibilities : typing.Optional[typing.Sequence[CompatiblePlans]]

        custom_plan_config : typing.Optional[CustomPlanConfig]

        custom_plan_id : typing.Optional[str]

        fallback_plan_id : typing.Optional[str]

        initial_plan_id : typing.Optional[str]

        initial_plan_price_id : typing.Optional[str]

        prevent_self_service_downgrade_button_text : typing.Optional[str]

        prevent_self_service_downgrade_url : typing.Optional[str]

        trial_days : typing.Optional[int]

        trial_expiry_plan_id : typing.Optional[str]

        trial_expiry_plan_price_id : typing.Optional[str]

        trial_payment_method_required : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreatePlanGroupResponse]
            Created
        """
        _response = await self._client_wrapper.httpx_client.request(
            "plan-groups",
            method="POST",
            json={
                "add_on_compatibilities": convert_and_respect_annotation_metadata(
                    object_=add_on_compatibilities, annotation=typing.Sequence[CompatiblePlans], direction="write"
                ),
                "add_on_ids": add_on_ids,
                "checkout_collect_address": checkout_collect_address,
                "checkout_collect_email": checkout_collect_email,
                "checkout_collect_phone": checkout_collect_phone,
                "custom_plan_config": convert_and_respect_annotation_metadata(
                    object_=custom_plan_config, annotation=CustomPlanConfig, direction="write"
                ),
                "custom_plan_id": custom_plan_id,
                "enable_tax_collection": enable_tax_collection,
                "fallback_plan_id": fallback_plan_id,
                "initial_plan_id": initial_plan_id,
                "initial_plan_price_id": initial_plan_price_id,
                "ordered_add_ons": convert_and_respect_annotation_metadata(
                    object_=ordered_add_ons, annotation=typing.Sequence[OrderedPlansInGroup], direction="write"
                ),
                "ordered_bundle_list": convert_and_respect_annotation_metadata(
                    object_=ordered_bundle_list, annotation=typing.Sequence[PlanGroupBundleOrder], direction="write"
                ),
                "ordered_plans": convert_and_respect_annotation_metadata(
                    object_=ordered_plans, annotation=typing.Sequence[OrderedPlansInGroup], direction="write"
                ),
                "prevent_downgrades_when_over_limit": prevent_downgrades_when_over_limit,
                "prevent_self_service_downgrade": prevent_self_service_downgrade,
                "prevent_self_service_downgrade_button_text": prevent_self_service_downgrade_button_text,
                "prevent_self_service_downgrade_url": prevent_self_service_downgrade_url,
                "proration_behavior": proration_behavior,
                "show_as_monthly_prices": show_as_monthly_prices,
                "show_credits": show_credits,
                "show_period_toggle": show_period_toggle,
                "show_zero_price_as_free": show_zero_price_as_free,
                "sync_customer_billing_details": sync_customer_billing_details,
                "trial_days": trial_days,
                "trial_expiry_plan_id": trial_expiry_plan_id,
                "trial_expiry_plan_price_id": trial_expiry_plan_price_id,
                "trial_payment_method_required": trial_payment_method_required,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreatePlanGroupResponse,
                    parse_obj_as(
                        type_=CreatePlanGroupResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, headers=dict(_response.headers), body=_response_json
        )

    async def update_plan_group(
        self,
        plan_group_id: str,
        *,
        add_on_ids: typing.Sequence[str],
        checkout_collect_address: bool,
        checkout_collect_email: bool,
        checkout_collect_phone: bool,
        enable_tax_collection: bool,
        ordered_add_ons: typing.Sequence[OrderedPlansInGroup],
        ordered_bundle_list: typing.Sequence[PlanGroupBundleOrder],
        ordered_plans: typing.Sequence[OrderedPlansInGroup],
        prevent_downgrades_when_over_limit: bool,
        prevent_self_service_downgrade: bool,
        proration_behavior: ProrationBehavior,
        show_as_monthly_prices: bool,
        show_credits: bool,
        show_period_toggle: bool,
        show_zero_price_as_free: bool,
        sync_customer_billing_details: bool,
        add_on_compatibilities: typing.Optional[typing.Sequence[CompatiblePlans]] = OMIT,
        custom_plan_config: typing.Optional[CustomPlanConfig] = OMIT,
        custom_plan_id: typing.Optional[str] = OMIT,
        fallback_plan_id: typing.Optional[str] = OMIT,
        initial_plan_id: typing.Optional[str] = OMIT,
        initial_plan_price_id: typing.Optional[str] = OMIT,
        prevent_self_service_downgrade_button_text: typing.Optional[str] = OMIT,
        prevent_self_service_downgrade_url: typing.Optional[str] = OMIT,
        trial_days: typing.Optional[int] = OMIT,
        trial_expiry_plan_id: typing.Optional[str] = OMIT,
        trial_expiry_plan_price_id: typing.Optional[str] = OMIT,
        trial_payment_method_required: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[UpdatePlanGroupResponse]:
        """
        Parameters
        ----------
        plan_group_id : str
            plan_group_id

        add_on_ids : typing.Sequence[str]
            Use OrderedAddOns instead

        checkout_collect_address : bool

        checkout_collect_email : bool

        checkout_collect_phone : bool

        enable_tax_collection : bool

        ordered_add_ons : typing.Sequence[OrderedPlansInGroup]

        ordered_bundle_list : typing.Sequence[PlanGroupBundleOrder]

        ordered_plans : typing.Sequence[OrderedPlansInGroup]

        prevent_downgrades_when_over_limit : bool

        prevent_self_service_downgrade : bool

        proration_behavior : ProrationBehavior

        show_as_monthly_prices : bool

        show_credits : bool

        show_period_toggle : bool

        show_zero_price_as_free : bool

        sync_customer_billing_details : bool

        add_on_compatibilities : typing.Optional[typing.Sequence[CompatiblePlans]]

        custom_plan_config : typing.Optional[CustomPlanConfig]

        custom_plan_id : typing.Optional[str]

        fallback_plan_id : typing.Optional[str]

        initial_plan_id : typing.Optional[str]

        initial_plan_price_id : typing.Optional[str]

        prevent_self_service_downgrade_button_text : typing.Optional[str]

        prevent_self_service_downgrade_url : typing.Optional[str]

        trial_days : typing.Optional[int]

        trial_expiry_plan_id : typing.Optional[str]

        trial_expiry_plan_price_id : typing.Optional[str]

        trial_payment_method_required : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[UpdatePlanGroupResponse]
            OK
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"plan-groups/{jsonable_encoder(plan_group_id)}",
            method="PUT",
            json={
                "add_on_compatibilities": convert_and_respect_annotation_metadata(
                    object_=add_on_compatibilities, annotation=typing.Sequence[CompatiblePlans], direction="write"
                ),
                "add_on_ids": add_on_ids,
                "checkout_collect_address": checkout_collect_address,
                "checkout_collect_email": checkout_collect_email,
                "checkout_collect_phone": checkout_collect_phone,
                "custom_plan_config": convert_and_respect_annotation_metadata(
                    object_=custom_plan_config, annotation=CustomPlanConfig, direction="write"
                ),
                "custom_plan_id": custom_plan_id,
                "enable_tax_collection": enable_tax_collection,
                "fallback_plan_id": fallback_plan_id,
                "initial_plan_id": initial_plan_id,
                "initial_plan_price_id": initial_plan_price_id,
                "ordered_add_ons": convert_and_respect_annotation_metadata(
                    object_=ordered_add_ons, annotation=typing.Sequence[OrderedPlansInGroup], direction="write"
                ),
                "ordered_bundle_list": convert_and_respect_annotation_metadata(
                    object_=ordered_bundle_list, annotation=typing.Sequence[PlanGroupBundleOrder], direction="write"
                ),
                "ordered_plans": convert_and_respect_annotation_metadata(
                    object_=ordered_plans, annotation=typing.Sequence[OrderedPlansInGroup], direction="write"
                ),
                "prevent_downgrades_when_over_limit": prevent_downgrades_when_over_limit,
                "prevent_self_service_downgrade": prevent_self_service_downgrade,
                "prevent_self_service_downgrade_button_text": prevent_self_service_downgrade_button_text,
                "prevent_self_service_downgrade_url": prevent_self_service_downgrade_url,
                "proration_behavior": proration_behavior,
                "show_as_monthly_prices": show_as_monthly_prices,
                "show_credits": show_credits,
                "show_period_toggle": show_period_toggle,
                "show_zero_price_as_free": show_zero_price_as_free,
                "sync_customer_billing_details": sync_customer_billing_details,
                "trial_days": trial_days,
                "trial_expiry_plan_id": trial_expiry_plan_id,
                "trial_expiry_plan_price_id": trial_expiry_plan_price_id,
                "trial_payment_method_required": trial_payment_method_required,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    UpdatePlanGroupResponse,
                    parse_obj_as(
                        type_=UpdatePlanGroupResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        types_api_error_ApiError,
                        parse_obj_as(
                            type_=types_api_error_ApiError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise core_api_error_ApiError(
                status_code=_response.status_code, headers=dict(_response.headers), body=_response.text
            )
        raise core_api_error_ApiError(
            status_code=_response.status_code, headers=dict(_response.headers), body=_response_json
        )

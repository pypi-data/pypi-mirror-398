<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>data_request_api.content.dump_transformation API documentation</title>
<meta name="description" content="Script to change the basic airtable export into readable files.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>data_request_api.content.dump_transformation</code></h1>
</header>
<section id="section-intro">
<p>Script to change the basic airtable export into readable files.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="data_request_api.content.dump_transformation.add_useful_keys"><code class="name flex">
<span>def <span class="ident">add_useful_keys</span></span>(<span>content)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_useful_keys(content):
    logger = get_logger()
    record_to_linked_id_index = defaultdict(lambda: dict())
    list_entries = sorted(list(content))
    test = defaultdict(set)
    for subelt in list_entries:
        list_record_ids = sorted(list(content[subelt]),
                                 key=lambda record_id: &#34;|&#34;.join([content[subelt][record_id].get(&#34;name&#34;, &#34;undef&#34;),
                                                                 content[subelt][record_id].get(&#34;uid&#34;, &#34;undef&#34;),
                                                                 record_id]))
        for record_id in list_record_ids:
            if &#34;name&#34; not in content[subelt][record_id]:
                content[subelt][record_id][&#34;name&#34;] = &#34;undef&#34;
            linked_id = content[subelt][record_id].pop(&#34;linked_id&#34;)
            if linked_id.endswith(os.linesep):
                logger.debug(f&#34;linked_id of element type {subelt} and record id {record_id} endswith &#39;\\n&#39;.&#34;)
                linked_id = linked_id.rstrip(os.linesep)
            if linked_id in content[subelt]:
                test[linked_id].add(content[subelt][record_id][&#34;uid&#34;])
                test[linked_id].add(content[subelt][linked_id][&#34;uid&#34;])
            record_to_linked_id_index[subelt][record_id] = linked_id
            content[subelt][linked_id] = content[subelt].pop(record_id)
    if len(test) &gt; 0:
        raise ValueError(&#34;Linked id must be unique: issue with %s&#34; % test)
    return content, record_to_linked_id_index</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.copy_useful_keys"><code class="name flex">
<span>def <span class="ident">copy_useful_keys</span></span>(<span>content, per_entry_input, **common_inputs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute(content, per_entry_input, **common_inputs):
    if &#34;default&#34; in per_entry_input:
        default_value = per_entry_input[&#34;default&#34;]
    else:
        default_value = None
    for key in sorted(list(content)):
        list_args = [content[key], ]
        if key in per_entry_input:
            list_args.append(per_entry_input[key])
        content[key] = func(*list_args, default=copy.deepcopy(default_value), **copy.deepcopy(common_inputs))
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.correct_dictionaries"><code class="name flex">
<span>def <span class="ident">correct_dictionaries</span></span>(<span>input_dict, is_record_ids=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_dictionaries(input_dict, is_record_ids=False):
    &#34;&#34;&#34;
    Correct the input_dict to correct the strings except the record ids.
    :param dict input_dict: the input dictionary to be corrected
    :param bool is_record_ids: a boolean to indicate whether the keys of input_dict contain record ids or not
    :return dict: the corrected dictionary
    &#34;&#34;&#34;
    logger = get_logger()
    if isinstance(input_dict, dict):
        rep = dict()
        for (key, value) in input_dict.items():
            if not is_record_ids:
                new_key = correct_key_string(key)
            else:
                new_key = key
            if isinstance(value, dict):
                rep[new_key] = correct_dictionaries(value, is_record_ids=key in [&#34;records&#34;, &#34;fields&#34;])
            else:
                rep[new_key] = copy.deepcopy(value)
        return rep
    else:
        logger.error(f&#34;Deal with dict types, not {type(input_dict).__name__}&#34;)
        raise TypeError(f&#34;Deal with dict types, not {type(input_dict).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Correct the input_dict to correct the strings except the record ids.
:param dict input_dict: the input dictionary to be corrected
:param bool is_record_ids: a boolean to indicate whether the keys of input_dict contain record ids or not
:return dict: the corrected dictionary</p></div>
</dd>
<dt id="data_request_api.content.dump_transformation.correct_key_string"><code class="name flex">
<span>def <span class="ident">correct_key_string</span></span>(<span>input_string, *to_remove_strings)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_key_string(input_string, *to_remove_strings):
    &#34;&#34;&#34;
    Change the input string by replacing &#39;&amp;&#39; by &#39;and&#39; and spaces by underscores.
    It also removes others specified strings.
    :param str input_string: the input string to be changed
    :param list of str to_remove_strings: the list of strings to be removed from input_string
    :return str: the changed string
    &#34;&#34;&#34;
    logger = get_logger()
    if isinstance(input_string, str):
        input_string = input_string.lower()
        for to_remove_string in to_remove_strings:
            input_string = input_string.replace(to_remove_string.lower(), &#34;&#34;)
        input_string = input_string.strip()
        input_string = input_string.replace(&#34;&amp;&#34;, &#34;and&#34;).replace(&#34; &#34;, &#34;_&#34;)
    else:
        logger.error(f&#34;Deal with string types, not {type(input_string).__name__}&#34;)
        raise TypeError(f&#34;Deal with string types, not {type(input_string).__name__}&#34;)
    return input_string</code></pre>
</details>
<div class="desc"><p>Change the input string by replacing '&amp;' by 'and' and spaces by underscores.
It also removes others specified strings.
:param str input_string: the input string to be changed
:param list of str to_remove_strings: the list of strings to be removed from input_string
:return str: the changed string</p></div>
</dd>
<dt id="data_request_api.content.dump_transformation.distribute_on_entry"><code class="name flex">
<span>def <span class="ident">distribute_on_entry</span></span>(<span>func)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute_on_entry(func):
    def distribute(content, per_entry_input, **common_inputs):
        if &#34;default&#34; in per_entry_input:
            default_value = per_entry_input[&#34;default&#34;]
        else:
            default_value = None
        for key in sorted(list(content)):
            list_args = [content[key], ]
            if key in per_entry_input:
                list_args.append(per_entry_input[key])
            content[key] = func(*list_args, default=copy.deepcopy(default_value), **copy.deepcopy(common_inputs))
        return content

    return distribute</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.filter_content"><code class="name flex">
<span>def <span class="ident">filter_content</span></span>(<span>content)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_content(content):
    variable_groups = set()
    experiment_groups = set()
    variables = set()
    experiments = set()
    subelt = &#34;opportunities&#34;
    for record_id in sorted(list(content[subelt])):
        if content[subelt][record_id].get(&#34;status&#34;) not in [&#34;Accepted&#34;, &#34;Under review&#34;, None]:
            del content[subelt][record_id]
        else:
            variable_groups = variable_groups | set(content[subelt][record_id].get(&#34;variable_groups&#34;, list()))
            experiment_groups = experiment_groups | set(content[subelt][record_id].get(&#34;experiment_groups&#34;, list()))
    subelt = &#34;variable_groups&#34;
    for record_id in sorted(list(content[subelt])):
        if record_id not in variable_groups:
            del content[subelt][record_id]
        else:
            variables = variables | set(content[subelt][record_id].get(&#34;variables&#34;, list()))
    subelt = &#34;experiment_groups&#34;
    for record_id in sorted(list(content[subelt])):
        if record_id not in experiment_groups:
            del content[subelt][record_id]
        elif content[subelt][record_id].get(&#34;status&#34;) in [&#34;Junk&#34;, ]:
            del content[subelt][record_id]
            for op in list(content[&#34;opportunities&#34;]):
                if record_id in content[&#34;opportunities&#34;][op][&#34;experiment_groups&#34;]:
                    content[&#34;opportunities&#34;][op][&#34;experiment_groups&#34;].remove(record_id)
        else:
            experiments = experiments | set(content[subelt][record_id].get(&#34;experiments&#34;, list()))
    subelt = &#34;variables&#34;
    for record_id in sorted(list(set(content[subelt]) - variables)):
        del content[subelt][record_id]
    subelt = &#34;experiments&#34;
    for record_id in sorted(list(set(content[subelt]) - experiments)):
        del content[subelt][record_id]
    for subelt in list(content):
        for record_id in list(content[subelt]):
            for key in [key for key in list(content[subelt][record_id])
                        if re.compile(r&#34;.*status.*&#34;).match(key) is not None]:
                del content[subelt][record_id][key]
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.get_transform_settings"><code class="name flex">
<span>def <span class="ident">get_transform_settings</span></span>(<span>version)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transform_settings(version):
    def update_dict(elt_1, elt_2):
        rep = copy.deepcopy(elt_1)
        for (elt, value) in elt_2.items():
            if isinstance(value, dict):
                val = rep.get(elt, dict())
                for (subelt, subvalue) in value.items():
                    if isinstance(subvalue, dict):
                        val[subelt] = val.get(subelt, dict())
                        val[subelt].update(subvalue)
                    else:
                        val[subelt] = subvalue
                rep[elt] = val
            elif isinstance(value, list):
                rep[elt] = rep.get(elt, list()) + value
            else:
                rep[elt] = value
        return rep

    def get_config_version(version, input_dict, keys_to_remove=[&#34;default&#34;, ], default=False):
        logger = get_logger()
        available_versions = list(set(list(input_dict)) - set(keys_to_remove))
        target_version = None
        if version in available_versions:
            target_version = version
        else:
            # Find out last matching version
            matching_versions = [v for v in available_versions if v in version]
            if len(matching_versions) == 1:
                target_version = matching_versions[0]
            elif len(matching_versions) &gt; 1:
                found_version = max(matching_versions, key=dc._parse_version)
                logger.warning(f&#34;Several versions found matching {version} in config, get last {found_version}.&#34;)
                target_version = found_version
        if target_version is None and default is not False:
            logger.warning(f&#34;No version found matching {version} in config&#34;)
            return default
        elif target_version is None:
            logger.error(f&#34;No version found matching {version} in config&#34;)
            raise ValueError(f&#34;No version found matching {version} in config&#34;)
        else:
            return input_dict[target_version]

    transform = read_json_input_file_content(os.sep.join([os.path.dirname(os.path.abspath(__file__)), &#34;transform.json&#34;]))
    common = transform.pop(&#34;common&#34;, dict())
    if version not in [&#34;default&#34;, ]:
        common = update_dict(common[&#34;default&#34;], get_config_version(version=version, input_dict=common, default=dict()))
    else:
        common = common[&#34;default&#34;]
    for (elt, content) in transform.items():
        default_content = update_dict(common, content[&#34;default&#34;])
        if version not in [&#34;default&#34;, ]:
            default_content = update_dict(default_content, get_config_version(version=version, input_dict=content, default=dict()))
        transform[elt] = default_content
    return transform</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.get_transformed_content"><code class="name flex">
<span>def <span class="ident">get_transformed_content</span></span>(<span>version='latest_stable',<br>export='release',<br>consolidate=False,<br>force_retrieve=False,<br>output_dir=None,<br>force_variable_name=False,<br>default_transformed_content_pattern='{kind}_{export_version}_{consolidate}_content.json',<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@append_kwargs_from_config
def get_transformed_content(version=&#34;latest_stable&#34;, export=&#34;release&#34;, consolidate=False,
                            force_retrieve=False, output_dir=None, force_variable_name=False,
                            default_transformed_content_pattern=&#34;{kind}_{export_version}_{consolidate}_content.json&#34;,
                            **kwargs):
    if export in [&#34;release&#34;, ]:
        if consolidate:
            DR_default_content = dc._json_release_c_DR
            VS_default_content = dc._json_release_c_VS
        else:
            DR_default_content = dc._json_release_nc_DR
            VS_default_content = dc._json_release_nc_VS
    elif export in [&#34;raw&#34;, ]:
        if consolidate:
            DR_default_content = dc._json_raw_c_DR
            VS_default_content = dc._json_raw_c_VS
        else:
            DR_default_content = dc._json_raw_nc_DR
            VS_default_content = dc._json_raw_nc_VS
    else:
        raise ValueError(f&#34;Should not have this error, found export {export}.&#34;)

    if version in [&#34;test&#34;, ]:
        from data_request_api.tests import filepath
        DR_content = filepath(DR_default_content)
        VS_content = filepath(VS_default_content)
    else:
        # Download specified version of data request content (if not locally cached)
        versions = dc.retrieve(version, export=export, consolidate=consolidate, **kwargs)

        # Check that there is only one version associated
        if len(versions) &gt; 1:
            raise ValueError(&#34;Could only deal with one version.&#34;)
        elif len(versions) == 0:
            raise ValueError(&#34;No version found.&#34;)
        else:
            version = list(versions)[0]
            content = versions[version]
            if output_dir is None:
                output_dir = os.path.dirname(content)
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
            DR_content = os.sep.join([output_dir, DR_default_content])
            VS_content = os.sep.join([output_dir, VS_default_content])
            if force_retrieve or not (all(os.path.exists(filepath) for filepath in [DR_content, VS_content])):
                if os.path.exists(DR_content):
                    os.remove(DR_content)
                if os.path.exists(VS_content):
                    os.remove(VS_content)
            if not (all(os.path.exists(filepath) for filepath in [DR_content, VS_content])):
                content = dc.load(version, export=export, consolidate=consolidate)
                data_request, vocabulary_server = transform_content(content, version, variable_name=kwargs[&#34;variable_name&#34;],
                                                                    force_variable_name=force_variable_name)
                write_json_output_file_content(DR_content, data_request)
                write_json_output_file_content(VS_content, vocabulary_server)
    return dict(DR_input=DR_content, VS_input=VS_content)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.initialize_useful_keys"><code class="name flex">
<span>def <span class="ident">initialize_useful_keys</span></span>(<span>content, per_entry_input, **common_inputs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute(content, per_entry_input, **common_inputs):
    if &#34;default&#34; in per_entry_input:
        default_value = per_entry_input[&#34;default&#34;]
    else:
        default_value = None
    for key in sorted(list(content)):
        list_args = [content[key], ]
        if key in per_entry_input:
            list_args.append(per_entry_input[key])
        content[key] = func(*list_args, default=copy.deepcopy(default_value), **copy.deepcopy(common_inputs))
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.merge_useful_keys"><code class="name flex">
<span>def <span class="ident">merge_useful_keys</span></span>(<span>content, per_entry_input, **common_inputs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute(content, per_entry_input, **common_inputs):
    if &#34;default&#34; in per_entry_input:
        default_value = per_entry_input[&#34;default&#34;]
    else:
        default_value = None
    for key in sorted(list(content)):
        list_args = [content[key], ]
        if key in per_entry_input:
            list_args.append(per_entry_input[key])
        content[key] = func(*list_args, default=copy.deepcopy(default_value), **copy.deepcopy(common_inputs))
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.remove_unused_keys"><code class="name flex">
<span>def <span class="ident">remove_unused_keys</span></span>(<span>content, per_entry_input, **common_inputs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute(content, per_entry_input, **common_inputs):
    if &#34;default&#34; in per_entry_input:
        default_value = per_entry_input[&#34;default&#34;]
    else:
        default_value = None
    for key in sorted(list(content)):
        list_args = [content[key], ]
        if key in per_entry_input:
            list_args.append(per_entry_input[key])
        content[key] = func(*list_args, default=copy.deepcopy(default_value), **copy.deepcopy(common_inputs))
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.rename_useful_keys"><code class="name flex">
<span>def <span class="ident">rename_useful_keys</span></span>(<span>content, per_entry_input, **common_inputs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute(content, per_entry_input, **common_inputs):
    if &#34;default&#34; in per_entry_input:
        default_value = per_entry_input[&#34;default&#34;]
    else:
        default_value = None
    for key in sorted(list(content)):
        list_args = [content[key], ]
        if key in per_entry_input:
            list_args.append(per_entry_input[key])
        content[key] = func(*list_args, default=copy.deepcopy(default_value), **copy.deepcopy(common_inputs))
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.reshape_useful_keys"><code class="name flex">
<span>def <span class="ident">reshape_useful_keys</span></span>(<span>content, per_entry_input, **common_inputs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute(content, per_entry_input, **common_inputs):
    if &#34;default&#34; in per_entry_input:
        default_value = per_entry_input[&#34;default&#34;]
    else:
        default_value = None
    for key in sorted(list(content)):
        list_args = [content[key], ]
        if key in per_entry_input:
            list_args.append(per_entry_input[key])
        content[key] = func(*list_args, default=copy.deepcopy(default_value), **copy.deepcopy(common_inputs))
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.sort_useful_keys"><code class="name flex">
<span>def <span class="ident">sort_useful_keys</span></span>(<span>content, per_entry_input, **common_inputs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distribute(content, per_entry_input, **common_inputs):
    if &#34;default&#34; in per_entry_input:
        default_value = per_entry_input[&#34;default&#34;]
    else:
        default_value = None
    for key in sorted(list(content)):
        list_args = [content[key], ]
        if key in per_entry_input:
            list_args.append(per_entry_input[key])
        content[key] = func(*list_args, default=copy.deepcopy(default_value), **copy.deepcopy(common_inputs))
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.split_content_one_base"><code class="name flex">
<span>def <span class="ident">split_content_one_base</span></span>(<span>content)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_content_one_base(content):
    &#34;&#34;&#34;
    Split the one base content into two dictionaries:
    - the DR (structure)
    - the VS (vocabulary server with all information)
    :param dict content: dictionary containing the one base content
    :return dict, dict: two dictionaries containing respectively the DR and VS
    &#34;&#34;&#34;
    logger = get_logger()
    data_request = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: dict)))
    keys_to_dr_dict = {
        &#34;opportunities&#34;: [(&#34;experiment_groups&#34;, list, list()),
                          (&#34;variable_groups&#34;, list, list()),
                          (&#34;data_request_themes&#34;, list, list()),
                          (&#34;time_subsets&#34;, list, [&#34;link::all&#34;, ]),
                          (&#34;mips&#34;, list, list())],
        &#34;variable_groups&#34;: [(&#34;variables&#34;, list, list()),
                            (&#34;mips&#34;, list, list()),
                            (&#34;priority_level&#34;, (str, type(None)), None)],
        &#34;experiment_groups&#34;: [(&#34;experiments&#34;, list, list()), ]
    }
    if &#34;all&#34; not in content[&#34;time_subsets&#34;]:
        content[&#34;time_subsets&#34;][&#34;all&#34;] = dict(start=None, end=None, title=&#34;Whole time serie&#34;, name=&#34;all&#34;, type=&#34;void&#34;, uid=&#34;80ac3156-a698-11ef-914a-613c0433d878&#34;)
    if isinstance(content, dict):
        logger.debug(&#34;Build DR and VS&#34;)
        for subelt in sorted(list(content)):
            if subelt in keys_to_dr_dict:
                for uid in content[subelt]:
                    for (key, target_type, default) in keys_to_dr_dict[subelt]:
                        value = content[subelt][uid].pop(key, default)
                        if not isinstance(value, target_type):
                            if target_type in [list, ] and isinstance(value, (str, int, type(None))):
                                value = [value, ]
                            elif str in target_type and isinstance(value, list):
                                value = value[0]
                            else:
                                raise TypeError(f&#34;Could not deal with target type {type(target_type)}&#34;)
                        data_request[subelt][uid][key] = value
        return data_request, content
    else:
        logger.error(f&#34;Deal with dict types, not {type(content).__name__}&#34;)
        raise TypeError(f&#34;Deal with dict types, not {type(content).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Split the one base content into two dictionaries:
- the DR (structure)
- the VS (vocabulary server with all information)
:param dict content: dictionary containing the one base content
:return dict, dict: two dictionaries containing respectively the DR and VS</p></div>
</dd>
<dt id="data_request_api.content.dump_transformation.tidy_content"><code class="name flex">
<span>def <span class="ident">tidy_content</span></span>(<span>content, record_to_uid_index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tidy_content(content, record_to_uid_index):
    logger = get_logger()
    # Replace record_id by uid
    logger.debug(&#34;Replace record ids by uids&#34;)
    to_remove_entries = defaultdict(lambda: defaultdict(lambda: 0))
    list_content = list(content)
    len_list_content = len(list_content)
    for content_subelt in list_content:
        content_string = json.dumps(content[content_subelt], indent=0)
        for subelt in record_to_uid_index:
            for (record_id, uid) in record_to_uid_index[subelt].items():
                tmp_content_string = content_string.replace(f&#39;&#34;{record_id}&#34;&#39;, f&#39;&#34;link::{uid}&#34;&#39;)
                if content_string == tmp_content_string:
                    to_remove_entries[subelt][(record_id, uid)] += 1
                content_string = tmp_content_string
        content[content_subelt] = json.loads(content_string)
    for content_subelt in [&#34;opportunities&#34;, &#34;coordinates_and_dimensions&#34;]:
        if content_subelt in to_remove_entries:
            to_remove = [elt for (elt, nb) in to_remove_entries[content_subelt].items() if nb == len_list_content]
            for record_id, _ in to_remove:
                del record_to_uid_index[content_subelt][record_id]
            del to_remove_entries[content_subelt]
    for (subelt, to_remove) in to_remove_entries.items():
        to_remove = [elt for (elt, nb) in to_remove.items() if nb == len_list_content]
        for (record_id, uid) in to_remove:
            del content[subelt][uid]
            del record_to_uid_index[subelt][record_id]
    # Tidy the content once again
    content_str = json.dumps(content)
    for subelt in record_to_uid_index:
        for uid in [uid for uid in record_to_uid_index[subelt].values() if content_str.count(uid) &lt; 3]:
            del content[subelt][uid]
    return content</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="data_request_api.content.dump_transformation.transform_content"><code class="name flex">
<span>def <span class="ident">transform_content</span></span>(<span>content, version, force_variable_name=False, variable_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_content(content, version, force_variable_name=False, variable_name=None):
    &#34;&#34;&#34;
    Function to transform the export content (single or several base-s- export) to VS and DR dictionaries.
    The key &#34;version&#34; is added to the DR and VS dictionaries.
    :param dict content: input export content (either single base or several bases)
    :param str version: string containing the version of the export content
    :param bool force_variable_name: bool whether to force variable name to config one
    :param str variable_name: string containing the variable name to be used
    :return dict, dict: DR and VS dictionaries containing respectively the structure (DR) and the vocabulary (VS)
    &#34;&#34;&#34;
    logger = get_logger()
    if &#34;Data Request&#34; in content:
        content[&#34;Data Request&#34;].pop(&#34;version&#34;, None)
    transform_settings = get_transform_settings(version)
    if isinstance(content, dict):
        # Correct dictionaries
        content = correct_dictionaries(content)
        # Get back to one database case if needed
        if len(content) == 1:
            logger.info(&#34;Single database case - no structure transformation needed&#34;)
            content = transform_content_inner(content, transform_settings[&#34;one_to_transform&#34;],
                                              force_variable_name=force_variable_name, variable_name=variable_name)
        elif len(content) in [3, 4]:
            logger.info(&#34;Several databases case - structure transformation needed&#34;)
            content = transform_content_inner(content, transform_settings[&#34;several_to_transform&#34;], change_tables=True,
                                              force_variable_name=force_variable_name, variable_name=variable_name)
        else:
            raise ValueError(f&#34;Could not manage the {len(content):d} bases export file.&#34;)
        # Separate DR and VS files
        data_request, vocabulary_server = split_content_one_base(content)
        data_request[&#34;version&#34;] = version
        vocabulary_server[&#34;version&#34;] = version
        return data_request, vocabulary_server
    else:
        logger.error(f&#34;Deal with dict types, not {type(content).__name__}&#34;)
        raise TypeError(f&#34;Deal with dict types, not {type(content).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Function to transform the export content (single or several base-s- export) to VS and DR dictionaries.
The key "version" is added to the DR and VS dictionaries.
:param dict content: input export content (either single base or several bases)
:param str version: string containing the version of the export content
:param bool force_variable_name: bool whether to force variable name to config one
:param str variable_name: string containing the variable name to be used
:return dict, dict: DR and VS dictionaries containing respectively the structure (DR) and the vocabulary (VS)</p></div>
</dd>
<dt id="data_request_api.content.dump_transformation.transform_content_inner"><code class="name flex">
<span>def <span class="ident">transform_content_inner</span></span>(<span>content,<br>settings,<br>change_tables=False,<br>force_variable_name=False,<br>variable_name=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transform_content_inner(content, settings, change_tables=False, force_variable_name=False, variable_name=None):
    &#34;&#34;&#34;
    Transform a one base export content to:
    - remove unused keys which could create circle import later
    - harmonise some entries
    - reshape entries if needed
    - remove elements which are not used
    - filter content on status
    :param dict content: one base content export (direct export or created from `transform_content_three_bases`
    :return dict: the transform content
    &#34;&#34;&#34;
    logger = get_logger()
    if isinstance(content, dict) and len(content) == 1 and change_tables:
        logger.error(&#34;For one base dict, change_tables must be False.&#34;)
        raise ValueError(&#34;For one base dict, change_tables must be False.&#34;)
    elif isinstance(content, dict) and len(content) &gt; 1 and not change_tables:
        logger.error(&#34;For several bases dict, changes_tables must be True.&#34;)
        raise ValueError(&#34;For several bases dict, changes_tables must be True.&#34;)
    elif isinstance(content, dict):
        # If needed, deal with one base creation
        if change_tables:
            new_content = dict()
            for (elt, (base, table)) in settings[&#34;tables_provenance&#34;].items():
                new_content[elt] = content[settings[&#34;several_bases_name&#34;][base]][table]
            logger.info(&#34;Harmonise bases content record ids&#34;)
            content_str = json.dumps(new_content)
            for ((base_old, table_old, key_old), (base_new, table_new, key_new)) in settings[&#34;several_bases_link&#34;].values():
                old_table = content[settings[&#34;several_bases_name&#34;][base_old]][table_old][&#34;records&#34;]
                new_table = content[settings[&#34;several_bases_name&#34;][base_new]][table_new][&#34;records&#34;]
                old_dict = {record_id: value[key_old] for (record_id, value) in old_table.items()}
                new_dict = {value[key_new]: record_id for (record_id, value) in new_table.items()}
                for (id, val) in old_dict.items():
                    content_str = content_str.replace(f&#39;&#34;{id}&#34;&#39;, f&#39;&#34;{new_dict[val]}&#34;&#39;)
            content = json.loads(content_str)
        else:
            content = content[list(content)[0]]
        # Rename some elements
        for (patt, repl) in settings[&#34;tables_to_rename&#34;].items():
            for key in [key for key in content if re.compile(patt).match(key) is not None]:
                content[re.sub(patt, repl, key)] = content.pop(key)
        for elt in [elt for elt in list(content) if any(re.compile(patt).match(elt) for patt in settings[&#34;tables_to_delete&#34;])]:
            del content[elt]
        # Tidy the content of the export file
        default_patterns_to_remove = settings[&#34;default_keys_to_delete&#34;]
        to_remove_keys_patterns = settings[&#34;keys_to_delete&#34;]
        to_rename_keys_patterns = settings[&#34;keys_to_rename&#34;]
        to_copy_keys_content = settings[&#34;keys_to_copy&#34;]
        if force_variable_name:
            for key in list(to_copy_keys_content[&#34;variables&#34;]):
                if to_copy_keys_content[&#34;variables&#34;][key] in [&#34;name&#34;, ]:
                    del to_copy_keys_content[&#34;variables&#34;][key]
            to_copy_keys_content[&#34;variables&#34;][correct_key_string(variable_name)] = &#34;name&#34;
        to_merge_keys_patterns = settings[&#34;keys_to_merge&#34;]
        to_sort_keys_content = settings[&#34;keys_to_sort&#34;]
        to_initialize_keys_content = settings[&#34;keys_to_initialize&#34;]
        content = remove_unused_keys(content=content, per_entry_input=to_remove_keys_patterns,
                                     default_patterns_to_remove=default_patterns_to_remove)
        content = copy_useful_keys(content=content, per_entry_input=to_copy_keys_content)
        content = rename_useful_keys(content=content, per_entry_input=to_rename_keys_patterns)
        content = merge_useful_keys(content=content, per_entry_input=to_merge_keys_patterns)
        # Filter on status if needed then remove linked keys
        content = filter_content(content)
        # Copy some keys to others
        global default_count
        default_count = 0
        content = initialize_useful_keys(content=content, per_entry_input=to_initialize_keys_content)
        # Add name and uid if needed, build equivalence dict between record_id and uid
        content, record_to_uid_index = add_useful_keys(content)
        # Tidy the content of the dictionary by removing unused entries
        content = tidy_content(content, record_to_uid_index)
        # Sort content of needed keys
        content = sort_useful_keys(content, per_entry_input=to_sort_keys_content)
        for (reshape_style, from_list_to_string_keys_content) in settings[&#34;keys_to_format&#34;].items():
            content = reshape_useful_keys(content, per_entry_input=from_list_to_string_keys_content,
                                          reshape_style=reshape_style)
        return content
    else:
        logger.error(f&#34;Deal with dict types, not {type(content).__name__}&#34;)
        raise TypeError(f&#34;Deal with dict types, not {type(content).__name__}&#34;)</code></pre>
</details>
<div class="desc"><p>Transform a one base export content to:
- remove unused keys which could create circle import later
- harmonise some entries
- reshape entries if needed
- remove elements which are not used
- filter content on status
:param dict content: one base content export (direct export or created from <code>transform_content_three_bases</code>
:return dict: the transform content</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="data_request_api.content" href="index.html">data_request_api.content</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="data_request_api.content.dump_transformation.add_useful_keys" href="#data_request_api.content.dump_transformation.add_useful_keys">add_useful_keys</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.copy_useful_keys" href="#data_request_api.content.dump_transformation.copy_useful_keys">copy_useful_keys</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.correct_dictionaries" href="#data_request_api.content.dump_transformation.correct_dictionaries">correct_dictionaries</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.correct_key_string" href="#data_request_api.content.dump_transformation.correct_key_string">correct_key_string</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.distribute_on_entry" href="#data_request_api.content.dump_transformation.distribute_on_entry">distribute_on_entry</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.filter_content" href="#data_request_api.content.dump_transformation.filter_content">filter_content</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.get_transform_settings" href="#data_request_api.content.dump_transformation.get_transform_settings">get_transform_settings</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.get_transformed_content" href="#data_request_api.content.dump_transformation.get_transformed_content">get_transformed_content</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.initialize_useful_keys" href="#data_request_api.content.dump_transformation.initialize_useful_keys">initialize_useful_keys</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.merge_useful_keys" href="#data_request_api.content.dump_transformation.merge_useful_keys">merge_useful_keys</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.remove_unused_keys" href="#data_request_api.content.dump_transformation.remove_unused_keys">remove_unused_keys</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.rename_useful_keys" href="#data_request_api.content.dump_transformation.rename_useful_keys">rename_useful_keys</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.reshape_useful_keys" href="#data_request_api.content.dump_transformation.reshape_useful_keys">reshape_useful_keys</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.sort_useful_keys" href="#data_request_api.content.dump_transformation.sort_useful_keys">sort_useful_keys</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.split_content_one_base" href="#data_request_api.content.dump_transformation.split_content_one_base">split_content_one_base</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.tidy_content" href="#data_request_api.content.dump_transformation.tidy_content">tidy_content</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.transform_content" href="#data_request_api.content.dump_transformation.transform_content">transform_content</a></code></li>
<li><code><a title="data_request_api.content.dump_transformation.transform_content_inner" href="#data_request_api.content.dump_transformation.transform_content_inner">transform_content_inner</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>data_request_api.content.consolidate_export API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>data_request_api.content.consolidate_export</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="data_request_api.content.consolidate_export.map_data"><code class="name flex">
<span>def <span class="ident">map_data</span></span>(<span>data, mapping_table, version, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_data(data, mapping_table, version, **kwargs):
    &#34;&#34;&#34;
    Maps the data to the one-base structure using the mapping table.

    Parameters
    ----------
    data : dict
        Three-base or one-base Airtable export.
    mapping_table dict
        The mapping table to apply to map to one base.
    version : str
        The version tag of the exported Data Request Content dictionary.

    Returns
    -------
    dict
        Mapped data with one-base structure.

    Note
    ----
        Returns the input dict if the data is already one-base.
    &#34;&#34;&#34;
    logger = get_logger()
    missing_bases = []
    missing_tables = []
    mapped_data = {&#34;Data Request&#34;: {}}

    # Check if data is already one-base
    if len(data.keys()) in [3, 4]:
        # Set version
        mapped_data[&#34;Data Request&#34;][&#34;version&#34;] = version

        # Reset filtered records
        global filtered_records
        if filtered_records:
            filtered_records = []
        filtered_records_dict = dict()

        # Get filtered records
        for table, mapinfo in mapping_table.items():
            if mapinfo[&#34;source_base&#34;] in data and any(
                [st in data[mapinfo[&#34;source_base&#34;]] for st in mapinfo[&#34;source_table&#34;]]
            ):
                source_table = [
                    st
                    for st in mapinfo[&#34;source_table&#34;]
                    if st in data[mapinfo[&#34;source_base&#34;]]
                ][0]
                if &#34;internal_filters&#34; in mapinfo:
                    for record_id, record in data[mapinfo[&#34;source_base&#34;]][source_table][
                        &#34;records&#34;
                    ].items():
                        filter_results = []
                        for filter_key, filter_val in mapinfo[
                            &#34;internal_filters&#34;
                        ].items():
                            if all(
                                [
                                    filter_alias not in record
                                    for filter_alias in [filter_key]
                                    + filter_val[&#34;aliases&#34;]
                                ]
                            ):
                                filter_results.append(False)
                            elif filter_val[&#34;operator&#34;] == &#34;nonempty&#34;:
                                filter_results.append(
                                    any(
                                        [
                                            bool(record[fk])
                                            for fk in [filter_key]
                                            + filter_val[&#34;aliases&#34;]
                                            if fk in record
                                        ]
                                    )
                                )
                            elif filter_val[&#34;operator&#34;] == &#34;in&#34;:
                                for fk in [filter_key] + filter_val[&#34;aliases&#34;]:
                                    if fk in record:
                                        if isinstance(record[filter_key], list):
                                            filter_results.append(
                                                any(
                                                    fj in filter_val[&#34;values&#34;]
                                                    for fj in record[filter_key]
                                                )
                                            )
                                            break
                                        else:
                                            filter_results.append(
                                                record[filter_key]
                                                in filter_val[&#34;values&#34;]
                                            )
                            elif filter_val[&#34;operator&#34;] == &#34;not in&#34;:
                                for fk in [filter_key] + filter_val[&#34;aliases&#34;]:
                                    if fk in record:
                                        if isinstance(record[filter_key], list):
                                            filter_results.append(
                                                any(
                                                    fj not in filter_val[&#34;values&#34;]
                                                    for fj in record[filter_key]
                                                )
                                            )
                                        break
                                else:
                                    filter_results.append(
                                        record[filter_key] not in filter_val[&#34;values&#34;]
                                    )
                        if not all(filter_results):
                            logger.debug(
                                f&#34;Filtered record &#39;{record_id}&#39;&#34;
                                f&#34; {&#39;(&#39; + record[&#39;name&#39;] + &#39;)&#39; if &#39;name&#39; in record else &#39;&#39;}&#34;
                                f&#34; from &#39;{table}&#39;.&#34;
                            )
                            filtered_records.append(record_id)
                            if table in filtered_records_dict:
                                filtered_records_dict[table].append(record_id)
                            else:
                                filtered_records_dict[table] = [record_id]
        for key in filtered_records_dict:
            logger.debug(
                f&#34;Filtered {len(filtered_records_dict[key])} records for &#39;{key}&#39;.&#34;
            )
        logger.debug(f&#34;Filtered {len(filtered_records)} records in total.&#34;)

        # Perform mapping in case of three-base structure
        for table, mapinfo in mapping_table.items():
            intm = mapinfo[&#34;internal_mapping&#34;]
            if mapinfo[&#34;source_base&#34;] in data and any(
                [st in data[mapinfo[&#34;source_base&#34;]] for st in mapinfo[&#34;source_table&#34;]]
            ):
                # Copy the selected data to the one-base structure
                # - skip filtered records
                # - rename record attributes according to
                #   &#34;internal_consistency&#34; settings
                # - filter references to records for fields that are not
                #   internally mapped below
                source_table = [
                    st
                    for st in mapinfo[&#34;source_table&#34;]
                    if st in data[mapinfo[&#34;source_base&#34;]]
                ][0]
                logger.debug(
                    f&#34;Mapping &#39;{mapinfo[&#39;source_base&#39;]}&#39; : &#39;{source_table}&#39; -&gt; &#39;{table}&#39;&#34;
                )
                mapped_data[&#34;Data Request&#34;][table] = {
                    **data[mapinfo[&#34;source_base&#34;]][source_table],
                    &#34;records&#34;: {
                        record_id: {
                            mapinfo[&#34;internal_consistency&#34;].get(
                                reckey, reckey
                            ): _filter_references(
                                recvalue,
                                reckey,
                                table,
                                record_id,
                                mapinfo[&#34;field_dtypes&#34;].get(
                                    mapinfo[&#34;internal_consistency&#34;].get(reckey, reckey),
                                    None,
                                ),
                            )
                            for reckey, recvalue in record.items()
                            if reckey not in mapinfo[&#34;drop_keys&#34;]
                        }
                        for record_id, record in data[mapinfo[&#34;source_base&#34;]][
                            source_table
                        ][&#34;records&#34;].items()
                        if record_id not in filtered_records
                    },
                }

                # If record attributes require mapping
                if intm != {}:
                    # for each attribute that requires mapping
                    for attr in intm.keys():
                        intm_table = [
                            tn
                            for tn in mapping_table.keys()
                            if tn in mapping_table[tn][&#34;source_table&#34;]
                            and tn == intm[attr][&#34;table&#34;]
                        ][0]
                        intm_table_alias = [
                            tn
                            for tn in mapping_table[intm_table][&#34;source_table&#34;]
                            if tn in data[intm[attr][&#34;base&#34;]]
                        ]
                        try:
                            intm_table_alias = intm_table_alias[0]
                        except IndexError:
                            errmsg = f&#34;None of the following tables exist in the data: {mapping_table[intm[attr][&#39;table&#39;]][&#39;source_table&#39;]}.&#34;
                            logger.error(errmsg)
                            raise ValueError(errmsg)

                        for record_id, record in data[mapinfo[&#34;source_base&#34;]][
                            source_table
                        ][&#34;records&#34;].items():
                            if record_id in filtered_records:
                                continue
                            elif (
                                attr not in record
                                or record[attr] is None
                                or record[attr] == &#34;&#34;
                                or record[attr] == []
                            ):
                                # Attribute name not found for record, but might have a different name
                                #  in another export type or release version
                                logger.debug(
                                    f&#34;{table}: Attribute &#39;{attr}&#39; not found for record &#39;{record_id}&#39;.&#34;
                                )
                                attr_aliases = [
                                    a
                                    for a in mapinfo[&#34;internal_consistency&#34;].keys()
                                    if mapinfo[&#34;internal_consistency&#34;][a] == attr
                                ]
                                attr_alias_found = False
                                for a in attr_aliases:
                                    if a in record:
                                        attr_vals = record[a]
                                        attr_alias_found = True
                                        logger.debug(
                                            f&#34;{table}: Using attribute &#39;{a}&#39; instead for record &#39;{record_id}&#39;.&#34;
                                        )
                                        break
                                if not attr_alias_found:
                                    continue
                            else:
                                attr_vals = record[attr]

                            # Get list of record-keys of the attribute (eg. &#34;Variables&#34;)
                            #   that is connected to the current record of the &#34;source_table
                            #   (eg. &#34;Variable Groups&#34;) by the specified &#34;operation&#34;
                            if intm[attr][&#34;operation&#34;] == &#34;split&#34;:
                                if isinstance(attr_vals, list):
                                    errmsg = (
                                        f&#34;Consolidation of {table}@{attr}: Selected &#39;split&#39; operation&#34;
                                        f&#34; for a list {record_id}:&#34;,
                                        attr_vals,
                                    )
                                    logger.error(f&#34;TypeError: {errmsg}&#34;)
                                    continue
                                    # raise TypeError({errmsg})
                                else:
                                    attr_vals = list(
                                        map(
                                            lambda x: x.strip(&#39;&#34;&#39;),
                                            re.split(
                                                r&#39;,\s*(?=(?:[^&#34;]|&#34;[^&#34;]*&#34;)*$)&#39;, attr_vals
                                            ),
                                        )
                                    )
                            elif intm[attr][&#34;operation&#34;] == &#34;&#34;:
                                if isinstance(attr_vals, str):
                                    attr_vals = [attr_vals]
                            else:
                                errmsg = (
                                    f&#34;Unknown internal mapping operation for attribute &#39;{attr}&#39;&#34;
                                    f&#34; (&#39;{source_table}&#39;): &#39;{intm[attr][&#39;operation&#39;]}&#39;&#34;
                                )
                                logger.error(f&#34;ValueError: {errmsg}&#34;)
                                raise ValueError(errmsg)

                            # Get mapped record_ids for this list of record-keys
                            # entry_type - single record_id or list of record_ids
                            # - map by record_id
                            if intm[attr][&#34;entry_type&#34;] == &#34;record_id&#34;:
                                if not intm[attr][&#34;base_copy_of_table&#34;]:
                                    errmsg = (
                                        &#34;A copy of the table in the same base is required if &#39;entry_type&#39;&#34;
                                        &#34; is set to &#39;record_id&#39;, but &#39;base_copy_of_table&#39; is set to&#34;
                                        f&#34; False: &#39;{source_table}&#39; - &#39;{attr}&#39;&#34;
                                    )
                                    logger.error(f&#34;ValueError: {errmsg}&#34;)
                                    raise ValueError(errmsg)
                                elif not intm[attr][&#34;base&#34;] in data:
                                    errmsg = f&#34;Base &#39;{intm[attr][&#39;base&#39;]}&#39; not found in data.&#34;
                                    logger.error(f&#34;KeyError: {errmsg}&#34;)
                                    raise KeyError(errmsg)
                                elif (
                                    intm[attr][&#34;base_copy_of_table&#34;]
                                    not in data[mapinfo[&#34;source_base&#34;]]
                                ):
                                    errmsg = f&#34;Table &#39;{intm[attr][&#39;base_copy_of_table&#39;]}&#39; not found in base &#39;{mapinfo[&#39;source_base&#39;]}&#39;.&#34;
                                    logger.error(f&#34;KeyError: {errmsg}&#34;)
                                    raise KeyError(errmsg)

                                recordIDs_new = []
                                for attr_val in attr_vals:
                                    # The record copy in the current base
                                    record_copy = data[mapinfo[&#34;source_base&#34;]][
                                        intm[attr][&#34;base_copy_of_table&#34;]
                                    ][&#34;records&#34;][attr_val]
                                    # The entire list of records in the base of origin
                                    recordlist = data[intm[attr][&#34;base&#34;]][
                                        intm_table_alias
                                    ][&#34;records&#34;]
                                    recordID_new = _map_record_id(
                                        record_copy,
                                        recordlist,
                                        intm[attr][&#34;map_by_key&#34;],
                                    )
                                    recordID_filtered = [
                                        r
                                        for r in recordID_new
                                        if r not in filtered_records
                                    ]
                                    if len(recordID_filtered) == 0:
                                        if len(recordID_new) == 0:
                                            logger.debug(
                                                f&#34;Consolidation of {table}@{intm_table_alias}: No matching&#34;
                                                f&#34; record found for attribute &#39;{attr}&#39; with value &#39;{attr_val}&#39;.&#34;
                                            )
                                    elif len(recordID_filtered) &gt; 1:
                                        logger.warning(
                                            f&#34;Consolidation of {table}@{intm_table_alias}:&#34;
                                            f&#34; Multiple matching records found for attribute &#39;{attr}&#39; with&#34;
                                            f&#34; value &#39;{attr_val}&#39;: {recordID_new}. Using first match.&#34;
                                        )
                                        recordIDs_new.append(recordID_filtered[0])
                                    else:
                                        recordIDs_new.append(recordID_filtered[0])

                            # entry_type - name (eg. unique label or similar)
                            # - map by attribute value
                            elif intm[attr][&#34;entry_type&#34;] == &#34;name&#34;:
                                recordIDs_new = []
                                for attr_val in attr_vals:
                                    recordID_new = _map_attribute(
                                        attr_val,
                                        data[intm[attr][&#34;base&#34;]][intm_table_alias][
                                            &#34;records&#34;
                                        ],
                                        (
                                            [intm[attr][&#34;map_by_key&#34;]]
                                            if isinstance(intm[attr][&#34;map_by_key&#34;], str)
                                            else intm[attr][&#34;map_by_key&#34;]
                                        ),
                                    )
                                    recordID_filtered = [
                                        r
                                        for r in recordID_new
                                        if r not in filtered_records
                                    ]
                                    if len(recordID_filtered) == 0:
                                        if len(recordID_new) == 0:
                                            logger.debug(
                                                f&#34;Consolidation of {table}@{intm_table_alias}: No matching&#34;
                                                f&#34; record found for attribute &#39;{attr}&#39; with value &#39;{attr_val}&#39;.&#34;
                                            )
                                    elif len(recordID_filtered) &gt; 1:
                                        logger.debug(
                                            &#34;Consolidation of&#34;
                                            f&#34; {table}@{intm_table_alias}: Multiple matching records found&#34;
                                            f&#34; for attribute &#39;{attr}&#39; with value &#39;{attr_val}&#39;: {recordID_new}&#34;
                                        )
                                        recordIDs_new.append(recordID_filtered[0])
                                    else:
                                        recordIDs_new.append(recordID_filtered[0])
                            else:
                                errmsg = (
                                    f&#34;Unknown &#39;entry_type&#39; specified for attribute &#39;{attr}&#39;&#34;
                                    f&#34; (&#39;{source_table}&#39;): &#39;{intm[attr][&#39;entry_type&#39;]}&#39;&#34;
                                )
                                logger.error(f&#34;ValueError: {errmsg}&#34;)
                                raise ValueError(errmsg)
                            if not recordIDs_new:
                                errmsg = (
                                    f&#34;{table} (record &#39;{record_id}&#39;): For attribute&#34;
                                    f&#34; &#39;{attr}&#39; no records could be mapped.&#34;
                                )
                                logger.error(errmsg)
                                # This case can actually happen for the &#39;Coordinate and Dimension&#39; table
                                # raise KeyError(errmsg)
                            try:
                                mapped_data[&#34;Data Request&#34;][table][&#34;records&#34;][
                                    record_id
                                ][
                                    mapinfo[&#34;internal_consistency&#34;].get(attr, attr)
                                ] = list(
                                    set(recordIDs_new)
                                )
                            except KeyError:
                                logger.debug(
                                    f&#34;Consolidation of {table}@{intm_table_alias}:&#34;
                                    f&#34; &#39;{record_id}&#39; not found when adding&#34;
                                    f&#34; Attribute &#39;{attr}&#39;: {recordIDs_new}&#34;
                                )
            else:
                if mapinfo[&#34;source_base&#34;] not in data:
                    missing_bases.append(mapinfo[&#34;source_base&#34;])
                elif all(
                    [
                        st not in data[mapinfo[&#34;source_base&#34;]]
                        for st in mapinfo[&#34;source_table&#34;]
                    ]
                ):
                    missing_tables.append(mapinfo[&#34;source_table&#34;][0])
        if len(missing_bases) &gt; 0:
            errmsg = (
                &#34;Encountered missing bases when consolidating the data:&#34;
                f&#34; {set(missing_bases)}&#34;
            )
            logger.critical(errmsg)
            raise KeyError(errmsg)
        if len(missing_tables) &gt; 0:
            logger.warning(
                &#34;Encountered missing tables when consolidating the data (not&#34;
                f&#34; necessarily problematic): {missing_tables}&#34;
            )
        return _apply_hard_fixes(mapped_data)
    # Return the data if it is already one-base
    elif len(data.keys()) == 1:
        l_version = next(iter(data.keys())).replace(&#34;Data Request&#34;, &#34;&#34;).strip()
        # Consistency fixes
        mapped_data = next(iter(data.values()))
        mapped_data = _apply_consistency_fixes(mapped_data)
        # String fixes
        logger.debug(
            &#34;Consolidation: Removing / Adding (un)necessary whitespace to strings.&#34;
        )
        _fix_str_nested(mapped_data)
        if _parse_version(version) == (0, 0, 0, 0, &#34;&#34;, 0):
            mapped_data[&#34;version&#34;] = version
        else:
            if l_version != version:
                errmsg = (
                    f&#34;The Data Request version inferred from the content dictionary&#34;
                    f&#34; ({l_version}) is different than the requested version ({version}).&#34;
                )
                logger.error(errmsg)
                raise ValueError(errmsg)
            mapped_data[&#34;version&#34;] = version
        mapped_data = _apply_hard_fixes_one_base(mapped_data, version)
        return {&#34;Data Request&#34;: mapped_data}
    else:
        errmsg = &#34;The loaded Data Request has an unexpected data structure.&#34;
        logger.error(errmsg)
        raise ValueError(errmsg)</code></pre>
</details>
<div class="desc"><p>Maps the data to the one-base structure using the mapping table.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Three-base or one-base Airtable export.</dd>
<dt>mapping_table dict</dt>
<dt>The mapping table to apply to map to one base.</dt>
<dt><strong><code>version</code></strong> :&ensp;<code>str</code></dt>
<dd>The version tag of the exported Data Request Content dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Mapped data with one-base structure.</dd>
</dl>
<h2 id="note">Note</h2>
<pre><code>Returns the input dict if the data is already one-base.
</code></pre></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="data_request_api.content" href="index.html">data_request_api.content</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="data_request_api.content.consolidate_export.map_data" href="#data_request_api.content.consolidate_export.map_data">map_data</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
